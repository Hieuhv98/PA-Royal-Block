if ( TRACE ) { TRACE( JSON.parse( '["AnimationData#Name#get","AnimationData#IsLoop#get","AnimatorUIControl#init","AnimatorUIControl#Play","AnimatorUIControl#PlayAnimation","AnimatorUIControl#PlayAnimation$1","ButtonCTA#init","ButtonCTA#TriggerCTA","CellData#getDefaultValue","CellData#ctor","CellData#getHashCode","CellData#equals","CellData#$clone","CoinSystem#CurrentCoin#get","CoinSystem#CurrentCoin#set","CoinSystem#init","CoinSystem#AddCoin","CoinSystem#MinusCoin","CoinSystem#SetCoin","CoinSystem#GetCurrentCoin","CoinSystem#Awake","CoinSystem#OnDestroy","CoinSystem#InternalSetCoin","CoinSystem#InternalAddCoin","CoinSystem#InternalMinusCoin","CoinSystem#OnChangeValue","CoinUpdater#init","CoinUpdater#OnEnable","CoinUpdater#OnDisable","CoinUpdater#OnBuildingProcessing","CoinUpdater#MoveOneCoinDone","CoinUpdater#MoveAllCoinDone","CoinUpdater#DecreaseCoin","CoinUpdater#UpdateDisplayValue","CoinUpdater#UpdateTextCoin","CoinUpdater#OnClickPlus","ColorConfig#Colors#get","ColorConfig#init","ColorConfig#GetData","ColorConfig#GetColor","ColorData#Color#get","ColorData#Type#get","ColorData#init","Constant#init","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor","DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor","DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor","DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor","DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get","DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor","DG.Tweening.DOTweenModuleAudio#DOFade","DG.Tweening.DOTweenModuleAudio#DOPitch","DG.Tweening.DOTweenModuleAudio#DOSetFloat","DG.Tweening.DOTweenModuleAudio#DOComplete","DG.Tweening.DOTweenModuleAudio#DOKill","DG.Tweening.DOTweenModuleAudio#DOFlip","DG.Tweening.DOTweenModuleAudio#DOGoto","DG.Tweening.DOTweenModuleAudio#DOPause","DG.Tweening.DOTweenModuleAudio#DOPlay","DG.Tweening.DOTweenModuleAudio#DOPlayBackwards","DG.Tweening.DOTweenModuleAudio#DOPlayForward","DG.Tweening.DOTweenModuleAudio#DORestart","DG.Tweening.DOTweenModuleAudio#DORewind","DG.Tweening.DOTweenModuleAudio#DOSmoothRewind","DG.Tweening.DOTweenModuleAudio#DOTogglePause","DG.Tweening.DOTweenModulePhysics#DOMove","DG.Tweening.DOTweenModulePhysics#DOMoveX","DG.Tweening.DOTweenModulePhysics#DOMoveY","DG.Tweening.DOTweenModulePhysics#DOMoveZ","DG.Tweening.DOTweenModulePhysics#DORotate","DG.Tweening.DOTweenModulePhysics#DOLookAt","DG.Tweening.DOTweenModulePhysics#DOJump","DG.Tweening.DOTweenModulePhysics#DOPath","DG.Tweening.DOTweenModulePhysics#DOPath$1","DG.Tweening.DOTweenModulePhysics#DOLocalPath","DG.Tweening.DOTweenModulePhysics#DOLocalPath$1","DG.Tweening.DOTweenModulePhysics2D#DOMove","DG.Tweening.DOTweenModulePhysics2D#DOMoveX","DG.Tweening.DOTweenModulePhysics2D#DOMoveY","DG.Tweening.DOTweenModulePhysics2D#DORotate","DG.Tweening.DOTweenModulePhysics2D#DOJump","DG.Tweening.DOTweenModulePhysics2D#DOPath","DG.Tweening.DOTweenModulePhysics2D#DOLocalPath","DG.Tweening.DOTweenModuleSprite#DOColor","DG.Tweening.DOTweenModuleSprite#DOFade","DG.Tweening.DOTweenModuleSprite#DOGradientColor","DG.Tweening.DOTweenModuleSprite#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOFade","DG.Tweening.DOTweenModuleUI#DOFade$1","DG.Tweening.DOTweenModuleUI#DOFade$2","DG.Tweening.DOTweenModuleUI#DOFade$3","DG.Tweening.DOTweenModuleUI#DOColor","DG.Tweening.DOTweenModuleUI#DOColor$1","DG.Tweening.DOTweenModuleUI#DOColor$2","DG.Tweening.DOTweenModuleUI#DOFillAmount","DG.Tweening.DOTweenModuleUI#DOGradientColor","DG.Tweening.DOTweenModuleUI#DOFlexibleSize","DG.Tweening.DOTweenModuleUI#DOMinSize","DG.Tweening.DOTweenModuleUI#DOPreferredSize","DG.Tweening.DOTweenModuleUI#DOAnchorPos","DG.Tweening.DOTweenModuleUI#DOAnchorPosX","DG.Tweening.DOTweenModuleUI#DOAnchorPosY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3D","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY","DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ","DG.Tweening.DOTweenModuleUI#DOAnchorMax","DG.Tweening.DOTweenModuleUI#DOAnchorMin","DG.Tweening.DOTweenModuleUI#DOPivot","DG.Tweening.DOTweenModuleUI#DOPivotX","DG.Tweening.DOTweenModuleUI#DOPivotY","DG.Tweening.DOTweenModuleUI#DOSizeDelta","DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos","DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1","DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos","DG.Tweening.DOTweenModuleUI#DONormalizedPos","DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos","DG.Tweening.DOTweenModuleUI#DOValue","DG.Tweening.DOTweenModuleUI#DOCounter","DG.Tweening.DOTweenModuleUI#DOText","DG.Tweening.DOTweenModuleUI#DOBlendableColor","DG.Tweening.DOTweenModuleUI#DOBlendableColor$1","DG.Tweening.DOTweenModuleUI#DOBlendableColor$2","DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor","DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1","DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion","DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind","DG.Tweening.DOTweenModuleUnityVersion#WaitForKill","DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops","DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition","DG.Tweening.DOTweenModuleUnityVersion#WaitForStart","DG.Tweening.DOTweenModuleUnityVersion#DOOffset","DG.Tweening.DOTweenModuleUnityVersion#DOTiling","DG.Tweening.DOTweenModuleUtils#Init","DG.Tweening.DOTweenModuleUtils#Preserver","DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D","DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody","DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween","DG.Tweening.EasingType#Interpolate","DirectionConfig#Datas#get","DirectionConfig#init","DirectionConfig#GetData","DirectionConfig#GetDirection","DirectionData#EDirectionType#get","DirectionData#Direction#get","DirectionData#init","Extension#CanvasToWorldPosition","Extension#WorldToCanvasPosition","Extension#GetNumberFromText","Extension#GetTextValueFromNumber","Extension#Clear","Extension#Jump","Extension#ArcMove","Extension#FlyToTarget","Extension#GetCoordinate","FreezeConfig#Type#get","FreezeConfig#Material#get","FreezeConfig#SoundCrack#get","FreezeConfig#FxBreak#get","FreezeConfig#FreezePrefab#get","FreezeLinker#Freezer#get","FreezeLinker#Prefab#get","FreezeLinker#ctor","FreezePrefab#init","FreezePrefab#SetUp","FreezePrefab#UpdateUI","GamePlayableManager#IsGamePlaying#get","GamePlayableManager#GetGameState","GamePlayableManager#OnEnable","GamePlayableManager#OnDisable","GamePlayableManager#Start","GamePlayableManager#PlayCurrentLevel","GamePlayableManager#ReplayGame","GamePlayableManager#NextLevel","GamePlayableManager#StartGame","GamePlayableManager#OnWinGame","GamePlayableManager#OnLoseGame","GameSettings#EnableDebugView#get","GameSettings#TargetFrameRate#get","GameSettings#MultiTouchEnabled#get","GameSettings#WinLevelMoney#get","GameSettings#PercentWinGiftPerLevel#get","GameSettings#PauseTimeBoosterAmount#get","GameSettings#HammerBoosterAmount#get","GameSettings#SuckBoosterAmount#get","GameSettings#EnableNotificationInGame#get","GameSettings#TimeDelayHideNotificationInGame#get","GameSettings#EnableRequireInternet#get","GameSettings#TimeDelayCheckInternet#get","GameSettings#TimeLoopCheckInternet#get","GameSettings#EnableShowPopupUpdate#get","GameSettings#init","GraphicsQualitySetting#QualityValue#get","GraphicsQualitySetting#QualityValue#set","GraphicsQualitySetting#SettingsCount#get","GraphicsQualitySetting#GraphicSettings#get","GraphicsQualitySetting#init","GraphicsQualitySetting#Refresh","GraphicsQualitySetting#SetGraphicsQuality","GraphicsQualitySetting#UpdateGraphicsQuality","GraphicsQualitySettingUI#init","GraphicsQualitySettingUI#Start","GraphicsQualitySettingUI#OnSliderValueChanged","GraphicsQualitySettingUI#OnDestroy","GridCreator#SetCenter","GridCreator#Create","GridCreator#GetPrefab","GridCreator#GetDistance","GridCreator#GetcellPosition","GridCreator#CanSpawn","GridCreator#SetNeighbor","GridSetting#init","GridSettingData#getDefaultValue","GridSettingData#Size#get","GridSettingData#ctor","GridSettingData#getHashCode","GridSettingData#equals","GridSettingData#$clone","HeartData#TimeCurrent#get","HeartData#IsCanIncrease#get","HeartData#IsRunOutOfHeart#get","HeartData#Count#get","HeartData#Count#set","HeartData#Max#get","HeartData#Max#set","HeartData#TimeRemainingToIncrease#get","HeartData#StartTimeIncrease#get","HeartData#StartTimeIncrease#set","HeartData#IsInitialized#get","HeartData#IsInitialized#set","HeartData#init","HeartData#ResetID","HeartData#Refesh","HeartData#ResetTimeIncrease","HeartData#Add","HeartData#Minus","HeartData#OnUpate","HeartData#AddDebug","HeartData#MinusDebug","ImmortalData#IsImmortalStatusVariable#get","ImmortalData#Init","ImmortalData#SetTimeImmortal","ImmortalData#OnCheckImmortalStatus","ImmortalData#OnUpdateImmortalStatus","LevelAdditionalTime#TimeCurrent#get","LevelAdditionalTime#TimeEnd#get","LevelAdditionalTime#TimeEnd#set","LevelAdditionalTime#Count#get","LevelAdditionalTime#Count#set","LevelAdditionalTime#IsAvailable#get","LevelAdditionalTime#init","LevelAdditionalTime#Add","LevelModeData#GetLevelData","LevelModeInfor#init","LevelTypeData#GetLevelTypeInfor","LevelTypeInfor#GetBoosterSprite","LevelTypeInfor#GetBoosterSpriteLock","LevelTypeInfor#GetIconSettingSprite","LevelTypeInfor#GetIconBoardLevelSprite","LevelTypeInfor#GetIconReplayLevelSprite","LevelTypeInfor#GetColorTextLevelModeHome","LevelTypeInfor#GetColorTextLevelModeGameplay","LevelTypeInfor.BoosterIconData#getDefaultValue","LevelTypeInfor.BoosterIconData#ctor","LevelTypeInfor.BoosterIconData#getHashCode","LevelTypeInfor.BoosterIconData#equals","LevelTypeInfor.BoosterIconData#$clone","SetCenterPosition#SetCenter","Spine.BoneMatrix#CalculateSetupWorld","Spine.BoneMatrix#GetInheritedInternal","Spine.BoneMatrix#getDefaultValue","Spine.BoneMatrix#$ctor2","Spine.BoneMatrix#$ctor1","Spine.BoneMatrix#ctor","Spine.BoneMatrix#TransformMatrix","Spine.BoneMatrix#getHashCode","Spine.BoneMatrix#equals","Spine.BoneMatrix#$clone","Spine.SpineSkeletonExtensions#IsWeighted","Spine.SpineSkeletonExtensions#InheritsRotation","Spine.SpineSkeletonExtensions#InheritsScale","Spine.Unity.ActivateBasedOnFlipDirection#init","Spine.Unity.ActivateBasedOnFlipDirection#Start","Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate","Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip","Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions","Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2","Spine.Unity.AnimationTools.TimelineExtensions#Evaluate","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix","Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix","Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone","Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline","Spine.Unity.AtlasAssetBase#TextureLoadingMode#get","Spine.Unity.AtlasAssetBase#TextureLoadingMode#set","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get","Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set","Spine.Unity.AtlasAssetBase#init","Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading","Spine.Unity.AtlasAssetBase#EndCustomTextureLoading","Spine.Unity.AtlasAssetBase#RequireTexturesLoaded","Spine.Unity.AtlasAssetBase#RequireTextureLoaded","Spine.Unity.AttachmentTools.AtlasUtilities#init","Spine.Unity.AttachmentTools.AtlasUtilities#Init","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone","Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin","Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1","Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite","Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture","Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetClone","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA","Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable","Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect","Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect","Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect","Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion","Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1","Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture","Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom","Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals","Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1","Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset","Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get","Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set","Spine.Unity.BlendModeMaterials#init","Spine.Unity.BlendModeMaterials#BlendModeForMaterial","Spine.Unity.BlendModeMaterials#ApplyMaterials","Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial","Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose","Spine.Unity.BoneFollower#SkeletonRenderer#get","Spine.Unity.BoneFollower#SkeletonRenderer#set","Spine.Unity.BoneFollower#init","Spine.Unity.BoneFollower#SetBone","Spine.Unity.BoneFollower#Awake","Spine.Unity.BoneFollower#HandleRebuildRenderer","Spine.Unity.BoneFollower#Initialize","Spine.Unity.BoneFollower#OnDestroy","Spine.Unity.BoneFollower#LateUpdate","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get","Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set","Spine.Unity.BoneFollowerGraphic#init","Spine.Unity.BoneFollowerGraphic#SetBone","Spine.Unity.BoneFollowerGraphic#Awake","Spine.Unity.BoneFollowerGraphic#Initialize","Spine.Unity.BoneFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Slot#get","Spine.Unity.BoundingBoxFollower#CurrentAttachment#get","Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollower#CurrentCollider#get","Spine.Unity.BoundingBoxFollower#IsTrigger#get","Spine.Unity.BoundingBoxFollower#init","Spine.Unity.BoundingBoxFollower#Start","Spine.Unity.BoundingBoxFollower#OnEnable","Spine.Unity.BoundingBoxFollower#HandleRebuild","Spine.Unity.BoundingBoxFollower#Initialize","Spine.Unity.BoundingBoxFollower#AddCollidersForSkin","Spine.Unity.BoundingBoxFollower#OnDisable","Spine.Unity.BoundingBoxFollower#ClearState","Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollower#LateUpdate","Spine.Unity.BoundingBoxFollower#MatchAttachment","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Slot#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get","Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get","Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get","Spine.Unity.BoundingBoxFollowerGraphic#init","Spine.Unity.BoundingBoxFollowerGraphic#Start","Spine.Unity.BoundingBoxFollowerGraphic#OnEnable","Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild","Spine.Unity.BoundingBoxFollowerGraphic#Initialize","Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin","Spine.Unity.BoundingBoxFollowerGraphic#OnDisable","Spine.Unity.BoundingBoxFollowerGraphic#ClearState","Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter","Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate","Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment","Spine.Unity.DoubleBuffered$1#init","Spine.Unity.DoubleBuffered$1#GetCurrent","Spine.Unity.DoubleBuffered$1#GetNext","Spine.Unity.EventDataReferenceAsset#init","Spine.Unity.EventDataReferenceAsset#op_Implicit","Spine.Unity.EventDataReferenceAsset#EventData#get","Spine.Unity.EventDataReferenceAsset#Initialize","Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed","Spine.Unity.MaterialsTextureLoader#ctor","Spine.Unity.MaterialsTextureLoader#Load","Spine.Unity.MaterialsTextureLoader#Unload","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction","Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder","Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction","Spine.Unity.MeshGenerator#TryReplaceMaterials","Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize","Spine.Unity.MeshGenerator#SolveTangents2DTriangles","Spine.Unity.MeshGenerator#SolveTangents2DBuffer","Spine.Unity.MeshGenerator#FillMeshLocal$1","Spine.Unity.MeshGenerator#FillMeshLocal","Spine.Unity.MeshGenerator#VertexCount#get","Spine.Unity.MeshGenerator#Buffers#get","Spine.Unity.MeshGenerator#init","Spine.Unity.MeshGenerator#ctor","Spine.Unity.MeshGenerator#SubmeshIndexCount","Spine.Unity.MeshGenerator#Begin","Spine.Unity.MeshGenerator#AddSubmesh","Spine.Unity.MeshGenerator#BuildMesh","Spine.Unity.MeshGenerator#BuildMeshWithArrays","Spine.Unity.MeshGenerator#ScaleVertexData","Spine.Unity.MeshGenerator#GetMeshBounds","Spine.Unity.MeshGenerator#AddAttachmentTintBlack","Spine.Unity.MeshGenerator#FillVertexData","Spine.Unity.MeshGenerator#FillLateVertexData","Spine.Unity.MeshGenerator#FillTriangles","Spine.Unity.MeshGenerator#EnsureVertexCapacity","Spine.Unity.MeshGenerator#TrimExcess","Spine.Unity.MeshGenerator.Settings#Default#get","Spine.Unity.MeshGenerator.Settings#getDefaultValue","Spine.Unity.MeshGenerator.Settings#ctor","Spine.Unity.MeshGenerator.Settings#getHashCode","Spine.Unity.MeshGenerator.Settings#equals","Spine.Unity.MeshGenerator.Settings#$clone","Spine.Unity.MeshGeneratorBuffers#getDefaultValue","Spine.Unity.MeshGeneratorBuffers#ctor","Spine.Unity.MeshGeneratorBuffers#getHashCode","Spine.Unity.MeshGeneratorBuffers#equals","Spine.Unity.MeshGeneratorBuffers#$clone","Spine.Unity.MeshRendererBuffers#init","Spine.Unity.MeshRendererBuffers#Initialize","Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray","Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate","Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials","Spine.Unity.MeshRendererBuffers#GetNextMesh","Spine.Unity.MeshRendererBuffers#Clear","Spine.Unity.MeshRendererBuffers#Dispose","Spine.Unity.MeshRendererBuffers.SmartMesh#init","Spine.Unity.MeshRendererBuffers.SmartMesh#Clear","Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose","Spine.Unity.NoOpTextureLoader#Load","Spine.Unity.NoOpTextureLoader#Unload","Spine.Unity.OnDemandTextureLoader#addTextureRequested","Spine.Unity.OnDemandTextureLoader#removeTextureRequested","Spine.Unity.OnDemandTextureLoader#addTextureLoaded","Spine.Unity.OnDemandTextureLoader#removeTextureLoaded","Spine.Unity.OnDemandTextureLoader#addTextureUnloaded","Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded","Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned","Spine.Unity.OnDemandTextureLoader#OnTextureRequested","Spine.Unity.OnDemandTextureLoader#OnTextureLoaded","Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded","Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get","Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment","Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment","Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment","Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment","Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance","Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1","Spine.Unity.SkeletonDataAsset#ReadSkeletonData","Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1","Spine.Unity.SkeletonDataAsset#IsLoaded#get","Spine.Unity.SkeletonDataAsset#init","Spine.Unity.SkeletonDataAsset#Reset","Spine.Unity.SkeletonDataAsset#Clear","Spine.Unity.SkeletonDataAsset#GetAnimationStateData","Spine.Unity.SkeletonDataAsset#GetSkeletonData","Spine.Unity.SkeletonDataAsset#InitializeWithData","Spine.Unity.SkeletonDataAsset#FillStateData","Spine.Unity.SkeletonDataAsset#GetAtlasArray","Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString","Spine.Unity.SkeletonExtensions#init","Spine.Unity.SkeletonExtensions#GetColor$2","Spine.Unity.SkeletonExtensions#GetColor$1","Spine.Unity.SkeletonExtensions#GetColor","Spine.Unity.SkeletonExtensions#GetColor$3","Spine.Unity.SkeletonExtensions#GetColorTintBlack","Spine.Unity.SkeletonExtensions#SetColor$4","Spine.Unity.SkeletonExtensions#SetColor$5","Spine.Unity.SkeletonExtensions#SetColor$6","Spine.Unity.SkeletonExtensions#SetColor$7","Spine.Unity.SkeletonExtensions#SetColor$2","Spine.Unity.SkeletonExtensions#SetColor$3","Spine.Unity.SkeletonExtensions#SetColor","Spine.Unity.SkeletonExtensions#SetColor$1","Spine.Unity.SkeletonExtensions#SetLocalScale","Spine.Unity.SkeletonExtensions#GetMatrix4x4","Spine.Unity.SkeletonExtensions#SetLocalPosition","Spine.Unity.SkeletonExtensions#SetLocalPosition$1","Spine.Unity.SkeletonExtensions#GetLocalPosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition","Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition","Spine.Unity.SkeletonExtensions#GetWorldPosition$1","Spine.Unity.SkeletonExtensions#GetWorldPosition$3","Spine.Unity.SkeletonExtensions#GetWorldPosition$2","Spine.Unity.SkeletonExtensions#GetQuaternion","Spine.Unity.SkeletonExtensions#GetLocalQuaternion","Spine.Unity.SkeletonExtensions#GetLocalScale","Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix","Spine.Unity.SkeletonExtensions#WorldToLocal","Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace","Spine.Unity.SkeletonExtensions#GetMaterial","Spine.Unity.SkeletonExtensions#GetLocalVertices","Spine.Unity.SkeletonExtensions#GetWorldVertices","Spine.Unity.SkeletonGraphicCustomMaterials#init","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides","Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable","Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode","Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get","Spine.Unity.SkeletonMecanim.MecanimTranslator#init","Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied","Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback","Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime","Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos","Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2","Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2","Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2","Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get","Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get","Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get","Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set","Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get","Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get","Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get","Spine.Unity.SkeletonRootMotionBase#init","Spine.Unity.SkeletonRootMotionBase#Reset","Spine.Unity.SkeletonRootMotionBase#Start","Spine.Unity.SkeletonRootMotionBase#FixedUpdate","Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate","Spine.Unity.SkeletonRootMotionBase#OnDisable","Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent","Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone","Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos","Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos","Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation","Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo","Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex","Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone","Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta","Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones","Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal","Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion","Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion","Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta","Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta","Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo","Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets","Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement","Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject","Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get","Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get","Spine.Unity.SkeletonPartsRenderer#MeshFilter#get","Spine.Unity.SkeletonPartsRenderer#init","Spine.Unity.SkeletonPartsRenderer#LazyIntialize","Spine.Unity.SkeletonPartsRenderer#OnDestroy","Spine.Unity.SkeletonPartsRenderer#ClearMesh","Spine.Unity.SkeletonPartsRenderer#RenderParts","Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get","Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#init","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials","Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides","Spine.Unity.SkeletonRendererCustomMaterials#OnEnable","Spine.Unity.SkeletonRendererCustomMaterials#OnDisable","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode","Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone","Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual","Spine.Unity.SkeletonRendererInstruction#init","Spine.Unity.SkeletonRendererInstruction#Clear","Spine.Unity.SkeletonRendererInstruction#Dispose","Spine.Unity.SkeletonRendererInstruction#SetWithSubset","Spine.Unity.SkeletonRendererInstruction#Set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get","Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set","Spine.Unity.SkeletonRenderSeparator#init","Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer","Spine.Unity.SkeletonRenderSeparator#OnEnable","Spine.Unity.SkeletonRenderSeparator#OnDisable","Spine.Unity.SkeletonRenderSeparator#HandleRender","Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals","Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone","Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty","Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty","Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh","Spine.Unity.SkeletonSubmeshGraphic#OnDisable","Spine.Unity.SkeletonSubmeshGraphic#OnEnable","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject","Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1","Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent","Spine.Unity.SkeletonUtility#SetColliderPointsLocal","Spine.Unity.SkeletonUtility#GetBoundingBoxBounds","Spine.Unity.SkeletonUtility#AddBoneRigidbody2D","Spine.Unity.SkeletonUtility#SkeletonComponent#get","Spine.Unity.SkeletonUtility#Skeleton#get","Spine.Unity.SkeletonUtility#IsValid#get","Spine.Unity.SkeletonUtility#PositionScale#get","Spine.Unity.SkeletonUtility#init","Spine.Unity.SkeletonUtility#Update","Spine.Unity.SkeletonUtility#ResubscribeEvents","Spine.Unity.SkeletonUtility#OnEnable","Spine.Unity.SkeletonUtility#Start","Spine.Unity.SkeletonUtility#OnDisable","Spine.Unity.SkeletonUtility#HandleRendererReset$1","Spine.Unity.SkeletonUtility#HandleRendererReset","Spine.Unity.SkeletonUtility#RegisterBone","Spine.Unity.SkeletonUtility#UnregisterBone","Spine.Unity.SkeletonUtility#RegisterConstraint","Spine.Unity.SkeletonUtility#UnregisterConstraint","Spine.Unity.SkeletonUtility#CollectBones","Spine.Unity.SkeletonUtility#UpdateLocal","Spine.Unity.SkeletonUtility#UpdateWorld","Spine.Unity.SkeletonUtility#UpdateComplete","Spine.Unity.SkeletonUtility#UpdateAllBones","Spine.Unity.SkeletonUtility#GetBoneRoot","Spine.Unity.SkeletonUtility#SpawnRoot","Spine.Unity.SkeletonUtility#SpawnHierarchy","Spine.Unity.SkeletonUtility#SpawnBoneRecursively","Spine.Unity.SkeletonUtility#SpawnBone","Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible","Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get","Spine.Unity.SkeletonUtilityBone#init","Spine.Unity.SkeletonUtilityBone#Reset","Spine.Unity.SkeletonUtilityBone#OnEnable","Spine.Unity.SkeletonUtilityBone#HandleOnReset","Spine.Unity.SkeletonUtilityBone#OnDisable","Spine.Unity.SkeletonUtilityBone#DoUpdate","Spine.Unity.SkeletonUtilityBone#AddBoundingBox","Spine.Unity.SkeletonUtilityConstraint#OnEnable","Spine.Unity.SkeletonUtilityConstraint#OnDisable","Spine.Unity.SpineAttributeBase#init","Spine.Unity.SpineAtlasRegion#ctor","Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue","Spine.Unity.SpineAttachment.Hierarchy#$ctor1","Spine.Unity.SpineAttachment.Hierarchy#ctor","Spine.Unity.SpineAttachment.Hierarchy#getHashCode","Spine.Unity.SpineAttachment.Hierarchy#equals","Spine.Unity.SpineAttachment.Hierarchy#$clone","Spine.Unity.SpineMesh#init","Spine.Unity.SpineMesh#NewSkeletonMesh","Spine.Unity.SubmeshInstruction#getDefaultValue","Spine.Unity.SubmeshInstruction#SlotCount#get","Spine.Unity.SubmeshInstruction#ctor","Spine.Unity.SubmeshInstruction#toString","Spine.Unity.SubmeshInstruction#getHashCode","Spine.Unity.SubmeshInstruction#equals","Spine.Unity.SubmeshInstruction#$clone","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get","Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get","Spine.Unity.WaitForSpineEvent#init","Spine.Unity.WaitForSpineEvent#ctor","Spine.Unity.WaitForSpineEvent#$ctor2","Spine.Unity.WaitForSpineEvent#$ctor1","Spine.Unity.WaitForSpineEvent#$ctor3","Spine.Unity.WaitForSpineEvent#Subscribe","Spine.Unity.WaitForSpineEvent#SubscribeByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName","Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent","Spine.Unity.WaitForSpineEvent#NowWaitFor","Spine.Unity.WaitForSpineEvent#NowWaitFor$1","Spine.Unity.WaitForSpineEvent#Clear","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext","Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset","StarSystem#CurrentStar#get","StarSystem#CurrentStar#set","StarSystem#init","StarSystem#AddStar","StarSystem#MinusStar","StarSystem#SetStar","StarSystem#GetCurrentStar","StarSystem#Awake","StarSystem#OnDestroy","StarSystem#InternalSetStar","StarSystem#InternalAddStar","StarSystem#InternalMinusStar","StarSystem#OnChangeValue","StarUpdater#init","StarUpdater#OnEnable","StarUpdater#OnDisable","StarUpdater#OnBuildingProcessing","StarUpdater#MoveOneCoinDone","StarUpdater#MoveAllCoinDone","StarUpdater#DecreaseCoin","StarUpdater#UpdateTextCoin","StarUpdater#OnClickPlus","Switcher#MusicChanged#get","Switcher#MusicChanged#set","Switcher#SoundFxChanged#get","Switcher#SoundFxChanged#set","Switcher#VibrateChanged#get","Switcher#VibrateChanged#set","Switcher#init","Switcher#SetupData","Switcher#SetupUI","Switcher#Setup","Switcher#OnEnable","Switcher#Switching","TheBeginning.Data.UserData#IsFirstOpenGame#get","TheBeginning.Data.UserData#IsFirstOpenGame#set","TheBeginning.Data.UserData#ProgressAmount#get","TheBeginning.Data.UserData#ProgressAmount#set","TheBeginning.Data.UserData#LastSessiontime#get","TheBeginning.Data.UserData#LastSessiontime#set","TheBeginning.Data.UserData#CurrentMonthBattlePass#get","TheBeginning.Data.UserData#CurrentMonthBattlePass#set","TheBeginning.Data.UserData#DayStartWinStreak#get","TheBeginning.Data.UserData#DayStartWinStreak#set","TheBeginning.Data.UserData#IsStartLoopingDailyReward#get","TheBeginning.Data.UserData#IsStartLoopingDailyReward#set","TheBeginning.Data.UserData#DateTimeStart#get","TheBeginning.Data.UserData#DateTimeStart#set","TheBeginning.Data.UserData#TotalPlayedDays#get","TheBeginning.Data.UserData#DailyRewardDayIndex#get","TheBeginning.Data.UserData#DailyRewardDayIndex#set","TheBeginning.Data.UserData#LastDailyRewardClaimed#get","TheBeginning.Data.UserData#LastDailyRewardClaimed#set","TheBeginning.Data.UserData#LastDailyMainGiftClaimed#get","TheBeginning.Data.UserData#LastDailyMainGiftClaimed#set","TheBeginning.Data.UserData#LastDailyGift#get","TheBeginning.Data.UserData#LastDailyGift#set","TheBeginning.Data.UserData#LastDailyInfinity#get","TheBeginning.Data.UserData#LastDailyInfinity#set","TheBeginning.Data.UserData#TotalClaimDailyReward#get","TheBeginning.Data.UserData#TotalClaimDailyReward#set","TheBeginning.Data.UserData#IsItemUnlocked#get","TheBeginning.Data.UserData#IsItemUnlocked#set","TheBeginning.Data.UserData#PercentWinGift#get","TheBeginning.Data.UserData#PercentWinGift#set","TheBeginning.Data.UserData#init","TheBeginning.Data.UserData#GetNumberShowGameObject","TheBeginning.Data.UserData#IncreaseNumberShowGameObject","TheBeginning.Data.UserData#GetBoosterAmount","TheBeginning.Data.UserData#SetBoosterAmount","TheBeginning.Data.UserData#GetBoosterUnlock","TheBeginning.Data.UserData#SetBoosterUnlock","TheBeginning.Data.UserData#GetSkinMakeupUnlocked","TheBeginning.Data.UserData#SetSkinMakeupUnlocked","TheBeginning.Data.UserData#GetSkinMakeupUnlockedSelectName","TheBeginning.Data.UserData#SetSkinMakeupUnlockedSelectName","TheBeginning.Data.UserData#SetInitData","TheBeginning.Data.UserData#GetInitData","TheBeginning.Data.UserData#GetCurrentSelectRoom","TheBeginning.Data.UserData#SetCurrentSelectRoom","TheBeginning.Data.UserData#SetItemBattlePassClaimed","TheBeginning.Data.UserData#GetItemBattlePassClaimed","TheBeginning.Data.UserData#SetStatValue","TheBeginning.Data.UserData#GetStatValue","TheBeginning.Data.UserData#SetUnlockWinStreakGift","TheBeginning.Data.UserData#GetUnlockWinStreakGift","TheBeginning.Data.UserData#SetPlayerProfileFrameThemeLag","TheBeginning.Data.UserData#GetPlayerProfileFrameThemeFlag","TheBeginning.Data.UserData#Get","TheBeginning.Data.UserData#Set","TheBeginning.Data.UserData#IsClaimedTodayDailyReward","TheBeginning.Data.UserData#IsItemEquipped","TheBeginning.Data.UserData#SetItemEquipped","TheBeginning.Data.UserData#getDefaultValue","TheBeginning.Data.UserData#$clone","TheBeginning.LevelSystem.LevelSettings#MaxLevel#get","TheBeginning.LevelSystem.LevelSettings#StartLoopLevel#get","TheBeginning.LevelSystem.LevelSettings#init","TheBeginning.LevelSystem.LevelSettings#GePrefabLevel","TheBeginning.LevelSystem.LevelSettings#GePrefabLevel$1","TheBeginning.Services.RuntimeInitialization#Awake","TheBeginning.UI.PopupSettings#ItemPopupConfigs#get","TheBeginning.UI.PopupSettings#init","TheBeginning.UI.PopupSettings#GetPrefabPopup","TrackingParameter#$ctor3","TrackingParameter#$ctor2","TrackingParameter#$ctor1","TrackingParameter#ctor","VirtueSky.Audio.AudioHelper#PlaySfx","VirtueSky.Audio.AudioHelper#PauseSfx","VirtueSky.Audio.AudioHelper#StopSfx","VirtueSky.Audio.AudioHelper#ResumeSfx","VirtueSky.Audio.AudioHelper#FinishSfx","VirtueSky.Audio.AudioHelper#StopAllSfx","VirtueSky.Audio.AudioHelper#PlayMusic","VirtueSky.Audio.AudioHelper#StopMusic","VirtueSky.Audio.AudioHelper#PauseMusic","VirtueSky.Audio.AudioHelper#ResumeMusic","VirtueSky.Core.App#InitMonoGlobalComponent","VirtueSky.Core.App#AddPauseCallback","VirtueSky.Core.App#RemovePauseCallback","VirtueSky.Core.App#AddFocusCallback","VirtueSky.Core.App#RemoveFocusCallback","VirtueSky.Core.App#AddQuitCallback","VirtueSky.Core.App#RemoveQuitCallback","VirtueSky.Core.App#SubTick$1","VirtueSky.Core.App#SubTick","VirtueSky.Core.App#SubFixedTick$1","VirtueSky.Core.App#SubFixedTick","VirtueSky.Core.App#SubLateTick$1","VirtueSky.Core.App#SubLateTick","VirtueSky.Core.App#UnSubTick$1","VirtueSky.Core.App#UnSubTick","VirtueSky.Core.App#UnSubFixedTick$1","VirtueSky.Core.App#UnSubFixedTick","VirtueSky.Core.App#UnSubLateTick$1","VirtueSky.Core.App#UnSubLateTick","VirtueSky.Core.App#Delay","VirtueSky.Core.App#Delay$1","VirtueSky.Core.App#CancelDelay","VirtueSky.Core.App#PauseDelay","VirtueSky.Core.App#ResumeDelay","VirtueSky.Core.App#CancelAllDelay","VirtueSky.Core.App#PauseAllDelay","VirtueSky.Core.App#ResumeAllDelay","VirtueSky.Core.App#StartCoroutine","VirtueSky.Core.App#StartCoroutine$2","VirtueSky.Core.App#StartCoroutine$1","VirtueSky.Core.App#StopCoroutine","VirtueSky.Core.App#StopCoroutine$2","VirtueSky.Core.App#StopCoroutine$1","VirtueSky.Core.App#StopAllCoroutine","VirtueSky.Core.App#ToMainThread","VirtueSky.Core.App#ToMainThread$1","VirtueSky.Core.App#ToMainThread$2","VirtueSky.Core.App#ToMainThread$3","VirtueSky.Core.App#RunOnMainThread","VirtueSky.Core.App#getDefaultValue","VirtueSky.Core.App#$clone","VirtueSky.Core.DelayHandle#IsPaused#get","VirtueSky.Core.DelayHandle#IsCancelled#get","VirtueSky.Core.DelayHandle#IsDone#get","VirtueSky.Core.DelayHandle#IsOwnerDestroyed#get","VirtueSky.Core.DelayHandle#ctor","VirtueSky.Core.DelayHandle#Cancel","VirtueSky.Core.DelayHandle#Pause","VirtueSky.Core.DelayHandle#Resume","VirtueSky.Core.DelayHandle#GetTimeElapsed","VirtueSky.Core.DelayHandle#GetTimeRemaining","VirtueSky.Core.DelayHandle#GetRatioComplete","VirtueSky.Core.DelayHandle#GetRatioRemaining","VirtueSky.Core.DelayHandle#GetWorldTime","VirtueSky.Core.DelayHandle#GetFireTime","VirtueSky.Core.DelayHandle#GetTimeDelta","VirtueSky.Core.DelayHandle#Update","VirtueSky.Core.MonoGlobal#init","VirtueSky.Core.MonoGlobal#AddTick$1","VirtueSky.Core.MonoGlobal#AddTick","VirtueSky.Core.MonoGlobal#AddFixedTick$1","VirtueSky.Core.MonoGlobal#AddFixedTick","VirtueSky.Core.MonoGlobal#AddLateTick$1","VirtueSky.Core.MonoGlobal#AddLateTick","VirtueSky.Core.MonoGlobal#RemoveTick$1","VirtueSky.Core.MonoGlobal#RemoveTick","VirtueSky.Core.MonoGlobal#RemoveFixedTick$1","VirtueSky.Core.MonoGlobal#RemoveFixedTick","VirtueSky.Core.MonoGlobal#RemoveLateTick$1","VirtueSky.Core.MonoGlobal#RemoveLateTick","VirtueSky.Core.MonoGlobal#Update","VirtueSky.Core.MonoGlobal#FixedUpdate","VirtueSky.Core.MonoGlobal#LateUpdate","VirtueSky.Core.MonoGlobal#OnApplicationFocus","VirtueSky.Core.MonoGlobal#OnApplicationPause","VirtueSky.Core.MonoGlobal#OnApplicationQuit","VirtueSky.Core.MonoGlobal#RegisterDelayHandle","VirtueSky.Core.MonoGlobal#CancelAllDelayHandle","VirtueSky.Core.MonoGlobal#PauseAllDelayHandle","VirtueSky.Core.MonoGlobal#ResumeAllDelayHandle","VirtueSky.Core.MonoGlobal#UpdateAllDelayHandle","VirtueSky.Core.MonoGlobal#StartCoroutineImpl","VirtueSky.Core.MonoGlobal#StartCoroutineImpl$2","VirtueSky.Core.MonoGlobal#StartCoroutineImpl$1","VirtueSky.Core.MonoGlobal#StopCoroutineImpl","VirtueSky.Core.MonoGlobal#StopCoroutineImpl$2","VirtueSky.Core.MonoGlobal#StopCoroutineImpl$1","VirtueSky.Core.MonoGlobal#StopAllCoroutinesImpl","VirtueSky.Core.MonoGlobal#RunOnMainThreadImpl","VirtueSky.Core.MonoGlobal#ToMainThreadImpl","VirtueSky.Core.MonoGlobal#ToMainThreadImpl$1","VirtueSky.Core.MonoGlobal#ToMainThreadImpl$2","VirtueSky.Core.MonoGlobal#ToMainThreadImpl$3","VirtueSky.Core.RuntimeInitialize#AutoInitialize","VirtueSky.DataStorage.GameData#GetPath#get","VirtueSky.DataStorage.GameData#IsInitialized#get","VirtueSky.DataStorage.GameData#init","VirtueSky.DataStorage.GameData#Init","VirtueSky.DataStorage.GameData#Serialize","VirtueSky.DataStorage.GameData#Deserialize","VirtueSky.DataStorage.GameData#RequireNullCheck","VirtueSky.DataStorage.GameData#GetDataPath","VirtueSky.DataStorage.GameData#GetPersistentDataPath","VirtueSky.DataStorage.GameData#ChangeProfile","VirtueSky.DataStorage.GameData#VerifyProfile","VirtueSky.DataStorage.GameData#Save","VirtueSky.DataStorage.GameData#SaveAsync","VirtueSky.DataStorage.GameData#Load","VirtueSky.DataStorage.GameData#LoadAsync","VirtueSky.DataStorage.GameData#Get","VirtueSky.DataStorage.GameData#TryGet","VirtueSky.DataStorage.GameData#Set","VirtueSky.DataStorage.GameData#HasKey","VirtueSky.DataStorage.GameData#DeleteKey","VirtueSky.DataStorage.GameData#DeleteAll","VirtueSky.DataStorage.GameData#DeleteFileData","VirtueSky.DataStorage.GameData#Backup","VirtueSky.DataStorage.GameData#Restore","VirtueSky.DataStorage.SerializeAdapter#ToBinary","VirtueSky.DataStorage.SerializeAdapter#FromBinary","VirtueSky.DataType.ShortDouble#inherits","VirtueSky.DataType.ShortDouble#ctor","VirtueSky.DataType.ShortDouble#Max","VirtueSky.DataType.ShortDouble#Min","VirtueSky.DataType.ShortDouble#Clamp","VirtueSky.DataType.ShortDouble#SetUnit","VirtueSky.DataType.ShortDouble#FindUnit","VirtueSky.DataType.ShortDouble#op_Implicit$1","VirtueSky.DataType.ShortDouble#op_Implicit","VirtueSky.DataType.ShortDouble#op_Addition","VirtueSky.DataType.ShortDouble#op_Subtraction","VirtueSky.DataType.ShortDouble#op_Multiply","VirtueSky.DataType.ShortDouble#op_Division","VirtueSky.DataType.ShortDouble#op_GreaterThan","VirtueSky.DataType.ShortDouble#op_GreaterThanOrEqual","VirtueSky.DataType.ShortDouble#op_LessThan","VirtueSky.DataType.ShortDouble#op_LessThanOrEqual","VirtueSky.DataType.ShortDouble#getDefaultValue","VirtueSky.DataType.ShortDouble#Value#get","VirtueSky.DataType.ShortDouble#Floor#get","VirtueSky.DataType.ShortDouble#Ceiling#get","VirtueSky.DataType.ShortDouble#Round#get","VirtueSky.DataType.ShortDouble#True#get","VirtueSky.DataType.ShortDouble#$ctor1","VirtueSky.DataType.ShortDouble#ctor","VirtueSky.DataType.ShortDouble#AsFloat","VirtueSky.DataType.ShortDouble#AsLong","VirtueSky.DataType.ShortDouble#AsBool","VirtueSky.DataType.ShortDouble#AsInt","VirtueSky.DataType.ShortDouble#Pow","VirtueSky.DataType.ShortDouble#compareTo$1","VirtueSky.DataType.ShortDouble#compareTo","VirtueSky.DataType.ShortDouble#equalsT","VirtueSky.DataType.ShortDouble#equals","VirtueSky.DataType.ShortDouble#getHashCode","VirtueSky.DataType.ShortDouble#toString","VirtueSky.DataType.ShortDouble#ToString$1","VirtueSky.DataType.ShortDouble#ToString","VirtueSky.DataType.ShortDouble#format","VirtueSky.DataType.ShortDouble#ToString$2","VirtueSky.DataType.ShortDouble#ToString$3","VirtueSky.DataType.ShortDouble#$clone","VirtueSky.DataType.ShortDouble.Unit#getDefaultValue","VirtueSky.DataType.ShortDouble.Unit#ctor","VirtueSky.DataType.ShortDouble.Unit#getHashCode","VirtueSky.DataType.ShortDouble.Unit#equals","VirtueSky.DataType.ShortDouble.Unit#$clone","VirtueSky.DataType.ShortDouble.Unit0#init","VirtueSky.DataType.ShortDouble.Unit0#ctor","VirtueSky.DataType.ShortDouble.Unit0#Find","VirtueSky.DataType.ShortDouble.Unit1#init","VirtueSky.DataType.ShortDouble.Unit1#ctor","VirtueSky.DataType.ShortDouble.Unit1#Find","VirtueSky.DataType.ShortDouble.Unit2#init","VirtueSky.DataType.ShortDouble.Unit2#ctor","VirtueSky.DataType.ShortDouble.Unit2#Find","VirtueSky.Events.EventListenerMono#Awake","VirtueSky.Events.EventListenerMono#OnEnable","VirtueSky.Events.EventListenerMono#OnDisable","VirtueSky.Events.EventListenerMono#OnDestroy","VirtueSky.Misc.Common#Format","VirtueSky.Misc.Common#IsInteger","VirtueSky.Misc.Common#GetNumberInAString","VirtueSky.Misc.Common#GetScreenRatio","VirtueSky.Misc.Common#CallActionAndClean","VirtueSky.Misc.Common#CallActionAndClean$1","VirtueSky.Misc.Common#StopCheckInternetConnection","VirtueSky.Misc.Common#CheckInternetConnection","VirtueSky.Misc.Common#InternetConnection","VirtueSky.Misc.Common#Delay","VirtueSky.Misc.Common#SetAlpha","VirtueSky.Misc.Common#ClearTransform","VirtueSky.Misc.Common#ToWorldPosition","VirtueSky.Misc.Common#SetPosition","VirtueSky.Misc.Common#SetPositionX","VirtueSky.Misc.Common#SetPositionY","VirtueSky.Misc.Common#SetPositionZ","VirtueSky.Misc.Common#SetPositionXY$2","VirtueSky.Misc.Common#SetPositionXY","VirtueSky.Misc.Common#SetPositionXY$1","VirtueSky.Misc.Common#GetPositionXZ","VirtueSky.Misc.Common#GetPositionXZ$1","VirtueSky.Misc.Common#SetPositionXZ$2","VirtueSky.Misc.Common#SetPositionXZ","VirtueSky.Misc.Common#SetPositionXZ$1","VirtueSky.Misc.Common#GetPositionYZ","VirtueSky.Misc.Common#GetPositionYZ$1","VirtueSky.Misc.Common#SetPositionYZ$2","VirtueSky.Misc.Common#SetPositionYZ","VirtueSky.Misc.Common#SetPositionYZ$1","VirtueSky.Misc.Common#SetRelativePosition","VirtueSky.Misc.Common#SetRelativePositionX","VirtueSky.Misc.Common#SetRelativePositionY","VirtueSky.Misc.Common#SetRelativePositionZ","VirtueSky.Misc.Common#SetRelativePositionXY$2","VirtueSky.Misc.Common#SetRelativePositionXY","VirtueSky.Misc.Common#SetRelativePositionXY$1","VirtueSky.Misc.Common#SetRelativePositionXZ$2","VirtueSky.Misc.Common#SetRelativePositionXZ","VirtueSky.Misc.Common#SetRelativePositionXZ$1","VirtueSky.Misc.Common#SetRelativePositionYZ$2","VirtueSky.Misc.Common#SetRelativePositionYZ","VirtueSky.Misc.Common#SetRelativePositionYZ$1","VirtueSky.Misc.Common#SetLocalPositionX","VirtueSky.Misc.Common#SetLocalPositionY","VirtueSky.Misc.Common#SetLocalPositionZ","VirtueSky.Misc.Common#SetLocalPositionXY$2","VirtueSky.Misc.Common#SetLocalPositionXY","VirtueSky.Misc.Common#SetLocalPositionXY$1","VirtueSky.Misc.Common#GetLocalPositionXZ","VirtueSky.Misc.Common#GetLocalPositionXZ$1","VirtueSky.Misc.Common#SetLocalPositionXZ$2","VirtueSky.Misc.Common#SetLocalPositionXZ","VirtueSky.Misc.Common#SetLocalPositionXZ$1","VirtueSky.Misc.Common#GetLocalPositionYZ","VirtueSky.Misc.Common#GetLocalPositionYZ$1","VirtueSky.Misc.Common#SetLocalPositionYZ$2","VirtueSky.Misc.Common#SetLocalPositionYZ","VirtueSky.Misc.Common#SetLocalPositionYZ$1","VirtueSky.Misc.Common#SetRelativeLocalPositionX","VirtueSky.Misc.Common#SetRelativeLocalPositionY","VirtueSky.Misc.Common#SetRelativeLocalPositionZ","VirtueSky.Misc.Common#SetRelativeLocalPositionXY$2","VirtueSky.Misc.Common#SetRelativeLocalPositionXY","VirtueSky.Misc.Common#SetRelativeLocalPositionXY$1","VirtueSky.Misc.Common#SetRelativeLocalPositionXZ$2","VirtueSky.Misc.Common#SetRelativeLocalPositionXZ","VirtueSky.Misc.Common#SetRelativeLocalPositionXZ$1","VirtueSky.Misc.Common#SetRelativeLocalPositionYZ$2","VirtueSky.Misc.Common#SetRelativeLocalPositionYZ","VirtueSky.Misc.Common#SetRelativeLocalPositionYZ$1","VirtueSky.Misc.Common#SetScaleX","VirtueSky.Misc.Common#SetScaleY","VirtueSky.Misc.Common#SetScaleZ","VirtueSky.Misc.Common#SetScaleXY$3","VirtueSky.Misc.Common#SetScaleXY$1","VirtueSky.Misc.Common#SetScaleXY","VirtueSky.Misc.Common#SetScaleXY$2","VirtueSky.Misc.Common#GetScaleXZ","VirtueSky.Misc.Common#GetScaleXZ$1","VirtueSky.Misc.Common#SetScaleXZ$3","VirtueSky.Misc.Common#SetScaleXZ$1","VirtueSky.Misc.Common#SetScaleXZ","VirtueSky.Misc.Common#SetScaleXZ$2","VirtueSky.Misc.Common#GetScaleYZ","VirtueSky.Misc.Common#GetScaleYZ$1","VirtueSky.Misc.Common#SetScaleYZ$3","VirtueSky.Misc.Common#SetScaleYZ$1","VirtueSky.Misc.Common#SetScaleYZ","VirtueSky.Misc.Common#SetScaleYZ$2","VirtueSky.Misc.Common#SetScale","VirtueSky.Misc.Common#SetRelativeScaleX","VirtueSky.Misc.Common#SetRelativeScaleY","VirtueSky.Misc.Common#SetRelativeScaleZ","VirtueSky.Misc.Common#SetRelativeScaleXY$3","VirtueSky.Misc.Common#SetRelativeScaleXY$1","VirtueSky.Misc.Common#SetRelativeScaleXY","VirtueSky.Misc.Common#SetRelativeScaleXY$2","VirtueSky.Misc.Common#SetRelativeScaleXZ$3","VirtueSky.Misc.Common#SetRelativeScaleXZ$1","VirtueSky.Misc.Common#SetRelativeScaleXZ","VirtueSky.Misc.Common#SetRelativeScaleXZ$2","VirtueSky.Misc.Common#SetRelativeScaleYZ$3","VirtueSky.Misc.Common#SetRelativeScaleYZ$1","VirtueSky.Misc.Common#SetRelativeScaleYZ","VirtueSky.Misc.Common#SetRelativeScaleYZ$2","VirtueSky.Misc.Common#SetRelativeScale","VirtueSky.Misc.Common#SetRotationX","VirtueSky.Misc.Common#SetRotationY","VirtueSky.Misc.Common#SetRotationZ","VirtueSky.Misc.Common#SetRotationXY$2","VirtueSky.Misc.Common#SetRotationXY","VirtueSky.Misc.Common#SetRotationXY$1","VirtueSky.Misc.Common#GetRotationXZ","VirtueSky.Misc.Common#GetRotationXZ$1","VirtueSky.Misc.Common#SetRotationXZ$2","VirtueSky.Misc.Common#SetRotationXZ","VirtueSky.Misc.Common#SetRotationXZ$1","VirtueSky.Misc.Common#GetRotationYZ","VirtueSky.Misc.Common#GetRotationYZ$1","VirtueSky.Misc.Common#SetRotationYZ$2","VirtueSky.Misc.Common#SetRotationYZ","VirtueSky.Misc.Common#SetRotationYZ$1","VirtueSky.Misc.Common#SetRelativeRotationX","VirtueSky.Misc.Common#SetRelativeRotationY","VirtueSky.Misc.Common#SetRelativeRotationZ","VirtueSky.Misc.Common#SetRelativeRotationXY$2","VirtueSky.Misc.Common#SetRelativeRotationXY","VirtueSky.Misc.Common#SetRelativeRotationXY$1","VirtueSky.Misc.Common#SetRelativeRotationXZ$2","VirtueSky.Misc.Common#SetRelativeRotationXZ","VirtueSky.Misc.Common#SetRelativeRotationXZ$1","VirtueSky.Misc.Common#SetRelativeRotationYZ$2","VirtueSky.Misc.Common#SetRelativeRotationYZ","VirtueSky.Misc.Common#SetRelativeRotationYZ$1","VirtueSky.Misc.Common#SetLocalRotationX","VirtueSky.Misc.Common#SetLocalRotationY","VirtueSky.Misc.Common#SetLocalRotationZ","VirtueSky.Misc.Common#SetLocalRotationXY$2","VirtueSky.Misc.Common#SetLocalRotationXY","VirtueSky.Misc.Common#SetLocalRotationXY$1","VirtueSky.Misc.Common#GetLocalRotationXZ","VirtueSky.Misc.Common#GetLocalRotationXZ$1","VirtueSky.Misc.Common#SetLocalRotationXZ$2","VirtueSky.Misc.Common#SetLocalRotationXZ","VirtueSky.Misc.Common#SetLocalRotationXZ$1","VirtueSky.Misc.Common#GetLocalRotationYZ","VirtueSky.Misc.Common#GetLocalRotationYZ$1","VirtueSky.Misc.Common#SetLocalRotationYZ$2","VirtueSky.Misc.Common#SetLocalRotationYZ","VirtueSky.Misc.Common#SetLocalRotationYZ$1","VirtueSky.Misc.Common#SetRelativeLocalRotationX","VirtueSky.Misc.Common#SetRelativeLocalRotationY","VirtueSky.Misc.Common#SetRelativeLocalRotationZ","VirtueSky.Misc.Common#SetRelativeLocalRotationXY$2","VirtueSky.Misc.Common#SetRelativeLocalRotationXY","VirtueSky.Misc.Common#SetRelativeLocalRotationXY$1","VirtueSky.Misc.Common#SetRelativeLocalRotationXZ$2","VirtueSky.Misc.Common#SetRelativeLocalRotationXZ","VirtueSky.Misc.Common#SetRelativeLocalRotationXZ$1","VirtueSky.Misc.Common#SetRelativeLocalRotationYZ$2","VirtueSky.Misc.Common#SetRelativeLocalRotationYZ","VirtueSky.Misc.Common#SetRelativeLocalRotationYZ$1","VirtueSky.Misc.Common#SetAnchoredPositionX","VirtueSky.Misc.Common#SetAnchoredPositionY","VirtueSky.Misc.Common#SetAnchoredPositionZ","VirtueSky.Misc.Common#SetRelativeAnchoredPositionX","VirtueSky.Misc.Common#SetRelativeAnchoredPositionY","VirtueSky.Misc.Common#SetRelativeAnchoredPositionZ","VirtueSky.Misc.SkeletonGraphicExtensions#Duration$1","VirtueSky.Misc.SkeletonGraphicExtensions#Duration","VirtueSky.Misc.SkeletonGraphicExtensions#OnComplete","VirtueSky.Misc.SkeletonGraphicExtensions#OnUpdate","VirtueSky.Misc.SkeletonGraphicExtensions#Play","VirtueSky.Misc.SkeletonGraphicExtensions#PlayOnly","VirtueSky.Misc.SkeletonGraphicExtensions#AddAnimation","VirtueSky.Misc.SkeletonGraphicExtensions#SetSkin$1","VirtueSky.Misc.SkeletonGraphicExtensions#SetSkin","VirtueSky.Misc.SkeletonGraphicExtensions#ChangeAttachment$1","VirtueSky.Misc.SkeletonGraphicExtensions#ChangeAttachment","VirtueSky.Misc.SkeletonGraphicExtensions#MixSkin$1","VirtueSky.Misc.SkeletonGraphicExtensions#MixSkin","VirtueSky.ObjectPooling.Pool#InitPool","VirtueSky.ObjectPooling.Pool#PreSpawn","VirtueSky.ObjectPooling.Pool#Spawn$2","VirtueSky.ObjectPooling.Pool#Spawn","VirtueSky.ObjectPooling.Pool#Spawn$3","VirtueSky.ObjectPooling.Pool#Spawn$1","VirtueSky.ObjectPooling.Pool#DeSpawn","VirtueSky.ObjectPooling.Pool#DeSpawn$1","VirtueSky.ObjectPooling.Pool#DeSpawnAll","VirtueSky.ObjectPooling.Pool#DestroyAll","VirtueSky.ObjectPooling.Pool#DestroyAllWaitPools","VirtueSky.ObjectPooling.PoolHandle#Initialize","VirtueSky.ObjectPooling.PoolHandle#PreSpawn","VirtueSky.ObjectPooling.PoolHandle#SpawnNew","VirtueSky.ObjectPooling.PoolHandle#DeSpawn$1","VirtueSky.ObjectPooling.PoolHandle#DeSpawn","VirtueSky.ObjectPooling.PoolHandle#DeSpawnAll","VirtueSky.ObjectPooling.PoolHandle#DestroyAllWaitPools","VirtueSky.ObjectPooling.PoolHandle#DestroyAll","VirtueSky.ObjectPooling.PoolHandle#Spawn","VirtueSky.ObjectPooling.PoolHandle#Spawn$2","VirtueSky.ObjectPooling.PoolHandle#Spawn$1","VirtueSky.ObjectPooling.PoolHandle#Spawn$3","VirtueSky.ObjectPooling.PoolHandle#InitializeObj","VirtueSky.ObjectPooling.PoolHandle#CleanUp","VirtueSky.TouchInput.TouchInputManager#init","VirtueSky.TouchInput.TouchInputManager#OnEnable","VirtueSky.TouchInput.TouchInputManager#OnDisable","VirtueSky.TouchInput.TouchInputManager#OnChangePreventTouch","VirtueSky.TouchInput.TouchInputManager#Update","VirtueSky.TouchInput.TouchInputManager#HandleTouch","VirtueSky.TouchInput.TouchInputManager#HandleMouse","VirtueSky.UIButton.ButtonCustom#init","VirtueSky.UIButton.ButtonCustom#OnEnable","VirtueSky.UIButton.ButtonCustom#OnDisable","VirtueSky.UIButton.ButtonCustom#OnPointerDown","VirtueSky.UIButton.ButtonCustom#OnPointerUp","VirtueSky.UIButton.ButtonCustom#OnPointerExit","VirtueSky.UIButton.ButtonCustom#DoScale","VirtueSky.UIButton.ButtonCustom#Shrug","VirtueSky.UIButton.ButtonCustom#ResetScale","VirtueSky.Vfx.VfxData#TimeDestroy#get","VirtueSky.Vfx.VfxData#init","VirtueSky.Vfx.VfxData#GetVfxRandom","VirtueSky.Vfx.VfxData#GetVfxByIndex","VirtueSky.Vfx.VfxData#PickRandom","VirtueSky.Vfx.VfxSpawner#Spawn$2","VirtueSky.Vfx.VfxSpawner#Spawn$1","VirtueSky.Vfx.VfxSpawner#Spawn","VirtueSky.Vibration.Vibration#EnableVibration#get","VirtueSky.Vibration.Vibration#EnableVibration#set","VirtueSky.Vibration.Vibration#AndroidVersion#get","VirtueSky.Vibration.Vibration#init","VirtueSky.Vibration.Vibration#Init","VirtueSky.Vibration.Vibration#VibrateIOS","VirtueSky.Vibration.Vibration#VibrateIOS$1","VirtueSky.Vibration.Vibration#VibrateIOS_SelectionChanged","VirtueSky.Vibration.Vibration#VibratePop","VirtueSky.Vibration.Vibration#VibratePeek","VirtueSky.Vibration.Vibration#VibrateNope","VirtueSky.Vibration.Vibration#CancelAndroid","VirtueSky.Vibration.Vibration#HasVibrator","VirtueSky.Vibration.Vibration#Vibrate","VirtueSky.Core.BaseMono#OnEnable","VirtueSky.Core.BaseMono#OnDisable","VirtueSky.Core.BaseMono#Initialize","VirtueSky.Core.BaseMono#Tick","VirtueSky.Core.BaseMono#LateTick","VirtueSky.Core.BaseMono#FixedTick","VirtueSky.Core.BaseMono#CleanUp","VirtueSky.Core.BaseMono#SubTick","VirtueSky.Core.BaseMono#UnSubTick","VirtueSky.Core.BaseSO#Enable","VirtueSky.Core.BaseSO#Disable","VirtueSky.Core.BaseSO#SubTick","VirtueSky.Core.BaseSO#Initialize","VirtueSky.Core.BaseSO#Tick","VirtueSky.Core.BaseSO#LateTick","VirtueSky.Core.BaseSO#FixedTick","VirtueSky.Core.BaseSO#CleanUp","VirtueSky.Core.BaseSO#Destroy","VirtueSky.Core.BaseSO#UnSubTick","Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials","Spine.Unity.BlendModeMaterialsAsset#init","Spine.Unity.BlendModeMaterialsAsset#Apply","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get","Spine.Unity.SkeletonMecanimRootMotion#init","Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonMecanimRootMotion#Reset","Spine.Unity.SkeletonMecanimRootMotion#Start","Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#AdditionalScale#get","Spine.Unity.SkeletonRootMotion#init","Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion","Spine.Unity.SkeletonRootMotion#GetRootMotionInfo","Spine.Unity.SkeletonRootMotion#Reset","Spine.Unity.SkeletonRootMotion#Start","Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta","Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1","Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta","Spine.Unity.SkeletonRootMotion#GetMixAlpha","Spine.Unity.SpineAnimation#ctor","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1","Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2","Spine.Unity.SpineAtlasAsset#IsLoaded#get","Spine.Unity.SpineAtlasAsset#Materials#get","Spine.Unity.SpineAtlasAsset#MaterialCount#get","Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineAtlasAsset#Reset","Spine.Unity.SpineAtlasAsset#Clear","Spine.Unity.SpineAtlasAsset#GetAtlas","Spine.Unity.SpineAtlasAsset#GenerateMesh","Spine.Unity.SpineAttachment#getHierarchy","Spine.Unity.SpineAttachment#getAttachment","Spine.Unity.SpineAttachment#getAttachment$1","Spine.Unity.SpineAttachment#init","Spine.Unity.SpineAttachment#ctor","Spine.Unity.SpineBone#getBone","Spine.Unity.SpineBone#getBoneData","Spine.Unity.SpineBone#ctor","Spine.Unity.SpineEvent#init","Spine.Unity.SpineEvent#ctor","Spine.Unity.SpineIkConstraint#ctor","Spine.Unity.SpinePathConstraint#ctor","Spine.Unity.SpineSkin#init","Spine.Unity.SpineSkin#ctor","Spine.Unity.SpineSlot#init","Spine.Unity.SpineSlot#ctor","Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture","Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites","Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get","Spine.Unity.SpineSpriteAtlasAsset#Materials#get","Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get","Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get","Spine.Unity.SpineSpriteAtlasAsset#Reset","Spine.Unity.SpineSpriteAtlasAsset#Clear","Spine.Unity.SpineSpriteAtlasAsset#GetAtlas","Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions","Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas","Spine.Unity.SpineTransformConstraint#ctor","TheBeginning.Services.PoolInitialization#Initialization","TheBeginning.Services.VibrationInitialization#Initialization","AnimatorComponent#Play","AnimatorComponent#Stop","AnimatorComponent#SetSpeed","CameraSystem#init","CameraSystem#Awake","CameraSystem#ReNative","CameraSystem#CheckDeviceResolution","ObjectBase#IsAlive#get","ObjectBase#IsCanMove#get","ObjectBase#IsHaveStar#get","ObjectBase#Size#get","ObjectBase#ListColliders#get","ObjectBase#YAxis#get","ObjectBase#EColorType#get","ObjectBase#Color#get","ObjectBase#Model#get","ObjectBase#Renderer#get","ObjectBase#MeshFilter#get","ObjectBase#GameObject#get","ObjectBase#FreezeCenterPosition#get","ObjectBase#FreezeCount#get","ObjectBase#TextSize#get","ObjectBase#init","ObjectBase#GetCenterPosition","ObjectBase#GetSize","ObjectBase#Awake","ObjectBase#Start","ObjectBase#OnEnable","ObjectBase#OnDisable","ObjectBase#OnStarttingLevel","ObjectBase#Dead","ObjectBase#GetWidth","ObjectBase#GetHeight","ObjectBase#ChangeColorType","ObjectBase#ChangeMesh","ObjectBase#UpdateRotation","ObjectBase#GetYAngle","ObjectBase#SetPosition","ObjectBase#GetPostion","ObjectBase#OnFreezerSetup","ObjectBase#OnFreezerChanged","ObjectBase#OnFreezerBreak","CoinGenerate#init","CoinGenerate#OnEnable","CoinGenerate#OnDisable","CoinGenerate#SaveCache","CoinGenerate#DecreaseCoin","CoinGenerate#SetFrom","CoinGenerate#AddTo","CoinGenerate#RemoveTo","CoinGenerate#GetToNear","CoinGenerate#GenerateCoin","CoinGenerate#MoveToTarget","CoinGenerate#SetNumberCoin","CoinGenerate#ScaleIconTo","CollisionComponent#OnTriggerEnter","CollisionComponent#OnTriggerStay","CollisionComponent#OnTriggerExit","ConnectionPrefab#init","ConnectionPrefab#OnEnable","ConnectionPrefab#SetMaterial","VirtueSky.Events.EventNoParamResult$1#addOnRaised","VirtueSky.Events.EventNoParamResult$1#removeOnRaised","VirtueSky.Events.EventNoParamResult$1#Raise","VirtueSky.Events.EventNoParamResult$1#AddListener","VirtueSky.Events.EventNoParamResult$1#RemoveListener","VirtueSky.Events.EventNoParamResult$1#RemoveAll","FreezeSystem#Material#get","FreezeSystem#freezePrefab#get","FreezeSystem#init","FreezeSystem#Awake","FreezeSystem#Contains","FreezeSystem#GetPrefab","FreezeSystem#GetFreezer","FreezeSystem#Add","FreezeSystem#Remove","FreezeSystem#CheckNull","FreezeSystem#OnFreezerBreak","FreezeSystem#OnChange","FreezeSystem#OnFreezerCrack","GateSwitcher#MaterialDefault#get","GateSwitcher#MaterialTarget#get","GateSwitcher#init","GateSwitcher#SetUp","GateSwitcher#SetMaterial","GateSwitcher#Switch","GateSwitcher#OnDisable","GridSystem#CoordinateOrigin#get","GridSystem#cells#get","GridSystem#init","GridSystem#GetCell","GridSystem#SetCells","HeartManager#init","HeartManager#Awake","HeartManager#OnEnable","HeartManager#OnDisable","HeartManager#IUpdateTimeIncreaseHeart","HeartUI#init","HeartUI#OnEnable","HeartUI#OnDisable","HeartUI#UpdateIcon","HeartUI#OnUpdateHeart","HeartUI#OnUpdatingTimeIncreaseHeart","HeartUI#OnInStatusImmortal","HeartUI#OnEndStatusImmortal","HeartUI#OnUpdatingTimeImmortal","HeartUI#ConvertSecondToTime","HeartUI#OnClickPlus","MapSystem#GridSystem#get","MapSystem#SizeActive#get","MapSystem#init","MapSystem#GetDistance","MapSystem#GetCell$1","MapSystem#GetCell","Outline#init","Outline#SetUp","Outline#SetColor","Outline#SetWidth","Outline#Active","Outline#Deactive","Outline#AddMaterial","Outline#RemoveMaterial","Outline#SetActive","Outline#SetRenderQueue","Outline#Reset","Outline#ChangeShader","PooledParticleCallback#OnParticleSystemStopped","PooledParticleCallback#IEDespawn","Shutter#init","Shutter#SetUp","Shutter#Switch","Shutter#Refresh","Shutter#SetStatus","Spine.Unity.AnimationReferenceAsset#init","Spine.Unity.AnimationReferenceAsset#op_Implicit","Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get","Spine.Unity.AnimationReferenceAsset#Animation#get","Spine.Unity.AnimationReferenceAsset#Clear","Spine.Unity.AnimationReferenceAsset#Initialize","Spine.Unity.PointFollower#SkeletonRenderer#get","Spine.Unity.PointFollower#SkeletonComponent#get","Spine.Unity.PointFollower#IsValid#get","Spine.Unity.PointFollower#init","Spine.Unity.PointFollower#Initialize","Spine.Unity.PointFollower#HandleRebuildRenderer","Spine.Unity.PointFollower#UpdateReferences","Spine.Unity.PointFollower#OnDestroy","Spine.Unity.PointFollower#LateUpdate","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#NewSpineGameObject","Spine.Unity.SkeletonRenderer#AddSpineComponent","Spine.Unity.SkeletonRenderer#UpdateMode#get","Spine.Unity.SkeletonRenderer#UpdateMode#set","Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get","Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get","Spine.Unity.SkeletonRenderer#Skeleton#get","Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get","Spine.Unity.SkeletonRenderer#init","Spine.Unity.SkeletonRenderer#addGenerateMeshOverride","Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride","Spine.Unity.SkeletonRenderer#SetMeshSettings","Spine.Unity.SkeletonRenderer#Awake","Spine.Unity.SkeletonRenderer#OnDisable","Spine.Unity.SkeletonRenderer#OnDestroy","Spine.Unity.SkeletonRenderer#ClearState","Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity","Spine.Unity.SkeletonRenderer#Initialize","Spine.Unity.SkeletonRenderer#LateUpdate","Spine.Unity.SkeletonRenderer#LateUpdateMesh","Spine.Unity.SkeletonRenderer#OnBecameVisible","Spine.Unity.SkeletonRenderer#OnBecameInvisible","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1","Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots","Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames","Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask","Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType","Spine.Unity.SkeletonRenderer#HandleOnDemandLoading","Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject","Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent","Spine.Unity.SkeletonGraphic#SetRectTransformSize$1","Spine.Unity.SkeletonGraphic#SetRectTransformSize","Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get","Spine.Unity.SkeletonGraphic#MeshScale#get","Spine.Unity.SkeletonGraphic#UpdateMode#get","Spine.Unity.SkeletonGraphic#UpdateMode#set","Spine.Unity.SkeletonGraphic#SeparatorParts#get","Spine.Unity.SkeletonGraphic#CustomTextureOverride#get","Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get","Spine.Unity.SkeletonGraphic#OverrideTexture#get","Spine.Unity.SkeletonGraphic#OverrideTexture#set","Spine.Unity.SkeletonGraphic#mainTexture#get","Spine.Unity.SkeletonGraphic#Skeleton#get","Spine.Unity.SkeletonGraphic#Skeleton#set","Spine.Unity.SkeletonGraphic#SkeletonData#get","Spine.Unity.SkeletonGraphic#IsValid#get","Spine.Unity.SkeletonGraphic#AnimationState#get","Spine.Unity.SkeletonGraphic#MeshGenerator#get","Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get","Spine.Unity.SkeletonGraphic#UpdateTiming#get","Spine.Unity.SkeletonGraphic#UpdateTiming#set","Spine.Unity.SkeletonGraphic#UnscaledTime#get","Spine.Unity.SkeletonGraphic#UnscaledTime#set","Spine.Unity.SkeletonGraphic#init","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer","Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers","Spine.Unity.SkeletonGraphic#Awake","Spine.Unity.SkeletonGraphic#OnDestroy","Spine.Unity.SkeletonGraphic#Rebuild","Spine.Unity.SkeletonGraphic#OnDisable","Spine.Unity.SkeletonGraphic#Update","Spine.Unity.SkeletonGraphic#Update$1","Spine.Unity.SkeletonGraphic#FixedUpdate","Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateAnimationStatus","Spine.Unity.SkeletonGraphic#ApplyAnimation","Spine.Unity.SkeletonGraphic#AfterAnimationApplied","Spine.Unity.SkeletonGraphic#LateUpdate","Spine.Unity.SkeletonGraphic#OnCullStateChanged","Spine.Unity.SkeletonGraphic#OnBecameVisible","Spine.Unity.SkeletonGraphic#OnBecameInvisible","Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames","Spine.Unity.SkeletonGraphic#GetLastMesh","Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds","Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer","Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers","Spine.Unity.SkeletonGraphic#SetRectTransformBounds","Spine.Unity.SkeletonGraphic#Clear","Spine.Unity.SkeletonGraphic#TrimRenderers","Spine.Unity.SkeletonGraphic#Initialize","Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers","Spine.Unity.SkeletonGraphic#UpdateMesh","Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions","Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions","Spine.Unity.SkeletonGraphic#InitMeshBuffers","Spine.Unity.SkeletonGraphic#DisposeMeshBuffers","Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer","Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers","Spine.Unity.SkeletonGraphic#HandleOnDemandLoading","Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount","Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects","Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers","Spine.Unity.SkeletonGraphic#EnsureMeshesCount","Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount","Spine.Unity.SkeletonGraphic#DestroyMeshes","Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount","Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents","Spine.Unity.SkeletonGraphic#GetLayoutScale","Spine.Unity.SkeletonGraphic#GetCurrentRectSize","StarGenerate#init","StarGenerate#OnEnable","StarGenerate#OnDisable","StarGenerate#SaveCache","StarGenerate#DecreaseCoin","StarGenerate#SetFrom","StarGenerate#AddTo","StarGenerate#RemoveTo","StarGenerate#GenerateCoin","StarGenerate#MoveToTarget","StarGenerate#SetNumberCoin","StarGenerate#AddComplete","TheBeginning.LevelSystem.Level#GetTransform","TheBeginning.LevelSystem.Level#OnEnable","TheBeginning.LevelSystem.Level#OnDisable","TheBeginning.LevelSystem.LevelLoader#CurrentLevel","TheBeginning.LevelSystem.LevelLoader#PreviousLevel","TheBeginning.LevelSystem.LevelLoader#OnEnable","TheBeginning.LevelSystem.LevelLoader#Start","TheBeginning.LevelSystem.LevelLoader#LoadLevel","TheBeginning.LevelSystem.LevelLoader#HandleIndexLevel","TheBeginning.LevelSystem.LevelLoader#ActiveCurrentLevel","TheBeginning.UI.UIPopup#ConditionShowMove#get","TheBeginning.UI.UIPopup#ConditionHideMove#get","TheBeginning.UI.UIPopup#ConditionShowOutBack#get","TheBeginning.UI.UIPopup#ConditionHideInBack#get","TheBeginning.UI.UIPopup#ConditionShowFlip#get","TheBeginning.UI.UIPopup#init","TheBeginning.UI.UIPopup#OnEnable","TheBeginning.UI.UIPopup#Show","TheBeginning.UI.UIPopup#Hide","TheBeginning.UI.UIPopup#OnBeforeShow","TheBeginning.UI.UIPopup#OnAfterShow","TheBeginning.UI.UIPopup#OnBeforeHide","TheBeginning.UI.UIPopup#OnAfterHide","TheBeginning.UI.PopupManager#Show","TheBeginning.UI.PopupManager#Hide","TheBeginning.UI.PopupManager#Get","TheBeginning.UI.PopupManager#IsPopupReady","TheBeginning.UI.PopupManager#HideAll","TheBeginning.UI.PopupManager#init","TheBeginning.UI.PopupManager#Awake","TheBeginning.UI.PopupManager#InternalShow","TheBeginning.UI.PopupManager#InternalHide","TheBeginning.UI.PopupManager#InternalGet","TheBeginning.UI.PopupManager#InternalIsPopupReady","TheBeginning.UI.PopupManager#InternalHideAll","TheBeginning.UI.PopupManager#GetKeyPopup","TimingController#OnEnable","TimingController#OnDisable","TimingController#Update","TimingController#AddTimePlayEvent","TimingController#OnStartCountDownTime","TimingController#OnCountDownTimeSetup","TimingController#SetTime","TimingController#OnValidate","TimingController#DisplayTime","TouchSystem#LastPosition#get","TouchSystem#init","TouchSystem#OnEnable","TouchSystem#OnDisable","TouchSystem#Initialize","TouchSystem#OnTouchBegin","TouchSystem#OnTouchEnd","TouchSystem#IsPointerOverUI","TouchSystem#GetPointPosition","TouchSystem#GetToucher","TouchSystem#CleanUp","VirtueSky.Events.BaseEvent$1#init","VirtueSky.Events.BaseEvent$1#addOnRaised","VirtueSky.Events.BaseEvent$1#removeOnRaised","VirtueSky.Events.BaseEvent$1#Raise","VirtueSky.Events.BaseEvent$1#AddListener$1","VirtueSky.Events.BaseEvent$1#AddListener","VirtueSky.Events.BaseEvent$1#RemoveListener$1","VirtueSky.Events.BaseEvent$1#RemoveListener","VirtueSky.Events.BaseEvent$1#RemoveAll","VirtueSky.Audio.AudioManager#init","VirtueSky.Audio.AudioManager#Awake","VirtueSky.Audio.AudioManager#OnEnable","VirtueSky.Audio.AudioManager#OnDisable","VirtueSky.Audio.AudioManager#OnMusicVolumeChanged","VirtueSky.Audio.AudioManager#OnSfxVolumeChanged","VirtueSky.Audio.AudioManager#PlaySfx","VirtueSky.Audio.AudioManager#StopSfx","VirtueSky.Audio.AudioManager#PauseSfx","VirtueSky.Audio.AudioManager#ResumeSfx","VirtueSky.Audio.AudioManager#FinishSfx","VirtueSky.Audio.AudioManager#StopAllSfx","VirtueSky.Audio.AudioManager#PlayMusic","VirtueSky.Audio.AudioManager#StopMusic","VirtueSky.Audio.AudioManager#PauseMusic","VirtueSky.Audio.AudioManager#ResumeMusic","VirtueSky.Audio.AudioManager#OnFinishPlayingAudio","VirtueSky.Audio.AudioManager#StopAndCleanAudioComponent","VirtueSky.Audio.AudioManager#StopAudioMusic","VirtueSky.Audio.AudioManager#GetSoundComponent","VirtueSky.Audio.AudioManager#GetSoundCache","VirtueSky.Audio.SoundCache#ctor","VirtueSky.Events.BaseEvent#init","VirtueSky.Events.BaseEvent#addOnRaised","VirtueSky.Events.BaseEvent#removeOnRaised","VirtueSky.Events.BaseEvent#Raise","VirtueSky.Events.BaseEvent#AddListener","VirtueSky.Events.BaseEvent#AddListener$1","VirtueSky.Events.BaseEvent#RemoveListener","VirtueSky.Events.BaseEvent#RemoveListener$1","VirtueSky.Events.BaseEvent#RemoveAll","VirtueSky.Audio.SoundData#NumberOfAudioClips#get","VirtueSky.Audio.SoundData#init","VirtueSky.Audio.SoundData#GetAudioClip","VirtueSky.Events.BaseEvent$2#init","VirtueSky.Events.BaseEvent$2#addOnRaised","VirtueSky.Events.BaseEvent$2#removeOnRaised","VirtueSky.Events.BaseEvent$2#Raise","VirtueSky.Events.BaseEvent$2#AddListener$1","VirtueSky.Events.BaseEvent$2#AddListener","VirtueSky.Events.BaseEvent$2#RemoveListener$1","VirtueSky.Events.BaseEvent$2#RemoveListener","VirtueSky.Events.BaseEvent$2#RemoveAll","VirtueSky.Core.CacheComponent$1#init","VirtueSky.Core.CacheComponent$1#Awake","VirtueSky.Core.CacheComponent$1#GetCacheComponent","VirtueSky.Component.BounceComponent#init","VirtueSky.Component.BounceComponent#OnEnable","VirtueSky.Component.BounceComponent#Pause","VirtueSky.Component.BounceComponent#Resume","VirtueSky.Component.BounceComponent#FixedTick","VirtueSky.Component.FollowTargetComponent#TargetTransform#get","VirtueSky.Component.FollowTargetComponent#TargetTransform#set","VirtueSky.Component.FollowTargetComponent#OffsetTrans#get","VirtueSky.Component.FollowTargetComponent#OffsetTrans#set","VirtueSky.Component.FollowTargetComponent#DirectionFollowTarget#get","VirtueSky.Component.FollowTargetComponent#DirectionFollowTarget#set","VirtueSky.Component.FollowTargetComponent#TypeFollowTarget#get","VirtueSky.Component.FollowTargetComponent#TypeFollowTarget#set","VirtueSky.Component.FollowTargetComponent#InterpolateValue#get","VirtueSky.Component.FollowTargetComponent#InterpolateValue#set","VirtueSky.Component.FollowTargetComponent#CurrentVelocity#get","VirtueSky.Component.FollowTargetComponent#CurrentVelocity#set","VirtueSky.Component.FollowTargetComponent#SmoothTime#get","VirtueSky.Component.FollowTargetComponent#SmoothTime#set","VirtueSky.Component.FollowTargetComponent#MaxSpeed#get","VirtueSky.Component.FollowTargetComponent#MaxSpeed#set","VirtueSky.Component.FollowTargetComponent#init","VirtueSky.Component.FollowTargetComponent#Awake","VirtueSky.Component.FollowTargetComponent#SetTarget","VirtueSky.Component.FollowTargetComponent#SetDirectionFollowTarget","VirtueSky.Component.FollowTargetComponent#SetTypeFollowTarget","VirtueSky.Component.FollowTargetComponent#LateTick","VirtueSky.Component.FollowTargetComponent#HandleSetPos","VirtueSky.Component.FollowTargetComponent#HandleLerp","VirtueSky.Component.FollowTargetComponent#HandleSmoothDamp","VirtueSky.Component.MoveComponent#init","VirtueSky.Component.MoveComponent#Start","VirtueSky.Component.MoveComponent#Tick","VirtueSky.Component.MoveComponent#StopMoving","VirtueSky.Component.MoveComponent#ResumeMoving","VirtueSky.Component.RotateComponent#init","VirtueSky.Component.RotateComponent#Resume","VirtueSky.Component.RotateComponent#Pause","VirtueSky.Component.RotateComponent#FixedTick","VirtueSky.Component.SafeAreaComponent#init","VirtueSky.Component.SafeAreaComponent#init","VirtueSky.Component.SafeAreaComponent#Awake","VirtueSky.Component.SafeAreaComponent#Tick","VirtueSky.Component.SafeAreaComponent#Refresh","VirtueSky.Component.SafeAreaComponent#GetSafeArea","VirtueSky.Component.SafeAreaComponent#ApplySafeArea","VirtueSky.Component.TimeRemainingComponent#init","VirtueSky.Component.TimeRemainingComponent#InitTargetTime","VirtueSky.Component.TimeRemainingComponent#InitTargetTime$1","VirtueSky.Component.TimeRemainingComponent#GetTimeRemaining","CellGrid#init","CellGrid#GetNeighbour","CellGrid#GetAllNeighbours","CellGrid#PrepareNeighbour","Plane#SetSize","Spine.Unity.SkeletonAnimation#AddToGameObject","Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject","Spine.Unity.SkeletonAnimation#AnimationState#get","Spine.Unity.SkeletonAnimation#UpdateTiming#get","Spine.Unity.SkeletonAnimation#UpdateTiming#set","Spine.Unity.SkeletonAnimation#UnscaledTime#get","Spine.Unity.SkeletonAnimation#UnscaledTime#set","Spine.Unity.SkeletonAnimation#AnimationName#get","Spine.Unity.SkeletonAnimation#AnimationName#set","Spine.Unity.SkeletonAnimation#init","Spine.Unity.SkeletonAnimation#addOnAnimationRebuild","Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild","Spine.Unity.SkeletonAnimation#addBeforeApply","Spine.Unity.SkeletonAnimation#removeBeforeApply","Spine.Unity.SkeletonAnimation#addUpdateLocal","Spine.Unity.SkeletonAnimation#removeUpdateLocal","Spine.Unity.SkeletonAnimation#addUpdateWorld","Spine.Unity.SkeletonAnimation#removeUpdateWorld","Spine.Unity.SkeletonAnimation#addUpdateComplete","Spine.Unity.SkeletonAnimation#removeUpdateComplete","Spine.Unity.SkeletonAnimation#ClearState","Spine.Unity.SkeletonAnimation#Initialize","Spine.Unity.SkeletonAnimation#Update$1","Spine.Unity.SkeletonAnimation#Update","Spine.Unity.SkeletonAnimation#FixedUpdate","Spine.Unity.SkeletonAnimation#UpdateAnimationStatus","Spine.Unity.SkeletonAnimation#ApplyAnimation","Spine.Unity.SkeletonAnimation#AfterAnimationApplied","Spine.Unity.SkeletonAnimation#LateUpdate","Spine.Unity.SkeletonAnimation#OnBecameVisible","Spine.Unity.SkeletonMecanim#Translator#get","Spine.Unity.SkeletonMecanim#UpdateTiming#get","Spine.Unity.SkeletonMecanim#UpdateTiming#set","Spine.Unity.SkeletonMecanim#init","Spine.Unity.SkeletonMecanim#addOnAnimationRebuild","Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild","Spine.Unity.SkeletonMecanim#addBeforeApply","Spine.Unity.SkeletonMecanim#removeBeforeApply","Spine.Unity.SkeletonMecanim#addUpdateLocal","Spine.Unity.SkeletonMecanim#removeUpdateLocal","Spine.Unity.SkeletonMecanim#addUpdateWorld","Spine.Unity.SkeletonMecanim#removeUpdateWorld","Spine.Unity.SkeletonMecanim#addUpdateComplete","Spine.Unity.SkeletonMecanim#removeUpdateComplete","Spine.Unity.SkeletonMecanim#Initialize","Spine.Unity.SkeletonMecanim#Update","Spine.Unity.SkeletonMecanim#Update$1","Spine.Unity.SkeletonMecanim#FixedUpdate","Spine.Unity.SkeletonMecanim#UpdateAnimation","Spine.Unity.SkeletonMecanim#ApplyAnimation","Spine.Unity.SkeletonMecanim#LateUpdate","Spine.Unity.SkeletonMecanim#OnBecameVisible","TheBeginning.UI.GameplayPopup#init","TheBeginning.UI.GameplayPopup#OnBeforeShow","TheBeginning.UI.GameplayPopup#UpdateBoardLevelMode","TheBeginning.UI.GameplayPopup#Refresh","TheBeginning.UI.GameplayPopup#OnBeforeHide","TheBeginning.UI.GameplayPopup#OnBackToBuildTutorialPlaying","TheBeginning.UI.GameplayPopup#Setup","TheBeginning.UI.GameplayPopup#OnShowBoosterGuildEvent","TheBeginning.UI.GameplayPopup#OnClickHome","TheBeginning.UI.GameplayPopup#OnClickReplay","TheBeginning.UI.GameplayPopup#OnPreStartLevel","TheBeginning.UI.GameplayPopup#OnClickPrevious","TheBeginning.UI.GameplayPopup#OnClickSkip","TheBeginning.UI.GameplayPopup#OnClickLose","TheBeginning.UI.GameplayPopup#OnClickWin","TheBeginning.UI.GameplayPopup#OnClickSetting","TheBeginning.UI.GameplayPopup#OnShowCTAButton","TheBeginning.UI.LosePopup#OnBeforeShow","TheBeginning.UI.LosePopup#OnAfterShow","TheBeginning.UI.LosePopup#OnBeforeHide","TheBeginning.UI.LosePopup#OnAfterHide","TheBeginning.UI.LosePopup#ClosePopup","TheBeginning.UI.LosePopup#OnClickReplay","TheBeginning.UI.SettingPopup#OnBeforeShow","TheBeginning.UI.SettingPopup#OnAfterShow","TheBeginning.UI.SettingPopup#OnBeforeHide","TheBeginning.UI.SettingPopup#InitBtnLanguage","TheBeginning.UI.SettingPopup#Init","TheBeginning.UI.SettingPopup#OnClickRestorePurchase","TheBeginning.UI.SettingPopup#OnClickSettingSound","TheBeginning.UI.SettingPopup#OnClickSettingMusic","TheBeginning.UI.SettingPopup#OnClickSettingVibration","TheBeginning.UI.SettingPopup#UpdateStatus","TheBeginning.UI.SettingPopup#OnClickHome","TheBeginning.UI.SettingPopup#OnClickShowPrivacyConsent","TheBeginning.UI.UpdatePopup#Start","TheBeginning.UI.UpdatePopup#OnBeforeShow","TheBeginning.UI.UpdatePopup#Setup","TheBeginning.UI.UpdatePopup#OnChangeValueShowAgain","TheBeginning.UI.WinPopup#init","TheBeginning.UI.WinPopup#OnBeforeShow","TheBeginning.UI.WinPopup#OnBeforeHide","TheBeginning.UI.WinPopup#Setup","TheBeginning.UI.WinPopup#OnClickContinue","TheBeginning.UI.WinPopup#OnClaimCoinWin","TheBeginning.UI.WinPopup#OnAfterHide","TheBeginning.UI.WinPopup#OnMoveAllCoinDone","VirtueSky.Variables.BaseVariable$1#InitializeValue#get","VirtueSky.Variables.BaseVariable$1#Guid#get","VirtueSky.Variables.BaseVariable$1#Guid#set","VirtueSky.Variables.BaseVariable$1#CustomId#get","VirtueSky.Variables.BaseVariable$1#CustomId#set","VirtueSky.Variables.BaseVariable$1#Id#get","VirtueSky.Variables.BaseVariable$1#Value#get","VirtueSky.Variables.BaseVariable$1#Value#set","VirtueSky.Variables.BaseVariable$1#IsShowGuid#get","VirtueSky.Variables.BaseVariable$1#IsShowCustomId#get","VirtueSky.Variables.BaseVariable$1#init","VirtueSky.Variables.BaseVariable$1#OnEnable","VirtueSky.Variables.BaseVariable$1#OnBeforeSerialize","VirtueSky.Variables.BaseVariable$1#OnAfterDeserialize","VirtueSky.Variables.BaseVariable$1#ResetValue","VirtueSky.Variables.BaseVariable$1#toString","VirtueSky.Audio.SoundComponent#GetClip#get","VirtueSky.Audio.SoundComponent#IsPlaying#get","VirtueSky.Audio.SoundComponent#IsLooping#get","VirtueSky.Audio.SoundComponent#Volume#get","VirtueSky.Audio.SoundComponent#Volume#set","VirtueSky.Audio.SoundComponent#Key#get","VirtueSky.Audio.SoundComponent#Key#set","VirtueSky.Audio.SoundComponent#Awake$1","VirtueSky.Audio.SoundComponent#PlayAudioClip","VirtueSky.Audio.SoundComponent#FadeInVolumeMusic","VirtueSky.Audio.SoundComponent#FadeOutVolumeMusic","VirtueSky.Audio.SoundComponent#Resume","VirtueSky.Audio.SoundComponent#Pause","VirtueSky.Audio.SoundComponent#Stop","VirtueSky.Audio.SoundComponent#Finish","VirtueSky.Audio.SoundComponent#FadePlayMusic","VirtueSky.Audio.SoundComponent#OnCompletedInvoke","VirtueSky.Component.ResizeCameraOrthographicComponent#init","VirtueSky.Component.ResizeCameraOrthographicComponent#Awake","VirtueSky.Component.ResizeMatchCanvasScalerComponent#init","VirtueSky.Component.ResizeMatchCanvasScalerComponent#Awake","VirtueSky.Component.ResizeMatchCanvasScalerComponent#GetCanvas","VirtueSky.Events.BaseEventListener$2#init","VirtueSky.Events.BaseEventListener$2#ToggleListenerEvent","VirtueSky.Events.BaseEventListener$2#OnEventRaised","VirtueSky.Events.BaseEventListener$2.EventResponseData#init","VirtueSky.Events.BaseEventListener$3#init","VirtueSky.Events.BaseEventListener$3#ToggleListenerEvent","VirtueSky.Events.BaseEventListener$3#OnEventRaised","VirtueSky.Events.BaseEventListener$3.EventResponseData#init","VirtueSky.Events.BaseEventListener$4#init","VirtueSky.Events.BaseEventListener$4#OnEventRaised","VirtueSky.Events.BaseEventListener$4#ToggleListenerEvent","VirtueSky.Events.BaseEventListener$4.EventResponseData#init","Wall#init","Wall#AutoSize","VirtueSky.Variables.FloatVariable#IsClamped#get","VirtueSky.Variables.FloatVariable#MinMax#get","VirtueSky.Variables.FloatVariable#MinMax#set","VirtueSky.Variables.FloatVariable#Min#get","VirtueSky.Variables.FloatVariable#Min#set","VirtueSky.Variables.FloatVariable#Max#get","VirtueSky.Variables.FloatVariable#Max#set","VirtueSky.Variables.FloatVariable#Value#get","VirtueSky.Variables.FloatVariable#Value#set","VirtueSky.Variables.FloatVariable#init","VirtueSky.Variables.FloatVariable#Add","VirtueSky.Variables.BooleanVariable#Toggle","VirtueSky.Variables.BaseReference$2#Value#get","VirtueSky.Variables.BaseReference$2#Value#set","VirtueSky.Variables.BaseReference$2#init","VirtueSky.Variables.BaseReference$2#toString","VirtueSky.Variables.BaseVariableListener$3#Start","VirtueSky.Variables.BaseVariableListener$3#OnEnable$1","VirtueSky.Variables.IntegerVariable#IsClamped#get","VirtueSky.Variables.IntegerVariable#MinMax#get","VirtueSky.Variables.IntegerVariable#MinMax#set","VirtueSky.Variables.IntegerVariable#Min#get","VirtueSky.Variables.IntegerVariable#Min#set","VirtueSky.Variables.IntegerVariable#Max#get","VirtueSky.Variables.IntegerVariable#Max#set","VirtueSky.Variables.IntegerVariable#Value#get","VirtueSky.Variables.IntegerVariable#Value#set","VirtueSky.Variables.IntegerVariable#init","VirtueSky.Variables.IntegerVariable#Add","WallPath#init","WallPath#Start","WallPath#OnSelectBlock","WallPath#MoveY","WallPath#OnDestroy"]' ) ); }
/**
 * @version 1.0.9358.24084
 * @copyright anton
 * @compiler Bridge.NET 17.9.42-luna
 */
Bridge.assembly("UnityScriptsCompiler", function ($asm, globals) {
    "use strict";

    /*AnimationData start.*/
    Bridge.define("AnimationData", {
        fields: {
            name: null,
            isLoop: false
        },
        props: {
            Name: {
                get: function () {
if ( TRACE ) { TRACE( "AnimationData#Name#get", this ); }

                    return this.name;
                }
            },
            IsLoop: {
                get: function () {
if ( TRACE ) { TRACE( "AnimationData#IsLoop#get", this ); }

                    return this.isLoop;
                }
            }
        }
    });
    /*AnimationData end.*/

    /*VirtueSky.Core.IEntity start.*/
    Bridge.define("VirtueSky.Core.IEntity", {
        $kind: 3
    });
    /*VirtueSky.Core.IEntity end.*/

    /*AnimatorUIControl start.*/
    Bridge.define("AnimatorUIControl", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            timeDelayPlay: 0,
            graphic: null,
            animations: null,
            isHideWhenPlay: false,
            timeHide: 0,
            timeDelayPlaySfx: 0,
            playSfxEvent: null,
            sound: null,
            _playAnimationCount: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "AnimatorUIControl#init", this ); }

                this.timeDelayPlay = 0.0;
                this.isHideWhenPlay = false;
                this.timeHide = 2.0;
                this.timeDelayPlaySfx = 0.5;
                this._playAnimationCount = 0;
            }
        },
        methods: {
            /*AnimatorUIControl.Play start.*/
            Play: function () {
if ( TRACE ) { TRACE( "AnimatorUIControl#Play", this ); }

                this.graphic.gameObject.SetActive(false);
                VirtueSky.Core.App.Delay(this.timeDelayPlay, Bridge.fn.bind(this, function () {
                    VirtueSky.Core.App.Delay(this.timeDelayPlaySfx, Bridge.fn.bind(this, function () {
                        this.playSfxEvent != null ? this.playSfxEvent.Raise(this.sound) : null;
                    }));

                    this.graphic.gameObject.SetActive(true);
                    this.PlayAnimation$1(this.animations);

                    if (this.isHideWhenPlay) {
                        VirtueSky.Core.App.Delay(this.timeHide, Bridge.fn.bind(this, function () {
                            this.graphic.gameObject.SetActive(false);
                        }));
                    }
                }));
            },
            /*AnimatorUIControl.Play end.*/

            /*AnimatorUIControl.PlayAnimation start.*/
            PlayAnimation: function (animation, trackIndex, actionComplete) {
if ( TRACE ) { TRACE( "AnimatorUIControl#PlayAnimation", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (actionComplete === void 0) { actionComplete = null; }
                VirtueSky.Misc.SkeletonGraphicExtensions.OnComplete(VirtueSky.Misc.SkeletonGraphicExtensions.PlayOnly(this.graphic, animation.Name, animation.IsLoop, trackIndex), function () {
                    !Bridge.staticEquals(actionComplete, null) ? actionComplete() : null;
                });
            },
            /*AnimatorUIControl.PlayAnimation end.*/

            /*AnimatorUIControl.PlayAnimation$1 start.*/
            PlayAnimation$1: function (animationBases, actionStepComplete, actionComplete) {
if ( TRACE ) { TRACE( "AnimatorUIControl#PlayAnimation$1", this ); }

                if (actionStepComplete === void 0) { actionStepComplete = null; }
                if (actionComplete === void 0) { actionComplete = null; }
                var Play = null;
                if (animationBases.Count === 0) {
                    !Bridge.staticEquals(actionComplete, null) ? actionComplete() : null;
                    return;
                }
                this._playAnimationCount = 0;
                Play = Bridge.fn.bind(this, function () {
                    this.PlayAnimation(animationBases.getItem(this._playAnimationCount), 0, Bridge.fn.bind(this, function () {
                        this._playAnimationCount = (this._playAnimationCount + 1) | 0;
                        if (this._playAnimationCount >= animationBases.Count) {
                            !Bridge.staticEquals(actionComplete, null) ? actionComplete() : null;
                        } else {
                            !Bridge.staticEquals(actionStepComplete, null) ? actionStepComplete() : null;
                            Play();
                        }
                    }));
                });
                Play();



            },
            /*AnimatorUIControl.PlayAnimation$1 end.*/


        },
        overloads: {
            "PlayAnimation(List<AnimationData>, Action, Action)": "PlayAnimation$1"
        }
    });
    /*AnimatorUIControl end.*/

    /*AxisType start.*/
    Bridge.define("AxisType", {
        $kind: 6,
        statics: {
            fields: {
                XZ: 0,
                XY: 1
            }
        }
    });
    /*AxisType end.*/

    /*ButtonCTA start.*/
    Bridge.define("ButtonCTA", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            urlAndroid: null,
            urlIos: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ButtonCTA#init", this ); }

                this.urlAndroid = "https://play.google.com/store/apps/details?id=com.gamee.homepin2.manor.homescape";
                this.urlIos = "https://apps.apple.com/vn/app/home-pin-2-family-adventure/id6443785203?l";
            }
        },
        methods: {
            /*ButtonCTA.TriggerCTA start.*/
            TriggerCTA: function () {
if ( TRACE ) { TRACE( "ButtonCTA#TriggerCTA", this ); }

                Luna.Unity.Playable.InstallFullGame(this.urlIos, this.urlAndroid);
                Luna.Unity.LifeCycle.GameEnded();
            },
            /*ButtonCTA.TriggerCTA end.*/


        }
    });
    /*ButtonCTA end.*/

    /*CellData start.*/
    Bridge.define("CellData", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "CellData#getDefaultValue", this ); }
 return new CellData(); }
            }
        },
        fields: {
            cell: null,
            direction: 0
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "CellData#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "CellData#getHashCode", this ); }

                var h = Bridge.addHash([3454060167, this.cell, this.direction]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "CellData#equals", this ); }

                if (!Bridge.is(o, CellData)) {
                    return false;
                }
                return Bridge.equals(this.cell, o.cell) && Bridge.equals(this.direction, o.direction);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "CellData#$clone", this ); }

                var s = to || new CellData();
                s.cell = this.cell;
                s.direction = this.direction;
                return s;
            }
        }
    });
    /*CellData end.*/

    /*IFreezer start.*/
    Bridge.define("IFreezer", {
        $kind: 3
    });
    /*IFreezer end.*/

    /*IObject start.*/
    Bridge.define("IObject", {
        $kind: 3
    });
    /*IObject end.*/

    /*CoinSystem start.*/
    Bridge.define("CoinSystem", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                CURRENT_COIN: null
            },
            events: {
                OnAddCoinEvent: null,
                OnMinusCoinEvent: null,
                OnSetCoinEvent: null
            },
            props: {
                CurrentCoin: {
                    get: function () {
if ( TRACE ) { TRACE( "CoinSystem#CurrentCoin#get", this ); }

                        return VirtueSky.DataStorage.GameData.Get(System.Int32, CoinSystem.CURRENT_COIN, 0);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "CoinSystem#CurrentCoin#set", this ); }

                        VirtueSky.DataStorage.GameData.Set(System.Int32, CoinSystem.CURRENT_COIN, value);
                        VirtueSky.DataStorage.GameData.Save();
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "CoinSystem#init", this ); }

                    this.CURRENT_COIN = "CURRENT_COIN";
                }
            },
            methods: {
                /*CoinSystem.AddCoin:static start.*/
                AddCoin: function (value, posGenerateCoin, resourceType, resourceReason, placement, isGenerate) {
if ( TRACE ) { TRACE( "CoinSystem#AddCoin", this ); }

                    if (isGenerate === void 0) { isGenerate = true; }
                    !Bridge.staticEquals(CoinSystem.OnAddCoinEvent, null) ? CoinSystem.OnAddCoinEvent(value, posGenerateCoin.$clone(), resourceType, TrackingEnum.EResourceName.gold, resourceReason, placement, isGenerate) : null;
                },
                /*CoinSystem.AddCoin:static end.*/

                /*CoinSystem.MinusCoin:static start.*/
                MinusCoin: function (value, resourceType, resourceReason, placement) {
if ( TRACE ) { TRACE( "CoinSystem#MinusCoin", this ); }

                    !Bridge.staticEquals(CoinSystem.OnMinusCoinEvent, null) ? CoinSystem.OnMinusCoinEvent(value, resourceType, TrackingEnum.EResourceName.gold, resourceReason, placement) : null;
                },
                /*CoinSystem.MinusCoin:static end.*/

                /*CoinSystem.SetCoin:static start.*/
                SetCoin: function (value, posGenerateCoin, resourceType, resourceReason, placement) {
if ( TRACE ) { TRACE( "CoinSystem#SetCoin", this ); }

                    !Bridge.staticEquals(CoinSystem.OnSetCoinEvent, null) ? CoinSystem.OnSetCoinEvent(value, posGenerateCoin.$clone(), resourceType, TrackingEnum.EResourceName.gold, resourceReason, placement) : null;
                },
                /*CoinSystem.SetCoin:static end.*/

                /*CoinSystem.GetCurrentCoin:static start.*/
                GetCurrentCoin: function () {
if ( TRACE ) { TRACE( "CoinSystem#GetCurrentCoin", this ); }

                    return CoinSystem.CurrentCoin;
                },
                /*CoinSystem.GetCurrentCoin:static end.*/


            }
        },
        fields: {
            generateCoinEvent: null,
            addCoinEvent: null,
            updateCoinEvent: null,
            minusCoinEvent: null,
            balanceAmount: null
        },
        methods: {
            /*CoinSystem.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CoinSystem#Awake", this ); }

                CoinSystem.addOnAddCoinEvent(Bridge.fn.cacheBind(this, this.InternalAddCoin));
                CoinSystem.addOnMinusCoinEvent(Bridge.fn.cacheBind(this, this.InternalMinusCoin));
                CoinSystem.addOnSetCoinEvent(Bridge.fn.cacheBind(this, this.InternalSetCoin));
            },
            /*CoinSystem.Awake end.*/

            /*CoinSystem.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "CoinSystem#OnDestroy", this ); }

                CoinSystem.removeOnAddCoinEvent(Bridge.fn.cacheBind(this, this.InternalAddCoin));
                CoinSystem.removeOnMinusCoinEvent(Bridge.fn.cacheBind(this, this.InternalMinusCoin));
                CoinSystem.removeOnSetCoinEvent(Bridge.fn.cacheBind(this, this.InternalSetCoin));
            },
            /*CoinSystem.OnDestroy end.*/

            /*CoinSystem.InternalSetCoin start.*/
            InternalSetCoin: function (value, posGenerateCoin, resourceType, resourceName, resourceReason, placement) {
if ( TRACE ) { TRACE( "CoinSystem#InternalSetCoin", this ); }

                if (value > CoinSystem.CurrentCoin) {
                    var valueChange = (value - CoinSystem.CurrentCoin) | 0;

                    CoinSystem.CurrentCoin = value;
                    this.OnChangeValue(CoinSystem.CurrentCoin);
                    this.addCoinEvent.Raise();

                    if (!pc.Vec3.equals( posGenerateCoin, Bridge.getDefaultValue(UnityEngine.Vector3) )) {
                        this.generateCoinEvent.Raise(posGenerateCoin.$clone());
                    }
                } else if (value < CoinSystem.CurrentCoin) {
                    var valueChange1 = (CoinSystem.CurrentCoin - value) | 0;
                    CoinSystem.CurrentCoin = value;
                    this.OnChangeValue(CoinSystem.CurrentCoin);
                    this.minusCoinEvent.Raise();
                }
            },
            /*CoinSystem.InternalSetCoin end.*/

            /*CoinSystem.InternalAddCoin start.*/
            InternalAddCoin: function (value, posGenerateCoin, resourceType, resourceName, resourceReason, placement, isGenerate) {
if ( TRACE ) { TRACE( "CoinSystem#InternalAddCoin", this ); }

                if (isGenerate === void 0) { isGenerate = true; }
                CoinSystem.CurrentCoin = (CoinSystem.CurrentCoin + value) | 0;
                this.OnChangeValue(CoinSystem.CurrentCoin);
                if (!isGenerate) {
                    this.updateCoinEvent != null ? this.updateCoinEvent.Raise() : null;
                    return;
                }
                this.addCoinEvent.Raise();
                if (!pc.Vec3.equals( posGenerateCoin, Bridge.getDefaultValue(UnityEngine.Vector3) )) {
                    this.generateCoinEvent.Raise(posGenerateCoin.$clone());
                }
            },
            /*CoinSystem.InternalAddCoin end.*/

            /*CoinSystem.InternalMinusCoin start.*/
            InternalMinusCoin: function (value, resourceType, resourceName, resourceReason, placement) {
if ( TRACE ) { TRACE( "CoinSystem#InternalMinusCoin", this ); }

                CoinSystem.CurrentCoin = (CoinSystem.CurrentCoin - value) | 0;
                this.OnChangeValue(CoinSystem.CurrentCoin);
                this.minusCoinEvent.Raise();
            },
            /*CoinSystem.InternalMinusCoin end.*/

            /*CoinSystem.OnChangeValue start.*/
            OnChangeValue: function (value) {
if ( TRACE ) { TRACE( "CoinSystem#OnChangeValue", this ); }

                this.balanceAmount.Value = value;
            },
            /*CoinSystem.OnChangeValue end.*/


        }
    });
    /*CoinSystem end.*/

    /*CoinUpdater start.*/
    Bridge.define("CoinUpdater", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CurrencyAmountText: null,
            iconCoin: null,
            updateCoinEvent: null,
            moveOneCoinDone: null,
            moveAllCoinDone: null,
            decreaseCoinEvent: null,
            addTargetToCoinGenerateEvent: null,
            removeTargetToCoinGenerateEvent: null,
            _isProcessingBuilding: false,
            isFirsCoinMoveDone: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CoinUpdater#init", this ); }

                this.isFirsCoinMoveDone = false;
            }
        },
        methods: {
            /*CoinUpdater.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "CoinUpdater#OnEnable", this ); }

                this._isProcessingBuilding = false;
                this.moveOneCoinDone.AddListener(Bridge.fn.cacheBind(this, this.MoveOneCoinDone));
                this.decreaseCoinEvent.AddListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.moveAllCoinDone.AddListener(Bridge.fn.cacheBind(this, this.MoveAllCoinDone));
                if (UnityEngine.Object.op_Implicit(this.updateCoinEvent)) {
                    this.updateCoinEvent.AddListener(Bridge.fn.cacheBind(this, this.UpdateTextCoin));
                }
                this.addTargetToCoinGenerateEvent.Raise(this.iconCoin);
                this.UpdateDisplayValue(CoinSystem.GetCurrentCoin());
            },
            /*CoinUpdater.OnEnable end.*/

            /*CoinUpdater.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "CoinUpdater#OnDisable", this ); }

                this.moveOneCoinDone.RemoveListener(Bridge.fn.cacheBind(this, this.MoveOneCoinDone));
                this.moveAllCoinDone.RemoveListener(Bridge.fn.cacheBind(this, this.MoveAllCoinDone));
                this.decreaseCoinEvent.RemoveListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.removeTargetToCoinGenerateEvent.Raise(this.iconCoin);
                if (UnityEngine.Object.op_Implicit(this.updateCoinEvent)) {
                    this.updateCoinEvent.RemoveListener(Bridge.fn.cacheBind(this, this.UpdateTextCoin));
                }
            },
            /*CoinUpdater.OnDisable end.*/

            /*CoinUpdater.OnBuildingProcessing start.*/
            OnBuildingProcessing: function (isProcessing) {
if ( TRACE ) { TRACE( "CoinUpdater#OnBuildingProcessing", this ); }

                this._isProcessingBuilding = isProcessing;
            },
            /*CoinUpdater.OnBuildingProcessing end.*/

            /*CoinUpdater.MoveOneCoinDone start.*/
            MoveOneCoinDone: function () {
if ( TRACE ) { TRACE( "CoinUpdater#MoveOneCoinDone", this ); }

                if (!this.isFirsCoinMoveDone) {
                    this.isFirsCoinMoveDone = true;
                    this.UpdateTextCoin();
                }
            },
            /*CoinUpdater.MoveOneCoinDone end.*/

            /*CoinUpdater.MoveAllCoinDone start.*/
            MoveAllCoinDone: function () {
if ( TRACE ) { TRACE( "CoinUpdater#MoveAllCoinDone", this ); }

                this.isFirsCoinMoveDone = false;
            },
            /*CoinUpdater.MoveAllCoinDone end.*/

            /*CoinUpdater.DecreaseCoin start.*/
            DecreaseCoin: function () {
if ( TRACE ) { TRACE( "CoinUpdater#DecreaseCoin", this ); }

                this.UpdateTextCoin();
            },
            /*CoinUpdater.DecreaseCoin end.*/

            /*CoinUpdater.UpdateDisplayValue start.*/
            UpdateDisplayValue: function (value) {
if ( TRACE ) { TRACE( "CoinUpdater#UpdateDisplayValue", this ); }

                this.CurrencyAmountText.text = Extension.GetTextValueFromNumber(value);
            },
            /*CoinUpdater.UpdateDisplayValue end.*/

            /*CoinUpdater.UpdateTextCoin start.*/
            UpdateTextCoin: function () {
if ( TRACE ) { TRACE( "CoinUpdater#UpdateTextCoin", this ); }

                var starCoin = Extension.GetNumberFromText(this.CurrencyAmountText.text);
                var coinChange = starCoin;
                DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.DOTween.To$2(function () {
                    return starCoin;
                }, function (x) {
                    starCoin = x;
                }, CoinSystem.GetCurrentCoin(), 0.5), Bridge.fn.bind(this, function () {
                    coinChange = starCoin;
                    this.UpdateDisplayValue(coinChange);
                }));
            },
            /*CoinUpdater.UpdateTextCoin end.*/

            /*CoinUpdater.OnClickPlus start.*/
            OnClickPlus: function () {
if ( TRACE ) { TRACE( "CoinUpdater#OnClickPlus", this ); }

                if (this._isProcessingBuilding) {
                    return;
                }
            },
            /*CoinUpdater.OnClickPlus end.*/


        }
    });
    /*CoinUpdater end.*/

    /*ColorConfig start.*/
    Bridge.define("ColorConfig", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            colors: null
        },
        props: {
            Colors: {
                get: function () {
if ( TRACE ) { TRACE( "ColorConfig#Colors#get", this ); }

                    return this.colors;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ColorConfig#init", this ); }

                this.colors = new (System.Collections.Generic.List$1(ColorData)).ctor();
            }
        },
        methods: {
            /*ColorConfig.GetData start.*/
            GetData: function (type) {
if ( TRACE ) { TRACE( "ColorConfig#GetData", this ); }

                return this.colors.Find(function (x) {
                    return x.Type === type;
                });
            },
            /*ColorConfig.GetData end.*/

            /*ColorConfig.GetColor start.*/
            GetColor: function (type) {
if ( TRACE ) { TRACE( "ColorConfig#GetColor", this ); }

                return this.GetData(type).Color.$clone();
            },
            /*ColorConfig.GetColor end.*/


        }
    });
    /*ColorConfig end.*/

    /*ColorData start.*/
    Bridge.define("ColorData", {
        fields: {
            type: 0,
            color: null
        },
        props: {
            Color: {
                get: function () {
if ( TRACE ) { TRACE( "ColorData#Color#get", this ); }

                    return this.color.$clone();
                }
            },
            Type: {
                get: function () {
if ( TRACE ) { TRACE( "ColorData#Type#get", this ); }

                    return this.type;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ColorData#init", this ); }

                this.color = new UnityEngine.Color();
            }
        }
    });
    /*ColorData end.*/

    /*Constant start.*/
    Bridge.define("Constant", {
        statics: {
            fields: {
                IS_FIRST_OPEN_GAME: null,
                IS_TESTING: null,
                DATE_TIME_START: null,
                LAST_DAILY_REWARD_CLAIM: null,
                LAST_DAILY_GIFT_CLAIM: null,
                LAST_DAILY_GIFT: null,
                LAST_DAILY_INFINITY: null,
                IS_START_LOOPING_DAILY_REWARD: null,
                DAILY_REWARD_DAY_INDEX: null,
                TOTAL_CLAIM_DAILY_REWARD: null,
                IS_OFF_INTER_ADS: null,
                LAST_WIN_STREAK_START: null,
                LAST_SESSION_TIME: null,
                GAME_SCENE: null,
                SERVICE_SCENE: null,
                EMPTY_SCENE: null,
                INDEX_LEVEL_CURRENT: null,
                PROGRESS_AMOUNT: null,
                UNLOCK_ITEM: null,
                EQUIP_ITEM: null,
                GAMEOBJECT_SHOW: null,
                PERCENT_WIN_GIFT: null,
                CURRENT_MONTH_BATTLE_PASS: null,
                SO_Event: null,
                SO_Variable: null,
                Normal_Attribute: null,
                Environment: null,
                UI_Motion: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Constant#init", this ); }

                    this.IS_FIRST_OPEN_GAME = "IS_FIRST_OPEN_GAME";
                    this.IS_TESTING = "IS_TESTING";
                    this.DATE_TIME_START = "DATE_TIME_START";
                    this.LAST_DAILY_REWARD_CLAIM = "LAST_DAILY_REWARD_CLAIM";
                    this.LAST_DAILY_GIFT_CLAIM = "LAST_DAILY_GIFT_CLAIM";
                    this.LAST_DAILY_GIFT = "LAST_DAILY_GIFT";
                    this.LAST_DAILY_INFINITY = "LAST_DAILY_INFINITY";
                    this.IS_START_LOOPING_DAILY_REWARD = "IS_START_LOOPING_DAILY_REWARD";
                    this.DAILY_REWARD_DAY_INDEX = "DAILY_REWARD_DAY_INDEX";
                    this.TOTAL_CLAIM_DAILY_REWARD = "TOTAL_CLAIM_DAILY_REWARD";
                    this.IS_OFF_INTER_ADS = "IS_OFF_INTER_ADS";
                    this.LAST_WIN_STREAK_START = "LAST_WIN_STREAK_START";
                    this.LAST_SESSION_TIME = "LAST_SESSION_TIME";
                    this.GAME_SCENE = "Game";
                    this.SERVICE_SCENE = "Service";
                    this.EMPTY_SCENE = "Empty";
                    this.INDEX_LEVEL_CURRENT = "INDEX_LEVEL_CURRENT";
                    this.PROGRESS_AMOUNT = "PROGRESS_AMOUNT";
                    this.UNLOCK_ITEM = "UNLOCK_ITEM";
                    this.EQUIP_ITEM = "EQUIP_ITEM";
                    this.GAMEOBJECT_SHOW = "GAMEOBJECT_SHOW";
                    this.PERCENT_WIN_GIFT = "PERCENT_WIN_GIFT";
                    this.CURRENT_MONTH_BATTLE_PASS = "CURRENT_MONTH_BATTLE_PASS";
                    this.SO_Event = "SO_Event";
                    this.SO_Variable = "SO_Variable";
                    this.Normal_Attribute = "Normal_Attribute";
                    this.Environment = "Environment";
                    this.UI_Motion = "UI_Motion";
                }
            }
        }
    });
    /*Constant end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction");
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#keepWaiting#get", this ); }

                    return this.t.active && !DG.Tweening.TweenExtensions.IsComplete(this.t);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForCompletion#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            elapsedLoops: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#keepWaiting#get", this ); }

                    return this.t.active && DG.Tweening.TweenExtensions.CompletedLoops(this.t) < this.elapsedLoops;
                }
            }
        },
        ctors: {
            ctor: function (tween, elapsedLoops) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.elapsedLoops = elapsedLoops;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForKill", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#keepWaiting#get", this ); }

                    return this.t.active;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForKill#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForPosition", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null,
            position: 0
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#keepWaiting#get", this ); }

                    return this.t.active && this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) < this.position;
                }
            }
        },
        ctors: {
            ctor: function (tween, position) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForPosition#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
                this.position = position;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForRewind", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#keepWaiting#get", this ); }

                    return this.t.active && (!this.t.playedOnce || this.t.position * (((DG.Tweening.TweenExtensions.CompletedLoops(this.t) + 1) | 0)) > 0);
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForRewind#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    Bridge.define("DG.Tweening.DOTweenCYInstruction.WaitForStart", {
        inherits: [UnityEngine.CustomYieldInstruction],
        $kind: 1002,
        fields: {
            t: null
        },
        props: {
            keepWaiting: {
                get: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#keepWaiting#get", this ); }

                    return this.t.active && !this.t.playedOnce;
                }
            }
        },
        ctors: {
            ctor: function (tween) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenCYInstruction.WaitForStart#ctor", this ); }

                this.$initialize();
                UnityEngine.CustomYieldInstruction.ctor.call(this);
                this.t = tween;
            }
        }
    });
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    Bridge.define("DG.Tweening.DOTweenModuleAudio", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static start.*/
                /**
                 * Tweens an AudioSource's volume to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFade", this ); }

                    if (endValue < 0) {
                        endValue = 0;
                    } else {
                        if (endValue > 1) {
                            endValue = 1;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.volume;
                    }, function (x) {
                        target.volume = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static start.*/
                /**
                 * Tweens an AudioSource's pitch to the given value.
                 Also stores the AudioSource as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.AudioSource}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPitch: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPitch", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.pitch;
                    }, function (x) {
                        target.pitch = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPitch:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static start.*/
                /**
                 * Tweens an AudioMixer's exposed float to the given value.
                 Also stores the AudioMixer as the tween's target so it can be used for filtered operations.
                 Note that you need to manually expose a float in an AudioMixerGroup in order to be able to tween it from an AudioMixer.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}      target       
                 * @param   {string}                            floatName    Name given to the exposed float to set
                 * @param   {number}                            endValue     The end value to reach
                 * @param   {number}                            duration     The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSetFloat: function (target, floatName, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSetFloat", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        var currVal = { };
                        target.GetFloat(floatName, currVal);
                        return currVal.v;
                    }, function (x) {
                        target.SetFloat(floatName, x);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSetFloat:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static start.*/
                /**
                 * Completes all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens completed
                 (meaning the tweens that don't have infinite loops and were not already complete)
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target           
                 * @param   {boolean}                         withCallbacks    For Sequences only: if TRUE also internal Sequence callbacks will be fired,
                 otherwise they will be ignored
                 * @return  {number}
                 */
                DOComplete: function (target, withCallbacks) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOComplete", this ); }

                    if (withCallbacks === void 0) { withCallbacks = false; }
                    return DG.Tweening.DOTween.Complete(target, withCallbacks);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOComplete:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOKill:static start.*/
                /**
                 * Kills all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens killed.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target      
                 * @param   {boolean}                         complete    If TRUE completes the tween before killing it
                 * @return  {number}
                 */
                DOKill: function (target, complete) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOKill", this ); }

                    if (complete === void 0) { complete = false; }
                    return DG.Tweening.DOTween.Kill(target, complete);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOKill:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static start.*/
                /**
                 * Flips the direction (backwards if it was going forward or viceversa) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens flipped.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOFlip: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOFlip", this ); }

                    return DG.Tweening.DOTween.Flip(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOFlip:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static start.*/
                /**
                 * Sends to the given position all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target     
                 * @param   {number}                          to         Time position to reach
                 (if higher than the whole tween duration the tween will simply reach its end)
                 * @param   {boolean}                         andPlay    If TRUE will play the tween after reaching the given position, otherwise it will pause it
                 * @return  {number}
                 */
                DOGoto: function (target, to, andPlay) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOGoto", this ); }

                    if (andPlay === void 0) { andPlay = false; }
                    return DG.Tweening.DOTween.Goto(target, to, andPlay);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOGoto:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPause:static start.*/
                /**
                 * Pauses all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens paused.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPause", this ); }

                    return DG.Tweening.DOTween.Pause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPause:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static start.*/
                /**
                 * Plays all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlay: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlay", this ); }

                    return DG.Tweening.DOTween.Play(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlay:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static start.*/
                /**
                 * Plays backwards all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayBackwards: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayBackwards", this ); }

                    return DG.Tweening.DOTween.PlayBackwards(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayBackwards:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static start.*/
                /**
                 * Plays forward all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens played.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOPlayForward: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOPlayForward", this ); }

                    return DG.Tweening.DOTween.PlayForward(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOPlayForward:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORestart:static start.*/
                /**
                 * Restarts all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens restarted.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORestart: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORestart", this ); }

                    return DG.Tweening.DOTween.Restart(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORestart:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DORewind:static start.*/
                /**
                 * Rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DORewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DORewind", this ); }

                    return DG.Tweening.DOTween.Rewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DORewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static start.*/
                /**
                 * Smoothly rewinds all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens rewinded.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOSmoothRewind: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOSmoothRewind", this ); }

                    return DG.Tweening.DOTween.SmoothRewind(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOSmoothRewind:static end.*/

                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static start.*/
                /**
                 * Toggles the paused state (plays if it was paused, pauses if it was playing) of all tweens that have this target as a reference
                 (meaning tweens that were started from this target, or that had this target added as an Id)
                 and returns the total number of tweens involved.
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleAudio
                 * @memberof DG.Tweening.DOTweenModuleAudio
                 * @param   {UnityEngine.Audio.AudioMixer}    target
                 * @return  {number}
                 */
                DOTogglePause: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleAudio#DOTogglePause", this ); }

                    return DG.Tweening.DOTween.TogglePause(target);
                },
                /*DG.Tweening.DOTweenModuleAudio.DOTogglePause:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody's X position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody's Y position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static start.*/
                /**
                 * Tweens a Rigidbody's Z position to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOMoveZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOMoveZ:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody's rotation to the given value.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {DG.Tweening.RotateMode}            mode        Rotation mode
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration, mode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DORotate", this ); }

                    if (mode === void 0) { mode = 0; }
                    var t = DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), t, target);
                    t.plugOptions.rotateMode = mode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static start.*/
                /**
                 * Tweens a Rigidbody's rotation so that it will look towards the given position.
                 Also stores the rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target            
                 * @param   {UnityEngine.Vector3}               towards           The position to look at
                 * @param   {number}                            duration          The duration of the tween
                 * @param   {DG.Tweening.AxisConstraint}        axisConstraint    Eventual axis constraint for the rotation
                 * @param   {?UnityEngine.Vector3}              up                The vector that defines in which direction up is (default: Vector3.up)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLookAt: function (target, towards, duration, axisConstraint, up) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLookAt", this ); }

                    if (axisConstraint === void 0) { axisConstraint = 0; }
                    if (up === void 0) { up = null; }
                    var t = DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.DOTween.To$9(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), towards.$clone(), duration), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetLookAt);
                    t.plugOptions.axisConstraint = axisConstraint;
                    t.plugOptions.up = (pc.Vec3.equals( up, null )) ? pc.Vec3.UP.clone() : System.Nullable.getValue(up);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLookAt:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}    target       
                 * @param   {UnityEngine.Vector3}      endValue     The end value to reach
                 * @param   {number}                   jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                   numJumps     Total number of jumps
                 * @param   {number}                   duration     The duration of the tween
                 * @param   {boolean}                  snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, jumpPower, 0 ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( endValue.x, 0, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(DG.Tweening.DOTween.To$12(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec3( 0, 0, endValue.z ), duration), DG.Tweening.AxisConstraint.Z, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.position.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static start.*/
                DOPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOPath$1:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a rigidbody correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics
                 * @memberof DG.Tweening.DOTweenModulePhysics
                 * @param   {UnityEngine.Rigidbody}             target        
                 * @param   {Array.<UnityEngine.Vector3>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static start.*/
                DOLocalPath$1: function (target, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics#DOLocalPath$1", this ); }

                    if (pathMode === void 0) { pathMode = 1; }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, path, duration), target);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics.DOLocalPath$1:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    Bridge.define("DG.Tweening.DOTweenModulePhysics2D", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMove: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMove", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMove:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static start.*/
                /**
                 * Tweens a Rigidbody2D's X position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveX:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static start.*/
                /**
                 * Tweens a Rigidbody2D's Y position to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMoveY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOMoveY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, Bridge.fn.cacheBind(target, target.MovePosition), new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOMoveY:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static start.*/
                /**
                 * Tweens a Rigidbody2D's rotation to the given value.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DORotate: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DORotate", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.rotation;
                    }, Bridge.fn.cacheBind(target, target.MoveRotation), endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DORotate:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static start.*/
                /**
                 * Tweens a Rigidbody2D's position to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>IMPORTANT: a rigidbody2D can't be animated in a jump arc using MovePosition, so the tween will directly set the position</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}    target       
                 * @param   {UnityEngine.Vector2}        endValue     The end value to reach
                 * @param   {number}                     jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                     numJumps     Total number of jumps
                 * @param   {number}                     duration     The duration of the tween
                 * @param   {boolean}                    snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJump: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOJump", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.position.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.position;
                    }, function (x) {
                        target.position = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Tween, yTween, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = UnityEngine.Vector3.FromVector2(target.position.$clone());
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedPercentage(yTween), DG.Tweening.Ease.OutQuad);
                        target.MovePosition$1(pos);
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOJump:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's position through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations.
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoints to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path (useless in case of Linear paths): higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return UnityEngine.Vector3.FromVector2(target.position);
                    }, function (x) {
                        target.MovePosition$1(x);
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOPath:static end.*/

                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static start.*/
                /**
                 * Tweens a Rigidbody2D's localPosition through the given path waypoints, using the chosen path algorithm.
                 Also stores the Rigidbody2D as the tween's target so it can be used for filtered operations
                 <p>NOTE: to tween a Rigidbody2D correctly it should be set to kinematic at least while being tweened.</p><p>BEWARE: doesn't work on Windows Phone store (waiting for Unity to fix their own bug).
                 If you plan to publish there you should use a regular transform.DOLocalPath.</p>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModulePhysics2D
                 * @memberof DG.Tweening.DOTweenModulePhysics2D
                 * @param   {UnityEngine.Rigidbody2D}           target        
                 * @param   {Array.<UnityEngine.Vector2>}       path          The waypoint to go through
                 * @param   {number}                            duration      The duration of the tween
                 * @param   {DG.Tweening.PathType}              pathType      The type of path: Linear (straight path), CatmullRom (curved CatmullRom path) or CubicBezier (curved with control points)
                 * @param   {DG.Tweening.PathMode}              pathMode      The path mode: 3D, side-scroller 2D, top-down 2D
                 * @param   {number}                            resolution    The resolution of the path: higher resolutions make for more detailed curved paths but are more expensive.
                 Defaults to 10, but a value of 5 is usually enough if you don't have dramatic long curves between waypoints
                 * @param   {?UnityEngine.Color}                gizmoColor    The color of the path (shown when gizmos are active in the Play panel and the tween is running)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOLocalPath: function (target, path, duration, pathType, pathMode, resolution, gizmoColor) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModulePhysics2D#DOLocalPath", this ); }

                    if (pathType === void 0) { pathType = 0; }
                    if (pathMode === void 0) { pathMode = 1; }
                    if (resolution === void 0) { resolution = 10; }
                    if (gizmoColor === void 0) { gizmoColor = null; }
                    if (resolution < 1) {
                        resolution = 1;
                    }
                    var len = path.length;
                    var path3D = System.Array.init(len, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        path3D[i] = UnityEngine.Vector3.FromVector2(path[i].$clone());
                    }
                    var trans = target.transform;
                    var t = DG.Tweening.TweenSettingsExtensions.SetUpdate$1(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions), DG.Tweening.DOTween.To(UnityEngine.Vector3, DG.Tweening.Plugins.Core.PathCore.Path, DG.Tweening.Plugins.Options.PathOptions, DG.Tweening.Plugins.PathPlugin.Get(), function () {
                        return trans.localPosition;
                    }, function (x) {
                        target.MovePosition$1(UnityEngine.Component.op_Equality(trans.parent, null) ? x.$clone() : trans.parent.TransformPoint$1(x));
                    }, new DG.Tweening.Plugins.Core.PathCore.Path.$ctor1(pathType, path3D, resolution, System.Nullable.lift1("$clone", gizmoColor)), duration), target), DG.Tweening.UpdateType.Fixed);

                    t.plugOptions.isRigidbody = true;
                    t.plugOptions.mode = pathMode;
                    t.plugOptions.useLocalPosition = true;
                    return t;
                },
                /*DG.Tweening.DOTweenModulePhysics2D.DOLocalPath:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    Bridge.define("DG.Tweening.DOTweenModuleSprite", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOFade:static start.*/
                /**
                 * Tweens a Material's alpha color to the given value.
                 Also stores the spriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}        target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOFade", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {pc.ColorGradient}              gradient    The gradient to use
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleSprite.DOColor(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleSprite.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static start.*/
                /**
                 * Tweens a SpriteRenderer's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the SpriteRenderer as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleSprite
                 * @memberof DG.Tweening.DOTweenModuleSprite
                 * @param   {UnityEngine.SpriteRenderer}    target      
                 * @param   {UnityEngine.Color}             endValue    The value to tween to
                 * @param   {number}                        duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleSprite#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleSprite.DOBlendableColor:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI.DOFade:static start.*/
                /**
                 * Tweens a CanvasGroup's alpha color to the given value.
                 Also stores the canvasGroup as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.CanvasGroup}           target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade", this ); }

                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.alpha;
                    }, function (x) {
                        target.alpha = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static start.*/
                /**
                 * Tweens an Graphic's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$1", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static start.*/
                /**
                 * Tweens an Image's alpha color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$2", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static start.*/
                /**
                 * Tweens a Text's alpha color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFade$3: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFade$3", this ); }

                    var t = DG.Tweening.DOTween.ToAlpha(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFade$3:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor:static start.*/
                /**
                 * Tweens an Graphic's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}            target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static start.*/
                /**
                 * Tweens an Image's color to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$1", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static start.*/
                /**
                 * Tweens a Text's color to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target      
                 * @param   {UnityEngine.Color}                 endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOColor$2", this ); }

                    var t = DG.Tweening.DOTween.To$8(function () {
                        return target.color;
                    }, function (x) {
                        target.color = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOColor$2:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static start.*/
                /**
                 * Tweens an Image's fillAmount to the given value.
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}              target      
                 * @param   {number}                            endValue    The end value to reach (0 to 1)
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFillAmount: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFillAmount", this ); }

                    if (endValue > 1) {
                        endValue = 1;
                    } else {
                        if (endValue < 0) {
                            endValue = 0;
                        }
                    }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.fillAmount;
                    }, function (x) {
                        target.fillAmount = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFillAmount:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static start.*/
                /**
                 * Tweens an Image's colors using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOColor$1(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static start.*/
                /**
                 * Tweens an LayoutElement's flexibleWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOFlexibleSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOFlexibleSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.flexibleWidth, target.flexibleHeight );
                    }, function (x) {
                        target.flexibleWidth = x.x;
                        target.flexibleHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOFlexibleSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static start.*/
                /**
                 * Tweens an LayoutElement's minWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOMinSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOMinSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.minWidth, target.minHeight );
                    }, function (x) {
                        target.minWidth = x.x;
                        target.minHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOMinSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static start.*/
                /**
                 * Tweens an LayoutElement's preferredWidth/Height to the given value.
                 Also stores the LayoutElement as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.LayoutElement}      target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPreferredSize: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPreferredSize", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.preferredWidth, target.preferredHeight );
                    }, function (x) {
                        target.preferredWidth = x.x;
                        target.preferredHeight = x.y;
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPreferredSize:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPosY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPosY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPosY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector3}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3D: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3D", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$13(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3D:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DX: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DX", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( endValue, 0, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.X, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DY: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DY", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Y, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition3D Z to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorPos3DZ: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorPos3DZ", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$12(function () {
                        return target.anchoredPosition3D;
                    }, function (x) {
                        target.anchoredPosition3D = x.$clone();
                    }, new pc.Vec3( 0, 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$12(t, DG.Tweening.AxisConstraint.Z, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorPos3DZ:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static start.*/
                /**
                 * Tweens a RectTransform's anchorMax to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMax: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMax", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMax;
                    }, function (x) {
                        target.anchorMax = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMax:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static start.*/
                /**
                 * Tweens a RectTransform's anchorMin to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOAnchorMin: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOAnchorMin", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.anchorMin;
                    }, function (x) {
                        target.anchorMin = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOAnchorMin:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivot:static start.*/
                /**
                 * Tweens a RectTransform's pivot to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivot: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivot", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivot:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static start.*/
                /**
                 * Tweens a RectTransform's pivot X to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotX: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotX", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( endValue, 0 ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.X), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotX:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static start.*/
                /**
                 * Tweens a RectTransform's pivot Y to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOPivotY: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPivotY", this ); }

                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.pivot;
                    }, function (x) {
                        target.pivot = x.$clone();
                    }, new pc.Vec2( 0, endValue ), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(t, DG.Tweening.AxisConstraint.Y), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOPivotY:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static start.*/
                /**
                 * Tweens a RectTransform's sizeDelta to the given value.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}         target      
                 * @param   {UnityEngine.Vector2}               endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOSizeDelta: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOSizeDelta", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.sizeDelta;
                    }, function (x) {
                        target.sizeDelta = x.$clone();
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOSizeDelta:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static start.*/
                /**
                 * Punches a RectTransform's anchoredPosition towards the given direction and then back to the starting one
                 as if it was connected to the starting position via an elastic.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {UnityEngine.Vector2}          punch         The direction and strength of the punch (added to the RectTransform's current position)
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       vibrato       Indicates how much will the punch vibrate
                 * @param   {number}                       elasticity    Represents how much (0 to 1) the vector will go beyond the starting position when bouncing backwards.
                 1 creates a full oscillation between the punch direction and the opposite direction,
                 while 0 oscillates only between the punch and the start position
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOPunchAnchorPos: function (target, punch, duration, vibrato, elasticity, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOPunchAnchorPos", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (elasticity === void 0) { elasticity = 1.0; }
                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Punch(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, UnityEngine.Vector3.FromVector2(punch.$clone()), duration, vibrato, elasticity), target), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOPunchAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {number}                       strength      The shake strength
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos", this ); }

                    if (strength === void 0) { strength = 100.0; }
                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, strength, vibrato, randomness, true, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static start.*/
                /**
                 * Shakes a RectTransform's anchoredPosition with the given values.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target        
                 * @param   {number}                       duration      The duration of the tween
                 * @param   {UnityEngine.Vector2}          strength      The shake strength on each axis
                 * @param   {number}                       vibrato       Indicates how much will the shake vibrate
                 * @param   {number}                       randomness    Indicates how much the shake will be random (0 to 180 - values higher than 90 kind of suck, so beware). 
                 Setting it to 0 will shake along a single direction.
                 * @param   {boolean}                      snapping      If TRUE the tween will smoothly snap all values to integers
                 * @param   {boolean}                      fadeOut       If TRUE the shake will automatically fadeOut smoothly within the tween's duration, otherwise it will not
                 * @return  {DG.Tweening.Tweener}
                 */
                DOShakeAnchorPos$1: function (target, duration, strength, vibrato, randomness, snapping, fadeOut) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOShakeAnchorPos$1", this ); }

                    if (vibrato === void 0) { vibrato = 10; }
                    if (randomness === void 0) { randomness = 90.0; }
                    if (snapping === void 0) { snapping = false; }
                    if (fadeOut === void 0) { fadeOut = true; }
                    return DG.Tweening.TweenSettingsExtensions.SetOptions$11(DG.Tweening.Core.Extensions.SetSpecialStartupMode(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,System.Array.type(UnityEngine.Vector3),DG.Tweening.Plugins.Options.Vector3ArrayOptions), DG.Tweening.DOTween.Shake$1(function () {
                        return UnityEngine.Vector3.FromVector2(target.anchoredPosition);
                    }, function (x) {
                        target.anchoredPosition = UnityEngine.Vector2.FromVector3(x.$clone());
                    }, duration, UnityEngine.Vector3.FromVector2(strength.$clone()), vibrato, randomness, fadeOut), target), DG.Tweening.Core.Enums.SpecialStartupMode.SetShake), snapping);
                },
                /*DG.Tweening.DOTweenModuleUI.DOShakeAnchorPos$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static start.*/
                /**
                 * Tweens a RectTransform's anchoredPosition to the given value, while also applying a jump effect along the Y axis.
                 Returns a Sequence instead of a Tweener.
                 Also stores the RectTransform as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.RectTransform}    target       
                 * @param   {UnityEngine.Vector2}          endValue     The end value to reach
                 * @param   {number}                       jumpPower    Power of the jump (the max height of the jump is represented by this plus the final Y offset)
                 * @param   {number}                       numJumps     Total number of jumps
                 * @param   {number}                       duration     The duration of the tween
                 * @param   {boolean}                      snapping     If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Sequence}
                 */
                DOJumpAnchorPos: function (target, endValue, jumpPower, numJumps, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOJumpAnchorPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    if (numJumps < 1) {
                        numJumps = 1;
                    }
                    var startPosY = 0;
                    var offsetY = -1;
                    var offsetYSet = false;

                    // Separate Y Tween so we can elaborate elapsedPercentage on that insted of on the Sequence
                    // (in case users add a delay or other elements to the Sequence)
                    var s = DG.Tweening.DOTween.Sequence();
                    var yTween = DG.Tweening.TweenSettingsExtensions.OnStart(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetLoops$1(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetRelative(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( 0, jumpPower ), duration / (Bridge.Int.mul(numJumps, 2))), DG.Tweening.AxisConstraint.Y, snapping), DG.Tweening.Ease.OutQuad)), Bridge.Int.mul(numJumps, 2), DG.Tweening.LoopType.Yoyo), function () {
                        startPosY = target.anchoredPosition.y;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$8(DG.Tweening.DOTween.To$11(function () {
                        return target.anchoredPosition;
                    }, function (x) {
                        target.anchoredPosition = x.$clone();
                    }, new pc.Vec2( endValue.x, 0 ), duration), DG.Tweening.AxisConstraint.X, snapping), DG.Tweening.Ease.Linear)), yTween), target), DG.Tweening.DOTween.defaultEaseType);
                    DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Sequence, s, function () {
                        if (!offsetYSet) {
                            offsetYSet = true;
                            offsetY = s.isRelative ? endValue.y : endValue.y - startPosY;
                        }
                        var pos = target.anchoredPosition.$clone();
                        pos.y += DG.Tweening.DOVirtual.EasedValue(0, offsetY, DG.Tweening.TweenExtensions.ElapsedDirectionalPercentage(s), DG.Tweening.Ease.OutQuad);
                        target.anchoredPosition = pos.$clone();
                    });
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUI.DOJumpAnchorPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontal/verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {UnityEngine.Vector2}          endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DONormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DONormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$9(DG.Tweening.DOTween.To$11(function () {
                        return new pc.Vec2( target.horizontalNormalizedPosition, target.verticalNormalizedPosition );
                    }, function (x) {
                        target.horizontalNormalizedPosition = x.x;
                        target.verticalNormalizedPosition = x.y;
                    }, endValue.$clone(), duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DONormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's horizontalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOHorizontalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOHorizontalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.horizontalNormalizedPosition;
                    }, function (x) {
                        target.horizontalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOHorizontalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static start.*/
                /**
                 * Tweens a ScrollRect's verticalNormalizedPosition to the given value.
                 Also stores the ScrollRect as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.ScrollRect}    target      
                 * @param   {number}                       endValue    The end value to reach
                 * @param   {number}                       duration    The duration of the tween
                 * @param   {boolean}                      snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Tweener}
                 */
                DOVerticalNormalizedPos: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOVerticalNormalizedPos", this ); }

                    if (snapping === void 0) { snapping = false; }
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(DG.Tweening.DOTween.To$4(function () {
                        return target.verticalNormalizedPosition;
                    }, function (x) {
                        target.verticalNormalizedPosition = x;
                    }, endValue, duration), snapping), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOVerticalNormalizedPos:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOValue:static start.*/
                /**
                 * Tweens a Slider's value to the given value.
                 Also stores the Slider as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Slider}             target      
                 * @param   {number}                            endValue    The end value to reach
                 * @param   {number}                            duration    The duration of the tween
                 * @param   {boolean}                           snapping    If TRUE the tween will smoothly snap all values to integers
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOValue: function (target, endValue, duration, snapping) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOValue", this ); }

                    if (snapping === void 0) { snapping = false; }
                    var t = DG.Tweening.DOTween.To$4(function () {
                        return target.value;
                    }, function (x) {
                        target.value = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$2(t, snapping), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOValue:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOCounter:static start.*/
                /**
                 * Tweens a Text's text from one integer to another, with options for thousands separators
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}                 target                   
                 * @param   {number}                              fromValue                The value to start from
                 * @param   {number}                              endValue                 The end value to reach
                 * @param   {number}                              duration                 The duration of the tween
                 * @param   {boolean}                             addThousandsSeparator    If TRUE (default) also adds thousands separators
                 * @param   {System.Globalization.CultureInfo}    culture                  The {@link } to use (InvariantCulture if NULL)
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOCounter: function (target, fromValue, endValue, duration, addThousandsSeparator, culture) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOCounter", this ); }

                    if (addThousandsSeparator === void 0) { addThousandsSeparator = true; }
                    if (culture === void 0) { culture = null; }
                    var v = fromValue;
                    var cInfo = !addThousandsSeparator ? null : culture || System.Globalization.CultureInfo.invariantCulture;
                    var t = DG.Tweening.DOTween.To$2(function () {
                        return v;
                    }, function (x) {
                        v = x;
                        target.text = addThousandsSeparator ? System.Int32.format(v, "N0", cInfo) : Bridge.toString(v);
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOCounter:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOText:static start.*/
                /**
                 * Tweens a Text's text to the given value.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}               target             
                 * @param   {string}                            endValue           The end string to tween to
                 * @param   {number}                            duration           The duration of the tween
                 * @param   {boolean}                           richTextEnabled    If TRUE (default), rich text will be interpreted correctly while animated,
                 otherwise all tags will be considered as normal text
                 * @param   {DG.Tweening.ScrambleMode}          scrambleMode       The type of scramble mode to use, if any
                 * @param   {string}                            scrambleChars      A string containing the characters to use for scrambling.
                 Use as many characters as possible (minimum 10) because DOTween uses a fast scramble mode which gives better results with more characters.
                 Leave it to NULL (default) to use default ones
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOText: function (target, endValue, duration, richTextEnabled, scrambleMode, scrambleChars) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOText", this ); }

                    if (richTextEnabled === void 0) { richTextEnabled = true; }
                    if (scrambleMode === void 0) { scrambleMode = 0; }
                    if (scrambleChars === void 0) { scrambleChars = null; }
                    if (endValue == null) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogWarning("You can't pass a NULL string to DOText: an empty string will be used instead to avoid errors");
                        }
                        endValue = "";
                    }
                    var t = DG.Tweening.DOTween.To$5(function () {
                        return target.text;
                    }, function (x) {
                        target.text = x;
                    }, endValue, duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Tweener, DG.Tweening.TweenSettingsExtensions.SetOptions$3(t, richTextEnabled, scrambleMode, scrambleChars), target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUI.DOText:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static start.*/
                /**
                 * Tweens a Graphic's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Graphic as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Graphic}    target      
                 * @param   {UnityEngine.Color}         endValue    The value to tween to
                 * @param   {number}                    duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static start.*/
                /**
                 * Tweens a Image's color to the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Image}    target      
                 * @param   {UnityEngine.Color}       endValue    The value to tween to
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$1: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$1", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static start.*/
                /**
                 * Tweens a Text's color BY the given value,
                 in a way that allows other DOBlendableColor tweens to work together on the same target,
                 instead than fight each other as multiple DOColor would do.
                 Also stores the Text as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI
                 * @memberof DG.Tweening.DOTweenModuleUI
                 * @param   {UnityEngine.UI.Text}    target      
                 * @param   {UnityEngine.Color}      endValue    The value to tween to
                 * @param   {number}                 duration    The duration of the tween
                 * @return  {DG.Tweening.Tweener}
                 */
                DOBlendableColor$2: function (target, endValue, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI#DOBlendableColor$2", this ); }

                    var $t;
                    endValue = ($t = target.color, new pc.Color( endValue.r - $t.r, endValue.g - $t.g, endValue.b - $t.b, endValue.a - $t.a ));
                    var to = new pc.Color( 0, 0, 0, 0 );
                    return DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.Core.Extensions.Blendable(UnityEngine.Color, UnityEngine.Color, DG.Tweening.Plugins.Options.ColorOptions, DG.Tweening.DOTween.To$8(function () {
                        return to;
                    }, function (x) {
                        var $t1;
                        var diff = new pc.Color( x.r - to.r, x.g - to.g, x.b - to.b, x.a - to.a );
                        to = x.$clone();
                        target.color = ($t1 = target.color.$clone(), new pc.Color( $t1.r + diff.$clone().r, $t1.g + diff.$clone().g, $t1.b + diff.$clone().b, $t1.a + diff.$clone().a ));
                    }, endValue.$clone(), duration)), target);
                },
                /*DG.Tweening.DOTweenModuleUI.DOBlendableColor$2:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUI.Utils", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static start.*/
                /**
                 * Converts the anchoredPosition of the first RectTransform to the second RectTransform,
                 taking into consideration offset, anchors and pivot, and returns the new anchoredPosition
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUI.Utils
                 * @memberof DG.Tweening.DOTweenModuleUI.Utils
                 * @param   {UnityEngine.RectTransform}    from    
                 * @param   {UnityEngine.RectTransform}    to
                 * @return  {UnityEngine.Vector2}
                 */
                SwitchToRectTransform: function (from, to) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUI.Utils#SwitchToRectTransform", this ); }

                    var localPoint = { v : new UnityEngine.Vector2() };
                    var fromPivotDerivedOffset = new pc.Vec2( from.rect.width * 0.5 + from.rect.xMin, from.rect.height * 0.5 + from.rect.yMin );
                    var screenP = UnityEngine.RectTransformUtility.WorldToScreenPoint(null, from.position);
                    screenP = screenP.$clone().add( fromPivotDerivedOffset.$clone() );
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(to, screenP, null, localPoint);
                    var pivotDerivedOffset = new pc.Vec2( to.rect.width * 0.5 + to.rect.xMin, to.rect.height * 0.5 + to.rect.yMin );
                    return to.anchoredPosition.$clone().add( localPoint.v ).sub( pivotDerivedOffset );
                },
                /*DG.Tweening.DOTweenModuleUI+Utils.SwitchToRectTransform:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    /** @namespace DG.Tweening */

    /**
     * Shortcuts/functions that are not strictly related to specific Modules
     but are available only on some Unity versions
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUnityVersion
     */
    Bridge.define("DG.Tweening.DOTweenModuleUnityVersion", {
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static start.*/
                /**
                 * Tweens a Material's color using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor: function (target, gradient, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.color = c.color.$clone();
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$3(target, c.color.$clone(), colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static start.*/
                /**
                 * Tweens a Material's named color property using the given gradient
                 (NOTE 1: only uses the colors of the gradient, not the alphas - NOTE 2: creates a Sequence, not a Tweener).
                 Also stores the image as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}    target      
                 * @param   {pc.ColorGradient}        gradient    The gradient to use
                 * @param   {string}                  property    The name of the material property to tween (like _Tint or _SpecColor)
                 * @param   {number}                  duration    The duration of the tween
                 * @return  {DG.Tweening.Sequence}
                 */
                DOGradientColor$1: function (target, gradient, property, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOGradientColor$1", this ); }

                    var s = DG.Tweening.DOTween.Sequence();
                    var colors = gradient.colorKeys;
                    var len = colors.length;
                    for (var i = 0; i < len; i = (i + 1) | 0) {
                        var c = colors[i];
                        if (i === 0 && c.time <= 0) {
                            target.SetColor$1(property, c.color);
                            continue;
                        }
                        var colorDuration = i === ((len - 1) | 0) ? duration - DG.Tweening.TweenExtensions.Duration(s, false) : duration * (i === 0 ? c.time : c.time - colors[((i - 1) | 0)].time);
                        DG.Tweening.TweenSettingsExtensions.Append(s, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.ShortcutExtensions.DOColor$4(target, c.color.$clone(), property, colorDuration), DG.Tweening.Ease.Linear));
                    }
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Sequence, s, target);
                    return s;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOGradientColor$1:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or complete.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForCompletion(true);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForCompletion: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForCompletion", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForCompletion(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForCompletion:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or rewinded.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForRewind();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForRewind: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForRewind", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForRewind(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForRewind:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForKill();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForKill: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForKill", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForKill(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForKill:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or has gone through the given amount of loops.
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForElapsedLoops(2);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                elapsedLoops                    Elapsed loops to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForElapsedLoops: function (t, elapsedLoops, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForElapsedLoops", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops(t, elapsedLoops);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForElapsedLoops:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed
                 or has reached the given time position (loops included, delays excluded).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForPosition(2.5f);</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {number}                                position                        Position (loops included, delays excluded) to wait for
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForPosition: function (t, position, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForPosition", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForPosition(t, position);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForPosition:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static start.*/
                /**
                 * Returns a {@link } that waits until the tween is killed or started
                 (meaning when the tween is set in a playing state the first time, after any eventual delay).
                 It can be used inside a coroutine as a yield.
                 <p>Example usage:</p><pre><code>yield return myTween.WaitForStart();</code></pre>
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {DG.Tweening.Tween}                     t                               
                 * @param   {boolean}                               returnCustomYieldInstruction
                 * @return  {UnityEngine.CustomYieldInstruction}
                 */
                WaitForStart: function (t, returnCustomYieldInstruction) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#WaitForStart", this ); }

                    if (!t.active) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogInvalidTween(t);
                        }
                        return null;
                    }
                    return new DG.Tweening.DOTweenCYInstruction.WaitForStart(t);
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.WaitForStart:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static start.*/
                /**
                 * Tweens a Material's named texture offset property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOOffset: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOOffset", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureOffset(propertyID);
                    }, function (x) {
                        target.SetTextureOffset(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOOffset:static end.*/

                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static start.*/
                /**
                 * Tweens a Material's named texture scale property with the given ID to the given value.
                 Also stores the material as the tween's target so it can be used for filtered operations
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUnityVersion
                 * @memberof DG.Tweening.DOTweenModuleUnityVersion
                 * @param   {UnityEngine.Material}              target        
                 * @param   {UnityEngine.Vector2}               endValue      The end value to reach
                 * @param   {number}                            propertyID    The ID of the material property to tween (also called nameID in Unity's manual)
                 * @param   {number}                            duration      The duration of the tween
                 * @return  {DG.Tweening.Core.TweenerCore$3}
                 */
                DOTiling: function (target, endValue, propertyID, duration) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUnityVersion#DOTiling", this ); }

                    if (!target.HasProperty(propertyID)) {
                        if (DG.Tweening.Core.Debugger.logPriority > 0) {
                            DG.Tweening.Core.Debugger.LogMissingMaterialProperty(propertyID);
                        }
                        return null;
                    }
                    var t = DG.Tweening.DOTween.To$11(function () {
                        return target.GetTextureScale(propertyID);
                    }, function (x) {
                        target.SetTextureScale(propertyID, x);
                    }, endValue.$clone(), duration);
                    DG.Tweening.TweenSettingsExtensions.SetTarget(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions), t, target);
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUnityVersion.DOTiling:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    /**
     * Utility functions that deal with available Modules.
     Modules defines:
     - DOTAUDIO
     - DOTPHYSICS
     - DOTPHYSICS2D
     - DOTSPRITE
     - DOTUI
     Extra defines set and used for implementation of external assets:
     - DOTWEEN_TMP  TextMesh Pro
     - DOTWEEN_TK2D  2D Toolkit
     *
     * @static
     * @abstract
     * @public
     * @class DG.Tweening.DOTweenModuleUtils
     */
    Bridge.define("DG.Tweening.DOTweenModuleUtils", {
        statics: {
            fields: {
                _initialized: false
            },
            methods: {
                /*DG.Tweening.DOTweenModuleUtils.Init:static start.*/
                /**
                 * Called via Reflection by DOTweenComponent on Awake
                 *
                 * @static
                 * @public
                 * @this DG.Tweening.DOTweenModuleUtils
                 * @memberof DG.Tweening.DOTweenModuleUtils
                 * @return  {void}
                 */
                Init: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Init", this ); }

                    if (DG.Tweening.DOTweenModuleUtils._initialized) {
                        return;
                    }

                    DG.Tweening.DOTweenModuleUtils._initialized = true;
                    DG.Tweening.Core.DOTweenExternalCommand.addSetOrientationOnPath(DG.Tweening.DOTweenModuleUtils.Physics.SetOrientationOnPath);

                },
                /*DG.Tweening.DOTweenModuleUtils.Init:static end.*/

                /*DG.Tweening.DOTweenModuleUtils.Preserver:static start.*/
                Preserver: function () {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils#Preserver", this ); }

                    var loadedAssemblies = System.AppDomain.getAssemblies();
                    var mi = Bridge.Reflection.getMembers(UnityEngine.MonoBehaviour, 8, 284, "Stub");
                },
                /*DG.Tweening.DOTweenModuleUtils.Preserver:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    Bridge.define("DG.Tweening.DOTweenModuleUtils.Physics", {
        $kind: 1002,
        statics: {
            methods: {
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static start.*/
                SetOrientationOnPath: function (options, t, newRot, trans) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#SetOrientationOnPath", this ); }

                    if (options.isRigidbody) {
                        Bridge.cast(t.target, UnityEngine.Rigidbody).rotation = newRot.$clone();
                    } else {
                        trans.rotation = newRot.$clone();
                    }
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.SetOrientationOnPath:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static start.*/
                HasRigidbody2D: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody2D", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody2D), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody2D:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static start.*/
                HasRigidbody: function (target) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#HasRigidbody", this ); }

                    return UnityEngine.Component.op_Inequality(target.GetComponent(UnityEngine.Rigidbody), null);
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.HasRigidbody:static end.*/

                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static start.*/
                CreateDOTweenPathTween: function (target, tweenRigidbody, isLocal, path, duration, pathMode) {
if ( TRACE ) { TRACE( "DG.Tweening.DOTweenModuleUtils.Physics#CreateDOTweenPathTween", this ); }

                    var t;
                    var rBody = tweenRigidbody ? target.GetComponent(UnityEngine.Rigidbody) : null;
                    if (tweenRigidbody && UnityEngine.Component.op_Inequality(rBody, null)) {
                        t = isLocal ? DG.Tweening.DOTweenModulePhysics.DOLocalPath$1(rBody, path, duration, pathMode) : DG.Tweening.DOTweenModulePhysics.DOPath$1(rBody, path, duration, pathMode);
                    } else {
                        t = isLocal ? DG.Tweening.ShortcutExtensions.DOLocalPath(target.transform, path, duration, pathMode) : DG.Tweening.ShortcutExtensions.DOPath(target.transform, path, duration, pathMode);
                    }
                    return t;
                },
                /*DG.Tweening.DOTweenModuleUtils+Physics.CreateDOTweenPathTween:static end.*/


            }
        }
    });
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*DG.Tweening.EasingType start.*/
    Bridge.define("DG.Tweening.EasingType", {
        statics: {
            methods: {
                /*DG.Tweening.EasingType.Interpolate:static start.*/
                Interpolate: function (type) {
if ( TRACE ) { TRACE( "DG.Tweening.EasingType#Interpolate", this ); }

                    switch (type) {
                        case DG.Tweening.EEasingType.InBack: 
                            return DG.Tweening.Ease.InBack;
                        case DG.Tweening.EEasingType.OutBack: 
                            return DG.Tweening.Ease.OutBack;
                        case DG.Tweening.EEasingType.InOutBack: 
                            return DG.Tweening.Ease.InOutBack;
                        case DG.Tweening.EEasingType.InBounce: 
                            return DG.Tweening.Ease.InBounce;
                        case DG.Tweening.EEasingType.OutBounce: 
                            return DG.Tweening.Ease.OutBounce;
                        case DG.Tweening.EEasingType.InOutBounce: 
                            return DG.Tweening.Ease.InOutBounce;
                        case DG.Tweening.EEasingType.InCirc: 
                            return DG.Tweening.Ease.InCirc;
                        case DG.Tweening.EEasingType.OutCirc: 
                            return DG.Tweening.Ease.OutCirc;
                        case DG.Tweening.EEasingType.InOutCirc: 
                            return DG.Tweening.Ease.InOutCirc;
                        case DG.Tweening.EEasingType.InCubic: 
                            return DG.Tweening.Ease.InCubic;
                        case DG.Tweening.EEasingType.OutCubic: 
                            return DG.Tweening.Ease.OutCubic;
                        case DG.Tweening.EEasingType.InOutCubic: 
                            return DG.Tweening.Ease.InOutCubic;
                        case DG.Tweening.EEasingType.InElastic: 
                            return DG.Tweening.Ease.InElastic;
                        case DG.Tweening.EEasingType.OutElastic: 
                            return DG.Tweening.Ease.OutElastic;
                        case DG.Tweening.EEasingType.InOutElastic: 
                            return DG.Tweening.Ease.InOutElastic;
                        case DG.Tweening.EEasingType.InExpo: 
                            return DG.Tweening.Ease.InExpo;
                        case DG.Tweening.EEasingType.OutExpo: 
                            return DG.Tweening.Ease.OutExpo;
                        case DG.Tweening.EEasingType.InOutExpo: 
                            return DG.Tweening.Ease.InOutExpo;
                        case DG.Tweening.EEasingType.Linear: 
                            return DG.Tweening.Ease.Linear;
                        case DG.Tweening.EEasingType.InQuad: 
                            return DG.Tweening.Ease.InQuad;
                        case DG.Tweening.EEasingType.OutQuad: 
                            return DG.Tweening.Ease.OutQuad;
                        case DG.Tweening.EEasingType.InOutQuad: 
                            return DG.Tweening.Ease.InOutQuad;
                        case DG.Tweening.EEasingType.InQuart: 
                            return DG.Tweening.Ease.InQuart;
                        case DG.Tweening.EEasingType.OutQuart: 
                            return DG.Tweening.Ease.OutQuart;
                        case DG.Tweening.EEasingType.InOutQuart: 
                            return DG.Tweening.Ease.InOutQuart;
                        case DG.Tweening.EEasingType.InQuint: 
                            return DG.Tweening.Ease.InQuint;
                        case DG.Tweening.EEasingType.OutQuint: 
                            return DG.Tweening.Ease.OutQuint;
                        case DG.Tweening.EEasingType.InOutQuint: 
                            return DG.Tweening.Ease.InOutQuint;
                        case DG.Tweening.EEasingType.InSine: 
                            return DG.Tweening.Ease.InSine;
                        case DG.Tweening.EEasingType.OutSine: 
                            return DG.Tweening.Ease.OutSine;
                        case DG.Tweening.EEasingType.InOutSine: 
                            return DG.Tweening.Ease.InOutSine;
                        default: 
                            throw new System.ArgumentOutOfRangeException.$ctor3("type", Bridge.box(type, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType)), null);
                    }
                },
                /*DG.Tweening.EasingType.Interpolate:static end.*/


            }
        }
    });
    /*DG.Tweening.EasingType end.*/

    /*DG.Tweening.EEasingType start.*/
    Bridge.define("DG.Tweening.EEasingType", {
        $kind: 6,
        statics: {
            fields: {
                InBack: 0,
                OutBack: 1,
                InOutBack: 2,
                InBounce: 3,
                OutBounce: 4,
                InOutBounce: 5,
                InCirc: 6,
                OutCirc: 7,
                InOutCirc: 8,
                InCubic: 9,
                OutCubic: 10,
                InOutCubic: 11,
                InElastic: 12,
                OutElastic: 13,
                InOutElastic: 14,
                InExpo: 15,
                OutExpo: 16,
                InOutExpo: 17,
                Linear: 18,
                InQuad: 19,
                OutQuad: 20,
                InOutQuad: 21,
                InQuart: 22,
                OutQuart: 23,
                InOutQuart: 24,
                InQuint: 25,
                OutQuint: 26,
                InOutQuint: 27,
                InSine: 28,
                OutSine: 29,
                InOutSine: 30,
                AnimationCurve: 31
            }
        }
    });
    /*DG.Tweening.EEasingType end.*/

    /*Direction start.*/
    Bridge.define("Direction", {
        $kind: 6,
        statics: {
            fields: {
                Up: 0,
                Down: 1,
                Right: 2,
                Left: 3,
                UpRight: 4,
                UpLeft: 5,
                DownRight: 6,
                DownLeft: 7
            }
        }
    });
    /*Direction end.*/

    /*DirectionConfig start.*/
    Bridge.define("DirectionConfig", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            datas: null
        },
        props: {
            Datas: {
                get: function () {
if ( TRACE ) { TRACE( "DirectionConfig#Datas#get", this ); }

                    return this.datas;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DirectionConfig#init", this ); }

                this.datas = new (System.Collections.Generic.List$1(DirectionData)).ctor();
            }
        },
        methods: {
            /*DirectionConfig.GetData start.*/
            GetData: function (type) {
if ( TRACE ) { TRACE( "DirectionConfig#GetData", this ); }

                return this.datas.Find(function (x) {
                    return x.EDirectionType === type;
                });
            },
            /*DirectionConfig.GetData end.*/

            /*DirectionConfig.GetDirection start.*/
            GetDirection: function (type) {
if ( TRACE ) { TRACE( "DirectionConfig#GetDirection", this ); }

                return this.GetData(type).Direction.$clone();
            },
            /*DirectionConfig.GetDirection end.*/


        }
    });
    /*DirectionConfig end.*/

    /*DirectionData start.*/
    Bridge.define("DirectionData", {
        fields: {
            eDirectionType: 0,
            direction: null
        },
        props: {
            EDirectionType: {
                get: function () {
if ( TRACE ) { TRACE( "DirectionData#EDirectionType#get", this ); }

                    return this.eDirectionType;
                }
            },
            Direction: {
                get: function () {
if ( TRACE ) { TRACE( "DirectionData#Direction#get", this ); }

                    return this.direction.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "DirectionData#init", this ); }

                this.direction = new UnityEngine.Vector2();
            }
        }
    });
    /*DirectionData end.*/

    /*EColorType start.*/
    Bridge.define("EColorType", {
        $kind: 6,
        statics: {
            fields: {
                NONE: 0,
                RED: 1,
                GREEN: 2,
                YELLOW: 3,
                BLUE: 4,
                ORANGE: 5,
                CYAN: 6,
                TIFFANY_BLUE: 7,
                DARK_GREEN: 8,
                VIOLET: 9,
                PINK: 10
            }
        }
    });
    /*EColorType end.*/

    /*EDirectionType start.*/
    Bridge.define("EDirectionType", {
        $kind: 6,
        statics: {
            fields: {
                NONE: 0,
                UP: 1,
                DOWN: 2,
                LEFT: 3,
                RIGHT: 4
            }
        }
    });
    /*EDirectionType end.*/

    /*EElementType start.*/
    Bridge.define("EElementType", {
        $kind: 6,
        statics: {
            fields: {
                None: -1,
                Fire: 0,
                Water: 1,
                Earth: 2,
                Air: 3,
                Light: 4,
                Dark: 5
            }
        }
    });
    /*EElementType end.*/

    /*EFreezeType start.*/
    Bridge.define("EFreezeType", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Wood: 1
            }
        }
    });
    /*EFreezeType end.*/

    /*ELevelMode start.*/
    Bridge.define("ELevelMode", {
        $kind: 6,
        statics: {
            fields: {
                Normal: 0,
                Hard: 1,
                VeryHard: 2
            }
        }
    });
    /*ELevelMode end.*/

    /*EPivotType start.*/
    Bridge.define("EPivotType", {
        $kind: 6,
        statics: {
            fields: {
                NONE: 0,
                LEFT_TOP: 1,
                LEFT_BOTTOM: 2,
                RIGHT_TOP: 3,
                RIGHT_BOTTOM: 4
            }
        }
    });
    /*EPivotType end.*/

    /*ERotationType start.*/
    Bridge.define("ERotationType", {
        $kind: 6,
        statics: {
            fields: {
                RIGHT: 0,
                UP: 1,
                LEFT: 2,
                DOWN: 3
            }
        }
    });
    /*ERotationType end.*/

    /*VirtueSky.Events.IEventNoParamResult$1 start.*/
    Bridge.definei("VirtueSky.Events.IEventNoParamResult$1", function (TResult) { return {
        $kind: 3
    }; });
    /*VirtueSky.Events.IEventNoParamResult$1 end.*/

    /*Extension start.*/
    Bridge.define("Extension", {
        statics: {
            methods: {
                /*Extension.CanvasToWorldPosition:static start.*/
                CanvasToWorldPosition: function (camera, canvas, rectTransform) {
if ( TRACE ) { TRACE( "Extension#CanvasToWorldPosition", this ); }

                    var screenPosition = UnityEngine.Vector3.FromVector2(UnityEngine.RectTransformUtility.WorldToScreenPoint(canvas.worldCamera, rectTransform.position));
                    var position = camera.ScreenToWorldPoint(new pc.Vec3( screenPosition.x, screenPosition.y, Math.abs(camera.transform.position.z) ));
                    return position.$clone();
                },
                /*Extension.CanvasToWorldPosition:static end.*/

                /*Extension.WorldToCanvasPosition:static start.*/
                WorldToCanvasPosition: function (camera, canvas, position) {
if ( TRACE ) { TRACE( "Extension#WorldToCanvasPosition", this ); }

                    var screenPosition = UnityEngine.Vector3.FromVector2(UnityEngine.RectTransformUtility.WorldToScreenPoint(camera, position));
                    var canvasPosition = { v : new UnityEngine.Vector2() };
                    UnityEngine.RectTransformUtility.ScreenPointToLocalPointInRectangle(canvas.GetComponent(UnityEngine.RectTransform), UnityEngine.Vector2.FromVector3(screenPosition), canvas.worldCamera, canvasPosition);
                    return UnityEngine.Vector3.FromVector2(canvasPosition.v.$clone());
                },
                /*Extension.WorldToCanvasPosition:static end.*/

                /*Extension.GetNumberFromText:static start.*/
                GetNumberFromText: function (text) {
if ( TRACE ) { TRACE( "Extension#GetNumberFromText", this ); }

                    var $t;
                    var numberPart = "";
                    $t = Bridge.getEnumerator(text);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            if (System.Char.isNumber(t)) {
                                numberPart = (numberPart || "") + String.fromCharCode(t);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    return System.Int32.parse(numberPart);
                },
                /*Extension.GetNumberFromText:static end.*/

                /*Extension.GetTextValueFromNumber:static start.*/
                GetTextValueFromNumber: function (value) {
if ( TRACE ) { TRACE( "Extension#GetTextValueFromNumber", this ); }

                    if (value >= 1000000000) {
                        return System.String.format("{0:0.#}B", [Bridge.box(value / 1E+09, System.Single, System.Single.format, System.Single.getHashCode)]);
                    }
                    if (value >= 1000000) {
                        return System.String.format("{0:0.#}M", [Bridge.box(value / 1000000.0, System.Single, System.Single.format, System.Single.getHashCode)]);
                    }
                    if (value >= 10000) {
                        return System.String.format("{0:0.#}K", [Bridge.box(value / 1000.0, System.Single, System.Single.format, System.Single.getHashCode)]);
                    }
                    return Bridge.toString(value);
                },
                /*Extension.GetTextValueFromNumber:static end.*/

                /*Extension.Clear:static start.*/
                Clear: function (transform) {
if ( TRACE ) { TRACE( "Extension#Clear", this ); }

                    for (var i = 0; i < transform.childCount; i = (i + 1) | 0) {
                        UnityEngine.Object.Destroy(transform.GetChild(i).gameObject);
                    }
                },
                /*Extension.Clear:static end.*/

                /*Extension.Jump:static start.*/
                Jump: function (target, endValue, duration, height, numJumps) {
if ( TRACE ) { TRACE( "Extension#Jump", this ); }

                    if (numJumps === void 0) { numJumps = 1; }
                    var sequence = DG.Tweening.DOTween.Sequence();
                    var jumpsSequence = DG.Tweening.DOTween.Sequence();

                    var startPos = target.position.$clone();
                    var jumpDuration = duration / numJumps;

                    for (var i = 0; i < numJumps; i = (i + 1) | 0) {
                        var t0 = i / numJumps;
                        var t1 = (((i + 1) | 0)) / numJumps;

                        var fromY = pc.math.lerp(startPos.y, endValue.y, t0);
                        var toY = pc.math.lerp(startPos.y, endValue.y, t1);

                        var peakY;
                        if (height > 0) {
                            peakY = UnityEngine.Mathf.Max(fromY, toY) + Math.abs(height);
                        } else {
                            peakY = UnityEngine.Mathf.Min(fromY, toY) - Math.abs(height);
                        }

                        DG.Tweening.TweenSettingsExtensions.Append(jumpsSequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(target, peakY, jumpDuration * 0.5), DG.Tweening.Ease.OutQuad));
                        DG.Tweening.TweenSettingsExtensions.Append(jumpsSequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveY(target, toY, jumpDuration * 0.5), DG.Tweening.Ease.InQuad));
                    }

                    if (!UnityEngine.Mathf.Approximately(startPos.x, endValue.x)) {
                        DG.Tweening.TweenSettingsExtensions.Join(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveX(target, endValue.x, duration), DG.Tweening.Ease.Linear));
                    }
                    if (!UnityEngine.Mathf.Approximately(startPos.z, endValue.z)) {
                        DG.Tweening.TweenSettingsExtensions.Join(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMoveZ(target, endValue.z, duration), DG.Tweening.Ease.Linear));
                    }

                    DG.Tweening.TweenSettingsExtensions.Join(sequence, jumpsSequence);
                    return sequence;
                },
                /*Extension.Jump:static end.*/

                /*Extension.ArcMove:static start.*/
                ArcMove: function (target, endValue, duration, height, numSteps) {
if ( TRACE ) { TRACE( "Extension#ArcMove", this ); }

                    if (numSteps === void 0) { numSteps = 20; }
                    var sequence = DG.Tweening.DOTween.Sequence();
                    var startPos = target.position.$clone();

                    var stepDuration = duration / numSteps;

                    for (var i = 1; i <= numSteps; i = (i + 1) | 0) {
                        var t = i / numSteps;

                        var targetPos = new pc.Vec3().lerp( startPos, endValue, t );

                        var curveWidth = pc.math.lerp(height, 0, Math.pow(t, 2));

                        targetPos.x += curveWidth;
                        targetPos.y += Math.sin(t * UnityEngine.Mathf.PI) * curveWidth;

                        DG.Tweening.TweenSettingsExtensions.Append(sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(target, targetPos.$clone(), stepDuration), DG.Tweening.Ease.Linear));
                    }

                    return sequence;
                },
                /*Extension.ArcMove:static end.*/

                /*Extension.FlyToTarget:static start.*/
                FlyToTarget: function (target, endValue, durationFlightUp, durationFlightDown, height, widthRange, complete, scaleEnd) {
if ( TRACE ) { TRACE( "Extension#FlyToTarget", this ); }

                    if (scaleEnd === void 0) { scaleEnd = new UnityEngine.Vector3(); }
                    var getRandomRangeX = UnityEngine.Random.Range$1(-widthRange / 2, widthRange / 2);
                    var targetPos = target.anchoredPosition3D.$clone();
                    var posFlight = new pc.Vec3( targetPos.x + getRandomRangeX, targetPos.y + height, targetPos.z );

                    var flySequence = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.Join(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.TweenSettingsExtensions.Append(DG.Tweening.DOTween.Sequence(), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPos3D(target, posFlight.$clone(), durationFlightUp), DG.Tweening.Ease.OutCubic)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.DOTweenModuleUI.DOAnchorPos3D(target, endValue.$clone(), durationFlightDown), DG.Tweening.Ease.InCirc)), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(target, scaleEnd.$clone(), durationFlightDown), DG.Tweening.Ease.InCubic)), function () {
                        !Bridge.staticEquals(complete, null) ? complete() : null;
                    });

                    return flySequence;
                },
                /*Extension.FlyToTarget:static end.*/

                /*Extension.GetCoordinate:static start.*/
                GetCoordinate: function (coordinate, direction) {
if ( TRACE ) { TRACE( "Extension#GetCoordinate", this ); }

                    var result = new UnityEngine.Vector2Int();

                    if (direction === Direction.Up) {
                        result = new UnityEngine.Vector2Int.$ctor1(coordinate.x, ((coordinate.y + 1) | 0));
                    } else if (direction === Direction.Down) {
                        result = new UnityEngine.Vector2Int.$ctor1(coordinate.x, ((coordinate.y - 1) | 0));
                    } else if (direction === Direction.Right) {
                        result = new UnityEngine.Vector2Int.$ctor1(((coordinate.x + 1) | 0), coordinate.y);
                    } else if (direction === Direction.Left) {
                        result = new UnityEngine.Vector2Int.$ctor1(((coordinate.x - 1) | 0), coordinate.y);
                    } else if (direction === Direction.UpRight) {
                        result = new UnityEngine.Vector2Int.$ctor1(((coordinate.x + 1) | 0), ((coordinate.y + 1) | 0));
                    } else if (direction === Direction.UpLeft) {
                        result = new UnityEngine.Vector2Int.$ctor1(((coordinate.x - 1) | 0), ((coordinate.y + 1) | 0));
                    } else if (direction === Direction.DownRight) {
                        result = new UnityEngine.Vector2Int.$ctor1(((coordinate.x + 1) | 0), ((coordinate.y - 1) | 0));
                    } else if (direction === Direction.DownLeft) {
                        result = new UnityEngine.Vector2Int.$ctor1(((coordinate.x - 1) | 0), ((coordinate.y - 1) | 0));
                    } else {
                        throw new System.ArgumentOutOfRangeException.$ctor3("direction", Bridge.box(direction, Direction, System.Enum.toStringFn(Direction)), null);
                    }

                    return result.$clone();
                },
                /*Extension.GetCoordinate:static end.*/


            }
        }
    });
    /*Extension end.*/

    /*FreezeConfig start.*/
    Bridge.define("FreezeConfig", {
        fields: {
            type: 0,
            freezePrefab: null,
            material: null,
            soundCrack: null,
            fxBreak: null
        },
        props: {
            Type: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeConfig#Type#get", this ); }

                    return this.type;
                }
            },
            Material: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeConfig#Material#get", this ); }

                    return this.material;
                }
            },
            SoundCrack: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeConfig#SoundCrack#get", this ); }

                    return this.soundCrack;
                }
            },
            FxBreak: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeConfig#FxBreak#get", this ); }

                    return this.fxBreak;
                }
            },
            FreezePrefab: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeConfig#FreezePrefab#get", this ); }

                    return this.freezePrefab;
                }
            }
        }
    });
    /*FreezeConfig end.*/

    /*FreezeLinker start.*/
    Bridge.define("FreezeLinker", {
        fields: {
            freezer: null,
            prefab: null
        },
        props: {
            Freezer: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeLinker#Freezer#get", this ); }

                    return this.freezer;
                }
            },
            Prefab: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeLinker#Prefab#get", this ); }

                    return this.prefab;
                }
            }
        },
        ctors: {
            ctor: function (freezer, prefab) {
if ( TRACE ) { TRACE( "FreezeLinker#ctor", this ); }

                this.$initialize();
                this.freezer = freezer;
                this.prefab = prefab;
            }
        }
    });
    /*FreezeLinker end.*/

    /*FreezePrefab start.*/
    Bridge.define("FreezePrefab", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            txtCount: null,
            yAxis: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "FreezePrefab#init", this ); }

                this.yAxis = 0.0;
            }
        },
        methods: {
            /*FreezePrefab.SetUp start.*/
            SetUp: function (position, count, textSize) {
if ( TRACE ) { TRACE( "FreezePrefab#SetUp", this ); }

                this.transform.position = new pc.Vec3( position.x, this.yAxis, position.z );
                this.txtCount.fontSize = textSize;
                this.UpdateUI(count);
            },
            /*FreezePrefab.SetUp end.*/

            /*FreezePrefab.UpdateUI start.*/
            UpdateUI: function (count) {
if ( TRACE ) { TRACE( "FreezePrefab#UpdateUI", this ); }

                this.txtCount.text = System.String.format("{0}", [Bridge.box(count, System.Int32)]);
            },
            /*FreezePrefab.UpdateUI end.*/


        }
    });
    /*FreezePrefab end.*/

    /*GamePlayableManager start.*/
    Bridge.define("GamePlayableManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            gameState: 0,
            levelHolder: null,
            indexLevelVariable: null,
            eventLoadLevel: null,
            eventGetCurrentLevel: null,
            eventGetPreviousLevel: null,
            callReplayLevelEvent: null,
            callPlayCurrentLevelEvent: null,
            callNextLevelEvent: null,
            onLoadLevelComplete: null,
            callWinLevelEvent: null,
            callLoseLevelEvent: null,
            playSfxEvent: null,
            levelModeData: null,
            _currentLevelMode: 0,
            _delayTimeTween: null
        },
        props: {
            IsGamePlaying: {
                get: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#IsGamePlaying#get", this ); }

                    return this.gameState === GameState.PlayingGame;
                }
            }
        },
        methods: {
            /*GamePlayableManager.GetGameState start.*/
            GetGameState: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#GetGameState", this ); }

                return this.gameState;
            },
            /*GamePlayableManager.GetGameState end.*/

            /*GamePlayableManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#OnEnable", this ); }

                this.callPlayCurrentLevelEvent.AddListener(Bridge.fn.cacheBind(this, this.PlayCurrentLevel));
                this.callReplayLevelEvent.AddListener(Bridge.fn.cacheBind(this, this.ReplayGame));
                this.callNextLevelEvent.AddListener(Bridge.fn.cacheBind(this, this.NextLevel));
                this.callWinLevelEvent.AddListener$1(Bridge.fn.cacheBind(this, this.OnWinGame));
                this.callLoseLevelEvent.AddListener$1(Bridge.fn.cacheBind(this, this.OnLoseGame));
            },
            /*GamePlayableManager.OnEnable end.*/

            /*GamePlayableManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#OnDisable", this ); }

                this.callPlayCurrentLevelEvent.RemoveListener(Bridge.fn.cacheBind(this, this.PlayCurrentLevel));
                this.callReplayLevelEvent.RemoveListener(Bridge.fn.cacheBind(this, this.ReplayGame));
                this.callNextLevelEvent.RemoveListener(Bridge.fn.cacheBind(this, this.NextLevel));
                this.callWinLevelEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.OnWinGame));
                this.callLoseLevelEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.OnLoseGame));
            },
            /*GamePlayableManager.OnDisable end.*/

            /*GamePlayableManager.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#Start", this ); }

                this.PlayCurrentLevel();
            },
            /*GamePlayableManager.Start end.*/

            /*GamePlayableManager.PlayCurrentLevel start.*/
            PlayCurrentLevel: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#PlayCurrentLevel", this ); }

                TheBeginning.UI.PopupManager.Show(TheBeginning.UI.GameplayPopup);
                this.StartGame();
            },
            /*GamePlayableManager.PlayCurrentLevel end.*/

            /*GamePlayableManager.ReplayGame start.*/
            ReplayGame: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#ReplayGame", this ); }

                TheBeginning.UI.PopupManager.Show(TheBeginning.UI.GameplayPopup);
                this.StartGame();
            },
            /*GamePlayableManager.ReplayGame end.*/

            /*GamePlayableManager.NextLevel start.*/
            NextLevel: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#NextLevel", this ); }

                var $t;
                ($t = this.indexLevelVariable).Value = ($t.Value + 1) | 0;
                var levelPrefab = this.eventLoadLevel.Raise();
                Extension.Clear(this.levelHolder);
                UnityEngine.Object.Instantiate$1(TheBeginning.LevelSystem.Level, levelPrefab, this.levelHolder, false);
            },
            /*GamePlayableManager.NextLevel end.*/

            /*GamePlayableManager.StartGame start.*/
            StartGame: function () {
if ( TRACE ) { TRACE( "GamePlayableManager#StartGame", this ); }

                this.gameState = GameState.PlayingGame;
                var levelData = this.levelModeData.GetLevelData();
                this._currentLevelMode = levelData.Item1.levelMode;
                if (UnityEngine.Object.op_Implicit(levelData.Item2.soundStartGame)) {
                    this.playSfxEvent.Raise(levelData.Item2.soundStartGame);
                }

                var currentLevelPrefab = this.eventLoadLevel.Raise();
                Extension.Clear(this.levelHolder);
                var level = UnityEngine.Object.Instantiate$1(TheBeginning.LevelSystem.Level, currentLevelPrefab, this.levelHolder, false);
                if (UnityEngine.Object.op_Implicit(this.onLoadLevelComplete)) {
                    this.onLoadLevelComplete != null ? this.onLoadLevelComplete.Raise() : null;
                }
            },
            /*GamePlayableManager.StartGame end.*/

            /*GamePlayableManager.OnWinGame start.*/
            OnWinGame: function (delayPopupShowTime) {
if ( TRACE ) { TRACE( "GamePlayableManager#OnWinGame", this ); }

                if (delayPopupShowTime === void 0) { delayPopupShowTime = 2.5; }
                if (this.gameState === GameState.WaitingResult || this.gameState === GameState.LoseGame || this.gameState === GameState.WinGame) {
                    return;
                }

                this.gameState = GameState.WinGame;

                this._delayTimeTween = DG.Tweening.DOVirtual.DelayedCall(delayPopupShowTime, Bridge.fn.bind(this, function () {
                    var Show = null;
                    Show = Bridge.fn.bind(this, function () {
                        TheBeginning.UI.PopupManager.Show(TheBeginning.UI.WinPopup);
                        TheBeginning.UI.PopupManager.Hide(TheBeginning.UI.GameplayPopup);
                        this.eventLoadLevel.Raise();
                    });
                    Show();

                }));
            },
            /*GamePlayableManager.OnWinGame end.*/

            /*GamePlayableManager.OnLoseGame start.*/
            OnLoseGame: function (delayPopupShowTime) {
if ( TRACE ) { TRACE( "GamePlayableManager#OnLoseGame", this ); }

                if (delayPopupShowTime === void 0) { delayPopupShowTime = 2.5; }
                if (this.gameState === GameState.WaitingResult || this.gameState === GameState.LoseGame || this.gameState === GameState.WinGame) {
                    return;
                }
                this.gameState = GameState.LoseGame;

                this._delayTimeTween = DG.Tweening.DOVirtual.DelayedCall(delayPopupShowTime, function () {
                    TheBeginning.UI.PopupManager.Show(TheBeginning.UI.LosePopup);
                });
            },
            /*GamePlayableManager.OnLoseGame end.*/


        }
    });
    /*GamePlayableManager end.*/

    /*GameSettings start.*/
    Bridge.define("GameSettings", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            enableDebugView: false,
            targetFrameRate: 0,
            multiTouchEnabled: false,
            winLevelMoney: 0,
            percentWinGiftPerLevel: 0,
            pauseTimeBoosterAmount: 0,
            hammerBoosterAmount: 0,
            suckBoosterAmount: 0,
            enableNotificationInGame: false,
            timeDelayHideNotificationInGame: 0,
            enableRequireInternet: false,
            timeDelayCheckInternet: 0,
            timeLoopCheckInternet: 0,
            enableShowPopupUpdate: false
        },
        props: {
            EnableDebugView: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#EnableDebugView#get", this ); }

                    return this.enableDebugView;
                }
            },
            TargetFrameRate: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#TargetFrameRate#get", this ); }

                    return this.targetFrameRate;
                }
            },
            MultiTouchEnabled: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#MultiTouchEnabled#get", this ); }

                    return this.multiTouchEnabled;
                }
            },
            WinLevelMoney: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#WinLevelMoney#get", this ); }

                    return this.winLevelMoney;
                }
            },
            PercentWinGiftPerLevel: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#PercentWinGiftPerLevel#get", this ); }

                    return this.percentWinGiftPerLevel;
                }
            },
            PauseTimeBoosterAmount: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#PauseTimeBoosterAmount#get", this ); }

                    return this.pauseTimeBoosterAmount;
                }
            },
            HammerBoosterAmount: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#HammerBoosterAmount#get", this ); }

                    return this.hammerBoosterAmount;
                }
            },
            SuckBoosterAmount: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#SuckBoosterAmount#get", this ); }

                    return this.suckBoosterAmount;
                }
            },
            EnableNotificationInGame: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#EnableNotificationInGame#get", this ); }

                    return this.enableNotificationInGame;
                }
            },
            TimeDelayHideNotificationInGame: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#TimeDelayHideNotificationInGame#get", this ); }

                    return this.timeDelayHideNotificationInGame;
                }
            },
            EnableRequireInternet: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#EnableRequireInternet#get", this ); }

                    return this.enableRequireInternet;
                }
            },
            TimeDelayCheckInternet: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#TimeDelayCheckInternet#get", this ); }

                    return this.timeDelayCheckInternet;
                }
            },
            TimeLoopCheckInternet: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#TimeLoopCheckInternet#get", this ); }

                    return this.timeLoopCheckInternet;
                }
            },
            EnableShowPopupUpdate: {
                get: function () {
if ( TRACE ) { TRACE( "GameSettings#EnableShowPopupUpdate#get", this ); }

                    return this.enableShowPopupUpdate;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GameSettings#init", this ); }

                this.enableDebugView = true;
                this.targetFrameRate = TargetFrameRate.Frame60;
                this.winLevelMoney = 100;
                this.percentWinGiftPerLevel = 10;
                this.pauseTimeBoosterAmount = 10;
                this.hammerBoosterAmount = 10;
                this.suckBoosterAmount = 10;
                this.enableNotificationInGame = true;
                this.timeDelayHideNotificationInGame = 1.0;
                this.enableRequireInternet = false;
                this.timeDelayCheckInternet = 5;
                this.timeLoopCheckInternet = 0.5;
                this.enableShowPopupUpdate = false;
            }
        }
    });
    /*GameSettings end.*/

    /*GraphicsQualitySetting start.*/
    Bridge.define("GraphicsQualitySetting", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            guid: null,
            graphicSettings: null,
            levelDefault: 0
        },
        props: {
            QualityValue: {
                get: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#QualityValue#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.Int32, this.guid, UnityEngine.Mathf.Min(this.levelDefault, this.graphicSettings.Count));
                },
                set: function (value) {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#QualityValue#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.Int32, this.guid, value);
                }
            },
            SettingsCount: {
                get: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#SettingsCount#get", this ); }

                    return this.graphicSettings.Count;
                }
            },
            GraphicSettings: {
                get: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#GraphicSettings#get", this ); }

                    return this.graphicSettings;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#init", this ); }

                this.guid = "graphics_quality_setting";
                this.levelDefault = 3;
            }
        },
        methods: {
            /*GraphicsQualitySetting.Refresh start.*/
            Refresh: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#Refresh", this ); }

                this.UpdateGraphicsQuality(this.QualityValue);
            },
            /*GraphicsQualitySetting.Refresh end.*/

            /*GraphicsQualitySetting.SetGraphicsQuality start.*/
            SetGraphicsQuality: function (setting) {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#SetGraphicsQuality", this ); }

                //QualitySettings.SetQualityLevel(setting.qualityLevel, true);
                pc.QualitySettings.instance.antiAliasing = setting.antiAliasing;
                pc.QualitySettings.instance.shadows = setting.shadowQuality;
                pc.QualitySettings.instance.shadowResolution = setting.shadowResolution;
                pc.QualitySettings.instance.shadowProjection = setting.shadowProjection;
                pc.QualitySettings.instance.shadowDistance = setting.shadowDistance;
                pc.QualitySettings.instance.shadowNearPlaneOffset = setting.shadowNearPlaneOffset;
            },
            /*GraphicsQualitySetting.SetGraphicsQuality end.*/

            /*GraphicsQualitySetting.UpdateGraphicsQuality start.*/
            UpdateGraphicsQuality: function (qualityIndex) {
if ( TRACE ) { TRACE( "GraphicsQualitySetting#UpdateGraphicsQuality", this ); }

                this.SetGraphicsQuality(this.graphicSettings.getItem(qualityIndex));
            },
            /*GraphicsQualitySetting.UpdateGraphicsQuality end.*/


        }
    });
    /*GraphicsQualitySetting end.*/

    /*GraphicsQualitySetting+GraphicsQualityLevel start.*/
    Bridge.define("GraphicsQualitySetting.GraphicsQualityLevel", {
        $kind: 1002,
        fields: {
            qualityName: null,
            qualityLevel: 0,
            antiAliasing: 0,
            shadowQuality: 0,
            shadowResolution: 0,
            shadowProjection: 0,
            shadowDistance: 0,
            shadowNearPlaneOffset: 0
        }
    });
    /*GraphicsQualitySetting+GraphicsQualityLevel end.*/

    /*GraphicsQualitySettingUI start.*/
    Bridge.define("GraphicsQualitySettingUI", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            qualitySlider: null,
            txtQuality: null,
            graphicsQualitySetting: null,
            isRefreshOnStart: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySettingUI#init", this ); }

                this.isRefreshOnStart = true;
            }
        },
        methods: {
            /*GraphicsQualitySettingUI.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySettingUI#Start", this ); }

                if (this.isRefreshOnStart) {
                    this.graphicsQualitySetting.Refresh();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.qualitySlider, null)) {
                    this.qualitySlider.minValue = 0;
                    this.qualitySlider.maxValue = (this.graphicsQualitySetting.SettingsCount - 1) | 0;
                    this.qualitySlider.value = this.graphicsQualitySetting.QualityValue;
                    this.qualitySlider.onValueChanged.AddListener(Bridge.fn.cacheBind(this, this.OnSliderValueChanged));
                }
            },
            /*GraphicsQualitySettingUI.Start end.*/

            /*GraphicsQualitySettingUI.OnSliderValueChanged start.*/
            OnSliderValueChanged: function (value) {
if ( TRACE ) { TRACE( "GraphicsQualitySettingUI#OnSliderValueChanged", this ); }

                var qualityIndex = Math.round(value);
                this.qualitySlider.value = qualityIndex;
                this.graphicsQualitySetting.QualityValue = qualityIndex;
                this.graphicsQualitySetting.Refresh();
                var settings = this.graphicsQualitySetting.GraphicSettings.getItem(qualityIndex);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.txtQuality, null)) {
                    this.txtQuality.text = settings.qualityName;
                }
            },
            /*GraphicsQualitySettingUI.OnSliderValueChanged end.*/

            /*GraphicsQualitySettingUI.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "GraphicsQualitySettingUI#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.qualitySlider, null)) {
                    this.qualitySlider.onValueChanged.RemoveListener(Bridge.fn.cacheBind(this, this.OnSliderValueChanged));
                }
            },
            /*GraphicsQualitySettingUI.OnDestroy end.*/


        }
    });
    /*GraphicsQualitySettingUI end.*/

    /*GridCreator start.*/
    Bridge.define("GridCreator", {
        statics: {
            methods: {
                /*GridCreator.SetCenter:static start.*/
                SetCenter: function (parent) {
if ( TRACE ) { TRACE( "GridCreator#SetCenter", this ); }

                    var pivotHelper = parent.AddComponent(SetCenterPosition);
                    pivotHelper.SetCenter();
                    parent.transform.position = pc.Vec3.ZERO.clone();
                    UnityEngine.Object.DestroyImmediate(pivotHelper);
                },
                /*GridCreator.SetCenter:static end.*/


            }
        },
        methods: {
            /*GridCreator.Create start.*/
            Create: function (parent, gridType, axisType, setting, size, createAsPrefab, sizeActive) {
if ( TRACE ) { TRACE( "GridCreator#Create", this ); }

                var $t;
                var prefab = this.GetPrefab(gridType, setting);

                //Create GridManager Object
                var gridSystem = ($t = new UnityEngine.GameObject.ctor(), $t.transform.name = System.String.format("Grid {0} [{1},{2}]", Bridge.box(gridType, GridType, System.Enum.toStringFn(GridType)), Bridge.box(sizeActive.x, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(sizeActive.y, System.Single, System.Single.format, System.Single.getHashCode)), $t).AddComponent(GridSystem);
                gridSystem.transform.SetParent(parent);

                //Bounds
                var delX = size.x - sizeActive.x;
                var delY = size.y - sizeActive.y;
                var hBoundMin = Math.floor(delX / 2);
                var hBoundMax = size.x - (delX - hBoundMin);

                var vBoundMin = Math.floor(delY / 2);
                var vBoundMax = size.y - (delY - vBoundMin);

                //Create cells
                var cells = new (System.Collections.Generic.List$1(CellGrid)).ctor();
                var cellsActive = new (System.Collections.Generic.List$1(CellGrid)).ctor();
                var cellPosition = pc.Vec3.ZERO.clone();

                for (var vertical = 0; vertical < size.y; vertical = (vertical + 1) | 0) {
                    cellPosition = this.GetcellPosition(cellPosition.$clone(), vertical, axisType, gridType, setting);

                    for (var horizontal = 0; horizontal < size.x; horizontal = (horizontal + 1) | 0) {
                        var coordinate = new UnityEngine.Vector2Int.$ctor1(horizontal, vertical);
                        if (!this.CanSpawn(gridType, coordinate)) {
                            continue;
                        }

                        cellPosition.x = horizontal * this.GetDistance(gridType, setting).x;

                        var cell = null;
                        if (createAsPrefab) {
                        } else {
                            cell = UnityEngine.Object.Instantiate$2(CellGrid, prefab, cellPosition, pc.Quat.IDENTITY.clone());
                        }

                        if (UnityEngine.MonoBehaviour.op_Equality(cell, null)) {
                            continue;
                        }
                        cell.transform.name = System.String.format("cell [{0},{1}]", Bridge.box(horizontal, System.Int32), Bridge.box(vertical, System.Int32));
                        cell.coordinate = coordinate.$clone();
                        cell.transform.SetParent(gridSystem.transform);
                        if (!(horizontal >= hBoundMin && horizontal < hBoundMax && vertical >= vBoundMin && vertical < vBoundMax)) {
                            cellsActive.add(cell);
                        }
                        cells.add(cell);
                    }
                }

                gridSystem.SetCells(cells);
                this.SetNeighbor(gridSystem, gridType);
                GridCreator.SetCenter(gridSystem.gameObject);
                $t = Bridge.getEnumerator(cellsActive);
                try {
                    while ($t.moveNext()) {
                        var cell1 = $t.Current;
                        cell1.gameObject.SetActive(false);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return gridSystem;
            },
            /*GridCreator.Create end.*/

            /*GridCreator.GetPrefab start.*/
            GetPrefab: function (gridType, cellSetting) {
if ( TRACE ) { TRACE( "GridCreator#GetPrefab", this ); }

                var result;

                if (gridType === GridType.Rectangle) {
                    result = cellSetting.rectangle.prefab;
                } else if (gridType === GridType.Hexagon) {
                    result = cellSetting.hexagon.prefab;
                } else {
                    result = null;
                }

                return result;
            },
            /*GridCreator.GetPrefab end.*/

            /*GridCreator.GetDistance start.*/
            GetDistance: function (gridType, cellSetting) {
if ( TRACE ) { TRACE( "GridCreator#GetDistance", this ); }

                var result = new UnityEngine.Vector2();

                if (gridType === GridType.Rectangle) {
                    result = cellSetting.rectangle.Size.$clone();
                } else if (gridType === GridType.Hexagon) {
                    result = cellSetting.hexagon.Size.$clone();
                } else {
                    result = UnityEngine.Vector2Int.op_Implicit(UnityEngine.Vector2Int.zero.$clone());
                }

                return result.$clone();
            },
            /*GridCreator.GetDistance end.*/

            /*GridCreator.GetcellPosition start.*/
            GetcellPosition: function (position, count, type, gridType, setting) {
if ( TRACE ) { TRACE( "GridCreator#GetcellPosition", this ); }

                var axis = count * this.GetDistance(gridType, setting).y;
                switch (type) {
                    case AxisType.XY: 
                        position.y = axis;
                        break;
                    case AxisType.XZ: 
                        position.z = axis;
                        break;
                    default: 
                        throw new System.ArgumentOutOfRangeException.ctor();
                }

                return position.$clone();
            },
            /*GridCreator.GetcellPosition end.*/

            /*GridCreator.CanSpawn start.*/
            CanSpawn: function (type, coordinate) {
if ( TRACE ) { TRACE( "GridCreator#CanSpawn", this ); }

                var isPairHorizontal = coordinate.x % 2 === 0;
                var isPairVertical = coordinate.y % 2 === 0;
                var result;

                if (type === GridType.Rectangle) {
                    result = true;
                } else if (type === GridType.Hexagon) {
                    result = isPairHorizontal === isPairVertical;
                } else {
                    throw new System.ArgumentOutOfRangeException.$ctor3("type", Bridge.box(type, GridType, System.Enum.toStringFn(GridType)), null);
                }

                return result;
            },
            /*GridCreator.CanSpawn end.*/

            /*GridCreator.SetNeighbor start.*/
            SetNeighbor: function (manager, gridType) {
if ( TRACE ) { TRACE( "GridCreator#SetNeighbor", this ); }

                var $t, $t1;
                var length = System.Enum.getNames(Direction).length;
                $t = Bridge.getEnumerator(manager.cells);
                try {
                    while ($t.moveNext()) {
                        var cell = $t.Current;
                        var data = new (System.Collections.Generic.List$1(CellData)).ctor();
                        for (var i = 0; i < length; i = (i + 1) | 0) {
                            var direction = i;
                            var coordinate = Extension.GetCoordinate(cell.coordinate, direction);

                            //One step more if hexagon and vertical
                            if (gridType === GridType.Hexagon) {
                                if (System.Enum.equals(direction, Bridge.box(Direction.Down, Direction, System.Enum.toStringFn(Direction)), Direction) || System.Enum.equals(direction, Bridge.box(Direction.Up, Direction, System.Enum.toStringFn(Direction)), Direction)) {
                                    coordinate = Extension.GetCoordinate(coordinate, direction);
                                }
                            }

                            var neighbour = manager.GetCell(coordinate);
                            if (!UnityEngine.Object.op_Implicit(neighbour)) {
                                continue;
                            }
                            data.add(($t1 = new CellData(), $t1.cell = manager.GetCell(coordinate), $t1.direction = direction, $t1));
                        }

                        cell.PrepareNeighbour(data);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*GridCreator.SetNeighbor end.*/


        }
    });
    /*GridCreator end.*/

    /*GridSetting start.*/
    Bridge.define("GridSetting", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            rectangle: null,
            hexagon: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GridSetting#init", this ); }

                this.rectangle = new GridSettingData();
                this.hexagon = new GridSettingData();
            }
        }
    });
    /*GridSetting end.*/

    /*GridSettingData start.*/
    Bridge.define("GridSettingData", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "GridSettingData#getDefaultValue", this ); }
 return new GridSettingData(); }
            }
        },
        fields: {
            prefab: null,
            size: null
        },
        props: {
            Size: {
                get: function () {
if ( TRACE ) { TRACE( "GridSettingData#Size#get", this ); }

                    return UnityEngine.Vector2.FromVector3(this.size.Value.$clone());
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "GridSettingData#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "GridSettingData#getHashCode", this ); }

                var h = Bridge.addHash([4792433252, this.prefab, this.size]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "GridSettingData#equals", this ); }

                if (!Bridge.is(o, GridSettingData)) {
                    return false;
                }
                return Bridge.equals(this.prefab, o.prefab) && Bridge.equals(this.size, o.size);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "GridSettingData#$clone", this ); }

                var s = to || new GridSettingData();
                s.prefab = this.prefab;
                s.size = this.size;
                return s;
            }
        }
    });
    /*GridSettingData end.*/

    /*GridType start.*/
    Bridge.define("GridType", {
        $kind: 6,
        statics: {
            fields: {
                Rectangle: 0,
                Hexagon: 1
            }
        }
    });
    /*GridType end.*/

    /*HeartData start.*/
    Bridge.define("HeartData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            immortalData: null,
            id: null,
            max: 0,
            updateHeartEvent: null,
            balanceAmount: null,
            countIncrease: 0,
            timeIncrease: 0
        },
        props: {
            TimeCurrent: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#TimeCurrent#get", this ); }

                    return System.DateTime.getNow();
                }
            },
            IsCanIncrease: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#IsCanIncrease#get", this ); }

                    return this.Count < this.Max;
                }
            },
            IsRunOutOfHeart: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#IsRunOutOfHeart#get", this ); }

                    return this.Count <= 0 && !this.immortalData.IsImmortalStatusVariable;
                }
            },
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#Count#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.Int32, System.String.format("{0}_count", [this.id]), this.max);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "HeartData#Count#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.Int32, System.String.format("{0}_count", [this.id]), value);
                }
            },
            Max: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#Max#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.Int32, System.String.format("{0}_max", [this.id]), this.max);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "HeartData#Max#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.Int32, System.String.format("{0}_max", [this.id]), value);
                }
            },
            TimeRemainingToIncrease: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#TimeRemainingToIncrease#get", this ); }

                    return this.IsCanIncrease ? ((this.timeIncrease - Bridge.Int.clip32((System.DateTime.subdd(this.TimeCurrent, this.StartTimeIncrease)).getTotalSeconds())) | 0) : this.timeIncrease;
                }
            },
            StartTimeIncrease: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#StartTimeIncrease#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.DateTime, System.String.format("{0}_count_start_time_increase", [this.id]), System.DateTime.getDefaultValue());
                },
                set: function (value) {
if ( TRACE ) { TRACE( "HeartData#StartTimeIncrease#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.DateTime, System.String.format("{0}_count_start_time_increase", [this.id]), value);
                }
            },
            IsInitialized: {
                get: function () {
if ( TRACE ) { TRACE( "HeartData#IsInitialized#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.Boolean, System.String.format("{0}_count_initialized", [this.id]), false);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "HeartData#IsInitialized#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.Boolean, System.String.format("{0}_count_initialized", [this.id]), value);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "HeartData#init", this ); }

                this.max = 5;
                this.countIncrease = 1;
                this.timeIncrease = 1800;
            }
        },
        methods: {
            /*HeartData.ResetID start.*/
            ResetID: function () {
if ( TRACE ) { TRACE( "HeartData#ResetID", this ); }

                this.id = this.name;
            },
            /*HeartData.ResetID end.*/

            /*HeartData.Refesh start.*/
            Refesh: function () {
if ( TRACE ) { TRACE( "HeartData#Refesh", this ); }

                if (!this.IsInitialized) {
                    this.StartTimeIncrease = this.TimeCurrent;
                    this.IsInitialized = true;
                }

                var countAdd = (Bridge.Int.div(Bridge.Int.clip32((System.DateTime.subdd(this.TimeCurrent, this.StartTimeIncrease)).getTotalSeconds()), this.timeIncrease)) | 0;
                if (countAdd > 0) {
                    this.Add(countAdd);
                    if (this.IsCanIncrease) {
                        this.StartTimeIncrease = System.DateTime.addSeconds(this.StartTimeIncrease, Bridge.Int.mul(countAdd, this.timeIncrease));
                    } else {
                        this.ResetTimeIncrease();
                    }
                }
            },
            /*HeartData.Refesh end.*/

            /*HeartData.ResetTimeIncrease start.*/
            ResetTimeIncrease: function () {
if ( TRACE ) { TRACE( "HeartData#ResetTimeIncrease", this ); }

                this.StartTimeIncrease = this.TimeCurrent;
            },
            /*HeartData.ResetTimeIncrease end.*/

            /*HeartData.Add start.*/
            Add: function (count) {
if ( TRACE ) { TRACE( "HeartData#Add", this ); }

                this.Count = (this.Count + count) | 0;
                this.OnUpate();
            },
            /*HeartData.Add end.*/

            /*HeartData.Minus start.*/
            Minus: function (count) {
if ( TRACE ) { TRACE( "HeartData#Minus", this ); }

                if (!this.immortalData.IsImmortalStatusVariable) {
                    this.Count = (this.Count - count) | 0;
                    this.OnUpate();
                }
            },
            /*HeartData.Minus end.*/

            /*HeartData.OnUpate start.*/
            OnUpate: function () {
if ( TRACE ) { TRACE( "HeartData#OnUpate", this ); }

                this.Count = Math.max(0, Math.min(this.Count, this.Max));
                this.balanceAmount.Value = this.Count;
                this.updateHeartEvent != null ? this.updateHeartEvent.Raise(this.Count) : null;
            },
            /*HeartData.OnUpate end.*/

            /*HeartData.AddDebug start.*/
            AddDebug: function () {
if ( TRACE ) { TRACE( "HeartData#AddDebug", this ); }

                this.Add(1);
            },
            /*HeartData.AddDebug end.*/

            /*HeartData.MinusDebug start.*/
            MinusDebug: function () {
if ( TRACE ) { TRACE( "HeartData#MinusDebug", this ); }

                this.Minus(1);
            },
            /*HeartData.MinusDebug end.*/


        }
    });
    /*HeartData end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    Bridge.define("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*ImmortalData start.*/
    Bridge.define("ImmortalData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            totalTimeCountDownImmortalVariable: null,
            isImmortalStatusVariable: false,
            isFirstTimePlayGame: null,
            _isStartCountDownTimeImmortal: false,
            OnUpdateTimeImmortalAction: null,
            OnInStatusImmortalAction: null,
            OnEndStatusImmortalAction: null
        },
        props: {
            IsImmortalStatusVariable: {
                get: function () {
if ( TRACE ) { TRACE( "ImmortalData#IsImmortalStatusVariable#get", this ); }

                    return this.isImmortalStatusVariable;
                }
            }
        },
        methods: {
            /*ImmortalData.Init start.*/
            Init: function () {
if ( TRACE ) { TRACE( "ImmortalData#Init", this ); }

                if (this.isFirstTimePlayGame.Value) {
                    this.SetTimeImmortal(0);
                }

                this.OnCheckImmortalStatus();
            },
            /*ImmortalData.Init end.*/

            /*ImmortalData.SetTimeImmortal start.*/
            SetTimeImmortal: function (timeSet) {
if ( TRACE ) { TRACE( "ImmortalData#SetTimeImmortal", this ); }

                var $t;
                if (!this.isImmortalStatusVariable) {
                    TheBeginning.Data.UserData.LastDailyInfinity = System.DateTime.format(System.DateTime.getNow());
                    this.totalTimeCountDownImmortalVariable.Value = 0;
                }

                ($t = this.totalTimeCountDownImmortalVariable).Value = ($t.Value + timeSet) | 0;
                this.OnCheckImmortalStatus();
            },
            /*ImmortalData.SetTimeImmortal end.*/

            /*ImmortalData.OnCheckImmortalStatus start.*/
            OnCheckImmortalStatus: function () {
if ( TRACE ) { TRACE( "ImmortalData#OnCheckImmortalStatus", this ); }

                var _currentTimeLeft = (System.DateTime.subdd(System.DateTime.getNow(), System.DateTime.parse(TheBeginning.Data.UserData.LastDailyInfinity))).getTotalSeconds();
                var totalDays = (System.DateTime.subdd(System.DateTime.getDate(System.DateTime.parse(TheBeginning.Data.UserData.LastDailyInfinity)), System.DateTime.getDate(System.DateTime.getNow()))).getTotalDays();
                this._isStartCountDownTimeImmortal = totalDays <= 0 && _currentTimeLeft < this.totalTimeCountDownImmortalVariable.Value;
                this.isImmortalStatusVariable = this._isStartCountDownTimeImmortal;
                if (this.isImmortalStatusVariable) {
                    !Bridge.staticEquals(this.OnInStatusImmortalAction, null) ? this.OnInStatusImmortalAction() : null;
                }

                if (totalDays > 0) {
                    this.SetTimeImmortal(0);
                }
            },
            /*ImmortalData.OnCheckImmortalStatus end.*/

            /*ImmortalData.OnUpdateImmortalStatus start.*/
            OnUpdateImmortalStatus: function () {
if ( TRACE ) { TRACE( "ImmortalData#OnUpdateImmortalStatus", this ); }

                if (this._isStartCountDownTimeImmortal) {
                    var _currentTimeLeft = Bridge.Int.clip32((System.DateTime.subdd(System.DateTime.getNow(), System.DateTime.parse(TheBeginning.Data.UserData.LastDailyInfinity))).getTotalSeconds());
                    var calculateTime = (this.totalTimeCountDownImmortalVariable.Value - _currentTimeLeft) | 0;
                    !Bridge.staticEquals(this.OnUpdateTimeImmortalAction, null) ? this.OnUpdateTimeImmortalAction(calculateTime) : null;
                    if (calculateTime <= 0) {
                        this._isStartCountDownTimeImmortal = false;
                        this.isImmortalStatusVariable = false;
                        !Bridge.staticEquals(this.OnEndStatusImmortalAction, null) ? this.OnEndStatusImmortalAction() : null;
                    }
                }
            },
            /*ImmortalData.OnUpdateImmortalStatus end.*/


        }
    });
    /*ImmortalData end.*/

    /*IShutter start.*/
    Bridge.define("IShutter", {
        $kind: 3
    });
    /*IShutter end.*/

    /*LevelAdditionalTime start.*/
    Bridge.define("LevelAdditionalTime", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            id: null
        },
        props: {
            TimeCurrent: {
                get: function () {
if ( TRACE ) { TRACE( "LevelAdditionalTime#TimeCurrent#get", this ); }

                    return System.DateTime.getNow();
                }
            },
            TimeEnd: {
                get: function () {
if ( TRACE ) { TRACE( "LevelAdditionalTime#TimeEnd#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.DateTime, System.String.format("{0}_time_end", [this.id]), System.DateTime.getMinValue());
                },
                set: function (value) {
if ( TRACE ) { TRACE( "LevelAdditionalTime#TimeEnd#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.DateTime, System.String.format("{0}_time_end", [this.id]), value);
                }
            },
            Count: {
                get: function () {
if ( TRACE ) { TRACE( "LevelAdditionalTime#Count#get", this ); }

                    return VirtueSky.DataStorage.GameData.Get(System.Int32, System.String.format("{0}_count", [this.id]), 0);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "LevelAdditionalTime#Count#set", this ); }

                    VirtueSky.DataStorage.GameData.Set(System.Int32, System.String.format("{0}_count", [this.id]), value);
                }
            },
            IsAvailable: {
                get: function () {
if ( TRACE ) { TRACE( "LevelAdditionalTime#IsAvailable#get", this ); }

                    return System.DateTime.lt(this.TimeCurrent, this.TimeEnd);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelAdditionalTime#init", this ); }

                this.id = "level_additional_time";
            }
        },
        methods: {
            /*LevelAdditionalTime.Add start.*/
            Add: function (count, time) {
if ( TRACE ) { TRACE( "LevelAdditionalTime#Add", this ); }

                if (!this.IsAvailable) {
                    this.Count = 0;
                }

                this.Count = (this.Count + count) | 0;
                var timeCurrent = this.IsAvailable ? this.TimeEnd : this.TimeCurrent;
                this.TimeEnd = System.DateTime.addSeconds(timeCurrent, time);
            },
            /*LevelAdditionalTime.Add end.*/


        }
    });
    /*LevelAdditionalTime end.*/

    /*LevelModeData start.*/
    Bridge.define("LevelModeData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            levelSettings: null,
            levelTypeData: null,
            levelModeInfors: null,
            currentLevel: null
        },
        methods: {
            /*LevelModeData.GetLevelData start.*/
            GetLevelData: function () {
if ( TRACE ) { TRACE( "LevelModeData#GetLevelData", this ); }

                return new (System.ValueTuple$2(LevelModeInfor,LevelTypeInfor)).$ctor1(this.levelModeInfors.getItem(((this.currentLevel.Value - 1) | 0)), this.levelTypeData.GetLevelTypeInfor(this.levelModeInfors.getItem(((this.currentLevel.Value - 1) | 0)).levelMode));
            },
            /*LevelModeData.GetLevelData end.*/


        }
    });
    /*LevelModeData end.*/

    /*LevelModeInfor start.*/
    Bridge.define("LevelModeInfor", {
        fields: {
            levelIndex: 0,
            star: 0,
            levelMode: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "LevelModeInfor#init", this ); }

                this.star = 1;
            }
        }
    });
    /*LevelModeInfor end.*/

    /*LevelTypeData start.*/
    Bridge.define("LevelTypeData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            levelTypeInfors: null
        },
        methods: {
            /*LevelTypeData.GetLevelTypeInfor start.*/
            GetLevelTypeInfor: function (getLevelMode) {
if ( TRACE ) { TRACE( "LevelTypeData#GetLevelTypeInfor", this ); }

                return System.Linq.Enumerable.from(this.levelTypeInfors, LevelTypeInfor).firstOrDefault(Bridge.fn.bind(this, function (l) {
                        return l.LevelMode === getLevelMode;
                    }), null);
            },
            /*LevelTypeData.GetLevelTypeInfor end.*/


        }
    });
    /*LevelTypeData end.*/

    /*LevelTypeInfor start.*/
    Bridge.define("LevelTypeInfor", {
        fields: {
            LevelMode: 0,
            colorTextGameplay: null,
            colorTextHome: null,
            iconReplay: null,
            iconBoardLevel: null,
            iconSetting: null,
            boosterIconDatas: null,
            icon: null,
            iconBoardGameplay: null,
            description: null,
            soundStartGame: null,
            coinBonus: 0
        },
        methods: {
            /*LevelTypeInfor.GetBoosterSprite start.*/
            GetBoosterSprite: function (getElementType) {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetBoosterSprite", this ); }

                return System.Linq.Enumerable.from(this.boosterIconDatas, LevelTypeInfor.BoosterIconData).firstOrDefault(Bridge.fn.bind(this, function (b) {
                        return b.elementType === getElementType;
                    }), new LevelTypeInfor.BoosterIconData()).icon;
            },
            /*LevelTypeInfor.GetBoosterSprite end.*/

            /*LevelTypeInfor.GetBoosterSpriteLock start.*/
            GetBoosterSpriteLock: function (getElementType) {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetBoosterSpriteLock", this ); }

                return System.Linq.Enumerable.from(this.boosterIconDatas, LevelTypeInfor.BoosterIconData).firstOrDefault(Bridge.fn.bind(this, function (b) {
                        return b.elementType === getElementType;
                    }), new LevelTypeInfor.BoosterIconData()).iconLock;
            },
            /*LevelTypeInfor.GetBoosterSpriteLock end.*/

            /*LevelTypeInfor.GetIconSettingSprite start.*/
            GetIconSettingSprite: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetIconSettingSprite", this ); }

                return this.iconSetting;
            },
            /*LevelTypeInfor.GetIconSettingSprite end.*/

            /*LevelTypeInfor.GetIconBoardLevelSprite start.*/
            GetIconBoardLevelSprite: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetIconBoardLevelSprite", this ); }

                return this.iconBoardLevel;
            },
            /*LevelTypeInfor.GetIconBoardLevelSprite end.*/

            /*LevelTypeInfor.GetIconReplayLevelSprite start.*/
            GetIconReplayLevelSprite: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetIconReplayLevelSprite", this ); }

                return this.iconReplay;
            },
            /*LevelTypeInfor.GetIconReplayLevelSprite end.*/

            /*LevelTypeInfor.GetColorTextLevelModeHome start.*/
            GetColorTextLevelModeHome: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetColorTextLevelModeHome", this ); }

                return this.colorTextHome;
            },
            /*LevelTypeInfor.GetColorTextLevelModeHome end.*/

            /*LevelTypeInfor.GetColorTextLevelModeGameplay start.*/
            GetColorTextLevelModeGameplay: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor#GetColorTextLevelModeGameplay", this ); }

                return this.colorTextGameplay;
            },
            /*LevelTypeInfor.GetColorTextLevelModeGameplay end.*/


        }
    });
    /*LevelTypeInfor end.*/

    /*LevelTypeInfor+BoosterIconData start.*/
    Bridge.define("LevelTypeInfor.BoosterIconData", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor.BoosterIconData#getDefaultValue", this ); }
 return new LevelTypeInfor.BoosterIconData(); }
            }
        },
        fields: {
            elementType: 0,
            icon: null,
            iconLock: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor.BoosterIconData#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "LevelTypeInfor.BoosterIconData#getHashCode", this ); }

                var h = Bridge.addHash([4323391610, this.elementType, this.icon, this.iconLock]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "LevelTypeInfor.BoosterIconData#equals", this ); }

                if (!Bridge.is(o, LevelTypeInfor.BoosterIconData)) {
                    return false;
                }
                return Bridge.equals(this.elementType, o.elementType) && Bridge.equals(this.icon, o.icon) && Bridge.equals(this.iconLock, o.iconLock);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "LevelTypeInfor.BoosterIconData#$clone", this ); }

                var s = to || new LevelTypeInfor.BoosterIconData();
                s.elementType = this.elementType;
                s.icon = this.icon;
                s.iconLock = this.iconLock;
                return s;
            }
        }
    });
    /*LevelTypeInfor+BoosterIconData end.*/

    /*SetCenterPosition start.*/
    Bridge.define("SetCenterPosition", {
        inherits: [UnityEngine.MonoBehaviour],
        methods: {
            /*SetCenterPosition.SetCenter start.*/
            SetCenter: function () {
if ( TRACE ) { TRACE( "SetCenterPosition#SetCenter", this ); }

                var $t, $t1, $t2, $t3;
                var childrenArray = this.GetComponentsInChildren(UnityEngine.Transform);

                var children = ($t = UnityEngine.Transform, System.Linq.Enumerable.from(childrenArray, $t).toList($t));
                children.removeAt(0);

                var centerPosition = pc.Vec3.ZERO.clone();
                $t1 = Bridge.getEnumerator(children);
                try {
                    while ($t1.moveNext()) {
                        var child = $t1.Current;
                        centerPosition = centerPosition.$clone().add( child.position.$clone() );
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                centerPosition = centerPosition.$clone().scale( 1.0 / ( (children.Count) | 0 ) );

                var parent = this.transform.parent;
                $t2 = Bridge.getEnumerator(children);
                try {
                    while ($t2.moveNext()) {
                        var item = $t2.Current;
                        item.SetParent(parent);
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }

                this.transform.position = centerPosition.$clone();
                $t3 = Bridge.getEnumerator(children);
                try {
                    while ($t3.moveNext()) {
                        var item1 = $t3.Current;
                        item1.SetParent(this.transform);
                    }
                } finally {
                    if (Bridge.is($t3, System.IDisposable)) {
                        $t3.System$IDisposable$Dispose();
                    }
                }
            },
            /*SetCenterPosition.SetCenter end.*/


        }
    });
    /*SetCenterPosition end.*/

    /*SettingType start.*/
    Bridge.define("SettingType", {
        $kind: 6,
        statics: {
            fields: {
                BackgroundMusic: 0,
                SoundFx: 1,
                Vibration: 2
            }
        }
    });
    /*SettingType end.*/

    /*Spine.BoneMatrix start.*/
    Bridge.define("Spine.BoneMatrix", {
        $kind: 4,
        statics: {
            methods: {
                /*Spine.BoneMatrix.CalculateSetupWorld:static start.*/
                /**
                 * Recursively calculates a worldspace bone matrix based on BoneData.
                 *
                 * @static
                 * @public
                 * @this Spine.BoneMatrix
                 * @memberof Spine.BoneMatrix
                 * @param   {spine.BoneData}      boneData
                 * @return  {Spine.BoneMatrix}
                 */
                CalculateSetupWorld: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#CalculateSetupWorld", this ); }

                    if (boneData == null) {
                        return Bridge.getDefaultValue(Spine.BoneMatrix);
                    }

                    // End condition: isRootBone
                    if (boneData.parent == null) {
                        return Spine.BoneMatrix.GetInheritedInternal(boneData, Bridge.getDefaultValue(Spine.BoneMatrix));
                    }

                    var result = Spine.BoneMatrix.CalculateSetupWorld(boneData.parent);
                    return Spine.BoneMatrix.GetInheritedInternal(boneData, result.$clone());
                },
                /*Spine.BoneMatrix.CalculateSetupWorld:static end.*/

                /*Spine.BoneMatrix.GetInheritedInternal:static start.*/
                GetInheritedInternal: function (boneData, parentMatrix) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#GetInheritedInternal", this ); }

                    var parent = boneData.parent;
                    if (parent == null) {
                        return new Spine.BoneMatrix.$ctor2(boneData);
                    } // isRootBone

                    var pa = parentMatrix.a, pb = parentMatrix.b, pc = parentMatrix.c, pd = parentMatrix.d;
                    var result = Bridge.getDefaultValue(Spine.BoneMatrix);
                    result.x = pa * boneData.x + pb * boneData.y + parentMatrix.x;
                    result.y = pc * boneData.x + pd * boneData.y + parentMatrix.y;

                    switch (boneData.transformMode) {
                        case spine.BoneData.Normal: 
                            {
                                var rotationY = boneData.rotation + 90 + boneData.shearY;
                                var la = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var lb = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                                var lc = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                var ld = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                                result.a = pa * la + pb * lc;
                                result.b = pa * lb + pb * ld;
                                result.c = pc * la + pd * lc;
                                result.d = pc * lb + pd * ld;
                                break;
                            }
                        case spine.BoneData.OnlyTranslation: 
                            {
                                var rotationY1 = boneData.rotation + 90 + boneData.shearY;
                                result.a = Spine.MathUtils.CosDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.b = Spine.MathUtils.CosDeg(rotationY1) * boneData.scaleY;
                                result.c = Spine.MathUtils.SinDeg(boneData.rotation + boneData.shearX) * boneData.scaleX;
                                result.d = Spine.MathUtils.SinDeg(rotationY1) * boneData.scaleY;
                                break;
                            }
                        case spine.BoneData.NoRotationOrReflection: 
                            {
                                var s = pa * pa + pc * pc, prx;
                                if (s > 0.0001) {
                                    s = Math.abs(pa * pd - pb * pc) / s;
                                    pb = pc * s;
                                    pd = pa * s;
                                    prx = Spine.MathUtils.Atan2(pc, pa) * Spine.MathUtils.RadDeg;
                                } else {
                                    pa = 0;
                                    pc = 0;
                                    prx = 90 - Spine.MathUtils.Atan2(pd, pb) * Spine.MathUtils.RadDeg;
                                }
                                var rx = boneData.rotation + boneData.shearX - prx;
                                var ry = boneData.rotation + boneData.shearY - prx + 90;
                                var la1 = Spine.MathUtils.CosDeg(rx) * boneData.scaleX;
                                var lb1 = Spine.MathUtils.CosDeg(ry) * boneData.scaleY;
                                var lc1 = Spine.MathUtils.SinDeg(rx) * boneData.scaleX;
                                var ld1 = Spine.MathUtils.SinDeg(ry) * boneData.scaleY;
                                result.a = pa * la1 - pb * lc1;
                                result.b = pa * lb1 - pb * ld1;
                                result.c = pc * la1 + pd * lc1;
                                result.d = pc * lb1 + pd * ld1;
                                break;
                            }
                        case spine.BoneData.NoScale: 
                        case spine.BoneData.NoScaleOrReflection: 
                            {
                                var cos = Spine.MathUtils.CosDeg(boneData.rotation), sin = Spine.MathUtils.SinDeg(boneData.rotation);
                                var za = pa * cos + pb * sin;
                                var zc = pc * cos + pd * sin;
                                var s1 = Math.sqrt(za * za + zc * zc);
                                if (s1 > 1E-05) {
                                    s1 = 1 / s1;
                                }
                                za *= s1;
                                zc *= s1;
                                s1 = Math.sqrt(za * za + zc * zc);
                                var r = 1.57079637 + Spine.MathUtils.Atan2(zc, za);
                                var zb = Spine.MathUtils.Cos(r) * s1;
                                var zd = Spine.MathUtils.Sin(r) * s1;
                                var la2 = Spine.MathUtils.CosDeg(boneData.shearX) * boneData.scaleX;
                                var lb2 = Spine.MathUtils.CosDeg(90 + boneData.shearY) * boneData.scaleY;
                                var lc2 = Spine.MathUtils.SinDeg(boneData.shearX) * boneData.scaleX;
                                var ld2 = Spine.MathUtils.SinDeg(90 + boneData.shearY) * boneData.scaleY;
                                if (boneData.transformMode !== spine.BoneData.NoScaleOrReflection ? pa * pd - pb * pc < 0 : false) {
                                    zb = -zb;
                                    zd = -zd;
                                }
                                result.a = za * la2 + zb * lc2;
                                result.b = za * lb2 + zb * ld2;
                                result.c = zc * la2 + zd * lc2;
                                result.d = zc * lb2 + zd * ld2;
                                break;
                            }
                    }

                    return result.$clone();
                },
                /*Spine.BoneMatrix.GetInheritedInternal:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getDefaultValue", this ); }
 return new Spine.BoneMatrix(); }
            }
        },
        fields: {
            a: 0,
            b: 0,
            c: 0,
            d: 0,
            x: 0,
            y: 0
        },
        ctors: {
            /**
             * Constructor for a local bone matrix based on Setup Pose BoneData.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {spine.BoneData}    boneData
             * @return  {void}
             */
            $ctor2: function (boneData) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor2", this ); }

                this.$initialize();
                var rotationY = boneData.rotation + 90 + boneData.shearY;
                var rotationX = boneData.rotation + boneData.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * boneData.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * boneData.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * boneData.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * boneData.scaleY;
                this.x = boneData.x;
                this.y = boneData.y;
            },
            /**
             * Constructor for a local bone matrix based on a bone instance's current pose.
             *
             * @instance
             * @public
             * @this Spine.BoneMatrix
             * @memberof Spine.BoneMatrix
             * @param   {Spine.Bone}    bone
             * @return  {void}
             */
            $ctor1: function (bone) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$ctor1", this ); }

                this.$initialize();
                var rotationY = bone.rotation + 90 + bone.shearY;
                var rotationX = bone.rotation + bone.shearX;

                this.a = Spine.MathUtils.CosDeg(rotationX) * bone.scaleX;
                this.c = Spine.MathUtils.SinDeg(rotationX) * bone.scaleX;
                this.b = Spine.MathUtils.CosDeg(rotationY) * bone.scaleY;
                this.d = Spine.MathUtils.SinDeg(rotationY) * bone.scaleY;
                this.x = bone.x;
                this.y = bone.y;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.BoneMatrix.TransformMatrix start.*/
            TransformMatrix: function (local) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#TransformMatrix", this ); }

                var $t;
                return ($t = new Spine.BoneMatrix.ctor(), $t.a = this.a * local.a + this.b * local.c, $t.b = this.a * local.b + this.b * local.d, $t.c = this.c * local.a + this.d * local.c, $t.d = this.c * local.b + this.d * local.d, $t.x = this.a * local.x + this.b * local.y + this.x, $t.y = this.c * local.x + this.d * local.y + this.y, $t);
            },
            /*Spine.BoneMatrix.TransformMatrix end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#getHashCode", this ); }

                var h = Bridge.addHash([3621996792, this.a, this.b, this.c, this.d, this.x, this.y]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#equals", this ); }

                if (!Bridge.is(o, Spine.BoneMatrix)) {
                    return false;
                }
                return Bridge.equals(this.a, o.a) && Bridge.equals(this.b, o.b) && Bridge.equals(this.c, o.c) && Bridge.equals(this.d, o.d) && Bridge.equals(this.x, o.x) && Bridge.equals(this.y, o.y);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.BoneMatrix#$clone", this ); }

                var s = to || new Spine.BoneMatrix();
                s.a = this.a;
                s.b = this.b;
                s.c = this.c;
                s.d = this.d;
                s.x = this.x;
                s.y = this.y;
                return s;
            }
        }
    });
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    Bridge.define("Spine.SpineSkeletonExtensions", {
        statics: {
            methods: {
                /*Spine.SpineSkeletonExtensions.IsWeighted:static start.*/
                IsWeighted: function (va) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#IsWeighted", this ); }

                    return va.bones != null && va.bones.length > 0;
                },
                /*Spine.SpineSkeletonExtensions.IsWeighted:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsRotation:static start.*/
                InheritsRotation: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsRotation", this ); }

                    var RotationBit = 0;
                    return (System.Int64(mode).and(System.Int64((1)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsRotation:static end.*/

                /*Spine.SpineSkeletonExtensions.InheritsScale:static start.*/
                InheritsScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.SpineSkeletonExtensions#InheritsScale", this ); }

                    var ScaleBit = 1;
                    return (System.Int64(mode).and(System.Int64((2)))).equals(System.Int64(0));
                },
                /*Spine.SpineSkeletonExtensions.InheritsScale:static end.*/


            }
        }
    });
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    /** @namespace Spine.Unity */

    /**
     * Utility component to support flipping of 2D hinge chains (chains of HingeJoint2D objects) along
     with the parent skeleton by activating the respective mirrored versions of the hinge chain.
     Note: This component is automatically attached when calling "Create Hinge Chain 2D" at {@link },
     do not attempt to use this component for other purposes.
     *
     * @public
     * @class Spine.Unity.ActivateBasedOnFlipDirection
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.ActivateBasedOnFlipDirection", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            skeletonGraphic: null,
            activeOnNormalX: null,
            activeOnFlippedX: null,
            jointsNormalX: null,
            jointsFlippedX: null,
            skeletonComponent: null,
            wasFlippedXBefore: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#init", this ); }

                this.wasFlippedXBefore = false;
            }
        },
        methods: {
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#Start", this ); }

                this.jointsNormalX = this.activeOnNormalX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.jointsFlippedX = this.activeOnFlippedX.GetComponentsInChildren(UnityEngine.HingeJoint2D);
                this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? Bridge.cast(this.skeletonRenderer, Spine.Unity.ISkeletonComponent) : Bridge.cast(this.skeletonGraphic, Spine.Unity.ISkeletonComponent);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.Start end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#FixedUpdate", this ); }

                var isFlippedX = (this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.scaleX < 0);
                if (isFlippedX !== this.wasFlippedXBefore) {
                    this.HandleFlip(isFlippedX);
                }
                this.wasFlippedXBefore = isFlippedX;
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.FixedUpdate end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip start.*/
            HandleFlip: function (isFlippedX) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#HandleFlip", this ); }

                var gameObjectToActivate = isFlippedX ? this.activeOnFlippedX : this.activeOnNormalX;
                var gameObjectToDeactivate = isFlippedX ? this.activeOnNormalX : this.activeOnFlippedX;

                gameObjectToActivate.SetActive(true);
                gameObjectToDeactivate.SetActive(false);

                this.ResetJointPositions(isFlippedX ? this.jointsFlippedX : this.jointsNormalX);
                this.ResetJointPositions(isFlippedX ? this.jointsNormalX : this.jointsFlippedX);
                this.CompensateMovementAfterFlipX(gameObjectToActivate.transform, gameObjectToDeactivate.transform);
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.HandleFlip end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions start.*/
            ResetJointPositions: function (joints) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#ResetJointPositions", this ); }

                for (var i = 0; i < joints.length; i = (i + 1) | 0) {
                    var joint = joints[i];
                    var parent = joint.connectedBody.transform;
                    joint.transform.position = parent.TransformPoint$1(UnityEngine.Vector3.FromVector2(joint.connectedAnchor));
                }
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.ResetJointPositions end.*/

            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX start.*/
            CompensateMovementAfterFlipX: function (toActivate, toDeactivate) {
if ( TRACE ) { TRACE( "Spine.Unity.ActivateBasedOnFlipDirection#CompensateMovementAfterFlipX", this ); }

                var targetLocation = toDeactivate.GetChild(0);
                var currentLocation = toActivate.GetChild(0);
                toActivate.position = toActivate.position.$clone().add( targetLocation.position.$clone().sub( currentLocation.position ) );
            },
            /*Spine.Unity.ActivateBasedOnFlipDirection.CompensateMovementAfterFlipX end.*/


        }
    });
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.ISpineComponent start.*/
    Bridge.define("Spine.Unity.ISpineComponent", {
        $kind: 3
    });
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    Bridge.define("Spine.Unity.AnimationTools.TimelineExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static start.*/
                /**
                 * Evaluates the resulting value of a TranslateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is provided, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateTimeline}    timeline        
                 * @param   {number}                     time            
                 * @param   {Spine.SkeletonData}         skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$1: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$1", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var x = { }, y = { };
                    timeline.getCurveValue(x, y, time);

                    if (skeletonData == null) {
                        return new pc.Vec2( x.v, y.v );
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return new pc.Vec2( boneData.x + x.v, boneData.y + y.v );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static start.*/
                /**
                 * Evaluates the resulting value of a pair of split translate timelines at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TranslateXTimeline}    xTimeline       
                 * @param   {spine.TranslateYTimeline}    yTimeline       
                 * @param   {number}                      time            
                 * @param   {Spine.SkeletonData}          skeletonData
                 * @return  {UnityEngine.Vector2}
                 */
                Evaluate$2: function (xTimeline, yTimeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate$2", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }

                    var x = 0, y = 0;
                    if (xTimeline != null && time > ($t = xTimeline.frames)[0]) {
                        x = xTimeline.getCurveValue(time);
                    }
                    if (yTimeline != null && time > ($t1 = yTimeline.frames)[0]) {
                        y = yTimeline.getCurveValue(time);
                    }

                    if (skeletonData == null) {
                        return new pc.Vec2( x, y );
                    } else {
                        var bonesItems = skeletonData.Bones.Items;
                        var boneDataX = bonesItems[xTimeline.boneIndex];
                        var boneDataY = bonesItems[yTimeline.boneIndex];
                        return new pc.Vec2( boneDataX.x + x, boneDataY.y + y );
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static start.*/
                /**
                 * Evaluates the resulting value of a RotateTimeline at a given time.
                 SkeletonData can be accessed from Skeleton.Data or from SkeletonDataAsset.GetSkeletonData.
                 If no SkeletonData is given, values are returned as difference to setup pose
                 instead of absolute values.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.RotateTimeline}    timeline        
                 * @param   {number}                  time            
                 * @param   {Spine.SkeletonData}      skeletonData
                 * @return  {number}
                 */
                Evaluate: function (timeline, time, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#Evaluate", this ); }

                    var $t, $t1;
                    if (skeletonData === void 0) { skeletonData = null; }
                    if (time < ($t = timeline.frames)[0]) {
                        return 0.0;
                    }

                    var rotation = timeline.getCurveValue(time);
                    if (skeletonData == null) {
                        return rotation;
                    } else {
                        var boneData = ($t1 = skeletonData.Bones.Items)[timeline.boneIndex];
                        return (boneData.rotation + rotation);
                    }
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.Evaluate:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static start.*/
                /**
                 * Evaluates the resulting X and Y translate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {UnityEngine.Vector2}
                 */
                EvaluateTranslateXYMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateTranslateXYMix", this ); }

                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return pc.Vec2.ZERO.clone();
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return new pc.Vec2( mixX.v, mixY.v );
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static start.*/
                /**
                 * Evaluates the resulting rotate mix values of a
                 TransformConstraintTimeline at a given time.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {spine.TransformConstraintTimeline}    timeline    
                 * @param   {number}                               time
                 * @return  {number}
                 */
                EvaluateRotateMix: function (timeline, time) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#EvaluateRotateMix", this ); }

                    var $t;
                    if (time < ($t = timeline.frames)[0]) {
                        return 0;
                    }

                    var rotate = { }, mixX = { }, mixY = { }, scaleX = { }, scaleY = { }, shearY = { };
                    timeline.getCurveValue(rotate, mixX, mixY, scaleX, scaleY, shearY, time);
                    return rotate.v;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static start.*/
                /**
                 * Gets the translate timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}            a            
                 * @param   {number}                     boneIndex
                 * @return  {spine.TranslateTimeline}
                 */
                FindTranslateTimelineForBone: function (a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTranslateTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TranslateTimeline)) {
                                continue;
                            }

                            var translateTimeline = Bridge.as(timeline, spine.TranslateTimeline);
                            if (translateTimeline != null && translateTimeline.boneIndex === boneIndex) {
                                return translateTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static start.*/
                /**
                 * Gets the IBoneTimeline timeline of a given type for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBoneIndex.
                 The root bone is always boneIndex 0.
                 This will return null if a timeline of the given type is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Function}           T            
                 * @param   {Spine.Animation}    a            
                 * @param   {number}             boneIndex
                 * @return  {T}
                 */
                FindTimelineForBone: function (T, a, boneIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTimelineForBone", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            var translateTimeline = Bridge.as(timeline, T);
                            if (Bridge.rValue(translateTimeline) != null && Bridge.rValue(translateTimeline).Spine$IBoneTimeline$BoneIndex === boneIndex) {
                                return Bridge.rValue(translateTimeline);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone:static end.*/

                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static start.*/
                /**
                 * Gets the transform constraint timeline for a given boneIndex.
                 You can get the boneIndex using SkeletonData.FindBone().Index.
                 The root bone is always boneIndex 0.
                 This will return null if a TranslateTimeline is not found.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AnimationTools.TimelineExtensions
                 * @memberof Spine.Unity.AnimationTools.TimelineExtensions
                 * @param   {Spine.Animation}                      a                           
                 * @param   {number}                               transformConstraintIndex
                 * @return  {spine.TransformConstraintTimeline}
                 */
                FindTransformConstraintTimeline: function (a, transformConstraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationTools.TimelineExtensions#FindTransformConstraintTimeline", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(a.Timelines);
                    try {
                        while ($t.moveNext()) {
                            var timeline = $t.Current;
                            if ((Bridge.getType(timeline).prototype instanceof spine.TransformConstraintTimeline)) {
                                continue;
                            }

                            var transformConstraintTimeline = Bridge.as(timeline, spine.TransformConstraintTimeline);
                            if (transformConstraintTimeline != null && transformConstraintTimeline.transformConstraintIndex === transformConstraintIndex) {
                                return transformConstraintTimeline;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    return null;
                },
                /*Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline:static end.*/


            }
        }
    });
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            textureLoadingMode: 0,
            onDemandTextureLoader: null
        },
        props: {
            TextureLoadingMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#get", this ); }

                    return this.textureLoadingMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#TextureLoadingMode#set", this ); }

                    this.textureLoadingMode = value;
                }
            },
            OnDemandTextureLoader: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#get", this ); }

                    return this.onDemandTextureLoader;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#OnDemandTextureLoader#set", this ); }

                    this.onDemandTextureLoader = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#init", this ); }

                this.textureLoadingMode = Spine.Unity.AtlasAssetBase.LoadingMode.Normal;
            }
        },
        methods: {
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading start.*/
            BeginCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#BeginCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.BeginCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.BeginCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading start.*/
            EndCustomTextureLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#EndCustomTextureLoading", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.EndCustomTextureLoading();
                }
            },
            /*Spine.Unity.AtlasAssetBase.EndCustomTextureLoading end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded start.*/
            RequireTexturesLoaded: function (material, overrideMaterial) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTexturesLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadMaterialTextures(material, overrideMaterial);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTexturesLoaded end.*/

            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded start.*/
            RequireTextureLoaded: function (placeholderTexture, replacementTexture, onTextureLoaded) {
if ( TRACE ) { TRACE( "Spine.Unity.AtlasAssetBase#RequireTextureLoaded", this ); }

                if (UnityEngine.Object.op_Implicit(this.onDemandTextureLoader)) {
                    this.onDemandTextureLoader.RequestLoadTexture(placeholderTexture, replacementTexture, onTextureLoaded);
                }
            },
            /*Spine.Unity.AtlasAssetBase.RequireTextureLoaded end.*/


        }
    });
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    Bridge.define("Spine.Unity.AtlasAssetBase.LoadingMode", {
        $kind: 1006,
        statics: {
            fields: {
                Normal: 0,
                OnDemand: 1
            }
        }
    });
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities", {
        statics: {
            fields: {
                SpineTextureFormat: 0,
                DefaultMipmapBias: 0,
                UseMipMaps: false,
                DefaultScale: 0,
                NonrenderingRegion: 0,
                existingRegions: null,
                regionIndices: null,
                originalRegions: null,
                repackedRegions: null,
                texturesToPackAtParam: null,
                inoutAttachments: null,
                CachedRegionTextures: null,
                CachedRegionTexturesList: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#init", this ); }

                    this.SpineTextureFormat = UnityEngine.TextureFormat.RGBA32;
                    this.DefaultMipmapBias = -0.5;
                    this.UseMipMaps = false;
                    this.DefaultScale = 0.01;
                    this.NonrenderingRegion = -1;
                    this.existingRegions = new (System.Collections.Generic.Dictionary$2(Spine.AtlasRegion,System.Int32)).ctor();
                    this.regionIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                    this.originalRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.repackedRegions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();
                    this.texturesToPackAtParam = System.Array.init(1, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    this.inoutAttachments = new (System.Collections.Generic.List$1(spine.Attachment)).ctor();
                    this.CachedRegionTextures = new (System.Collections.Generic.Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D)).ctor();
                    this.CachedRegionTexturesList = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#Init", this ); }

                    // handle disabled domain reload
                    Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.Init:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static start.*/
                ToAtlasRegion$2: function (t, materialPropertySource, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$2", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(t, materialPropertySource.shader, scale, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static start.*/
                ToAtlasRegion$3: function (t, shader, scale, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$3", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    material.mainTexture = t;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var width = t.width;
                    var height = t.height;

                    var region = new Spine.AtlasRegion();
                    region.name = t.name;

                    // World space units
                    var boundsMin = pc.Vec2.ZERO.clone(), boundsMax = new pc.Vec2( width, height ).scale( scale );

                    // Texture space/pixel units
                    region.width = Bridge.Int.clip32(width);
                    region.originalWidth = Bridge.Int.clip32(width);
                    region.height = Bridge.Int.clip32(height);
                    region.originalHeight = Bridge.Int.clip32(height);
                    region.offsetX = width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    // Use the full area of the texture.
                    region.u = 0;
                    region.v = 1;
                    region.u2 = 1;
                    region.v2 = 0;
                    region.x = 0;
                    region.y = 0;

                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}    s       
                 * @param   {Spine.AtlasPage}       page
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion: function (s, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion", this ); }

                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor3("page", "page cannot be null. AtlasPage determines which texture region belongs and how it should be rendered. You can use material.ToSpineAtlasPage() to get a shareable AtlasPage from a Material, or use the sprite.ToAtlasRegion(material) overload.");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = page;
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion from a UnityEngine.Sprite. This creates a new AtlasPage object for every AtlasRegion you create. You can centralize Material control by creating a shared atlas page using Material.ToSpineAtlasPage and using the sprite.ToAtlasRegion(AtlasPage) overload.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}      s           
                 * @param   {UnityEngine.Material}    material
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegion$1: function (s, material) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$1", this ); }

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s);
                    region.page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);
                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static start.*/
                ToAtlasRegion$4: function (s, isolatedTexture) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegion$4", this ); }

                    if (isolatedTexture === void 0) { isolatedTexture = false; }
                    var region = new Spine.AtlasRegion();
                    region.name = s.name;
                    region.index = -1;
                    region.degrees = s.packed && s.packingRotation !== UnityEngine.SpritePackingRotation.None ? 90 : 0;

                    // World space units
                    var bounds = s.bounds;
                    var boundsMin = UnityEngine.Vector2.FromVector3(bounds.min.$clone()), boundsMax = UnityEngine.Vector2.FromVector3(bounds.max.$clone());

                    // Texture space/pixel units
                    var spineRect = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(s.textureRect, s.texture.height);
                    var originalRect = s.rect.$clone();
                    region.width = Bridge.Int.clip32(spineRect.width);
                    region.originalWidth = Bridge.Int.clip32(originalRect.width);
                    region.height = Bridge.Int.clip32(spineRect.height);
                    region.originalHeight = Bridge.Int.clip32(originalRect.height);
                    region.offsetX = s.textureRectOffset.x + spineRect.width * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.x, boundsMax.x, 0));
                    region.offsetY = s.textureRectOffset.y + spineRect.height * (0.5 - Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp(boundsMin.y, boundsMax.y, 0));

                    if (isolatedTexture) {
                        region.u = 0;
                        region.v = 1;
                        region.u2 = 1;
                        region.v2 = 0;
                        region.x = 0;
                        region.y = 0;
                    } else {
                        var tex = s.texture;
                        var uvRect = Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect(s.textureRect.$clone(), tex.width, tex.height);
                        region.u = uvRect.xMin;
                        region.v = uvRect.yMax;
                        region.u2 = uvRect.xMax;
                        region.v2 = uvRect.yMin;
                        region.x = Bridge.Int.clip32(spineRect.x);
                        region.y = Bridge.Int.clip32(spineRect.y);
                    }

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$2: function (t, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$2", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3(t, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$2:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Texture2D}        t                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$3: function (t, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$3", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    var newTexture = Spine.Unity.AttachmentTools.AtlasUtilities.GetClone(t, textureFormat, mipmaps, false, true);

                    newTexture.name = (t.name || "") + "-pma-";
                    material.name = (t.name || "") + (shader.name || "");

                    material.mainTexture = newTexture;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$3(newTexture, shader);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$3:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static start.*/
                ToAtlasRegionPMAClone: function (s, materialPropertySource, textureFormat, mipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    return Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(s, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate of the Sprite's texture data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Sprite}           s                         
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource
                 * @return  {Spine.AtlasRegion}
                 */
                ToAtlasRegionPMAClone$1: function (s, shader, textureFormat, mipmaps, materialPropertySource) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToAtlasRegionPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    var material = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        material.CopyPropertiesFromMaterial(materialPropertySource);
                        material.shaderKeywords = materialPropertySource.shaderKeywords;
                    }

                    var tex = Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1(s, textureFormat, mipmaps, false, true);
                    tex.name = (s.name || "") + "-pma-";
                    material.name = (tex.name || "") + (shader.name || "");

                    material.mainTexture = tex;
                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material);

                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$4(s, true);
                    region.page = page;

                    return region;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static start.*/
                /**
                 * Creates a new Spine.AtlasPage from a UnityEngine.Material. If the material has a preassigned texture, the page width and height will be set.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Material}    m
                 * @return  {Spine.AtlasPage}
                 */
                ToSpineAtlasPage: function (m) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSpineAtlasPage", this ); }

                    var $t;
                    var newPage = ($t = new Spine.AtlasPage(), $t.rendererObject = m, $t.name = m.name, $t);

                    var t = m.mainTexture;
                    if (t != null) {
                        newPage.width = t.width;
                        newPage.height = t.height;
                    }

                    return newPage;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments: function (sourceAttachments, outputAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    var shader = materialPropertySource == null ? UnityEngine.Shader.Find("Spine/Skeleton") : materialPropertySource.shader;
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1(sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static start.*/
                /**
                 * Fills the outputAttachments list with new attachment objects based on the attachments in sourceAttachments,
                 but mapped to a new single texture using the same material.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {System.Collections.Generic.List$1}    sourceAttachments                     The list of attachments to be repacked.
                 * @param   {System.Collections.Generic.List$1}    outputAttachments                     The List(Attachment) to populate with the newly created Attachment objects.
                 May be equal to <pre><code>sourceAttachments</code></pre> for in-place operation.
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {string}                               newAssetName                          
                 * @param   {UnityEngine.Material}                 materialPropertySource                May be null. If no Material property source is provided, a material with
                 default parameters using the provided <pre><code>shader</code></pre> will be created.
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {void}
                 */
                GetRepackedAttachments$1: function (sourceAttachments, outputAttachments, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newAssetName, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedAttachments$1", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (newAssetName === void 0) { newAssetName = "Repacked Attachments"; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    if (sourceAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("sourceAttachments");
                    }
                    if (outputAttachments == null) {
                        throw new System.ArgumentNullException.$ctor1("outputAttachments");
                    }
                    outputTexture.v = null;
                    if (additionalTexturePropertyIDsToCopy != null && additionalTextureIsLinear == null) {
                        additionalTextureIsLinear = System.Array.init(additionalTexturePropertyIDsToCopy.length, false, System.Boolean);
                        for (var i = 0; i < additionalTextureIsLinear.length; i = (i + 1) | 0) {
                            additionalTextureIsLinear[i] = true;
                        }
                    }

                    // Use these to detect and use shared regions.
                    Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.clear();

                    // Collect all textures from original attachments.
                    var numTextureParamsToRepack = (1 + (additionalTexturePropertyIDsToCopy == null ? 0 : additionalTexturePropertyIDsToCopy.length)) | 0;
                    additionalOutputTextures = (additionalTexturePropertyIDsToCopy == null ? null : System.Array.init(additionalTexturePropertyIDsToCopy.length, null, UnityEngine.Texture2D));
                    if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam.length < numTextureParamsToRepack) {
                        System.Array.resize(Bridge.ref(Spine.Unity.AttachmentTools.AtlasUtilities, "texturesToPackAtParam"), numTextureParamsToRepack, null, System.Collections.Generic.List$1(UnityEngine.Texture2D));
                    }
                    for (var i1 = 0; i1 < numTextureParamsToRepack; i1 = (i1 + 1) | 0) {
                        if (Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] != null) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1].clear();
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i1] = new (System.Collections.Generic.List$1(UnityEngine.Texture2D)).ctor();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.clear();

                    if (!Bridge.referenceEquals(sourceAttachments, outputAttachments)) {
                        outputAttachments.clear();
                        outputAttachments.AddRange(sourceAttachments);
                    }

                    var newRegionIndex = 0;
                    for (var attachmentIndex = 0, n = sourceAttachments.Count; attachmentIndex < n; attachmentIndex = (attachmentIndex + 1) | 0) {
                        var originalAttachment = sourceAttachments.getItem(attachmentIndex);

                        if (Bridge.is(originalAttachment, Spine.IHasTextureRegion)) {
                            var originalMeshAttachment = Bridge.as(originalAttachment, Spine.MeshAttachment);
                            var newAttachment = (originalMeshAttachment != null) ? originalMeshAttachment.newLinkedMesh() : originalAttachment.copy();
                            var region = Bridge.as(Bridge.cast(newAttachment, Spine.IHasTextureRegion).Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var existingIndex = { };
                            if (Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.tryGetValue(region, existingIndex)) {
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(existingIndex.v);
                            } else {
                                Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.add(region);
                                for (var i2 = 0; i2 < numTextureParamsToRepack; i2 = (i2 + 1) | 0) {
                                    var regionTexture = (i2 === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, textureFormat, mipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture(region, (additionalTextureFormats != null && ((i2 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i2 - 1) | 0)] : textureFormat, mipmaps, additionalTexturePropertyIDsToCopy[((i2 - 1) | 0)], additionalTextureIsLinear[((i2 - 1) | 0)]));
                                    Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i2].add(regionTexture);
                                }

                                Spine.Unity.AttachmentTools.AtlasUtilities.existingRegions.add(region, newRegionIndex);
                                Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(newRegionIndex);
                                newRegionIndex = (newRegionIndex + 1) | 0;
                            }

                            outputAttachments.setItem(attachmentIndex, newAttachment);
                        } else {
                            outputAttachments.setItem(attachmentIndex, useOriginalNonrenderables ? originalAttachment : originalAttachment.copy());
                            Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.add(Spine.Unity.AttachmentTools.AtlasUtilities.NonrenderingRegion); // Output attachments pairs with regionIndices list 1:1. Pad with a sentinel if the attachment doesn't have a region.
                        }
                    }

                    // Rehydrate the repacked textures as a Material, Spine atlas and Spine.AtlasAttachments
                    var newMaterial = new UnityEngine.Material.$ctor2(shader);
                    if (materialPropertySource != null) {
                        newMaterial.CopyPropertiesFromMaterial(materialPropertySource);
                        newMaterial.shaderKeywords = materialPropertySource.shaderKeywords;
                    }
                    newMaterial.name = newAssetName;

                    var rects = null;
                    for (var i3 = 0; i3 < numTextureParamsToRepack; i3 = (i3 + 1) | 0) {
                        // Fill a new texture with the collected attachment textures.
                        var newTexture = new UnityEngine.Texture2D.$ctor12(maxAtlasSize, maxAtlasSize, (i3 > 0 && additionalTextureFormats != null && ((i3 - 1) | 0) < additionalTextureFormats.length) ? additionalTextureFormats[((i3 - 1) | 0)] : textureFormat, mipmaps, (i3 > 0) ? additionalTextureIsLinear[((i3 - 1) | 0)] : false);
                        newTexture.mipMapBias = Spine.Unity.AttachmentTools.AtlasUtilities.DefaultMipmapBias;

                        var texturesToPack = Spine.Unity.AttachmentTools.AtlasUtilities.texturesToPackAtParam[i3];
                        if (texturesToPack.Count > 0) {
                            var sourceTexture = texturesToPack.getItem(0);
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, sourceTexture);
                        }
                        newTexture.name = newAssetName;
                        var rectsForTexParam = newTexture.PackTextures(texturesToPack.ToArray(), padding, maxAtlasSize);
                        if (i3 === 0) {
                            rects = rectsForTexParam;
                            newMaterial.mainTexture = newTexture;
                            outputTexture.v = newTexture;
                        } else {
                            newMaterial.SetTexture(additionalTexturePropertyIDsToCopy[((i3 - 1) | 0)], newTexture);
                            additionalOutputTextures[((i3 - 1) | 0)] = newTexture;
                        }
                    }

                    var page = Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(newMaterial);
                    page.name = newAssetName;

                    Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.clear();
                    for (var i4 = 0, n1 = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.Count; i4 < n1; i4 = (i4 + 1) | 0) {
                        var oldRegion = Spine.Unity.AttachmentTools.AtlasUtilities.originalRegions.getItem(i4);
                        var newRegion = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion(rects[i4], oldRegion, page);
                        Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.add(newRegion);
                    }

                    // Map the cloned attachments to the repacked atlas.
                    for (var i5 = 0, n2 = outputAttachments.Count; i5 < n2; i5 = (i5 + 1) | 0) {
                        var attachment = outputAttachments.getItem(i5);
                        var iHasRegion = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (iHasRegion != null) {
                            iHasRegion.Spine$IHasTextureRegion$Region = Spine.Unity.AttachmentTools.AtlasUtilities.repackedRegions.getItem(Spine.Unity.AttachmentTools.AtlasUtilities.regionIndices.getItem(i5));
                            iHasRegion.Spine$IHasTextureRegion$UpdateRegion();
                        }
                    }

                    // Clean up.
                    if (clearCache) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache();
                    }

                    outputMaterial.v = newMaterial;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {boolean}                              clearCache                            When set to <pre><code>true</code></pre>, {@link } is called after
                 repacking to clear the texture cache. See remarks for additional info.
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    Optional additional textures (such as normal maps) to copy while repacking.
                 To copy e.g. the main texture and normal maps, pass 'new int[] { Shader.PropertyToID("_BumpMap") }' at this parameter.
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be filled with the resulting repacked texture for every property,
                 just as the main repacked texture is assigned to <pre><code>outputTexture</code></pre>.
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used as <pre><code>TextureFormat</code></pre> at the Texture at the respective property.
                 When <pre><code>additionalTextureFormats</code></pre> is <pre><code>null</code></pre> or when its array size is smaller,
                 <pre><code>textureFormat</code></pre> is used where there exists no corresponding array item.
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear             When <pre><code>additionalTexturePropertyIDsToCopy</code></pre> is non-null,
                 this array will be used to determine whether <pre><code>linear</code></pre> or <pre><code>sRGB</code></pre> color space is used at the
                 Texture at the respective property. When <pre><code>additionalTextureIsLinear</code></pre> is <pre><code>null</code></pre>, <pre><code>linear</code></pre> color space
                 is assumed at every additional Texture element.
                 When e.g. packing the main texture and normal maps, pass 'new bool[] { true }' at this parameter, because normal maps use
                 linear color space.
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin: function (o, newName, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, useOriginalNonrenderables, clearCache, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin", this ); }

                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1(o, newName, materialPropertySource.shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static start.*/
                /**
                 * Creates and populates a duplicate skin with cloned attachments that are backed by a new packed texture atlas
                 comprised of all the regions from the original skin.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.Skin}                           o                                     
                 * @param   {string}                               newName                               
                 * @param   {UnityEngine.Shader}                   shader                                
                 * @param   {UnityEngine.Material}                 outputMaterial                        
                 * @param   {UnityEngine.Texture2D}                outputTexture                         
                 * @param   {number}                               maxAtlasSize                          
                 * @param   {number}                               padding                               
                 * @param   {UnityEngine.TextureFormat}            textureFormat                         
                 * @param   {boolean}                              mipmaps                               
                 * @param   {UnityEngine.Material}                 materialPropertySource                
                 * @param   {boolean}                              clearCache                            
                 * @param   {boolean}                              useOriginalNonrenderables             
                 * @param   {Array.<number>}                       additionalTexturePropertyIDsToCopy    
                 * @param   {Array.<UnityEngine.Texture2D>}        additionalOutputTextures              
                 * @param   {Array.<UnityEngine.TextureFormat>}    additionalTextureFormats              
                 * @param   {Array.<boolean>}                      additionalTextureIsLinear
                 * @return  {Spine.Skin}
                 */
                GetRepackedSkin$1: function (o, newName, shader, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, materialPropertySource, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetRepackedSkin$1", this ); }

                    var $t, $t1;
                    if (maxAtlasSize === void 0) { maxAtlasSize = 1024; }
                    if (padding === void 0) { padding = 2; }
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (clearCache === void 0) { clearCache = false; }
                    if (useOriginalNonrenderables === void 0) { useOriginalNonrenderables = true; }
                    if (additionalTexturePropertyIDsToCopy === void 0) { additionalTexturePropertyIDsToCopy = null; }
                    if (additionalOutputTextures === void 0) { additionalOutputTextures = null; }
                    if (additionalTextureFormats === void 0) { additionalTextureFormats = null; }
                    if (additionalTextureIsLinear === void 0) { additionalTextureIsLinear = null; }

                    outputTexture.v = null;

                    if (o == null) {
                        throw new System.NullReferenceException.$ctor1("Skin was null");
                    }
                    var skinAttachments = o.Attachments;
                    var newSkin = new Spine.Skin(newName);

                    newSkin.Bones.AddRange(o.Bones);
                    newSkin.Constraints.AddRange(o.Constraints);

                    Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.clear();
                    $t = Bridge.getEnumerator(skinAttachments, spine.SkinEntry);
                    try {
                        while ($t.moveNext()) {
                            var entry = $t.Current;
                            Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.add(entry.attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedAttachments(Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments, materialPropertySource, outputMaterial, outputTexture, maxAtlasSize, padding, textureFormat, mipmaps, newName, clearCache, useOriginalNonrenderables, additionalTexturePropertyIDsToCopy, additionalOutputTextures, additionalTextureFormats, additionalTextureIsLinear);
                    var i = 0;
                    $t1 = Bridge.getEnumerator(skinAttachments, spine.SkinEntry);
                    try {
                        while ($t1.moveNext()) {
                            var originalSkinEntry = $t1.Current;
                            var newAttachment = Spine.Unity.AttachmentTools.AtlasUtilities.inoutAttachments.getItem(Bridge.identity(i, ((i = (i + 1) | 0))));
                            newSkin.setAttachment(originalSkinEntry.slotIndex, originalSkinEntry.name, newAttachment);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    return newSkin;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetRepackedSkin$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static start.*/
                ToSprite: function (ar, pixelsPerUnit) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToSprite", this ); }

                    if (pixelsPerUnit === void 0) { pixelsPerUnit = 100.0; }
                    return UnityEngine.Sprite.Create$1(Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar), Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar), new pc.Vec2( 0.5, 0.5 ), pixelsPerUnit);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToSprite:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static start.*/
                /**
                 * Frees up textures cached by repacking and remapping operations.
                 Calling {@link } with parameter <pre><code>premultiplyAlpha=true</code></pre>,
                 {@link } or {@link } will cache textures for later re-use,
                	which might steadily increase the texture memory footprint when used excessively.
                	You can clear this Texture cache by calling {@link }.
                 You may also want to call <pre><code>Resources.UnloadUnusedAssets()</code></pre> after that. Be aware that while this cleanup
                 frees up memory, it is also a costly operation and will likely cause a spike in the framerate.
                 Thus it is recommended to perform costly repacking and cleanup operations after e.g. a character customization
                 screen has been exited, and if required additionally after a certain number of <pre><code>GetRemappedClone()</code></pre> calls.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @return  {void}
                 */
                ClearCache: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ClearCache", this ); }

                    var $t;
                    $t = Bridge.getEnumerator(Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            UnityEngine.Object.Destroy(t);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.clear();
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.clear();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ClearCache:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static start.*/
                /**
                 * Creates a new Texture2D object based on an AtlasRegion.
                 If applyImmediately is true, Texture2D.Apply is called immediately after the Texture2D is filled with data.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}            ar                   
                 * @param   {UnityEngine.TextureFormat}    textureFormat        
                 * @param   {boolean}                      mipmaps              
                 * @param   {number}                       texturePropertyId    
                 * @param   {boolean}                      linear               
                 * @param   {boolean}                      applyPMA
                 * @return  {UnityEngine.Texture2D}
                 */
                ToTexture: function (ar, textureFormat, mipmaps, texturePropertyId, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture", this ); }

                    var $t;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (texturePropertyId === void 0) { texturePropertyId = 0; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var output = { };

                    var cacheKey = new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey.$ctor1(texturePropertyId, ar);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.tryGetValue(cacheKey.$clone(), output);
                    if (output.v == null) {
                        var sourceTexture = texturePropertyId === 0 ? Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture(ar) : Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture(ar, texturePropertyId);
                        var r = Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect(ar);
                        var width = Bridge.Int.clip32(r.width);
                        var height = Bridge.Int.clip32(r.height);
                        output.v = ($t = new UnityEngine.Texture2D.$ctor12(width, height, textureFormat, mipmaps, linear), $t.name = ar.name, $t);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(output.v, sourceTexture);
                        if (applyPMA) {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(sourceTexture, r, output.v);
                        } else {
                            Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(sourceTexture, r, output.v);
                        }
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTextures.add(cacheKey.$clone(), output.v);
                        Spine.Unity.AttachmentTools.AtlasUtilities.CachedRegionTexturesList.add(output.v);
                    }

                    return output.v;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static start.*/
                ToTexture$1: function (s, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#ToTexture$1", this ); }

                    var $t, $t1, $t2, $t3, $t4, $t5, $t6, $t7;
                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var spriteTexture = s.texture;
                    var r = new UnityEngine.Rect();
                    if (!s.packed || s.packingMode === UnityEngine.SpritePackingMode.Rectangle) {
                        r = s.textureRect.$clone();
                    } else {
                        r = new UnityEngine.Rect.ctor();
                        r.xMin = Math.min(($t = s.uv)[0].x, ($t1 = s.uv)[1].x) * spriteTexture.width;
                        r.xMax = Math.max(($t2 = s.uv)[0].x, ($t3 = s.uv)[1].x) * spriteTexture.width;
                        r.yMin = Math.min(($t4 = s.uv)[0].y, ($t5 = s.uv)[2].y) * spriteTexture.height;
                        r.yMax = Math.max(($t6 = s.uv)[0].y, ($t7 = s.uv)[2].y) * spriteTexture.height;
                    }
                    var newTexture = new UnityEngine.Texture2D.$ctor12(Bridge.Int.clip32(r.width), Bridge.Int.clip32(r.height), textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, spriteTexture);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(spriteTexture, r, newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(spriteTexture, r, newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.ToTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static start.*/
                GetClone: function (t, textureFormat, mipmaps, linear, applyPMA) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (linear === void 0) { linear = false; }
                    if (applyPMA === void 0) { applyPMA = false; }

                    var newTexture = new UnityEngine.Texture2D.$ctor12(t.width, t.height, textureFormat, mipmaps, linear);
                    Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom(newTexture, t);
                    if (applyPMA) {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    } else {
                        Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture(t, new UnityEngine.Rect.$ctor1(0, 0, t.width, t.height), newTexture);
                    }
                    return newTexture;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetClone:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static start.*/
                CopyTexture: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTexture", this ); }

                    if (UnityEngine.SystemInfo.copyTextureSupport === UnityEngine.Rendering.CopyTextureSupport.None) {
                        // GetPixels fallback for old devices.
                        var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                        destination.SetPixels$1(pixelBuffer);
                        destination.Apply();
                    } else {
                        UnityEngine.Graphics.CopyTexture(source, 0, 0, Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height), destination, 0, 0, 0, 0);
                    }
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static start.*/
                CopyTextureApplyPMA: function (source, sourceRect, destination) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureApplyPMA", this ); }

                    var pixelBuffer = source.GetPixels$2(Bridge.Int.clip32(sourceRect.x), Bridge.Int.clip32(sourceRect.y), Bridge.Int.clip32(sourceRect.width), Bridge.Int.clip32(sourceRect.height));
                    for (var i = 0, n = pixelBuffer.length; i < n; i = (i + 1) | 0) {
                        var p = pixelBuffer[i].$clone();
                        var a = p.a;
                        p.r = p.r * a;
                        p.g = p.g * a;
                        p.b = p.b * a;
                        pixelBuffer[i] = p.$clone();
                    }
                    destination.SetPixels$1(pixelBuffer);
                    destination.Apply();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureApplyPMA:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static start.*/
                IsRenderable: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#IsRenderable", this ); }

                    return Bridge.is(a, Spine.IHasTextureRegion);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.IsRenderable:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static start.*/
                /**
                 * Get a rect with flipped Y so that a Spine atlas rect gets converted to a Unity Sprite rect and vice versa.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    rect             
                 * @param   {number}              textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                SpineUnityFlipRect: function (rect, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#SpineUnityFlipRect", this ); }

                    rect.y = textureHeight - rect.y - rect.height;
                    return rect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 This overload relies on region.page.height being correctly set.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), region.page.height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static start.*/
                /**
                 * Gets the Rect of an AtlasRegion according to Unity texture coordinates (x-right, y-up).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {number}               textureHeight
                 * @return  {UnityEngine.Rect}
                 */
                GetUnityRect$1: function (region, textureHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetUnityRect$1", this ); }

                    return Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect(region), textureHeight);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetUnityRect$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static start.*/
                /**
                 * Returns a Rect of the AtlasRegion according to Spine texture coordinates. (x-right, y-down)
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}    region           
                 * @param   {boolean}              includeRotate
                 * @return  {UnityEngine.Rect}
                 */
                GetSpineAtlasRect: function (region, includeRotate) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetSpineAtlasRect", this ); }

                    if (includeRotate === void 0) { includeRotate = true; }
                    var width = region.width;
                    var height = region.height;
                    if (includeRotate && region.degrees === 270) {
                        width = region.height;
                        height = region.width;
                    }
                    return new UnityEngine.Rect.$ctor1(region.x, region.y, width, height);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetSpineAtlasRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static start.*/
                /**
                 * Denormalize a uvRect into a texture-space Rect.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    uvRect       
                 * @param   {number}              texWidth     
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                UVRectToTextureRect: function (uvRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToTextureRect", this ); }

                    uvRect.x *= texWidth;
                    uvRect.width *= texWidth;
                    uvRect.y *= texHeight;
                    uvRect.height *= texHeight;
                    return uvRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static start.*/
                /**
                 * Normalize a texture Rect into UV coordinates.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}    textureRect    
                 * @param   {number}              texWidth       
                 * @param   {number}              texHeight
                 * @return  {UnityEngine.Rect}
                 */
                TextureRectToUVRect: function (textureRect, texWidth, texHeight) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#TextureRectToUVRect", this ); }

                    textureRect.x = pc.math.inverseLerp(0, texWidth, textureRect.x);
                    textureRect.y = pc.math.inverseLerp(0, texHeight, textureRect.y);
                    textureRect.width = pc.math.inverseLerp(0, texWidth, textureRect.width);
                    textureRect.height = pc.math.inverseLerp(0, texHeight, textureRect.height);
                    return textureRect.$clone();
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.TextureRectToUVRect:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static start.*/
                /**
                 * Creates a new Spine AtlasRegion according to a Unity UV Rect (x-right, y-up, uv-normalized).
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {UnityEngine.Rect}     uvRect             
                 * @param   {Spine.AtlasRegion}    referenceRegion    
                 * @param   {Spine.AtlasPage}      page
                 * @return  {Spine.AtlasRegion}
                 */
                UVRectToAtlasRegion: function (uvRect, referenceRegion, page) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#UVRectToAtlasRegion", this ); }

                    var $t;
                    var tr = Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToTextureRect(uvRect.$clone(), page.width, page.height);
                    var rr = Spine.Unity.AttachmentTools.AtlasUtilities.SpineUnityFlipRect(tr, page.height);

                    var x = Bridge.Int.clip32(rr.x);
                    var y = Bridge.Int.clip32(rr.y);
                    var w = Bridge.Int.clip32(rr.width);
                    var h = Bridge.Int.clip32(rr.height);

                    if (referenceRegion.degrees === 270) {
                        var tempW = w;
                        w = h;
                        h = tempW;
                    }

                    // Note: originalW and originalH need to be scaled according to the
                    // repacked width and height, repacking can mess with aspect ratio, etc.
                    var originalW = Math.round(w * (referenceRegion.originalWidth / referenceRegion.width));
                    var originalH = Math.round(h * (referenceRegion.originalHeight / referenceRegion.height));

                    var offsetX = Math.round(referenceRegion.offsetX * (w / referenceRegion.width));
                    var offsetY = Math.round(referenceRegion.offsetY * (h / referenceRegion.height));

                    var u = uvRect.xMin;
                    var u2 = uvRect.xMax;
                    var v = uvRect.yMax;
                    var v2 = uvRect.yMin;

                    if (referenceRegion.degrees === 270) {
                        // at a 270 degree region, u2/v2 deltas and atlas width/height are swapped, and delta-v is negative.
                        var du = uvRect.width; // u2 - u;
                        var dv = uvRect.height; // v - v2;
                        var atlasAspectRatio = page.width / page.height;
                        u2 = u + (dv / atlasAspectRatio);
                        v2 = v - (du * atlasAspectRatio);
                    }

                    return ($t = new Spine.AtlasRegion(), $t.page = page, $t.name = referenceRegion.name, $t.u = u, $t.u2 = u2, $t.v = v, $t.v2 = v2, $t.index = -1, $t.width = w, $t.originalWidth = originalW, $t.height = h, $t.originalHeight = originalH, $t.offsetX = offsetX, $t.offsetY = offsetY, $t.x = x, $t.y = y, $t.rotate = referenceRegion.rotate, $t.degrees = referenceRegion.degrees, $t);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.UVRectToAtlasRegion:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static start.*/
                /**
                 * Convenience method for getting the main texture of the material of the page of the region.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region
                 * @return  {UnityEngine.Texture2D}
                 */
                GetMainTexture: function (region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetMainTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.mainTexture, UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetMainTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property name.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region                 
                 * @param   {string}                   texturePropertyName
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture$1: function (region, texturePropertyName) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture$1", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture$1(texturePropertyName), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture$1:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static start.*/
                /**
                 * Convenience method for getting any texture of the material of the page of the region by texture property id.
                 *
                 * @static
                 * @private
                 * @this Spine.Unity.AttachmentTools.AtlasUtilities
                 * @memberof Spine.Unity.AttachmentTools.AtlasUtilities
                 * @param   {Spine.AtlasRegion}        region               
                 * @param   {number}                   texturePropertyId
                 * @return  {UnityEngine.Texture2D}
                 */
                GetTexture: function (region, texturePropertyId) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#GetTexture", this ); }

                    var material = (Bridge.as(region.page.rendererObject, UnityEngine.Material));
                    return Bridge.as(material.GetTexture(texturePropertyId), UnityEngine.Texture2D);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.GetTexture:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static start.*/
                CopyTextureAttributesFrom: function (destination, source) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#CopyTextureAttributesFrom", this ); }

                    destination.filterMode = source.filterMode;
                    destination.anisoLevel = source.anisoLevel;
                    destination.wrapModeU = source.wrapModeU;
                    destination.wrapModeV = source.wrapModeV;
                    destination.wrapModeW = source.wrapModeW;
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.CopyTextureAttributesFrom:static end.*/

                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static start.*/
                InverseLerp: function (a, b, value) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities#InverseLerp", this ); }

                    return (value - a) / (b - a);
                },
                /*Spine.Unity.AttachmentTools.AtlasUtilities.InverseLerp:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getDefaultValue", this ); }
 return new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey(); }
            }
        },
        fields: {
            i: 0,
            region: null
        },
        ctors: {
            $ctor1: function (i, region) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$ctor1", this ); }

                this.$initialize();
                this.i = i;
                this.region = region;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#getHashCode", this ); }

                return Bridge.Int.mul(Bridge.getHashCode(this.i), 23) ^ Bridge.getHashCode(this.region);
            },
            /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey.getHashCode end.*/

            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey)) {
                    return false;
                }
                return Bridge.equals(this.i, o.i) && Bridge.equals(this.region, o.region);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey#$clone", this ); }

                var s = to || new Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey();
                s.i = this.i;
                s.region = this.region;
                return s;
            }
        },
        overloads: {
            "GetHashCode()": "getHashCode"
        }
    });
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static start.*/
                
                GetRemappedClone$1: function (o, sprite, sourceMaterial, premultiplyAlpha, cloneMeshAsLinked, useOriginalRegionSize, pivotShiftsMeshUVCoords, useOriginalRegionScale, pmaCloneTextureFormat, pmaCloneMipmaps) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone$1", this ); }

                    var $t;
                    if (premultiplyAlpha === void 0) { premultiplyAlpha = true; }
                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (pivotShiftsMeshUVCoords === void 0) { pivotShiftsMeshUVCoords = true; }
                    if (useOriginalRegionScale === void 0) { useOriginalRegionScale = false; }
                    if (pmaCloneTextureFormat === void 0) { pmaCloneTextureFormat = 4; }
                    if (pmaCloneMipmaps === void 0) { pmaCloneMipmaps = false; }

                    var atlasRegion = premultiplyAlpha ? Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone(sprite, sourceMaterial, pmaCloneTextureFormat, pmaCloneMipmaps) : Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion$1(sprite, ($t = new UnityEngine.Material.$ctor1(sourceMaterial), $t.mainTexture = sprite.texture, $t));
                    if (!pivotShiftsMeshUVCoords && Bridge.is(o, Spine.MeshAttachment)) {
                        // prevent non-central sprite pivot setting offsetX/Y and shifting uv coords out of mesh bounds
                        atlasRegion.offsetX = 0;
                        atlasRegion.offsetY = 0;
                    }
                    var scale = 1.0 / sprite.pixelsPerUnit;
                    if (useOriginalRegionScale) {
                        var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            scale = regionAttachment.width / regionAttachment.region.originalWidth;
                        }
                    }
                    return Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone(o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale);
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static start.*/
                /**
                 * Gets a clone of the attachment remapped with an atlasRegion image.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentCloneExtensions
                 * @param   {spine.Attachment}     o                        The original attachment.
                 * @param   {Spine.AtlasRegion}    atlasRegion              Atlas region.
                 * @param   {boolean}              cloneMeshAsLinked        If <pre><code>true</code></pre> MeshAttachments will be cloned as linked meshes and will inherit animation from the original attachment.
                 * @param   {boolean}              useOriginalRegionSize    If <pre><code>true</code></pre> the size of the original attachment will be followed, instead of using the Sprite size.
                 * @param   {number}               scale                    Unity units per pixel scale used to scale the atlas region size when not using the original region size.
                 * @return  {spine.Attachment}                              The remapped clone.
                 */
                GetRemappedClone: function (o, atlasRegion, cloneMeshAsLinked, useOriginalRegionSize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentCloneExtensions#GetRemappedClone", this ); }

                    if (cloneMeshAsLinked === void 0) { cloneMeshAsLinked = true; }
                    if (useOriginalRegionSize === void 0) { useOriginalRegionSize = false; }
                    if (scale === void 0) { scale = 0.01; }
                    var regionAttachment = Bridge.as(o, Spine.RegionAttachment);
                    if (regionAttachment != null) {
                        var newAttachment = Bridge.cast(regionAttachment.copy(), Spine.RegionAttachment);
                        newAttachment.region = atlasRegion;
                        if (!useOriginalRegionSize) {
                            newAttachment.width = atlasRegion.width * scale;
                            newAttachment.height = atlasRegion.height * scale;
                        }
                        newAttachment.updateRegion();
                        return newAttachment;
                    } else {
                        var meshAttachment = Bridge.as(o, Spine.MeshAttachment);
                        if (meshAttachment != null) {
                            var newAttachment1 = cloneMeshAsLinked ? meshAttachment.newLinkedMesh() : Bridge.cast(meshAttachment.copy(), Spine.MeshAttachment);
                            newAttachment1.region = atlasRegion;
                            newAttachment1.updateRegion();
                            return newAttachment1;
                        }
                    }
                    return o.copy();
                },
                /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions.GetRemappedClone:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    Bridge.define("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses a new AtlasPage with the Material provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {UnityEngine.Material}      material    
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$2: function (sprite, material, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$2", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1(sprite, Spine.Unity.AttachmentTools.AtlasUtilities.ToSpineAtlasPage(material), rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$2:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static start.*/
                /**
                 * Creates a RegionAttachment based on a sprite. This method creates a real, usable AtlasRegion. That AtlasRegion uses the AtlasPage provided.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}        sprite      
                 * @param   {Spine.AtlasPage}           page        
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment$1: function (sprite, page, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment$1", this ); }

                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (page == null) {
                        throw new System.ArgumentNullException.$ctor1("page");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegion(sprite, page);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static start.*/
                /**
                 * Creates a new RegionAttachment from a given AtlasRegion.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.AtlasRegion}         region            
                 * @param   {string}                    attachmentName    
                 * @param   {number}                    scale             
                 * @param   {number}                    rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachment: function (region, attachmentName, scale, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachment", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (System.String.isNullOrEmpty(attachmentName)) {
                        throw new System.ArgumentException.$ctor3("attachmentName can't be null or empty.", "attachmentName");
                    }
                    if (region == null) {
                        throw new System.ArgumentNullException.$ctor1("region");
                    }

                    // (AtlasAttachmentLoader.cs)
                    var attachment = new Spine.RegionAttachment(attachmentName);

                    attachment.region = region;
                    attachment.path = region.name;
                    attachment.scaleX = 1;
                    attachment.scaleY = 1;
                    attachment.rotation = rotation;

                    attachment.color.r = 1;
                    attachment.color.g = 1;
                    attachment.color.b = 1;
                    attachment.color.a = 1;

                    // pass OriginalWidth and OriginalHeight because UpdateOffset uses it in its calculation.
                    var textreRegion = attachment.region;
                    var atlasRegion = Bridge.as(textreRegion, Spine.AtlasRegion);
                    var originalWidth = atlasRegion != null ? atlasRegion.originalWidth : textreRegion.width;
                    var originalHeight = atlasRegion != null ? atlasRegion.originalHeight : textreRegion.height;
                    attachment.width = originalWidth * scale;
                    attachment.height = originalHeight * scale;

                    Spine.Unity.SkeletonExtensions.SetColor$2(attachment, new pc.Color( 1, 1, 1, 1 ));
                    attachment.updateRegion();
                    return attachment;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static start.*/
                /**
                 * Creates a Spine.AtlasRegion that uses a premultiplied alpha duplicate texture of the Sprite's texture data.
                 Returns a RegionAttachment that uses it. Use this if you plan to use a premultiply alpha shader such as "Spine/Skeleton".
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {UnityEngine.Sprite}           sprite                    
                 * @param   {UnityEngine.Shader}           shader                    
                 * @param   {UnityEngine.TextureFormat}    textureFormat             
                 * @param   {boolean}                      mipmaps                   
                 * @param   {UnityEngine.Material}         materialPropertySource    
                 * @param   {number}                       rotation
                 * @return  {Spine.RegionAttachment}
                 */
                ToRegionAttachmentPMAClone$1: function (sprite, shader, textureFormat, mipmaps, materialPropertySource, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone$1", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (materialPropertySource === void 0) { materialPropertySource = null; }
                    if (rotation === void 0) { rotation = 0.0; }
                    if (sprite == null) {
                        throw new System.ArgumentNullException.$ctor1("sprite");
                    }
                    if (shader == null) {
                        throw new System.ArgumentNullException.$ctor1("shader");
                    }
                    var region = Spine.Unity.AttachmentTools.AtlasUtilities.ToAtlasRegionPMAClone$1(sprite, shader, textureFormat, mipmaps, materialPropertySource);
                    var unitsPerPixel = 1.0 / sprite.pixelsPerUnit;
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachment(region, sprite.name, unitsPerPixel, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static start.*/
                ToRegionAttachmentPMAClone: function (sprite, materialPropertySource, textureFormat, mipmaps, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#ToRegionAttachmentPMAClone", this ); }

                    if (textureFormat === void 0) { textureFormat = 4; }
                    if (mipmaps === void 0) { mipmaps = false; }
                    if (rotation === void 0) { rotation = 0.0; }
                    return Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone$1(sprite, materialPropertySource.shader, textureFormat, mipmaps, materialPropertySource, rotation);
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.ToRegionAttachmentPMAClone:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       scale
                 * @return  {void}
                 */
                SetScale$1: function (regionAttachment, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale$1", this ); }

                    regionAttachment.scaleX = scale.x;
                    regionAttachment.scaleY = scale.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static start.*/
                /**
                 * Sets the scale. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetScale: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetScale", this ); }

                    regionAttachment.scaleX = x;
                    regionAttachment.scaleY = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetScale:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {UnityEngine.Vector2}       offset
                 * @return  {void}
                 */
                SetPositionOffset$1: function (regionAttachment, offset) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset$1", this ); }

                    regionAttachment.x = offset.x;
                    regionAttachment.y = offset.y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset$1:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static start.*/
                /**
                 * Sets the position offset. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    x                   
                 * @param   {number}                    y
                 * @return  {void}
                 */
                SetPositionOffset: function (regionAttachment, x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetPositionOffset", this ); }

                    regionAttachment.x = x;
                    regionAttachment.y = y;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetPositionOffset:static end.*/

                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static start.*/
                /**
                 * Sets the rotation. Call regionAttachment.UpdateOffset to apply the change.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @memberof Spine.Unity.AttachmentTools.AttachmentRegionExtensions
                 * @param   {Spine.RegionAttachment}    regionAttachment    
                 * @param   {number}                    rotation
                 * @return  {void}
                 */
                SetRotation: function (regionAttachment, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.AttachmentTools.AttachmentRegionExtensions#SetRotation", this ); }

                    regionAttachment.rotation = rotation;
                },
                /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions.SetRotation:static end.*/


            }
        }
    });
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials", {
        fields: {
            requiresBlendModeMaterials: false,
            applyAdditiveMaterial: false,
            additiveMaterials: null,
            multiplyMaterials: null,
            screenMaterials: null
        },
        props: {
            RequiresBlendModeMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#get", this ); }

                    return this.requiresBlendModeMaterials;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#RequiresBlendModeMaterials#set", this ); }

                    this.requiresBlendModeMaterials = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#init", this ); }

                this.requiresBlendModeMaterials = false;
                this.applyAdditiveMaterial = false;
                this.additiveMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.multiplyMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
                this.screenMaterials = new (System.Collections.Generic.List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial start.*/
            BlendModeForMaterial: function (material) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#BlendModeForMaterial", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.multiplyMaterials);
                try {
                    while ($t.moveNext()) {
                        var pair = $t.Current;
                        if (Bridge.referenceEquals(pair.material, material)) {
                            return spine.BlendMode.Multiply;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.additiveMaterials);
                try {
                    while ($t1.moveNext()) {
                        var pair1 = $t1.Current;
                        if (Bridge.referenceEquals(pair1.material, material)) {
                            return spine.BlendMode.Additive;
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
                $t2 = Bridge.getEnumerator(this.screenMaterials);
                try {
                    while ($t2.moveNext()) {
                        var pair2 = $t2.Current;
                        if (Bridge.referenceEquals(pair2.material, material)) {
                            return spine.BlendMode.Screen;
                        }
                    }
                } finally {
                    if (Bridge.is($t2, System.IDisposable)) {
                        $t2.System$IDisposable$Dispose();
                    }
                }
                return spine.BlendMode.Normal;
            },
            /*Spine.Unity.BlendModeMaterials.BlendModeForMaterial end.*/

            /*Spine.Unity.BlendModeMaterials.ApplyMaterials start.*/
            ApplyMaterials: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#ApplyMaterials", this ); }

                var $t, $t1;
                if (skeletonData == null) {
                    throw new System.ArgumentNullException.$ctor1("skeletonData");
                }
                if (!this.requiresBlendModeMaterials) {
                    return;
                }

                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                var slotsItems = skeletonData.Slots.Items;
                for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                    var slot = slotsItems[slotIndex];
                    if (slot.blendMode === spine.BlendMode.Normal) {
                        continue;
                    }
                    if (!this.applyAdditiveMaterial && slot.blendMode === spine.BlendMode.Additive) {
                        continue;
                    }

                    var replacementMaterials = null;
                    switch (slot.blendMode) {
                        case spine.BlendMode.Multiply: 
                            replacementMaterials = this.multiplyMaterials;
                            break;
                        case spine.BlendMode.Screen: 
                            replacementMaterials = this.screenMaterials;
                            break;
                        case spine.BlendMode.Additive: 
                            replacementMaterials = this.additiveMaterials;
                            break;
                    }
                    if (replacementMaterials == null) {
                        continue;
                    }

                    skinEntries.clear();
                    $t = Bridge.getEnumerator(skeletonData.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    $t1 = Bridge.getEnumerator(skinEntries);
                    try {
                        while ($t1.moveNext()) {
                            var entry = $t1.Current;
                            var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                            if (renderableAttachment != null) {
                                if (renderableAttachment.Spine$IHasTextureRegion$Region != null) {
                                    renderableAttachment.Spine$IHasTextureRegion$Region = this.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), replacementMaterials);
                                } else {
                                    if (renderableAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                        var regions = renderableAttachment.Spine$IHasTextureRegion$Sequence.regions;
                                        for (var i = 0; i < regions.length; i = (i + 1) | 0) {
                                            regions[i] = this.CloneAtlasRegionWithMaterial(Bridge.cast(regions[i], Spine.AtlasRegion), replacementMaterials);
                                        }
                                    }
                                }
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*Spine.Unity.BlendModeMaterials.ApplyMaterials end.*/

            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial start.*/
            CloneAtlasRegionWithMaterial: function (originalRegion, replacementMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterials#CloneAtlasRegionWithMaterial", this ); }

                var $t;
                var newRegion = originalRegion.Clone();
                var material = null;
                $t = Bridge.getEnumerator(replacementMaterials);
                try {
                    while ($t.moveNext()) {
                        var replacement = $t.Current;
                        if (Bridge.referenceEquals(replacement.pageName, originalRegion.page.name)) {
                            material = replacement.material;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var originalPage = originalRegion.page;
                var newPage = originalPage.Clone();
                newPage.rendererObject = material;
                newRegion.page = newPage;
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterials.CloneAtlasRegionWithMaterial end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    Bridge.define("Spine.Unity.BlendModeMaterials.ReplacementMaterial", {
        $kind: 1002,
        fields: {
            pageName: null,
            material: null
        }
    });
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    /**
     * Can be stored by SkeletonDataAsset to automatically apply modifications to loaded SkeletonData.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonDataModifierAsset
     * @augments UnityEngine.ScriptableObject
     */
    Bridge.define("Spine.Unity.SkeletonDataModifierAsset", {
        inherits: [UnityEngine.ScriptableObject]
    });
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            cache: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#init", this ); }

                this.cache = new (System.Collections.Generic.Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial start.*/
            /**
             * Creates a clone of an AtlasRegion that uses different Material settings, while retaining the original texture.
             *
             * @instance
             * @public
             * @this Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @memberof Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache
             * @param   {Spine.AtlasRegion}       originalRegion      
             * @param   {UnityEngine.Material}    materialTemplate
             * @return  {Spine.AtlasRegion}
             */
            CloneAtlasRegionWithMaterial: function (originalRegion, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#CloneAtlasRegionWithMaterial", this ); }

                var newRegion = originalRegion.Clone();
                newRegion.page = this.GetAtlasPageWithMaterial(originalRegion.page, materialTemplate);
                return newRegion;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.CloneAtlasRegionWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial start.*/
            GetAtlasPageWithMaterial: function (originalPage, materialTemplate) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#GetAtlasPageWithMaterial", this ); }

                var $t;
                if (originalPage == null) {
                    throw new System.ArgumentNullException.$ctor1("originalPage");
                }

                var newPage = { v : null };
                var key = new (System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material)).$ctor1(originalPage, materialTemplate);
                this.cache.tryGetValue(key, newPage);

                if (newPage.v == null) {
                    newPage.v = originalPage.Clone();
                    var originalMaterial = Bridge.as(originalPage.rendererObject, UnityEngine.Material);
                    newPage.v.rendererObject = ($t = new UnityEngine.Material.$ctor1(materialTemplate), $t.name = (originalMaterial.name || "") + " " + (materialTemplate.name || ""), $t.mainTexture = originalMaterial.mainTexture, $t);
                    this.cache.add(key, newPage.v);
                }

                return newPage.v;
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.GetAtlasPageWithMaterial end.*/

            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache#Dispose", this ); }

                this.cache.clear();
            },
            /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache.Dispose end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.BoneFollower start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.BoneFollower
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.BoneFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollower
             * @type string
             */
            boneName: null,
            followXYPosition: false,
            followZPosition: false,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            maintainedAxisOrientation: 0,
            initializeOnAwake: false,
            valid: false,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SkeletonRenderer#set", this ); }

                    this.skeletonRenderer = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#init", this ); }

                this.followXYPosition = true;
                this.followZPosition = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
                this.initializeOnAwake = true;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollower.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found. To set the bone by reference, use BoneFollower.bone directly.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollower
             * @memberof Spine.Unity.BoneFollower
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#SetBone", this ); }

                this.bone = this.skeletonRenderer.skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollower.SetBone end.*/

            /*Spine.Unity.BoneFollower.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollower.Awake end.*/

            /*Spine.Unity.BoneFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoneFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.BoneFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollower.Initialize end.*/

            /*Spine.Unity.BoneFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.BoneFollower.OnDestroy end.*/

            /*Spine.Unity.BoneFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollower#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonRenderer.skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = this.transform;
                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        var halfRotation = Math.atan2(this.bone.c, this.bone.a) * 0.5;
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            halfRotation += 1.57079637;
                        }

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX, this.bone.worldY, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    Bridge.define("Spine.Unity.BoneFollower.AxisOrientation", {
        $kind: 1006,
        statics: {
            fields: {
                XAxis: 1,
                YAxis: 2
            }
        }
    });
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoneFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            initializeOnAwake: false,
            /**
             * If a bone isn't set in code, boneName is used to find the bone at the beginning. For runtime switching by name, use SetBoneByName. You can also set the BoneFollower.bone field directly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @type string
             */
            boneName: null,
            followBoneRotation: false,
            followSkeletonFlip: false,
            followLocalScale: false,
            followParentWorldScale: false,
            followXYPosition: false,
            followZPosition: false,
            maintainedAxisOrientation: 0,
            bone: null,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            valid: false
        },
        props: {
            SkeletonGraphic: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#get", this ); }

                    return this.skeletonGraphic;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SkeletonGraphic#set", this ); }

                    this.skeletonGraphic = value;
                    this.Initialize();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#init", this ); }

                this.initializeOnAwake = true;
                this.followBoneRotation = true;
                this.followSkeletonFlip = true;
                this.followLocalScale = false;
                this.followParentWorldScale = false;
                this.followXYPosition = true;
                this.followZPosition = true;
                this.maintainedAxisOrientation = Spine.Unity.BoneFollower.AxisOrientation.XAxis;
            }
        },
        methods: {
            /*Spine.Unity.BoneFollowerGraphic.SetBone start.*/
            /**
             * Sets the target bone by its bone name. Returns false if no bone was found.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoneFollowerGraphic
             * @memberof Spine.Unity.BoneFollowerGraphic
             * @param   {string}     name
             * @return  {boolean}
             */
            SetBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#SetBone", this ); }

                this.bone = this.skeletonGraphic.Skeleton.findBone(name);
                if (this.bone == null) {
                    UnityEngine.Debug.LogError$2("Bone not found: " + (name || ""), this);
                    return false;
                }
                this.boneName = name;
                return true;
            },
            /*Spine.Unity.BoneFollowerGraphic.SetBone end.*/

            /*Spine.Unity.BoneFollowerGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Awake", this ); }

                if (this.initializeOnAwake) {
                    this.Initialize();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.Awake end.*/

            /*Spine.Unity.BoneFollowerGraphic.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#Initialize", this ); }

                this.bone = null;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid;
                if (!this.valid) {
                    return;
                }

                this.skeletonTransform = this.skeletonGraphic.transform;
                //			skeletonGraphic.OnRebuild -= HandleRebuildRenderer;
                //			skeletonGraphic.OnRebuild += HandleRebuildRenderer;
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                if (!System.String.isNullOrEmpty(this.boneName)) {
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                }

            },
            /*Spine.Unity.BoneFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoneFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoneFollowerGraphic#LateUpdate", this ); }

                var $t, $t1;
                if (!this.valid) {
                    this.Initialize();
                    return;
                }


                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = this.skeletonGraphic.Skeleton.findBone(this.boneName);
                    if (!this.SetBone(this.boneName)) {
                        return;
                    }
                }

                var thisTransform = Bridge.as(this.transform, UnityEngine.RectTransform);
                if (UnityEngine.Component.op_Equality(thisTransform, null)) {
                    return;
                }

                var scale = this.skeletonGraphic.MeshScale;

                var additionalFlipScale = 1;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( this.followXYPosition ? this.bone.worldX * scale : thisTransform.localPosition.x, this.followXYPosition ? this.bone.worldY * scale : thisTransform.localPosition.y, this.followZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followBoneRotation) {
                        thisTransform.localRotation = Spine.Unity.SkeletonExtensions.GetQuaternion(this.bone);
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( this.bone.worldX * scale, this.bone.worldY * scale, 0.0 ));
                    if (!this.followZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }
                    if (!this.followXYPosition) {
                        targetWorldPosition.x = thisTransform.position.x;
                        targetWorldPosition.y = thisTransform.position.y;
                    }

                    var skeletonLossyScale = this.skeletonTransform.lossyScale.$clone();
                    var transformParent = thisTransform.parent;
                    var parentLossyScale = UnityEngine.Component.op_Inequality(transformParent, null) ? transformParent.lossyScale.$clone() : new pc.Vec3( 1, 1, 1 );
                    if (this.followBoneRotation) {
                        var boneWorldRotation = this.bone.getWorldRotationX();

                        if ((skeletonLossyScale.x * skeletonLossyScale.y) < 0) {
                            boneWorldRotation = -boneWorldRotation;
                        }

                        if (this.followSkeletonFlip || this.maintainedAxisOrientation === Spine.Unity.BoneFollower.AxisOrientation.XAxis) {
                            if ((skeletonLossyScale.x * parentLossyScale.x < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        } else {
                            if ((skeletonLossyScale.y * parentLossyScale.y < 0)) {
                                boneWorldRotation += 180.0;
                            }
                        }

                        var worldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        if (this.followLocalScale && this.bone.scaleX < 0) {
                            boneWorldRotation += 180.0;
                        }
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( worldRotation.x, worldRotation.y, worldRotation.z + boneWorldRotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }

                    additionalFlipScale = ($t = skeletonLossyScale.x * parentLossyScale.x * skeletonLossyScale.y * parentLossyScale.y, ($t === 0 ? 1 : Math.sign($t)));
                }

                var parentBone = this.bone.parent;
                if (this.followParentWorldScale || this.followLocalScale || this.followSkeletonFlip) {
                    var localScale = new pc.Vec3( 1.0, 1.0, 1.0 );
                    if (this.followParentWorldScale && parentBone != null) {
                        localScale = new pc.Vec3( parentBone.getWorldScaleX(), parentBone.getWorldScaleY(), 1.0 );
                    }
                    if (this.followLocalScale) {
                        localScale.mul( new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 ) );
                    }
                    if (this.followSkeletonFlip) {
                        localScale.y *= ($t1 = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t1 === 0 ? 1 : Math.sign($t1))) * additionalFlipScale;
                    }
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.BoneFollowerGraphic.LateUpdate end.*/


        }
    });
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollower", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonRenderer: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollower.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.Start end.*/

            /*Spine.Unity.BoundingBoxFollower.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollower.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#HandleRebuild", this ); }

                //if (BoundingBoxFollower.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollower.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollower.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollower.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollower colliders. This is method checks if the BoundingBoxFollower has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }

                this.skeletonRenderer.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonRenderer.skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonRenderer.skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollower on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollower tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollower.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollower.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollower.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollower.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollower.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollower.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollower
             * @memberof Spine.Unity.BoundingBoxFollower
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollower#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollower.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollower tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollower.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollower.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollower.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    Bridge.define("Spine.Unity.BoundingBoxFollowerGraphic", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DebugMessages: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                    this.DebugMessages = true;
                }
            }
        },
        fields: {
            skeletonGraphic: null,
            slotName: null,
            isTrigger: false,
            usedByEffector: false,
            usedByComposite: false,
            clearStateOnDisable: false,
            slot: null,
            currentAttachment: null,
            currentAttachmentName: null,
            currentCollider: null,
            colliderTable: null,
            nameTable: null
        },
        props: {
            Slot: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Slot#get", this ); }

                    return this.slot;
                }
            },
            CurrentAttachment: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachment#get", this ); }

                    return this.currentAttachment;
                }
            },
            CurrentAttachmentName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentAttachmentName#get", this ); }

                    return this.currentAttachmentName;
                }
            },
            CurrentCollider: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#CurrentCollider#get", this ); }

                    return this.currentCollider;
                }
            },
            IsTrigger: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#IsTrigger#get", this ); }

                    return this.isTrigger;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#init", this ); }

                this.clearStateOnDisable = true;
                this.colliderTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D)).ctor();
                this.nameTable = new (System.Collections.Generic.Dictionary$2(spine.BoundingBoxAttachment,System.String)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Start", this ); }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Start end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }

                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnEnable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild start.*/
            HandleRebuild: function (sr) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#HandleRebuild", this ); }

                //if (BoundingBoxFollowerGraphic.DebugMessages) Debug.Log("Skeleton was rebuilt. Repopulating BoundingBoxFollowerGraphic.");
                this.Initialize();
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.HandleRebuild end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize start.*/
            /**
             * Initialize and instantiate the BoundingBoxFollowerGraphic colliders. This is method checks if the BoundingBoxFollowerGraphic has already been initialized for the skeleton instance and slotName and prevents overwriting unless it detects a new setup.
             *
             * @instance
             * @public
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {boolean}    overwrite
             * @return  {void}
             */
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#Initialize", this ); }

                var $t;
                if (overwrite === void 0) { overwrite = false; }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    return;
                }

                this.skeletonGraphic.Initialize(false);

                if (System.String.isNullOrEmpty(this.slotName)) {
                    return;
                }

                // Don't reinitialize if the setup did not change.
                if (!overwrite && this.colliderTable.Count > 0 && this.slot != null && Bridge.referenceEquals(this.skeletonGraphic.Skeleton, this.slot.getSkeleton()) && Bridge.referenceEquals(this.slotName, this.slot.data.name)) {
                    return;
                }

                this.slot = null;
                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
                this.colliderTable.clear();
                this.nameTable.clear();

                var skeleton = this.skeletonGraphic.Skeleton;
                if (skeleton == null) {
                    return;
                }
                this.slot = skeleton.findSlot(this.slotName);
                if (this.slot == null) {
                    if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                        UnityEngine.Debug.LogWarning$1(System.String.format("Slot '{0}' not found for BoundingBoxFollowerGraphic on '{1}'. (Previous colliders were disposed.)", this.slotName, this.gameObject.name));
                    }
                    return;
                }
                var slotIndex = this.slot.data.index;

                var requiredCollidersCount = { v : 0 };
                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (this.gameObject.activeInHierarchy) {
                    var scale = this.skeletonGraphic.MeshScale;
                    $t = Bridge.getEnumerator(skeleton.data.Skins);
                    try {
                        while ($t.moveNext()) {
                            var skin = $t.Current;
                            this.AddCollidersForSkin(skin, slotIndex, colliders, scale, requiredCollidersCount);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (skeleton.skin != null) {
                        this.AddCollidersForSkin(skeleton.skin, slotIndex, colliders, scale, requiredCollidersCount);
                    }
                }
                this.DisposeExcessCollidersAfter(requiredCollidersCount.v);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                    var valid = this.colliderTable.Count !== 0;
                    if (!valid) {
                        if (this.gameObject.activeInHierarchy) {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower not valid! Slot [" + (this.slotName || "") + "] does not contain any Bounding Box Attachments!");
                        } else {
                            UnityEngine.Debug.LogWarning$1("Bounding Box Follower tried to rebuild as a prefab.");
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.Initialize end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin start.*/
            AddCollidersForSkin: function (skin, slotIndex, previousColliders, scale, collidersCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#AddCollidersForSkin", this ); }

                var $t;
                if (skin == null) {
                    return;
                }
                var skinEntries = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                ( skinEntries._items.length = 0, skin.getAttachmentsForSlot( slotIndex, skinEntries._items ), skinEntries._size = skinEntries._items.length );

                $t = Bridge.getEnumerator(skinEntries);
                try {
                    while ($t.moveNext()) {
                        var entry = $t.Current;
                        var attachment = skin.getAttachment(slotIndex, entry.name);
                        var boundingBoxAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && boundingBoxAttachment == null) {
                            UnityEngine.Debug.Log$1("BoundingBoxFollowerGraphic tried to follow a slot that contains non-boundingbox attachments: " + (this.slotName || ""));
                        }

                        if (boundingBoxAttachment != null) {
                            if (!this.colliderTable.containsKey(boundingBoxAttachment)) {
                                var bbCollider = collidersCount.v < previousColliders.length ? previousColliders[collidersCount.v] : this.gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                                collidersCount.v = (collidersCount.v + 1) | 0;
                                Spine.Unity.SkeletonUtility.SetColliderPointsLocal(bbCollider, this.slot, boundingBoxAttachment, scale);
                                bbCollider.isTrigger = this.isTrigger;
                                bbCollider.usedByEffector = this.usedByEffector;
                                bbCollider.usedByComposite = this.usedByComposite;
                                bbCollider.enabled = false;
                                bbCollider.hideFlags = UnityEngine.HideFlags.NotEditable;
                                this.colliderTable.add(boundingBoxAttachment, bbCollider);
                                this.nameTable.add(boundingBoxAttachment, entry.name);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.AddCollidersForSkin end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#OnDisable", this ); }

                if (this.clearStateOnDisable) {
                    this.ClearState();
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuild));
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.OnDisable end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState start.*/
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#ClearState", this ); }

                var $t;
                if (this.colliderTable != null) {
                    $t = Bridge.getEnumerator(this.colliderTable.Values);
                    try {
                        while ($t.moveNext()) {
                            var col = $t.Current;
                            col.enabled = false;
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }

                this.currentAttachment = null;
                this.currentAttachmentName = null;
                this.currentCollider = null;
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.ClearState end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter start.*/
            DisposeExcessCollidersAfter: function (requiredCount) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#DisposeExcessCollidersAfter", this ); }

                var colliders = this.GetComponents(UnityEngine.PolygonCollider2D);
                if (colliders.length === 0) {
                    return;
                }

                for (var i = requiredCount; i < colliders.length; i = (i + 1) | 0) {
                    var collider = colliders[i];
                    if (UnityEngine.Component.op_Inequality(collider, null)) {
                        UnityEngine.Object.Destroy(collider);
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.DisposeExcessCollidersAfter end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#LateUpdate", this ); }

                if (this.slot != null && !Bridge.referenceEquals(this.slot.getAttachment(), this.currentAttachment)) {
                    this.MatchAttachment(this.slot.getAttachment());
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.LateUpdate end.*/

            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment start.*/
            /**
             * Sets the current collider to match attachment.
             *
             * @instance
             * @private
             * @this Spine.Unity.BoundingBoxFollowerGraphic
             * @memberof Spine.Unity.BoundingBoxFollowerGraphic
             * @param   {spine.Attachment}    attachment    If the attachment is not a bounding box, it will be treated as null.
             * @return  {void}
             */
            MatchAttachment: function (attachment) {
if ( TRACE ) { TRACE( "Spine.Unity.BoundingBoxFollowerGraphic#MatchAttachment", this ); }

                var bbAttachment = Bridge.as(attachment, spine.BoundingBoxAttachment);

                if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages && attachment != null && bbAttachment == null) {
                    UnityEngine.Debug.LogWarning$1("BoundingBoxFollowerGraphic tried to match a non-boundingbox attachment. It will treat it as null.");
                }

                if (UnityEngine.Component.op_Inequality(this.currentCollider, null)) {
                    this.currentCollider.enabled = false;
                }

                if (bbAttachment == null) {
                    this.currentCollider = null;
                    this.currentAttachment = null;
                    this.currentAttachmentName = null;
                } else {
                    var foundCollider = { };
                    this.colliderTable.tryGetValue(bbAttachment, foundCollider);
                    if (UnityEngine.Component.op_Inequality(foundCollider.v, null)) {
                        this.currentCollider = foundCollider.v;
                        this.currentCollider.enabled = true;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = this.nameTable.getItem(bbAttachment);
                    } else {
                        this.currentCollider = null;
                        this.currentAttachment = bbAttachment;
                        this.currentAttachmentName = null;
                        if (Spine.Unity.BoundingBoxFollowerGraphic.DebugMessages) {
                            UnityEngine.Debug.LogFormat("Collider for BoundingBoxAttachment named '{0}' was not initialized. It is possibly from a new skin. currentAttachmentName will be null. You may need to call BoundingBoxFollowerGraphic.Initialize(overwrite: true);", [bbAttachment.name]);
                        }
                    }
                }
            },
            /*Spine.Unity.BoundingBoxFollowerGraphic.MatchAttachment end.*/


        }
    });
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    Bridge.define("Spine.Unity.DoubleBuffered$1", function (T) { return {
        fields: {
            a: null,
            b: null,
            usingA: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#init", this ); }

                this.a = Bridge.createInstance(T);
                this.b = Bridge.createInstance(T);
            }
        },
        methods: {
            /*Spine.Unity.DoubleBuffered$1.GetCurrent start.*/
            GetCurrent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetCurrent", this ); }

                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetCurrent end.*/

            /*Spine.Unity.DoubleBuffered$1.GetNext start.*/
            GetNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.DoubleBuffered$1#GetNext", this ); }

                this.usingA = !this.usingA;
                return this.usingA ? Bridge.rValue(this.a) : Bridge.rValue(this.b);
            },
            /*Spine.Unity.DoubleBuffered$1.GetNext end.*/


        }
    }; });
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    Bridge.define("Spine.Unity.EventDataReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#op_Implicit", this ); }

                    return asset.EventData;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            eventName: null,
            eventData: null
        },
        props: {
            EventData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#EventData#get", this ); }

                    if (this.eventData == null) {
                        this.Initialize();
                    }
                    return this.eventData;
                }
            }
        },
        methods: {
            /*Spine.Unity.EventDataReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.EventDataReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                this.eventData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.EventDataReferenceAsset.QuietSkeletonData).findEvent(this.eventName);
                if (this.eventData == null) {
                    UnityEngine.Debug.LogWarningFormat("Event Data '{0}' not found in SkeletonData : {1}.", [this.eventName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.EventDataReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    Bridge.define("Spine.Unity.ISpineComponentExtensions", {
        statics: {
            methods: {
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static start.*/
                IsNullOrDestroyed: function (component) {
if ( TRACE ) { TRACE( "Spine.Unity.ISpineComponentExtensions#IsNullOrDestroyed", this ); }

                    if (component == null) {
                        return true;
                    }
                    return Bridge.cast(component, UnityEngine.Object) == null;
                },
                /*Spine.Unity.ISpineComponentExtensions.IsNullOrDestroyed:static end.*/


            }
        }
    });
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    Bridge.define("Spine.Unity.MaterialsTextureLoader", {
        inherits: [Spine.TextureLoader],
        fields: {
            atlasAsset: null
        },
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        ctors: {
            ctor: function (atlasAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#ctor", this ); }

                this.$initialize();
                this.atlasAsset = atlasAsset;
            }
        },
        methods: {
            /*Spine.Unity.MaterialsTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Load", this ); }

                var $t;
                var name = System.IO.Path.GetFileNameWithoutExtension(path);
                var material = null;
                $t = Bridge.getEnumerator(this.atlasAsset.materials);
                try {
                    while ($t.moveNext()) {
                        var other = $t.Current;
                        if (other.mainTexture == null) {
                            UnityEngine.Debug.LogError$2("Material is missing texture: " + (other.name || ""), other);
                            return;
                        }
                        var textureName = other.mainTexture.name;
                        if (Bridge.referenceEquals(textureName, name) || (this.atlasAsset.OnDemandTextureLoader != null && Bridge.referenceEquals(textureName, this.atlasAsset.OnDemandTextureLoader.GetPlaceholderTextureName(name)))) {
                            material = other;
                            break;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                if (material == null) {
                    UnityEngine.Debug.LogError$2("Material with texture name \"" + (name || "") + "\" not found for atlas asset: " + (this.atlasAsset.name || ""), this.atlasAsset);
                    return;
                }
                page.rendererObject = material;

                // Very old atlas files expected the texture's actual size to be used at runtime.
                if (page.width === 0 || page.height === 0) {
                    page.width = material.mainTexture.width;
                    page.height = material.mainTexture.height;
                }
            },
            /*Spine.Unity.MaterialsTextureLoader.Load end.*/

            /*Spine.Unity.MaterialsTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.MaterialsTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.MaterialsTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.MeshGenerator start.*/
    /**
     * Holds several methods to prepare and generate a UnityEngine mesh based on a skeleton. Contains buffers needed to perform the operation, and serializes settings for mesh generation.
     *
     * @public
     * @class Spine.Unity.MeshGenerator
     */
    Bridge.define("Spine.Unity.MeshGenerator", {
        statics: {
            fields: {
                BoundsMinDefault: 0,
                BoundsMaxDefault: 0,
                AttachmentVerts: null,
                AttachmentUVs: null,
                AttachmentColors32: null,
                AttachmentIndices: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                    this.BoundsMinDefault = Number.POSITIVE_INFINITY;
                    this.BoundsMaxDefault = Number.NEGATIVE_INFINITY;
                    this.AttachmentVerts = new (System.Collections.Generic.List$1(UnityEngine.Vector3)).ctor();
                    this.AttachmentUVs = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                    this.AttachmentColors32 = new (System.Collections.Generic.List$1(UnityEngine.Color32)).ctor();
                    this.AttachmentIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                }
            },
            methods: {
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static start.*/
                /**
                 * A specialized variant of {@link }.
                 Generates renderer instructions using a single submesh, using only a single material and texture.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Spine.Unity.SkeletonRendererInstruction}    instructionOutput    The resulting instructions.
                 * @param   {Spine.Skeleton}                             skeleton             The skeleton to generate renderer instructions for.
                 * @param   {UnityEngine.Material}                       material             Material to be set at the renderer instruction. When null, the last attachment
                 in the draw order list is assigned as the instruction's material.
                 * @return  {void}
                 */
                GenerateSingleSubmeshInstruction: function (instructionOutput, skeleton, material) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSingleSubmeshInstruction", this ); }

                    var $t;
                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;

                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t.startSlot = 0, $t.rawFirstVertexIndex = 0, $t.material = material, $t.forceSeparate = false, $t.endSlot = drawOrderCount, $t);

                    var rendererObject = null;
                    var skeletonHasClipping = false;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();

                        workingAttachmentsItems[i] = attachment;
                        var attachmentTriangleCount;
                        var attachmentVertexCount;

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            rendererObject = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                rendererObject = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                attachmentVertexCount = 0;
                                attachmentTriangleCount = 0;
                            }
                        }
                        current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                        current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                        totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                    }

                    if (material == null && rendererObject != null) {
                        current.material = Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;

                    if (totalRawVertexCount > 0) {
                        workingSubmeshInstructions.Resize(1);
                        workingSubmeshInstructions.Items[0] = current.$clone();
                    } else {
                        workingSubmeshInstructions.Resize(0);
                    }
                },
                /*Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static start.*/
                RequiresMultipleSubmeshesByDrawOrder: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#RequiresMultipleSubmeshesByDrawOrder", this ); }


                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;
                    var drawOrderItems = drawOrder.Items;

                    var lastRendererMaterial = null;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            continue;
                        }
                        var attachment = slot.getAttachment();
                        var rendererAttachment = Bridge.as(attachment, Spine.IHasTextureRegion);
                        if (rendererAttachment != null) {
                            if (rendererAttachment.Spine$IHasTextureRegion$Sequence != null) {
                                rendererAttachment.Spine$IHasTextureRegion$Sequence.apply(slot, rendererAttachment);
                            }
                            var atlasRegion = Bridge.cast(rendererAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion);
                            var material = Bridge.cast(atlasRegion.page.rendererObject, UnityEngine.Material);
                            if (!Bridge.referenceEquals(lastRendererMaterial, material)) {
                                if (lastRendererMaterial != null) {
                                    return true;
                                }
                                lastRendererMaterial = material;
                            }
                        }
                    }
                    return false;
                },
                /*Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder:static end.*/

                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static start.*/
                GenerateSkeletonRendererInstruction: function (instructionOutput, skeleton, customSlotMaterials, separatorSlots, generateMeshOverride, immutableTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GenerateSkeletonRendererInstruction", this ); }

                    var $t;
                    if (immutableTriangles === void 0) { immutableTriangles = false; }
                    //			if (skeleton == null) throw new ArgumentNullException("skeleton");
                    //			if (instructionOutput == null) throw new ArgumentNullException("instructionOutput");

                    var drawOrder = skeleton.DrawOrder;
                    var drawOrderCount = drawOrder.Count;

                    // Clear last state of attachments and submeshes
                    instructionOutput.Clear(); // submeshInstructions.Clear(); attachments.Clear();
                    var workingSubmeshInstructions = instructionOutput.submeshInstructions;
                    instructionOutput.attachments.Resize(drawOrderCount);
                    var workingAttachmentsItems = instructionOutput.attachments.Items;
                    var totalRawVertexCount = 0;
                    var skeletonHasClipping = false;

                    var current = ($t = new Spine.Unity.SubmeshInstruction(), $t.skeleton = skeleton, $t.preActiveClippingSlotSource = -1, $t);

                    var isCustomSlotMaterialsPopulated = customSlotMaterials != null && customSlotMaterials.Count > 0;

                    var separatorCount = separatorSlots == null ? 0 : separatorSlots.Count;
                    var hasSeparators = separatorCount > 0;

                    var clippingAttachmentSource = -1;
                    var lastPreActiveClipping = -1; // The index of the last slot that had an active ClippingAttachment.
                    var clippingEndSlot = null;
                    var submeshIndex = 0;
                    var drawOrderItems = drawOrder.Items;
                    for (var i = 0; i < drawOrderCount; i = (i + 1) | 0) {
                        var slot = drawOrderItems[i];
                        if (!slot.bone.isActive()) {
                            workingAttachmentsItems[i] = null;
                            continue;
                        }
                        if (slot.data.blendMode === spine.BlendMode.Additive) {
                            current.hasPMAAdditiveSlot = true;
                        }
                        var attachment = slot.getAttachment();
                        workingAttachmentsItems[i] = attachment;
                        var attachmentVertexCount = 0, attachmentTriangleCount = 0;

                        var region = null;
                        var noRender = false; // Using this allows empty slots as separators, and keeps separated parts more stable despite slots being reordered

                        var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                        if (regionAttachment != null) {
                            if (regionAttachment.sequence != null) {
                                regionAttachment.sequence.apply(slot, regionAttachment);
                            }
                            region = regionAttachment.region;
                            attachmentVertexCount = 4;
                            attachmentTriangleCount = 6;
                        } else {
                            var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                            if (meshAttachment != null) {
                                if (meshAttachment.sequence != null) {
                                    meshAttachment.sequence.apply(slot, meshAttachment);
                                }
                                region = meshAttachment.region;
                                attachmentVertexCount = meshAttachment.worldVerticesLength >> 1;
                                attachmentTriangleCount = meshAttachment.triangles.length;
                            } else {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    clippingEndSlot = clippingAttachment.endSlot;
                                    clippingAttachmentSource = i;
                                    current.hasClipping = true;
                                    skeletonHasClipping = true;
                                }
                                noRender = true;
                            }
                        }

                        // Create a new SubmeshInstruction when material changes. (or when forced to separate by a submeshSeparator)
                        // Slot with a separator/new material will become the starting slot of the next new instruction.
                        if (hasSeparators) { //current.forceSeparate = hasSeparators && separatorSlots.Contains(slot);
                            current.forceSeparate = false;
                            for (var s = 0; s < separatorCount; s = (s + 1) | 0) {
                                if (Bridge.referenceEquals(slot, separatorSlots.getItem(s))) {
                                    current.forceSeparate = true;
                                    break;
                                }
                            }
                        }

                        if (noRender) {
                            if (current.forceSeparate && generateMeshOverride) { // && current.rawVertexCount > 0) {
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();

                                    submeshIndex = (submeshIndex + 1) | 0;
                                }

                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }
                        } else {
                            var material = { };
                            if (isCustomSlotMaterialsPopulated) {
                                if (!customSlotMaterials.tryGetValue(slot, material)) {
                                    material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                                }
                            } else {
                                material.v = Bridge.cast(Bridge.cast(region, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                            }

                            if (current.forceSeparate || (current.rawVertexCount > 0 && !Bridge.referenceEquals(current.material, material.v))) { // Material changed. Add the previous submesh.
                                { // Add
                                    current.endSlot = i;
                                    current.preActiveClippingSlotSource = lastPreActiveClipping;

                                    workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                                    workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                                    submeshIndex = (submeshIndex + 1) | 0;
                                }
                                current.startSlot = i;
                                lastPreActiveClipping = clippingAttachmentSource;
                                current.rawTriangleCount = 0;
                                current.rawVertexCount = 0;
                                current.rawFirstVertexIndex = totalRawVertexCount;
                                current.hasClipping = clippingAttachmentSource >= 0;
                            }

                            // Update state for the next Attachment.
                            current.material = material.v;
                            current.rawTriangleCount = (current.rawTriangleCount + attachmentTriangleCount) | 0;
                            current.rawVertexCount = (current.rawVertexCount + attachmentVertexCount) | 0;
                            current.rawFirstVertexIndex = totalRawVertexCount;
                            totalRawVertexCount = (totalRawVertexCount + attachmentVertexCount) | 0;
                        }

                        if (clippingEndSlot != null && Bridge.referenceEquals(slot.data, clippingEndSlot) && i !== clippingAttachmentSource) {
                            clippingEndSlot = null;
                            clippingAttachmentSource = -1;
                        }
                    }

                    if (current.rawVertexCount > 0) {
                        { // Add last or only submesh.
                            current.endSlot = drawOrderCount;
                            current.preActiveClippingSlotSource = lastPreActiveClipping;
                            current.forceSeparate = false;

                            workingSubmeshInstructions.Resize(((submeshIndex + 1) | 0));
                            workingSubmeshInstructions.Items[submeshIndex] = current.$clone();
                            //submeshIndex++;
                        }
                    }

                    instructionOutput.hasActiveClipping = skeletonHasClipping;
                    instructionOutput.rawVertexCount = totalRawVertexCount;
                    instructionOutput.immutableTriangles = immutableTriangles;
                },
                /*Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction:static end.*/

                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static start.*/
                TryReplaceMaterials: function (workingSubmeshInstructions, customMaterialOverride) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TryReplaceMaterials", this ); }

                    // Material overrides are done here so they can be applied per submesh instead of per slot
                    // but they will still be passed through the GenerateMeshOverride delegate,
                    // and will still go through the normal material match check step in STEP 3.
                    var wsii = workingSubmeshInstructions.Items;
                    for (var i = 0; i < workingSubmeshInstructions.Count; i = (i + 1) | 0) {
                        var material = wsii[i].material;
                        if (material == null) {
                            continue;
                        }

                        var overrideMaterial = { };
                        if (customMaterialOverride.tryGetValue(material, overrideMaterial)) {
                            wsii[i].material = overrideMaterial.v;
                        }
                    }
                },
                /*Spine.Unity.MeshGenerator.TryReplaceMaterials:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static start.*/
                /**
                 * Step 1 of solving tangents. Ensure you have buffers of the correct size.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Vector4}    tangentBuffer         Eventual Vector4[] tangent buffer to assign to Mesh.tangents.
                 * @param   {UnityEngine.Vector2}    tempTanBuffer         Temporary Vector2 buffer for calculating directions.
                 * @param   {number}                 vertexCount           Number of vertices that require tangents (or the size of the vertex array)
                 * @param   {number}                 vertexBufferLength
                 * @return  {void}
                 */
                SolveTangents2DEnsureSize: function (tangentBuffer, tempTanBuffer, vertexCount, vertexBufferLength) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DEnsureSize", this ); }

                    if (tangentBuffer.v == null || tangentBuffer.v.length !== vertexBufferLength) {
                        tangentBuffer.v = System.Array.init(vertexBufferLength, function (){
                            return new UnityEngine.Vector4();
                        }, UnityEngine.Vector4);
                    }

                    if (tempTanBuffer.v == null || tempTanBuffer.v.length < Bridge.Int.mul(vertexCount, 2)) {
                        tempTanBuffer.v = System.Array.init(Bridge.Int.mul(vertexCount, 2), function (){
                            return new UnityEngine.Vector2();
                        }, UnityEngine.Vector2);
                    } // two arrays in one.
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static start.*/
                /**
                 * Step 2 of solving tangents. Fills (part of) a temporary tangent-solution buffer based on the vertices and uvs defined by a submesh's triangle buffer. Only needs to be called once for single-submesh meshes.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {Array.<number>}                 triangles        The mesh's current triangles buffer.
                 * @param   {number}                         triangleCount    The number of triangle indexes in the triangle array to be used.
                 * @param   {Array.<UnityEngine.Vector3>}    vertices         The mesh's current vertex position buffer.
                 * @param   {Array.<UnityEngine.Vector2>}    uvs              The mesh's current uvs buffer.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DTriangles: function (tempTanBuffer, triangles, triangleCount, vertices, uvs, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DTriangles", this ); }

                    var $t, $t1;
                    var sdir = new UnityEngine.Vector2();
                    var tdir = new UnityEngine.Vector2();
                    for (var t = 0; t < triangleCount; t = (t + 3) | 0) {
                        var i1 = triangles[((t + 0) | 0)];
                        var i2 = triangles[((t + 1) | 0)];
                        var i3 = triangles[((t + 2) | 0)];

                        var v1 = vertices[i1].$clone();
                        var v2 = vertices[i2].$clone();
                        var v3 = vertices[i3].$clone();

                        var w1 = uvs[i1].$clone();
                        var w2 = uvs[i2].$clone();
                        var w3 = uvs[i3].$clone();

                        var x1 = v2.x - v1.x;
                        var x2 = v3.x - v1.x;
                        var y1 = v2.y - v1.y;
                        var y2 = v3.y - v1.y;

                        var s1 = w2.x - w1.x;
                        var s2 = w3.x - w1.x;
                        var t1 = w2.y - w1.y;
                        var t2 = w3.y - w1.y;

                        var div = s1 * t2 - s2 * t1;
                        var r = (div === 0.0) ? 0.0 : 1.0 / div;

                        sdir.x = (t2 * x1 - t1 * x2) * r;
                        sdir.y = (t2 * y1 - t1 * y2) * r;
                        tempTanBuffer[i1] = ($t = (tempTanBuffer[i3] = sdir.$clone(), sdir.$clone()), tempTanBuffer[i2] = $t.$clone(), $t);

                        tdir.x = (s1 * x2 - s2 * x1) * r;
                        tdir.y = (s1 * y2 - s2 * y1) * r;
                        tempTanBuffer[((vertexCount + i1) | 0)] = ($t1 = (tempTanBuffer[((vertexCount + i3) | 0)] = tdir.$clone(), tdir.$clone()), tempTanBuffer[((vertexCount + i2) | 0)] = $t1.$clone(), $t1);
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DTriangles:static end.*/

                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static start.*/
                /**
                 * Step 3 of solving tangents. Fills a Vector4[] tangents array according to values calculated in step 2.
                 *
                 * @static
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {Array.<UnityEngine.Vector4>}    tangents         A Vector4[] that will eventually be used to set Mesh.tangents
                 * @param   {Array.<UnityEngine.Vector2>}    tempTanBuffer    A temporary Vector3[] for calculating tangents.
                 * @param   {number}                         vertexCount      Number of vertices that require tangents (or the size of the vertex array)
                 * @return  {void}
                 */
                SolveTangents2DBuffer: function (tangents, tempTanBuffer, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SolveTangents2DBuffer", this ); }

                    var tangent = new UnityEngine.Vector4();
                    tangent.z = 0;
                    for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                        var t = tempTanBuffer[i].$clone();

                        // t.Normalize() (aggressively inlined). Even better if offloaded to GPU via vertex shader.
                        var magnitude = Math.sqrt(t.x * t.x + t.y * t.y);
                        if (magnitude > 1E-05) {
                            var reciprocalMagnitude = 1.0 / magnitude;
                            t.x *= reciprocalMagnitude;
                            t.y *= reciprocalMagnitude;
                        }

                        var t2 = tempTanBuffer[((vertexCount + i) | 0)].$clone();
                        tangent.x = t.x;
                        tangent.y = t.y;
                        //tangent.z = 0;
                        tangent.w = (t.y * t2.x > t.x * t2.y) ? 1 : -1; // 2D direction calculation. Used for binormals.
                        tangents[i] = tangent.$clone();
                    }
                },
                /*Spine.Unity.MeshGenerator.SolveTangents2DBuffer:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static start.*/
                /**
                 * Fills mesh vertex data to render a RegionAttachment.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.MeshGenerator
                 * @memberof Spine.Unity.MeshGenerator
                 * @param   {UnityEngine.Mesh}          mesh                
                 * @param   {Spine.RegionAttachment}    regionAttachment
                 * @return  {void}
                 */
                FillMeshLocal$1: function (mesh, regionAttachment) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal$1", this ); }

                    if (mesh == null) {
                        return;
                    }
                    if (regionAttachment == null) {
                        return;
                    }

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    var offsets = regionAttachment.offset;
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[0], offsets[1], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[2], offsets[3], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[4], offsets[5], 0 ));
                    Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( offsets[6], offsets[7], 0 ));

                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    var uvs = regionAttachment.uvs;
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[2], uvs[3] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[4], uvs[5] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[6], uvs[7] ));
                    Spine.Unity.MeshGenerator.AttachmentUVs.add(new pc.Vec2( uvs[0], uvs[1] ));

                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( regionAttachment.color.r, regionAttachment.color.g, regionAttachment.color.b, regionAttachment.color.a )));
                    for (var i = 0; i < 4; i = (i + 1) | 0) {
                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(System.Array.init([0, 2, 1, 0, 3, 2], System.Int32));

                    mesh.Clear();
                    mesh.name = regionAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal$1:static end.*/

                /*Spine.Unity.MeshGenerator.FillMeshLocal:static start.*/
                FillMeshLocal: function (mesh, meshAttachment, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillMeshLocal", this ); }

                    var $t;
                    if (mesh == null) {
                        return;
                    }
                    if (meshAttachment == null) {
                        return;
                    }
                    var vertexCount = (Bridge.Int.div(meshAttachment.worldVerticesLength, 2)) | 0;

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    if (Spine.SpineSkeletonExtensions.IsWeighted(meshAttachment)) {
                        var count = meshAttachment.worldVerticesLength;
                        var meshAttachmentBones = meshAttachment.bones;
                        var v = 0;

                        var vertices = meshAttachment.vertices;
                        for (var w = 0, b = 0; w < count; w = (w + 2) | 0) {
                            var wx = 0, wy = 0;
                            var n = meshAttachmentBones[Bridge.identity(v, ((v = (v + 1) | 0)))];
                            n = (n + v) | 0;
                            for (; v < n; v = (v + 1) | 0, b = (b + 3) | 0) {
                                var bm = Spine.BoneMatrix.CalculateSetupWorld(($t = skeletonData.Bones.Items)[meshAttachmentBones[v]]);
                                var vx = vertices[b], vy = vertices[((b + 1) | 0)], weight = vertices[((b + 2) | 0)];
                                wx += (vx * bm.a + vy * bm.b + bm.x) * weight;
                                wy += (vx * bm.c + vy * bm.d + bm.y) * weight;
                            }
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(new pc.Vec3( wx, wy, 0 ));
                        }
                    } else {
                        var localVerts = meshAttachment.vertices;
                        var pos = Bridge.getDefaultValue(UnityEngine.Vector3);
                        for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                            var ii = Bridge.Int.mul(i, 2);
                            pos.x = localVerts[ii];
                            pos.y = localVerts[((ii + 1) | 0)];
                            Spine.Unity.MeshGenerator.AttachmentVerts.add(pos.$clone());
                        }
                    }

                    var uvs = meshAttachment.uvs;
                    var uv = Bridge.getDefaultValue(UnityEngine.Vector2);
                    var c = UnityEngine.Color32.op_Implicit$1((new pc.Color( meshAttachment.color.r, meshAttachment.color.g, meshAttachment.color.b, meshAttachment.color.a )));
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    for (var i1 = 0; i1 < vertexCount; i1 = (i1 + 1) | 0) {
                        var ii1 = Bridge.Int.mul(i1, 2);
                        uv.x = uvs[ii1];
                        uv.y = uvs[((ii1 + 1) | 0)];
                        Spine.Unity.MeshGenerator.AttachmentUVs.add(uv.$clone());

                        Spine.Unity.MeshGenerator.AttachmentColors32.add(c.$clone());
                    }

                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.AddRange(meshAttachment.triangles);

                    mesh.Clear();
                    mesh.name = meshAttachment.name;
                    mesh.SetVertices(Spine.Unity.MeshGenerator.AttachmentVerts);
                    mesh.SetUVs(0, Spine.Unity.MeshGenerator.AttachmentUVs);
                    mesh.SetColors$1(Spine.Unity.MeshGenerator.AttachmentColors32);
                    mesh.SetTriangles(Spine.Unity.MeshGenerator.AttachmentIndices, 0);
                    mesh.RecalculateBounds();

                    Spine.Unity.MeshGenerator.AttachmentVerts.clear();
                    Spine.Unity.MeshGenerator.AttachmentUVs.clear();
                    Spine.Unity.MeshGenerator.AttachmentColors32.clear();
                    Spine.Unity.MeshGenerator.AttachmentIndices.clear();
                },
                /*Spine.Unity.MeshGenerator.FillMeshLocal:static end.*/


            }
        },
        fields: {
            settings: null,
            vertexBuffer: null,
            uvBuffer: null,
            colorBuffer: null,
            submeshes: null,
            meshBoundsMin: null,
            meshBoundsMax: null,
            meshBoundsThickness: 0,
            submeshIndex: 0,
            clipper: null,
            tempVerts: null,
            regionTriangles: null,
            normals: null,
            tangents: null,
            tempTanBuffer: null,
            uv2: null,
            uv3: null
        },
        props: {
            VertexCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#VertexCount#get", this ); }

                    return this.vertexBuffer.Count;
                }
            },
            /**
             * A set of mesh arrays whose values are modifiable by the user. Modify these values before they are passed to the UnityEngine mesh object in order to see the effect.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.MeshGenerator
             * @function Buffers
             * @type Spine.Unity.MeshGeneratorBuffers
             */
            Buffers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Buffers#get", this ); }

                    var $t;
                    return ($t = new Spine.Unity.MeshGeneratorBuffers(), $t.vertexCount = this.VertexCount, $t.vertexBuffer = this.vertexBuffer.Items, $t.uvBuffer = this.uvBuffer.Items, $t.colorBuffer = this.colorBuffer.Items, $t.meshGenerator = this, $t);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#init", this ); }

                this.settings = new Spine.Unity.MeshGenerator.Settings();
                this.meshBoundsMin = new UnityEngine.Vector2();
                this.meshBoundsMax = new UnityEngine.Vector2();
                this.settings = Spine.Unity.MeshGenerator.Settings.Default.$clone();
                this.vertexBuffer = new (Spine.ExposedList$1(UnityEngine.Vector3)).$ctor3(4);
                this.uvBuffer = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(4);
                this.colorBuffer = new (Spine.ExposedList$1(UnityEngine.Color32)).$ctor3(4);
                this.submeshes = function (_o1) {
                        _o1.Add(new (Spine.ExposedList$1(System.Int32)).$ctor3(6));
                        return _o1;
                    }(new (Spine.ExposedList$1(Spine.ExposedList$1(System.Int32))).ctor());
                this.submeshIndex = 0;
                this.clipper = new Spine.SkeletonClipping();
                this.tempVerts = System.Array.init(8, 0, System.Single);
                this.regionTriangles = System.Array.init([
                    0, 
                    1, 
                    2, 
                    2, 
                    3, 
                    0
                ], System.Int32);
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ctor", this ); }

                this.$initialize();
                this.submeshes.TrimExcess();
            }
        },
        methods: {
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount start.*/
            SubmeshIndexCount: function (submeshIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#SubmeshIndexCount", this ); }

                var $t;
                return ($t = this.submeshes.Items)[submeshIndex].Count;
            },
            /*Spine.Unity.MeshGenerator.SubmeshIndexCount end.*/

            /*Spine.Unity.MeshGenerator.Begin start.*/
            Begin: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#Begin", this ); }

                this.vertexBuffer.Clear(false);
                this.colorBuffer.Clear(false);
                this.uvBuffer.Clear(false);
                this.clipper.clipEnd();

                {
                    this.meshBoundsMin.x = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMin.y = Spine.Unity.MeshGenerator.BoundsMinDefault;
                    this.meshBoundsMax.x = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsMax.y = Spine.Unity.MeshGenerator.BoundsMaxDefault;
                    this.meshBoundsThickness = 0.0;
                }

                this.submeshIndex = 0;
                this.submeshes.Count = 1;
                //submeshes.Items[0].Clear(false);
            },
            /*Spine.Unity.MeshGenerator.Begin end.*/

            /*Spine.Unity.MeshGenerator.AddSubmesh start.*/
            AddSubmesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddSubmesh", this ); }

                var $t, $t1, $t2;
                if (updateTriangles === void 0) { updateTriangles = true; }
                var settings = this.settings.$clone();

                var newSubmeshCount = (this.submeshIndex + 1) | 0;
                if (this.submeshes.Items.length < newSubmeshCount) {
                    this.submeshes.Resize(newSubmeshCount);
                }
                this.submeshes.Count = newSubmeshCount;
                var submesh = ($t = this.submeshes.Items)[this.submeshIndex];
                if (submesh == null) {
                    ($t1 = this.submeshes.Items)[this.submeshIndex] = (submesh = new (Spine.ExposedList$1(System.Int32)).ctor());
                }
                submesh.Clear(false);

                var skeleton = instruction.skeleton;
                var drawOrderItems = skeleton.DrawOrder.Items;

                var color = Bridge.getDefaultValue(UnityEngine.Color32);
                var skeletonA = skeleton.color.a, skeletonR = skeleton.color.r, skeletonG = skeleton.color.g, skeletonB = skeleton.color.b;
                var meshBoundsMin = this.meshBoundsMin.$clone(), meshBoundsMax = this.meshBoundsMax.$clone();

                // Settings
                var zSpacing = settings.zSpacing;
                var pmaVertexColors = settings.pmaVertexColors;
                var tintBlack = settings.tintBlack;
                var useClipping = settings.useClipping && instruction.hasClipping;
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;

                if (useClipping) {
                    if (instruction.preActiveClippingSlotSource >= 0) {
                        var slot = drawOrderItems[instruction.preActiveClippingSlotSource];
                        this.clipper.clipStart(slot, Bridge.as(slot.getAttachment(), spine.ClippingAttachment));
                    }
                }

                for (var slotIndex = instruction.startSlot; slotIndex < instruction.endSlot; slotIndex = (slotIndex + 1) | 0) {
                    var slot1 = drawOrderItems[slotIndex];
                    if (!slot1.bone.isActive()) {
                        this.clipper.clipEndWithSlot( slot1 );
                        continue;
                    }
                    var attachment = slot1.getAttachment();
                    var z = zSpacing * slotIndex;

                    var workingVerts = this.tempVerts;
                    var uvs;
                    var attachmentTriangleIndices;
                    var attachmentVertexCount;
                    var attachmentIndexCount;

                    var c = Bridge.getDefaultValue(UnityEngine.Color);

                    // Identify and prepare values.
                    var region = Bridge.as(attachment, Spine.RegionAttachment);
                    if (region != null) {
                        region.computeWorldVertices(slot1, workingVerts, 0);
                        uvs = region.uvs;
                        attachmentTriangleIndices = this.regionTriangles;
                        c.r = region.color.r;
                        c.g = region.color.g;
                        c.b = region.color.b;
                        c.a = region.color.a;
                        attachmentVertexCount = 4;
                        attachmentIndexCount = 6;
                    } else {
                        var mesh = Bridge.as(attachment, Spine.MeshAttachment);
                        if (mesh != null) {
                            var meshVerticesLength = mesh.worldVerticesLength;
                            if (workingVerts.length < meshVerticesLength) {
                                workingVerts = System.Array.init(meshVerticesLength, 0, System.Single);
                                this.tempVerts = workingVerts;
                            }
                            mesh.computeWorldVertices( slot1, 0, meshVerticesLength, workingVerts, 0, 2 || 2 ); //meshAttachment.ComputeWorldVertices(slot, tempVerts);
                            uvs = mesh.uvs;
                            attachmentTriangleIndices = mesh.triangles;
                            c.r = mesh.color.r;
                            c.g = mesh.color.g;
                            c.b = mesh.color.b;
                            c.a = mesh.color.a;
                            attachmentVertexCount = meshVerticesLength >> 1; // meshVertexCount / 2;
                            attachmentIndexCount = mesh.triangles.length;
                        } else {
                            if (useClipping) {
                                var clippingAttachment = Bridge.as(attachment, spine.ClippingAttachment);
                                if (clippingAttachment != null) {
                                    this.clipper.clipStart(slot1, clippingAttachment);
                                    continue;
                                }
                            }

                            // If not any renderable attachment.
                            this.clipper.clipEndWithSlot( slot1 );
                            continue;
                        }
                    }

                    var tintBlackAlpha = 1.0;
                    if (pmaVertexColors) {
                        var colorA = skeletonA * slot1.color.a * c.a;
                        color.a = Bridge.Int.clipu8(colorA * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * color.a);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * color.a);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * color.a);
                        if (slot1.data.blendMode === spine.BlendMode.Additive) {
                            if (canvasGroupTintBlack) {
                                tintBlackAlpha = 0;
                            } else {
                                color.a = 0;
                            }
                        } else if (canvasGroupTintBlack) { // other blend modes
                            tintBlackAlpha = colorA;
                        }
                    } else {
                        color.a = Bridge.Int.clipu8(skeletonA * slot1.color.a * c.a * 255);
                        color.r = Bridge.Int.clipu8(skeletonR * slot1.color.r * c.r * 255);
                        color.g = Bridge.Int.clipu8(skeletonG * slot1.color.g * c.g * 255);
                        color.b = Bridge.Int.clipu8(skeletonB * slot1.color.b * c.b * 255);
                    }

                    if (useClipping && this.clipper.isClipping()) {
                        this.clipper.ClipTriangles(workingVerts, attachmentVertexCount << 1, attachmentTriangleIndices, attachmentIndexCount, uvs);
                        workingVerts = this.clipper.ClippedVertices.Items;
                        attachmentVertexCount = this.clipper.ClippedVertices.Count >> 1;
                        attachmentTriangleIndices = this.clipper.ClippedTriangles.Items;
                        attachmentIndexCount = this.clipper.ClippedTriangles.Count;
                        uvs = this.clipper.ClippedUVs.Items;
                    }

                    // Actually add slot/attachment data into buffers.
                    if (attachmentVertexCount !== 0 && attachmentIndexCount !== 0) {
                        if (tintBlack) {
                            var r2 = slot1.darkColor.r || 0;
                            var g2 = slot1.darkColor.g || 0;
                            var b2 = slot1.darkColor.b || 0;
                            if (pmaVertexColors) {
                                var alpha = skeletonA * slot1.color.a * c.a;
                                r2 *= alpha;
                                g2 *= alpha;
                                b2 *= alpha;
                            }
                            this.AddAttachmentTintBlack(r2, g2, b2, tintBlackAlpha, attachmentVertexCount);
                        }

                        //AddAttachment(workingVerts, uvs, color, attachmentTriangleIndices, attachmentVertexCount, attachmentIndexCount, ref meshBoundsMin, ref meshBoundsMax, z);
                        var ovc = this.vertexBuffer.Count;
                        // Add data to vertex buffers
                        {
                            var newVertexCount = (ovc + attachmentVertexCount) | 0;
                            var oldArraySize = this.vertexBuffer.Items.length;
                            if (newVertexCount > oldArraySize) {
                                var newArraySize = Bridge.Int.clip32(oldArraySize * 1.3);
                                if (newArraySize < newVertexCount) {
                                    newArraySize = newVertexCount;
                                }
                                System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector3);
                                }, UnityEngine.Vector3);
                                System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), newArraySize, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Color32);
                                }, UnityEngine.Color32);
                            }
                            this.vertexBuffer.Count = ($t2 = (this.colorBuffer.Count = newVertexCount, newVertexCount), this.uvBuffer.Count = $t2, $t2);
                        }

                        var vbi = this.vertexBuffer.Items;
                        var ubi = this.uvBuffer.Items;
                        var cbi = this.colorBuffer.Items;
                        if (ovc === 0) {
                            for (var i = 0; i < attachmentVertexCount; i = (i + 1) | 0) {
                                var vi = (ovc + i) | 0;
                                var i2 = i << 1; // i * 2
                                var x = workingVerts[i2];
                                var y = workingVerts[((i2 + 1) | 0)];

                                vbi[vi].x = x;
                                vbi[vi].y = y;
                                vbi[vi].z = z;
                                ubi[vi].x = uvs[i2];
                                ubi[vi].y = uvs[((i2 + 1) | 0)];
                                cbi[vi] = color.$clone();

                                // Calculate bounds.
                                if (x < meshBoundsMin.x) {
                                    meshBoundsMin.x = x;
                                }
                                if (x > meshBoundsMax.x) {
                                    meshBoundsMax.x = x;
                                }
                                if (y < meshBoundsMin.y) {
                                    meshBoundsMin.y = y;
                                }
                                if (y > meshBoundsMax.y) {
                                    meshBoundsMax.y = y;
                                }
                            }
                        } else {
                            for (var i1 = 0; i1 < attachmentVertexCount; i1 = (i1 + 1) | 0) {
                                var vi1 = (ovc + i1) | 0;
                                var i21 = i1 << 1; // i * 2
                                var x1 = workingVerts[i21];
                                var y1 = workingVerts[((i21 + 1) | 0)];

                                vbi[vi1].x = x1;
                                vbi[vi1].y = y1;
                                vbi[vi1].z = z;
                                ubi[vi1].x = uvs[i21];
                                ubi[vi1].y = uvs[((i21 + 1) | 0)];
                                cbi[vi1] = color.$clone();

                                // Calculate bounds.
                                if (x1 < meshBoundsMin.x) {
                                    meshBoundsMin.x = x1;
                                } else {
                                    if (x1 > meshBoundsMax.x) {
                                        meshBoundsMax.x = x1;
                                    }
                                }
                                if (y1 < meshBoundsMin.y) {
                                    meshBoundsMin.y = y1;
                                } else {
                                    if (y1 > meshBoundsMax.y) {
                                        meshBoundsMax.y = y1;
                                    }
                                }
                            }
                        }


                        // Add data to triangle buffer
                        if (updateTriangles) {
                            var oldTriangleCount = submesh.Count;
                            { //submesh.Resize(oldTriangleCount + attachmentIndexCount);
                                var newTriangleCount = (oldTriangleCount + attachmentIndexCount) | 0;
                                if (newTriangleCount > submesh.Items.length) {
                                    System.Array.resize(Bridge.ref(submesh, "Items"), newTriangleCount, 0, System.Int32);
                                }
                                submesh.Count = newTriangleCount;
                            }
                            var submeshItems = submesh.Items;
                            for (var i2 = 0; i2 < attachmentIndexCount; i2 = (i2 + 1) | 0) {
                                submeshItems[((oldTriangleCount + i2) | 0)] = (attachmentTriangleIndices[i2] + ovc) | 0;
                            }
                        }
                    }

                    this.clipper.clipEndWithSlot( slot1 );
                }
                this.clipper.clipEnd();

                this.meshBoundsMin = meshBoundsMin.$clone();
                this.meshBoundsMax = meshBoundsMax.$clone();
                this.meshBoundsThickness = instruction.endSlot * zSpacing;

                // Trim or zero submesh triangles.
                var currentSubmeshItems = submesh.Items;
                for (var i3 = submesh.Count, n = currentSubmeshItems.length; i3 < n; i3 = (i3 + 1) | 0) {
                    currentSubmeshItems[i3] = 0;
                }

                this.submeshIndex = (this.submeshIndex + 1) | 0; // Next AddSubmesh will use a new submeshIndex value.
            },
            /*Spine.Unity.MeshGenerator.AddSubmesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMesh start.*/
            BuildMesh: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMesh", this ); }

                var wsii = instruction.submeshInstructions.Items;
                for (var i = 0, n = instruction.submeshInstructions.Count; i < n; i = (i + 1) | 0) {
                    this.AddSubmesh(wsii[i], updateTriangles);
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMesh end.*/

            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays start.*/
            BuildMeshWithArrays: function (instruction, updateTriangles) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#BuildMeshWithArrays", this ); }

                var $t, $t1, $t2, $t3, $t4;
                var settings = this.settings.$clone();
                var canvasGroupTintBlack = settings.tintBlack && settings.canvasGroupTintBlack;
                var totalVertexCount = instruction.rawVertexCount;

                // Add data to vertex buffers
                {
                    if (totalVertexCount > this.vertexBuffer.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector3);
                        }, UnityEngine.Vector3);
                        System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), totalVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Color32);
                        }, UnityEngine.Color32);
                    }
                    this.vertexBuffer.Count = ($t = (this.colorBuffer.Count = totalVertexCount, totalVertexCount), this.uvBuffer.Count = $t, $t);
                }

                // Populate Verts
                var color = Bridge.getDefaultValue(UnityEngine.Color32);

                var vertexIndex = 0;
                var tempVerts = this.tempVerts;
                var bmin = this.meshBoundsMin.$clone();
                var bmax = this.meshBoundsMax.$clone();

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var lastSlotIndex = 0;

                // drawOrder[endSlot] is excluded
                for (var si = 0, n = instruction.submeshInstructions.Count; si < n; si = (si + 1) | 0) {
                    var submesh = ($t1 = instruction.submeshInstructions.Items)[si].$clone();
                    var skeleton = submesh.skeleton;
                    var drawOrderItems = skeleton.DrawOrder.Items;
                    var a = skeleton.color.a, r = skeleton.color.r, g = skeleton.color.g, b = skeleton.color.b;

                    var endSlot = submesh.endSlot;
                    var startSlot = submesh.startSlot;
                    lastSlotIndex = endSlot;

                    if (settings.tintBlack) {
                        var rg = new UnityEngine.Vector2(), b2 = new UnityEngine.Vector2();
                        var vi = vertexIndex;
                        b2.y = 1.0;

                        {
                            if (this.uv2 == null) {
                                this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                                this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                            }
                            if (totalVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), totalVertexCount, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                            }
                            this.uv2.Count = (this.uv3.Count = totalVertexCount, totalVertexCount);
                        }

                        var uv2i = this.uv2.Items;
                        var uv3i = this.uv3.Items;

                        for (var slotIndex = startSlot; slotIndex < endSlot; slotIndex = (slotIndex + 1) | 0) {
                            var slot = drawOrderItems[slotIndex];
                            if (!slot.bone.isActive()) {
                                continue;
                            }
                            var attachment = slot.getAttachment();

                            rg.x = slot.darkColor.r || 0; //r
                            rg.y = slot.darkColor.g || 0; //g
                            b2.x = slot.darkColor.b || 0; //b
                            b2.y = 1.0;

                            var regionAttachment = Bridge.as(attachment, Spine.RegionAttachment);
                            if (regionAttachment != null) {
                                if (settings.pmaVertexColors) {
                                    var alpha = a * slot.color.a * regionAttachment.color.a;
                                    rg.x *= alpha;
                                    rg.y *= alpha;
                                    b2.x *= alpha;
                                    b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha;
                                }
                                uv2i[vi] = rg.$clone();
                                uv2i[((vi + 1) | 0)] = rg.$clone();
                                uv2i[((vi + 2) | 0)] = rg.$clone();
                                uv2i[((vi + 3) | 0)] = rg.$clone();
                                uv3i[vi] = b2.$clone();
                                uv3i[((vi + 1) | 0)] = b2.$clone();
                                uv3i[((vi + 2) | 0)] = b2.$clone();
                                uv3i[((vi + 3) | 0)] = b2.$clone();
                                vi = (vi + 4) | 0;
                            } else { //} if (settings.renderMeshes) {
                                var meshAttachment = Bridge.as(attachment, Spine.MeshAttachment);
                                if (meshAttachment != null) {
                                    if (settings.pmaVertexColors) {
                                        var alpha1 = a * slot.color.a * meshAttachment.color.a;
                                        rg.x *= alpha1;
                                        rg.y *= alpha1;
                                        b2.x *= alpha1;
                                        b2.y = slot.data.blendMode === spine.BlendMode.Additive ? 0 : alpha1;
                                    }
                                    var verticesArrayLength = meshAttachment.worldVerticesLength;
                                    for (var iii = 0; iii < verticesArrayLength; iii = (iii + 2) | 0) {
                                        uv2i[vi] = rg.$clone();
                                        uv3i[vi] = b2.$clone();
                                        vi = (vi + 1) | 0;
                                    }
                                }
                            }
                        }
                    }

                    for (var slotIndex1 = startSlot; slotIndex1 < endSlot; slotIndex1 = (slotIndex1 + 1) | 0) {
                        var slot1 = drawOrderItems[slotIndex1];
                        if (!slot1.bone.isActive()) {
                            continue;
                        }
                        var attachment1 = slot1.getAttachment();
                        var z = slotIndex1 * settings.zSpacing;

                        var regionAttachment1 = Bridge.as(attachment1, Spine.RegionAttachment);
                        if (regionAttachment1 != null) {
                            regionAttachment1.computeWorldVertices(slot1, tempVerts, 0);

                            var x1 = tempVerts[0], y1 = tempVerts[1];
                            var x2 = tempVerts[2], y2 = tempVerts[3];
                            var x3 = tempVerts[4], y3 = tempVerts[5];
                            var x4 = tempVerts[6], y4 = tempVerts[7];
                            vbi[vertexIndex].x = x1;
                            vbi[vertexIndex].y = y1;
                            vbi[vertexIndex].z = z;
                            vbi[((vertexIndex + 1) | 0)].x = x4;
                            vbi[((vertexIndex + 1) | 0)].y = y4;
                            vbi[((vertexIndex + 1) | 0)].z = z;
                            vbi[((vertexIndex + 2) | 0)].x = x2;
                            vbi[((vertexIndex + 2) | 0)].y = y2;
                            vbi[((vertexIndex + 2) | 0)].z = z;
                            vbi[((vertexIndex + 3) | 0)].x = x3;
                            vbi[((vertexIndex + 3) | 0)].y = y3;
                            vbi[((vertexIndex + 3) | 0)].z = z;

                            if (settings.pmaVertexColors) {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * color.a);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * color.a);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * color.a);
                                if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                    color.a = 0;
                                }
                            } else {
                                color.a = Bridge.Int.clipu8(a * slot1.color.a * regionAttachment1.color.a * 255);
                                color.r = Bridge.Int.clipu8(r * slot1.color.r * regionAttachment1.color.r * 255);
                                color.g = Bridge.Int.clipu8(g * slot1.color.g * regionAttachment1.color.g * 255);
                                color.b = Bridge.Int.clipu8(b * slot1.color.b * regionAttachment1.color.b * 255);
                            }

                            cbi[vertexIndex] = color.$clone();
                            cbi[((vertexIndex + 1) | 0)] = color.$clone();
                            cbi[((vertexIndex + 2) | 0)] = color.$clone();
                            cbi[((vertexIndex + 3) | 0)] = color.$clone();

                            var regionUVs = regionAttachment1.uvs;
                            ubi[vertexIndex].x = regionUVs[0];
                            ubi[vertexIndex].y = regionUVs[1];
                            ubi[((vertexIndex + 1) | 0)].x = regionUVs[6];
                            ubi[((vertexIndex + 1) | 0)].y = regionUVs[7];
                            ubi[((vertexIndex + 2) | 0)].x = regionUVs[2];
                            ubi[((vertexIndex + 2) | 0)].y = regionUVs[3];
                            ubi[((vertexIndex + 3) | 0)].x = regionUVs[4];
                            ubi[((vertexIndex + 3) | 0)].y = regionUVs[5];

                            if (x1 < bmin.x) {
                                bmin.x = x1;
                            } // Potential first attachment bounds initialization. Initial min should not block initial max. Same for Y below.
                            if (x1 > bmax.x) {
                                bmax.x = x1;
                            }
                            if (x2 < bmin.x) {
                                bmin.x = x2;
                            } else {
                                if (x2 > bmax.x) {
                                    bmax.x = x2;
                                }
                            }
                            if (x3 < bmin.x) {
                                bmin.x = x3;
                            } else {
                                if (x3 > bmax.x) {
                                    bmax.x = x3;
                                }
                            }
                            if (x4 < bmin.x) {
                                bmin.x = x4;
                            } else {
                                if (x4 > bmax.x) {
                                    bmax.x = x4;
                                }
                            }

                            if (y1 < bmin.y) {
                                bmin.y = y1;
                            }
                            if (y1 > bmax.y) {
                                bmax.y = y1;
                            }
                            if (y2 < bmin.y) {
                                bmin.y = y2;
                            } else {
                                if (y2 > bmax.y) {
                                    bmax.y = y2;
                                }
                            }
                            if (y3 < bmin.y) {
                                bmin.y = y3;
                            } else {
                                if (y3 > bmax.y) {
                                    bmax.y = y3;
                                }
                            }
                            if (y4 < bmin.y) {
                                bmin.y = y4;
                            } else {
                                if (y4 > bmax.y) {
                                    bmax.y = y4;
                                }
                            }

                            vertexIndex = (vertexIndex + 4) | 0;
                        } else { //if (settings.renderMeshes) {
                            var meshAttachment1 = Bridge.as(attachment1, Spine.MeshAttachment);
                            if (meshAttachment1 != null) {
                                var verticesArrayLength1 = meshAttachment1.worldVerticesLength;
                                if (tempVerts.length < verticesArrayLength1) {
                                    this.tempVerts = (tempVerts = System.Array.init(verticesArrayLength1, 0, System.Single));
                                }
                                meshAttachment1.computeWorldVertices( slot1, 0, meshAttachment1.worldVerticesLength, tempVerts, 0, 2 );

                                if (settings.pmaVertexColors) {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * color.a);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * color.a);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * color.a);
                                    if (slot1.data.blendMode === spine.BlendMode.Additive && !canvasGroupTintBlack) {
                                        color.a = 0;
                                    }
                                } else {
                                    color.a = Bridge.Int.clipu8(a * slot1.color.a * meshAttachment1.color.a * 255);
                                    color.r = Bridge.Int.clipu8(r * slot1.color.r * meshAttachment1.color.r * 255);
                                    color.g = Bridge.Int.clipu8(g * slot1.color.g * meshAttachment1.color.g * 255);
                                    color.b = Bridge.Int.clipu8(b * slot1.color.b * meshAttachment1.color.b * 255);
                                }

                                var attachmentUVs = meshAttachment1.uvs;

                                // Potential first attachment bounds initialization. See conditions in RegionAttachment logic.
                                if (vertexIndex === 0) {
                                    // Initial min should not block initial max.
                                    // vi == vertexIndex does not always mean the bounds are fresh. It could be a submesh. Do not nuke old values by omitting the check.
                                    // Should know that this is the first attachment in the submesh. slotIndex == startSlot could be an empty slot.
                                    var fx = tempVerts[0], fy = tempVerts[1];
                                    if (fx < bmin.x) {
                                        bmin.x = fx;
                                    }
                                    if (fx > bmax.x) {
                                        bmax.x = fx;
                                    }
                                    if (fy < bmin.y) {
                                        bmin.y = fy;
                                    }
                                    if (fy > bmax.y) {
                                        bmax.y = fy;
                                    }
                                }

                                for (var iii1 = 0; iii1 < verticesArrayLength1; iii1 = (iii1 + 2) | 0) {
                                    var x = tempVerts[iii1], y = tempVerts[((iii1 + 1) | 0)];
                                    vbi[vertexIndex].x = x;
                                    vbi[vertexIndex].y = y;
                                    vbi[vertexIndex].z = z;
                                    cbi[vertexIndex] = color.$clone();
                                    ubi[vertexIndex].x = attachmentUVs[iii1];
                                    ubi[vertexIndex].y = attachmentUVs[((iii1 + 1) | 0)];

                                    if (x < bmin.x) {
                                        bmin.x = x;
                                    } else {
                                        if (x > bmax.x) {
                                            bmax.x = x;
                                        }
                                    }

                                    if (y < bmin.y) {
                                        bmin.y = y;
                                    } else {
                                        if (y > bmax.y) {
                                            bmax.y = y;
                                        }
                                    }

                                    vertexIndex = (vertexIndex + 1) | 0;
                                }
                            }
                        }
                    }
                }

                this.meshBoundsMin = bmin.$clone();
                this.meshBoundsMax = bmax.$clone();
                this.meshBoundsThickness = lastSlotIndex * settings.zSpacing;

                var submeshInstructionCount = instruction.submeshInstructions.Count;
                this.submeshes.Count = submeshInstructionCount;

                // Add triangles
                if (updateTriangles) {
                    // Match submesh buffers count with submeshInstruction count.
                    if (this.submeshes.Items.length < submeshInstructionCount) {
                        this.submeshes.Resize(submeshInstructionCount);
                        for (var i = 0, n1 = submeshInstructionCount; i < n1; i = (i + 1) | 0) {
                            var submeshBuffer = ($t2 = this.submeshes.Items)[i];
                            if (submeshBuffer == null) {
                                ($t3 = this.submeshes.Items)[i] = new (Spine.ExposedList$1(System.Int32)).ctor();
                            } else {
                                submeshBuffer.Clear(false);
                            }
                        }
                    }

                    var submeshInstructionsItems = instruction.submeshInstructions.Items; // This relies on the resize above.

                    // Fill the buffers.
                    var attachmentFirstVertex = 0;
                    for (var smbi = 0; smbi < submeshInstructionCount; smbi = (smbi + 1) | 0) {
                        var submeshInstruction = submeshInstructionsItems[smbi].$clone();
                        var currentSubmeshBuffer = ($t4 = this.submeshes.Items)[smbi];
                        { //submesh.Resize(submesh.rawTriangleCount);
                            var newTriangleCount = submeshInstruction.rawTriangleCount;
                            if (newTriangleCount > currentSubmeshBuffer.Items.length) {
                                System.Array.resize(Bridge.ref(currentSubmeshBuffer, "Items"), newTriangleCount, 0, System.Int32);
                            } else {
                                if (newTriangleCount < currentSubmeshBuffer.Items.length) {
                                    // Zero the extra.
                                    var sbi = currentSubmeshBuffer.Items;
                                    for (var ei = newTriangleCount, nn = sbi.length; ei < nn; ei = (ei + 1) | 0) {
                                        sbi[ei] = 0;
                                    }
                                }
                            }
                            currentSubmeshBuffer.Count = newTriangleCount;
                        }

                        var tris = currentSubmeshBuffer.Items;
                        var triangleIndex = 0;
                        var skeleton1 = submeshInstruction.skeleton;
                        var drawOrderItems1 = skeleton1.DrawOrder.Items;
                        for (var slotIndex2 = submeshInstruction.startSlot, endSlot1 = submeshInstruction.endSlot; slotIndex2 < endSlot1; slotIndex2 = (slotIndex2 + 1) | 0) {
                            var slot2 = drawOrderItems1[slotIndex2];
                            if (!slot2.bone.isActive()) {
                                continue;
                            }

                            var attachment2 = drawOrderItems1[slotIndex2].getAttachment();
                            if (Bridge.is(attachment2, Spine.RegionAttachment)) {
                                tris[triangleIndex] = attachmentFirstVertex;
                                tris[((triangleIndex + 1) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 2) | 0)] = (attachmentFirstVertex + 1) | 0;
                                tris[((triangleIndex + 3) | 0)] = (attachmentFirstVertex + 2) | 0;
                                tris[((triangleIndex + 4) | 0)] = (attachmentFirstVertex + 3) | 0;
                                tris[((triangleIndex + 5) | 0)] = (attachmentFirstVertex + 1) | 0;
                                triangleIndex = (triangleIndex + 6) | 0;
                                attachmentFirstVertex = (attachmentFirstVertex + 4) | 0;
                                continue;
                            }
                            var meshAttachment2 = Bridge.as(attachment2, Spine.MeshAttachment);
                            if (meshAttachment2 != null) {
                                var attachmentTriangles = meshAttachment2.triangles;
                                for (var ii = 0, nn1 = attachmentTriangles.length; ii < nn1; ii = (ii + 1) | 0, triangleIndex = (triangleIndex + 1) | 0) {
                                    tris[triangleIndex] = (attachmentFirstVertex + attachmentTriangles[ii]) | 0;
                                }
                                attachmentFirstVertex = (attachmentFirstVertex + (meshAttachment2.worldVerticesLength >> 1)) | 0; // length/2;
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.BuildMeshWithArrays end.*/

            /*Spine.Unity.MeshGenerator.ScaleVertexData start.*/
            ScaleVertexData: function (scale) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#ScaleVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                for (var i = 0, n = this.vertexBuffer.Count; i < n; i = (i + 1) | 0) {
                    vbi[i] = vbi[i].$clone().clone().scale( scale ); // vbi[i].x *= scale; vbi[i].y *= scale;
                }

                this.meshBoundsMin = this.meshBoundsMin.$clone().scale( scale );
                this.meshBoundsMax = this.meshBoundsMax.$clone().scale( scale );
                this.meshBoundsThickness *= scale;
            },
            /*Spine.Unity.MeshGenerator.ScaleVertexData end.*/

            /*Spine.Unity.MeshGenerator.GetMeshBounds start.*/
            GetMeshBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#GetMeshBounds", this ); }

                var $t;
                if ((Math.abs(this.meshBoundsMin.x) === Number.POSITIVE_INFINITY)) { // meshBoundsMin.x == BoundsMinDefault // == doesn't work on float Infinity constants.
                    return new pc.BoundingBox.ctor();
                } else {
                    //mesh.bounds = ArraysMeshGenerator.ToBounds(meshBoundsMin, meshBoundsMax);
                    var halfWidth = (this.meshBoundsMax.x - this.meshBoundsMin.x) * 0.5;
                    var halfHeight = (this.meshBoundsMax.y - this.meshBoundsMin.y) * 0.5;
                    return ($t = new pc.BoundingBox.ctor(), $t.center = new pc.Vec3( this.meshBoundsMin.x + halfWidth, this.meshBoundsMin.y + halfHeight, 0 ), $t.halfExtents = new pc.Vec3( halfWidth, halfHeight, this.meshBoundsThickness * 0.5 ), $t);
                }
            },
            /*Spine.Unity.MeshGenerator.GetMeshBounds end.*/

            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack start.*/
            AddAttachmentTintBlack: function (r2, g2, b2, a, vertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#AddAttachmentTintBlack", this ); }

                var rg = new pc.Vec2( r2, g2 );
                var bo = new pc.Vec2( b2, a );

                var ovc = this.vertexBuffer.Count;
                var newVertexCount = (ovc + vertexCount) | 0;
                {
                    if (this.uv2 == null) {
                        this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                        this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).ctor();
                    }
                    if (newVertexCount > this.uv2.Items.length) { // Manual ExposedList.Resize()
                        System.Array.resize(Bridge.ref(this.uv2, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                        System.Array.resize(Bridge.ref(this.uv3, "Items"), newVertexCount, function () {
                            return Bridge.getDefaultValue(UnityEngine.Vector2);
                        }, UnityEngine.Vector2);
                    }
                    this.uv2.Count = (this.uv3.Count = newVertexCount, newVertexCount);
                }

                var uv2i = this.uv2.Items;
                var uv3i = this.uv3.Items;
                for (var i = 0; i < vertexCount; i = (i + 1) | 0) {
                    uv2i[((ovc + i) | 0)] = rg.$clone();
                    uv3i[((ovc + i) | 0)] = bo.$clone();
                }
            },
            /*Spine.Unity.MeshGenerator.AddAttachmentTintBlack end.*/

            /*Spine.Unity.MeshGenerator.FillVertexData start.*/
            FillVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillVertexData", this ); }

                var vbi = this.vertexBuffer.Items;
                var ubi = this.uvBuffer.Items;
                var cbi = this.colorBuffer.Items;
                var vbiLength = vbi.length;

                // Zero the extra.
                {
                    var listCount = this.vertexBuffer.Count;
                    var vector3zero = pc.Vec3.ZERO.clone();
                    for (var i = listCount; i < vbiLength; i = (i + 1) | 0) {
                        vbi[i] = vector3zero.$clone();
                    }
                }

                // Set the vertex buffer.
                {
                    mesh.vertices = vbi;
                    mesh.uv = ubi;
                    mesh.colors32 = cbi;
                    mesh.bounds = this.GetMeshBounds();
                }

                {
                    if (this.settings.addNormals) {
                        var oldLength = 0;

                        if (this.normals == null) {
                            this.normals = System.Array.init(vbiLength, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            oldLength = this.normals.length;
                        }

                        if (oldLength !== vbiLength) {
                            System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                            var localNormals = this.normals;
                            for (var i1 = oldLength; i1 < vbiLength; i1 = (i1 + 1) | 0) {
                                localNormals[i1] = new pc.Vec3( 0, 0, -1 );
                            }
                        }
                        mesh.normals = this.normals;
                    }

                    if (this.settings.tintBlack) {
                        if (this.uv2 != null) {
                            // Sometimes, the vertex buffer becomes smaller. We need to trim the size of the tint black buffers to match.
                            if (vbiLength !== this.uv2.Items.length) {
                                System.Array.resize(Bridge.ref(this.uv2, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                System.Array.resize(Bridge.ref(this.uv3, "Items"), vbiLength, function () {
                                    return Bridge.getDefaultValue(UnityEngine.Vector2);
                                }, UnityEngine.Vector2);
                                this.uv2.Count = (this.uv3.Count = vbiLength, vbiLength);
                            }
                            mesh.uv2 = this.uv2.Items;
                            mesh.uv3 = this.uv3.Items;
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.FillVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillLateVertexData start.*/
            FillLateVertexData: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillLateVertexData", this ); }

                if (this.settings.calculateTangents) {
                    var vertexCount = this.vertexBuffer.Count;
                    var sbi = this.submeshes.Items;
                    var submeshCount = this.submeshes.Count;
                    var vbi = this.vertexBuffer.Items;
                    var ubi = this.uvBuffer.Items;

                    Spine.Unity.MeshGenerator.SolveTangents2DEnsureSize(Bridge.ref(this, "tangents"), Bridge.ref(this, "tempTanBuffer"), vertexCount, vbi.length);
                    for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                        var submesh = sbi[i].Items;
                        var triangleCount = sbi[i].Count;
                        Spine.Unity.MeshGenerator.SolveTangents2DTriangles(this.tempTanBuffer, submesh, triangleCount, vbi, ubi, vertexCount);
                    }
                    Spine.Unity.MeshGenerator.SolveTangents2DBuffer(this.tangents, this.tempTanBuffer, vertexCount);
                    mesh.tangents = this.tangents;
                }
            },
            /*Spine.Unity.MeshGenerator.FillLateVertexData end.*/

            /*Spine.Unity.MeshGenerator.FillTriangles start.*/
            FillTriangles: function (mesh) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#FillTriangles", this ); }

                var submeshCount = this.submeshes.Count;
                var submeshesItems = this.submeshes.Items;
                mesh.subMeshCount = submeshCount;

                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    mesh.SetTriangles$4(submeshesItems[i].Items, 0, submeshesItems[i].Count, i, false);
                }
            },
            /*Spine.Unity.MeshGenerator.FillTriangles end.*/

            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity start.*/
            EnsureVertexCapacity: function (minimumVertexCount, inlcudeTintBlack, includeTangents, includeNormals) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#EnsureVertexCapacity", this ); }

                if (inlcudeTintBlack === void 0) { inlcudeTintBlack = false; }
                if (includeTangents === void 0) { includeTangents = false; }
                if (includeNormals === void 0) { includeNormals = false; }
                if (minimumVertexCount > this.vertexBuffer.Items.length) {
                    System.Array.resize(Bridge.ref(this.vertexBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                    System.Array.resize(Bridge.ref(this.uvBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector2);
                    }, UnityEngine.Vector2);
                    System.Array.resize(Bridge.ref(this.colorBuffer, "Items"), minimumVertexCount, function () {
                        return Bridge.getDefaultValue(UnityEngine.Color32);
                    }, UnityEngine.Color32);

                    if (inlcudeTintBlack) {
                        if (this.uv2 == null) {
                            this.uv2 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                            this.uv3 = new (Spine.ExposedList$1(UnityEngine.Vector2)).$ctor3(minimumVertexCount);
                        }
                        this.uv2.Resize(minimumVertexCount);
                        this.uv3.Resize(minimumVertexCount);
                    }

                    if (includeNormals) {
                        if (this.normals == null) {
                            this.normals = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector3();
                            }, UnityEngine.Vector3);
                        } else {
                            System.Array.resize(Bridge.ref(this, "normals"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector3);
                            }, UnityEngine.Vector3);
                        }

                    }

                    if (includeTangents) {
                        if (this.tangents == null) {
                            this.tangents = System.Array.init(minimumVertexCount, function (){
                                return new UnityEngine.Vector4();
                            }, UnityEngine.Vector4);
                        } else {
                            System.Array.resize(Bridge.ref(this, "tangents"), minimumVertexCount, function () {
                                return Bridge.getDefaultValue(UnityEngine.Vector4);
                            }, UnityEngine.Vector4);
                        }
                    }
                }
            },
            /*Spine.Unity.MeshGenerator.EnsureVertexCapacity end.*/

            /*Spine.Unity.MeshGenerator.TrimExcess start.*/
            /**
             * Trims internal buffers to reduce the resulting mesh data stream size.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshGenerator
             * @memberof Spine.Unity.MeshGenerator
             * @return  {void}
             */
            TrimExcess: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator#TrimExcess", this ); }

                this.vertexBuffer.TrimExcess();
                this.uvBuffer.TrimExcess();
                this.colorBuffer.TrimExcess();

                if (this.uv2 != null) {
                    this.uv2.TrimExcess();
                }
                if (this.uv3 != null) {
                    this.uv3.TrimExcess();
                }

                var vbiLength = this.vertexBuffer.Items.length;
                if (this.normals != null) {
                    System.Array.resize(Bridge.ref(this, "normals"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector3);
                    }, UnityEngine.Vector3);
                }
                if (this.tangents != null) {
                    System.Array.resize(Bridge.ref(this, "tangents"), vbiLength, function () {
                        return Bridge.getDefaultValue(UnityEngine.Vector4);
                    }, UnityEngine.Vector4);
                }
            },
            /*Spine.Unity.MeshGenerator.TrimExcess end.*/


        }
    });
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    Bridge.define("Spine.Unity.MeshGenerator.Settings", {
        $kind: 1004,
        statics: {
            props: {
                Default: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#Default#get", this ); }

                        var $t;
                        return ($t = new Spine.Unity.MeshGenerator.Settings(), $t.pmaVertexColors = true, $t.zSpacing = 0.0, $t.useClipping = true, $t.tintBlack = false, $t.calculateTangents = false, $t.addNormals = false, $t.immutableTriangles = false, $t);
                    }
                }
            },
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getDefaultValue", this ); }
 return new Spine.Unity.MeshGenerator.Settings(); }
            }
        },
        fields: {
            useClipping: false,
            zSpacing: 0,
            pmaVertexColors: false,
            tintBlack: false,
            canvasGroupTintBlack: false,
            calculateTangents: false,
            addNormals: false,
            immutableTriangles: false
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#getHashCode", this ); }

                var h = Bridge.addHash([3889943484, this.useClipping, this.zSpacing, this.pmaVertexColors, this.tintBlack, this.canvasGroupTintBlack, this.calculateTangents, this.addNormals, this.immutableTriangles]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGenerator.Settings)) {
                    return false;
                }
                return Bridge.equals(this.useClipping, o.useClipping) && Bridge.equals(this.zSpacing, o.zSpacing) && Bridge.equals(this.pmaVertexColors, o.pmaVertexColors) && Bridge.equals(this.tintBlack, o.tintBlack) && Bridge.equals(this.canvasGroupTintBlack, o.canvasGroupTintBlack) && Bridge.equals(this.calculateTangents, o.calculateTangents) && Bridge.equals(this.addNormals, o.addNormals) && Bridge.equals(this.immutableTriangles, o.immutableTriangles);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGenerator.Settings#$clone", this ); }

                var s = to || new Spine.Unity.MeshGenerator.Settings();
                s.useClipping = this.useClipping;
                s.zSpacing = this.zSpacing;
                s.pmaVertexColors = this.pmaVertexColors;
                s.tintBlack = this.tintBlack;
                s.canvasGroupTintBlack = this.canvasGroupTintBlack;
                s.calculateTangents = this.calculateTangents;
                s.addNormals = this.addNormals;
                s.immutableTriangles = this.immutableTriangles;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    Bridge.define("Spine.Unity.MeshGeneratorBuffers", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getDefaultValue", this ); }
 return new Spine.Unity.MeshGeneratorBuffers(); }
            }
        },
        fields: {
            /**
             * The vertex count that will actually be used for the mesh. The Lengths of the buffer arrays may be larger than this number.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type number
             */
            vertexCount: 0,
            /**
             * Vertex positions. To be used for UnityEngine.Mesh.vertices.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector3>
             */
            vertexBuffer: null,
            /**
             * Vertex UVs. To be used for UnityEngine.Mesh.uvs.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Vector2>
             */
            uvBuffer: null,
            /**
             * Vertex colors. To be used for UnityEngine.Mesh.colors32.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Array.<UnityEngine.Color32>
             */
            colorBuffer: null,
            /**
             * The Spine rendering component's MeshGenerator.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.MeshGeneratorBuffers
             * @type Spine.Unity.MeshGenerator
             */
            meshGenerator: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#getHashCode", this ); }

                var h = Bridge.addHash([8979862494, this.vertexCount, this.vertexBuffer, this.uvBuffer, this.colorBuffer, this.meshGenerator]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.MeshGeneratorBuffers)) {
                    return false;
                }
                return Bridge.equals(this.vertexCount, o.vertexCount) && Bridge.equals(this.vertexBuffer, o.vertexBuffer) && Bridge.equals(this.uvBuffer, o.uvBuffer) && Bridge.equals(this.colorBuffer, o.colorBuffer) && Bridge.equals(this.meshGenerator, o.meshGenerator);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshGeneratorBuffers#$clone", this ); }

                var s = to || new Spine.Unity.MeshGeneratorBuffers();
                s.vertexCount = this.vertexCount;
                s.vertexBuffer = this.vertexBuffer;
                s.uvBuffer = this.uvBuffer;
                s.colorBuffer = this.colorBuffer;
                s.meshGenerator = this.meshGenerator;
                return s;
            }
        }
    });
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    /**
     * A double-buffered Mesh, and a shared material array, bundled for use by Spine components that need to push a Mesh and materials to a Unity MeshRenderer and MeshFilter.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers", {
        inherits: [System.IDisposable],
        fields: {
            doubleBufferedMesh: null,
            submeshMaterials: null,
            sharedMaterials: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#init", this ); }

                this.submeshMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Initialize", this ); }

                if (this.doubleBufferedMesh != null) {
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.doubleBufferedMesh.GetNext().Clear();
                    this.submeshMaterials.Clear();
                } else {
                    this.doubleBufferedMesh = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.MeshRendererBuffers.Initialize end.*/

            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray start.*/
            /**
             * Returns a sharedMaterials array for use on a MeshRenderer.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {Array.<UnityEngine.Material>}
             */
            GetUpdatedSharedMaterialsArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetUpdatedSharedMaterialsArray", this ); }

                if (this.submeshMaterials.Count === this.sharedMaterials.length) {
                    this.submeshMaterials.CopyTo(this.sharedMaterials);
                } else {
                    this.sharedMaterials = this.submeshMaterials.ToArray();
                }

                return this.sharedMaterials;
            },
            /*Spine.Unity.MeshRendererBuffers.GetUpdatedSharedMaterialsArray end.*/

            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate start.*/
            /**
             * Returns true if the materials were modified since the buffers were last updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @return  {boolean}
             */
            MaterialsChangedInLastUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#MaterialsChangedInLastUpdate", this ); }

                var newSubmeshMaterials = this.submeshMaterials.Count;
                var sharedMaterials = this.sharedMaterials;
                if (newSubmeshMaterials !== sharedMaterials.length) {
                    return true;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                for (var i = 0; i < newSubmeshMaterials; i = (i + 1) | 0) {
                    if (!Bridge.referenceEquals(submeshMaterialsItems[i], sharedMaterials[i])) {
                        return true;
                    }
                } //if (submeshMaterialsItems[i].GetInstanceID() != sharedMaterials[i].GetInstanceID()) return true;

                return false;
            },
            /*Spine.Unity.MeshRendererBuffers.MaterialsChangedInLastUpdate end.*/

            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials start.*/
            /**
             * Updates the internal shared materials array with the given instruction list.
             *
             * @instance
             * @public
             * @this Spine.Unity.MeshRendererBuffers
             * @memberof Spine.Unity.MeshRendererBuffers
             * @param   {Spine.ExposedList$1}    instructions
             * @return  {void}
             */
            UpdateSharedMaterials: function (instructions) {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#UpdateSharedMaterials", this ); }

                var newSize = instructions.Count;
                { //submeshMaterials.Resize(instructions.Count);
                    if (newSize > this.submeshMaterials.Items.length) {
                        System.Array.resize(Bridge.ref(this.submeshMaterials, "Items"), newSize, null, UnityEngine.Material);
                    }
                    this.submeshMaterials.Count = newSize;
                }

                var submeshMaterialsItems = this.submeshMaterials.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < newSize; i = (i + 1) | 0) {
                    submeshMaterialsItems[i] = instructionsItems[i].material;
                }
            },
            /*Spine.Unity.MeshRendererBuffers.UpdateSharedMaterials end.*/

            /*Spine.Unity.MeshRendererBuffers.GetNextMesh start.*/
            GetNextMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#GetNextMesh", this ); }

                return this.doubleBufferedMesh.GetNext();
            },
            /*Spine.Unity.MeshRendererBuffers.GetNextMesh end.*/

            /*Spine.Unity.MeshRendererBuffers.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Clear", this ); }

                this.sharedMaterials = System.Array.init(0, null, UnityEngine.Material);
                this.submeshMaterials.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers#Dispose", this ); }

                if (this.doubleBufferedMesh == null) {
                    return;
                }
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh.GetNext().Dispose();
                this.doubleBufferedMesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    /**
     * This is a Mesh that also stores the instructions SkeletonRenderer generated for it.
     *
     * @public
     * @class Spine.Unity.MeshRendererBuffers.SmartMesh
     * @implements  System.IDisposable
     */
    Bridge.define("Spine.Unity.MeshRendererBuffers.SmartMesh", {
        inherits: [System.IDisposable],
        $kind: 1002,
        fields: {
            mesh: null,
            instructionUsed: null
        },
        alias: ["Dispose", "System$IDisposable$Dispose"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#init", this ); }

                this.mesh = Spine.Unity.SpineMesh.NewSkeletonMesh();
                this.instructionUsed = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Clear", this ); }

                this.mesh.Clear();
                this.instructionUsed.Clear();
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Clear end.*/

            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.MeshRendererBuffers.SmartMesh#Dispose", this ); }

                if (this.mesh != null) {
                    UnityEngine.Object.Destroy(this.mesh);
                }
                this.mesh = null;
            },
            /*Spine.Unity.MeshRendererBuffers+SmartMesh.Dispose end.*/


        }
    });
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    Bridge.define("Spine.Unity.NoOpTextureLoader", {
        inherits: [Spine.TextureLoader],
        alias: [
            "Load", "Spine$TextureLoader$Load",
            "Unload", "Spine$TextureLoader$Unload"
        ],
        methods: {
            /*Spine.Unity.NoOpTextureLoader.Load start.*/
            Load: function (page, path) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Load", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Load end.*/

            /*Spine.Unity.NoOpTextureLoader.Unload start.*/
            Unload: function (texture) {
if ( TRACE ) { TRACE( "Spine.Unity.NoOpTextureLoader#Unload", this ); }
 },
            /*Spine.Unity.NoOpTextureLoader.Unload end.*/


        }
    });
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    Bridge.define("Spine.Unity.OnDemandTextureLoader", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            atlasAsset: null
        },
        events: {
            onTextureRequested: null,
            onTextureLoaded: null,
            onTextureUnloaded: null
        },
        methods: {
            addTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureRequested", this ); }

                this.addonTextureRequested(value);
            },
            removeTextureRequested: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureRequested", this ); }

                this.removeonTextureRequested(value);
            },
            addTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureLoaded", this ); }

                this.addonTextureLoaded(value);
            },
            removeTextureLoaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureLoaded", this ); }

                this.removeonTextureLoaded(value);
            },
            addTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#addTextureUnloaded", this ); }

                this.addonTextureUnloaded(value);
            },
            removeTextureUnloaded: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#removeTextureUnloaded", this ); }

                this.removeonTextureUnloaded(value);
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned start.*/
            /**
             * Returns whether any main texture is null at a Material of the associated AtlasAssetBase.
             *
             * @instance
             * @public
             * @this Spine.Unity.OnDemandTextureLoader
             * @memberof Spine.Unity.OnDemandTextureLoader
             * @param   {System.Collections.Generic.List}    nullTextureMaterials    A newly created list of materials which has a null main texture assigned.
             * @return  {boolean}                                                    True, if any null main texture is assigned at a Material of the associated AtlasAssetBase.
             */
            HasNullMainTexturesAssigned: function (nullTextureMaterials) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#HasNullMainTexturesAssigned", this ); }

                var $t;
                nullTextureMaterials.v = null;
                if (!UnityEngine.Object.op_Implicit(this.atlasAsset)) {
                    return false;
                }

                var anyNullTexture = false;
                $t = Bridge.getEnumerator(this.atlasAsset.Materials, UnityEngine.Material);
                try {
                    while ($t.moveNext()) {
                        var material = $t.Current;
                        if (material.mainTexture == null) {
                            anyNullTexture = true;
                            if (nullTextureMaterials.v == null) {
                                nullTextureMaterials.v = new (System.Collections.Generic.List$1(UnityEngine.Material)).ctor();
                            }
                            nullTextureMaterials.v.add(material);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return anyNullTexture;
            },
            /*Spine.Unity.OnDemandTextureLoader.HasNullMainTexturesAssigned end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested start.*/
            OnTextureRequested: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureRequested", this ); }

                if (!Bridge.staticEquals(this.onTextureRequested, null)) {
                    this.onTextureRequested(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureRequested end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded start.*/
            OnTextureLoaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureLoaded", this ); }

                if (!Bridge.staticEquals(this.onTextureLoaded, null)) {
                    this.onTextureLoaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureLoaded end.*/

            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded start.*/
            OnTextureUnloaded: function (material, textureIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.OnDemandTextureLoader#OnTextureUnloaded", this ); }

                if (!Bridge.staticEquals(this.onTextureUnloaded, null)) {
                    this.onTextureUnloaded(this, material, textureIndex);
                }
            },
            /*Spine.Unity.OnDemandTextureLoader.OnTextureUnloaded end.*/


        }
    });
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    Bridge.define("Spine.Unity.RegionlessAttachmentLoader", {
        inherits: [Spine.AttachmentLoader],
        statics: {
            fields: {
                emptyRegion: null
            },
            props: {
                EmptyRegion: {
                    get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#EmptyRegion#get", this ); }

                        var $t, $t1, $t2;
                        if (Spine.Unity.RegionlessAttachmentLoader.emptyRegion == null) {
                            Spine.Unity.RegionlessAttachmentLoader.emptyRegion = ($t = new Spine.AtlasRegion(), $t.name = "Empty AtlasRegion", $t.page = ($t1 = new Spine.AtlasPage(), $t1.name = "Empty AtlasPage", $t1.rendererObject = ($t2 = new UnityEngine.Material.$ctor2(UnityEngine.Shader.Find("Spine/Special/HiddenPass")), $t2.name = "NoRender Material", $t2), $t1), $t);
                        }
                        return Spine.Unity.RegionlessAttachmentLoader.emptyRegion;
                    }
                }
            }
        },
        alias: [
            "NewBoundingBoxAttachment", "Spine$AttachmentLoader$NewBoundingBoxAttachment",
            "NewPathAttachment", "Spine$AttachmentLoader$NewPathAttachment",
            "NewPointAttachment", "Spine$AttachmentLoader$NewPointAttachment",
            "NewClippingAttachment", "Spine$AttachmentLoader$NewClippingAttachment"
        ],
        methods: {
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment start.*/
            NewRegionAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewRegionAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.RegionAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewRegionAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment start.*/
            NewMeshAttachment: function (skin, name, path, sequence) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewMeshAttachment", this ); }

                var $t;
                var attachment = ($t = new Spine.MeshAttachment(name), $t.region = Spine.Unity.RegionlessAttachmentLoader.EmptyRegion, $t);
                return attachment;
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewMeshAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment start.*/
            NewBoundingBoxAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewBoundingBoxAttachment", this ); }

                return new spine.BoundingBoxAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewBoundingBoxAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment start.*/
            NewPathAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPathAttachment", this ); }

                return new spine.PathAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPathAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment start.*/
            NewPointAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewPointAttachment", this ); }

                return new spine.PointAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewPointAttachment end.*/

            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment start.*/
            NewClippingAttachment: function (skin, name) {
if ( TRACE ) { TRACE( "Spine.Unity.RegionlessAttachmentLoader#NewClippingAttachment", this ); }

                return new spine.ClippingAttachment( name );
            },
            /*Spine.Unity.RegionlessAttachmentLoader.NewClippingAttachment end.*/


        }
    });
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    Bridge.define("Spine.Unity.SkeletonDataAsset", {
        inherits: [UnityEngine.ScriptableObject],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}            skeletonDataFile    
                 * @param   {Spine.Unity.AtlasAssetBase}       atlasAsset          
                 * @param   {boolean}                          initialize          
                 * @param   {number}                           scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance: function (skeletonDataFile, atlasAsset, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    return Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1(skeletonDataFile, System.Array.init([atlasAsset], Spine.Unity.AtlasAssetBase), initialize, scale);
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime SkeletonDataAsset.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonDataAsset
                 * @memberof Spine.Unity.SkeletonDataAsset
                 * @param   {UnityEngine.TextAsset}                 skeletonDataFile    
                 * @param   {Array.<Spine.Unity.AtlasAssetBase>}    atlasAssets         
                 * @param   {boolean}                               initialize          
                 * @param   {number}                                scale
                 * @return  {Spine.Unity.SkeletonDataAsset}
                 */
                CreateRuntimeInstance$1: function (skeletonDataFile, atlasAssets, initialize, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#CreateRuntimeInstance$1", this ); }

                    if (scale === void 0) { scale = 0.01; }
                    var skeletonDataAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SkeletonDataAsset);
                    skeletonDataAsset.Clear();
                    skeletonDataAsset.skeletonJSON = skeletonDataFile;
                    skeletonDataAsset.atlasAssets = atlasAssets;
                    skeletonDataAsset.scale = scale;

                    if (initialize) {
                        skeletonDataAsset.GetSkeletonData(true);
                    }

                    return skeletonDataAsset;
                },
                /*Spine.Unity.SkeletonDataAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static start.*/
                ReadSkeletonData: function (bytes, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData", this ); }

                    var $t;
                    var input = new System.IO.MemoryStream.$ctor1(bytes);
                    try {
                        var binary = ($t = new Spine.SkeletonBinary(attachmentLoader), $t.scale = scale, $t);
                        return binary.ReadSkeletonData(input);
                    }
                    finally {
                        if (Bridge.hasValue(input)) {
                            input.System$IDisposable$Dispose();
                        }
                    }
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData:static end.*/

                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static start.*/
                ReadSkeletonData$1: function (text, attachmentLoader, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#ReadSkeletonData$1", this ); }

                    var $t;
                    var input = new System.IO.StringReader(text);
                    var json = ($t = new Spine.SkeletonJson(attachmentLoader), $t.scale = scale, $t);
                    return json.ReadSkeletonData(input);
                },
                /*Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1:static end.*/


            }
        },
        fields: {
            atlasAssets: null,
            scale: 0,
            skeletonJSON: null,
            isUpgradingBlendModeMaterials: false,
            blendModeMaterials: null,
            skeletonDataModifiers: null,
            fromAnimation: null,
            toAnimation: null,
            duration: null,
            defaultMix: 0,
            controller: null,
            skeletonData: null,
            stateData: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#IsLoaded#get", this ); }

                    return this.skeletonData != null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#init", this ); }

                this.atlasAssets = System.Array.init(0, null, Spine.Unity.AtlasAssetBase);
                this.scale = 0.01;
                this.isUpgradingBlendModeMaterials = false;
                this.blendModeMaterials = new Spine.Unity.BlendModeMaterials();
                this.skeletonDataModifiers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonDataModifierAsset)).ctor();
                this.fromAnimation = System.Array.init(0, null, System.String);
                this.toAnimation = System.Array.init(0, null, System.String);
                this.duration = System.Array.init(0, 0, System.Single);
            }
        },
        methods: {
            /*Spine.Unity.SkeletonDataAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SkeletonDataAsset.Reset end.*/

            /*Spine.Unity.SkeletonDataAsset.Clear start.*/
            /**
             * Clears the loaded SkeletonData and AnimationStateData. Use this to force a reload for the next time GetSkeletonData is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#Clear", this ); }

                this.skeletonData = null;
                this.stateData = null;
            },
            /*Spine.Unity.SkeletonDataAsset.Clear end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData start.*/
            GetAnimationStateData: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAnimationStateData", this ); }

                if (this.stateData != null) {
                    return this.stateData;
                }
                this.GetSkeletonData(false);
                return this.stateData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetAnimationStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData start.*/
            /**
             * Loads, caches and returns the SkeletonData from the skeleton data file. Returns the cached SkeletonData after the first time it is called. Pass false to prevent direct errors from being logged.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonDataAsset
             * @memberof Spine.Unity.SkeletonDataAsset
             * @param   {boolean}               quiet
             * @return  {Spine.SkeletonData}
             */
            GetSkeletonData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetSkeletonData", this ); }

                var $t;
                if (this.skeletonJSON == null) {
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Skeleton JSON file not set for SkeletonData asset: " + (this.name || ""), this);
                    }
                    this.Clear();
                    return null;
                }

                // Disabled to support attachmentless/skinless SkeletonData.
                //			if (atlasAssets == null) {
                //				atlasAssets = new AtlasAsset[0];
                //				if (!quiet)
                //					Debug.LogError("Atlas not set for SkeletonData asset: " + name, this);
                //				Clear();
                //				return null;
                //			}
                //			#if !SPINE_TK2D
                //			if (atlasAssets.Length == 0) {
                //				Clear();
                //				return null;
                //			}
                //			#else
                //			if (atlasAssets.Length == 0 && spriteCollection == null) {
                //				Clear();
                //				return null;
                //			}
                //			#endif

                if (this.skeletonData != null) {
                    return this.skeletonData;
                }

                var attachmentLoader;
                var skeletonDataScale;
                var atlasArray = this.GetAtlasArray();

                attachmentLoader = (atlasArray.length === 0) ? Bridge.cast(new Spine.Unity.RegionlessAttachmentLoader(), Spine.AttachmentLoader) : Bridge.cast(new Spine.AtlasAttachmentLoader(atlasArray), Spine.AttachmentLoader);
                skeletonDataScale = this.scale;

                var hasBinaryExtension = System.String.contains(this.skeletonJSON.name.toLowerCase(),".skel");
                var loadedSkeletonData = null;

                try {
                    if (hasBinaryExtension) {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData(this.skeletonJSON.bytes, attachmentLoader, skeletonDataScale);
                    } else {
                        loadedSkeletonData = Spine.Unity.SkeletonDataAsset.ReadSkeletonData$1(this.skeletonJSON.text, attachmentLoader, skeletonDataScale);
                    }
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    if (!quiet) {
                        UnityEngine.Debug.LogError$2("Error reading skeleton JSON file for SkeletonData asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this.skeletonJSON);
                    }
                }

                if (loadedSkeletonData == null) {
                    return null;
                }

                if (this.skeletonDataModifiers != null) {
                    $t = Bridge.getEnumerator(this.skeletonDataModifiers);
                    try {
                        while ($t.moveNext()) {
                            var modifier = $t.Current;
                            if (modifier != null && !(this.isUpgradingBlendModeMaterials && Bridge.is(modifier, Spine.Unity.BlendModeMaterialsAsset))) {
                                modifier.Apply(loadedSkeletonData);
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
                if (!this.isUpgradingBlendModeMaterials) {
                    this.blendModeMaterials.ApplyMaterials(loadedSkeletonData);
                }

                this.InitializeWithData(loadedSkeletonData);

                return this.skeletonData;
            },
            /*Spine.Unity.SkeletonDataAsset.GetSkeletonData end.*/

            /*Spine.Unity.SkeletonDataAsset.InitializeWithData start.*/
            InitializeWithData: function (sd) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#InitializeWithData", this ); }

                this.skeletonData = sd;
                this.stateData = new spine.AnimationStateData( this.skeletonData );
                this.FillStateData();
            },
            /*Spine.Unity.SkeletonDataAsset.InitializeWithData end.*/

            /*Spine.Unity.SkeletonDataAsset.FillStateData start.*/
            FillStateData: function (quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#FillStateData", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.stateData != null) {
                    this.stateData.defaultMix = this.defaultMix;

                    for (var i = 0, n = this.fromAnimation.length; i < n; i = (i + 1) | 0) {
                        var fromAnimationName = this.fromAnimation[i];
                        var toAnimationName = this.toAnimation[i];
                        if (fromAnimationName.length === 0 || toAnimationName.length === 0) {
                            continue;
                        }
                        this.stateData.setMix(fromAnimationName, toAnimationName, this.duration[i]);
                    }
                }
            },
            /*Spine.Unity.SkeletonDataAsset.FillStateData end.*/

            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray start.*/
            GetAtlasArray: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataAsset#GetAtlasArray", this ); }

                var returnList = new (System.Collections.Generic.List$1(Spine.Atlas)).$ctor2(this.atlasAssets.length);
                for (var i = 0; i < this.atlasAssets.length; i = (i + 1) | 0) {
                    var aa = this.atlasAssets[i];
                    if (aa == null) {
                        continue;
                    }
                    var a = aa.GetAtlas();
                    if (a == null) {
                        continue;
                    }
                    returnList.add(a);
                }
                return returnList.ToArray();
            },
            /*Spine.Unity.SkeletonDataAsset.GetAtlasArray end.*/


        }
    });
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility");
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", {
        $kind: 1002,
        fields: {
            actualVersion: null,
            compatibleVersions: null,
            explicitProblemDescription: null
        },
        methods: {
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString start.*/
            DescriptionString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo#DescriptionString", this ); }

                var $t, $t1, $t2;
                if (!System.String.isNullOrEmpty(this.explicitProblemDescription)) {
                    return this.explicitProblemDescription;
                }

                var compatibleVersionString = "";
                var optionalOr = null;
                $t = Bridge.getEnumerator(this.compatibleVersions);
                try {
                    while ($t.moveNext()) {
                        var version = $t.Current;
                        compatibleVersionString = (compatibleVersionString || "") + ((System.String.format("{0}{1}.{2}", optionalOr, Bridge.box(version[0], System.Int32), Bridge.box(version[1], System.Int32))) || "");
                        optionalOr = " or ";
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                return System.String.format("Skeleton data could not be loaded. Data version: {0}. Required version: {1}.\nPlease re-export skeleton data with Spine {1} or change runtime to version {2}.{3}.", this.actualVersion.rawVersion, compatibleVersionString, Bridge.box(($t1 = this.actualVersion.version)[0], System.Int32), Bridge.box(($t2 = this.actualVersion.version)[1], System.Int32));
            },
            /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo.DescriptionString end.*/


        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.SourceType", {
        $kind: 1006,
        statics: {
            fields: {
                Json: 0,
                Binary: 1
            }
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonDataCompatibility.VersionInfo", {
        $kind: 1002,
        fields: {
            rawVersion: null,
            version: null,
            sourceType: 0
        }
    });
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    Bridge.define("Spine.Unity.SkeletonExtensions", {
        statics: {
            fields: {
                ByteToFloat: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#init", this ); }

                    this.ByteToFloat = 0.003921569;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static start.*/
                GetColor$2: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$2", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$1:static start.*/
                GetColor$1: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$1", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor:static start.*/
                GetColor: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor", this ); }

                    return new pc.Color( a.color.r, a.color.g, a.color.b, a.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColor$3:static start.*/
                GetColor$3: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColor$3", this ); }

                    return new pc.Color( s.color.r, s.color.g, s.color.b, s.color.a );
                },
                /*Spine.Unity.SkeletonExtensions.GetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static start.*/
                GetColorTintBlack: function (s) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetColorTintBlack", this ); }

                    return new pc.Color( s.darkColor.r || 0, s.darkColor.g || 0, s.darkColor.b || 0, 1.0 );
                },
                /*Spine.Unity.SkeletonExtensions.GetColorTintBlack:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$4:static start.*/
                SetColor$4: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$4", this ); }

                    skeleton.color.a = color.a;
                    skeleton.color.r = color.r;
                    skeleton.color.g = color.g;
                    skeleton.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$5:static start.*/
                SetColor$5: function (skeleton, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$5", this ); }

                    skeleton.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    skeleton.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$5:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$6:static start.*/
                SetColor$6: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$6", this ); }

                    slot.color.a = color.a;
                    slot.color.r = color.r;
                    slot.color.g = color.g;
                    slot.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$6:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$7:static start.*/
                SetColor$7: function (slot, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$7", this ); }

                    slot.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    slot.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$7:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$2:static start.*/
                SetColor$2: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$2", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$3:static start.*/
                SetColor$3: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$3", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor:static start.*/
                SetColor: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor", this ); }

                    attachment.color.a = color.a;
                    attachment.color.r = color.r;
                    attachment.color.g = color.g;
                    attachment.color.b = color.b;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetColor$1:static start.*/
                SetColor$1: function (attachment, color) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetColor$1", this ); }

                    attachment.color.a = color.a * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.r = color.r * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.g = color.g * Spine.Unity.SkeletonExtensions.ByteToFloat;
                    attachment.color.b = color.b * Spine.Unity.SkeletonExtensions.ByteToFloat;
                },
                /*Spine.Unity.SkeletonExtensions.SetColor$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static start.*/
                /**
                 * Sets the Skeleton's local scale using a UnityEngine.Vector2. If only individual components need to be set, set Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton    
                 * @param   {UnityEngine.Vector2}    scale
                 * @return  {void}
                 */
                SetLocalScale: function (skeleton, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalScale", this ); }

                    skeleton.scaleX = scale.x;
                    skeleton.scaleY = scale.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static start.*/
                /**
                 * Gets the internal bone matrix as a Unity bonespace-to-skeletonspace transformation matrix.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone
                 * @return  {UnityEngine.Matrix4x4}
                 */
                GetMatrix4x4: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMatrix4x4", this ); }

                    var $t;
                    return ($t = new pc.Mat4.ctor(), $t.e00 = bone.a, $t.e01 = bone.b, $t.e03 = bone.worldX, $t.e10 = bone.c, $t.e11 = bone.d, $t.e13 = bone.worldY, $t.e33 = 1, $t);
                },
                /*Spine.Unity.SkeletonExtensions.GetMatrix4x4:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector2
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector2}    position
                 * @return  {void}
                 */
                SetLocalPosition: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static start.*/
                /**
                 * Sets the bone's (local) X and Y according to a Vector3. The z component is ignored.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone        
                 * @param   {UnityEngine.Vector3}    position
                 * @return  {void}
                 */
                SetLocalPosition$1: function (bone, position) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetLocalPosition$1", this ); }

                    bone.x = position.x;
                    bone.y = position.y;
                },
                /*Spine.Unity.SkeletonExtensions.SetLocalPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static start.*/
                /**
                 * Gets the bone's local X and Y as a Vector2.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalPosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalPosition", this ); }

                    return new pc.Vec2( bone.x, bone.y );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static start.*/
                /**
                 * Gets the position of the bone in Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition", this ); }

                    return new pc.Vec2( bone.worldX, bone.worldY );
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static start.*/
                /**
                 * Gets a local offset from the bone and converts it into Skeleton-space.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone         
                 * @param   {UnityEngine.Vector2}    boneLocal
                 * @return  {UnityEngine.Vector2}
                 */
                GetSkeletonSpacePosition$1: function (bone, boneLocal) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetSkeletonSpacePosition$1", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.LocalToWorld(boneLocal.x, boneLocal.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.GetSkeletonSpacePosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static start.*/
                /**
                 * Gets the bone's Unity World position using its Spine GameObject Transform. UpdateWorldTransform needs to have been called for this to return the correct, updated value.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition: function (bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX, bone.worldY, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static start.*/
                GetWorldPosition$1: function (bone, spineGameObjectTransform, positionScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$1", this ); }

                    return spineGameObjectTransform.TransformPoint$1(new pc.Vec3( bone.worldX * positionScale, bone.worldY * positionScale, 0 ));
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$1:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Slot}               slot                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$3: function (attachment, slot, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$3", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(slot.bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$3:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static start.*/
                /**
                 * Gets the PointAttachment's Unity World position using its Spine GameObject Transform.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.PointAttachment}    attachment                  
                 * @param   {Spine.Bone}               bone                        
                 * @param   {UnityEngine.Transform}    spineGameObjectTransform
                 * @return  {UnityEngine.Vector3}
                 */
                GetWorldPosition$2: function (attachment, bone, spineGameObjectTransform) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldPosition$2", this ); }

                    var skeletonSpacePosition = new UnityEngine.Vector3();
                    skeletonSpacePosition.z = 0;
                    attachment.ComputeWorldPosition(bone, Bridge.ref(skeletonSpacePosition, "x"), Bridge.ref(skeletonSpacePosition, "y"));
                    return spineGameObjectTransform.TransformPoint$1(skeletonSpacePosition);
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldPosition$2:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static start.*/
                /**
                 * Gets a skeleton space UnityEngine.Quaternion representation of bone.WorldRotationX.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetQuaternion", this ); }

                    var halfRotation = Math.atan2(bone.c, bone.a) * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static start.*/
                /**
                 * Gets a bone-local space UnityEngine.Quaternion representation of bone.rotation.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}                bone
                 * @return  {UnityEngine.Quaternion}
                 */
                GetLocalQuaternion: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalQuaternion", this ); }

                    var halfRotation = bone.rotation * UnityEngine.Mathf.Deg2Rad * 0.5;
                    return new pc.Quat( 0, 0, Math.sin(halfRotation), Math.cos(halfRotation) );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalQuaternion:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static start.*/
                /**
                 * Returns the Skeleton's local scale as a UnityEngine.Vector2. If only individual components are needed, use Skeleton.ScaleX or Skeleton.ScaleY.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Skeleton}         skeleton
                 * @return  {UnityEngine.Vector2}
                 */
                GetLocalScale: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalScale", this ); }

                    return new pc.Vec2( skeleton.scaleX, skeleton.scaleY );
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalScale:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static start.*/
                /**
                 * Calculates a 2x2 Transformation Matrix that can convert a skeleton-space position to a bone-local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}       bone    
                 * @param   {System.Single}    ia      
                 * @param   {System.Single}    ib      
                 * @param   {System.Single}    ic      
                 * @param   {System.Single}    id
                 * @return  {void}
                 */
                GetWorldToLocalMatrix: function (bone, ia, ib, ic, id) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldToLocalMatrix", this ); }

                    var a = bone.a, b = bone.b, c = bone.c, d = bone.d;
                    var invDet = 1 / (a * d - b * c);
                    ia.v = invDet * d;
                    ib.v = invDet * -b;
                    ic.v = invDet * -c;
                    id.v = invDet * a;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix:static end.*/

                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static start.*/
                /**
                 * UnityEngine.Vector2 override of Bone.WorldToLocal. This converts a skeleton-space position into a bone local position.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone             
                 * @param   {UnityEngine.Vector2}    worldPosition
                 * @return  {UnityEngine.Vector2}
                 */
                WorldToLocal: function (bone, worldPosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#WorldToLocal", this ); }

                    var o = new UnityEngine.Vector2();
                    bone.WorldToLocal(worldPosition.x, worldPosition.y, Bridge.ref(o, "x"), Bridge.ref(o, "y"));
                    return o.$clone();
                },
                /*Spine.Unity.SkeletonExtensions.WorldToLocal:static end.*/

                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static start.*/
                /**
                 * Sets the skeleton-space position of a bone.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {Spine.Bone}             bone                     
                 * @param   {UnityEngine.Vector2}    skeletonSpacePosition
                 * @return  {UnityEngine.Vector2}                             The local position in its parent bone space, or in skeleton space if it is the root bone.
                 */
                SetPositionSkeletonSpace: function (bone, skeletonSpacePosition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#SetPositionSkeletonSpace", this ); }

                    if (bone.parent == null) { // root bone
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, skeletonSpacePosition.$clone());
                        return skeletonSpacePosition.$clone();
                    } else {
                        var parent = bone.parent;
                        var parentLocal = Spine.Unity.SkeletonExtensions.WorldToLocal(parent, skeletonSpacePosition.$clone());
                        Spine.Unity.SkeletonExtensions.SetLocalPosition(bone, parentLocal.$clone());
                        return parentLocal.$clone();
                    }
                },
                /*Spine.Unity.SkeletonExtensions.SetPositionSkeletonSpace:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetMaterial:static start.*/
                GetMaterial: function (a) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetMaterial", this ); }

                    var rendererObject = null;
                    var renderableAttachment = Bridge.as(a, Spine.IHasTextureRegion);
                    if (renderableAttachment != null) {
                        rendererObject = renderableAttachment.Spine$IHasTextureRegion$Region;
                    }

                    if (rendererObject == null) {
                        return null;
                    }

                    return Bridge.cast(Bridge.cast(rendererObject, Spine.AtlasRegion).page.rendererObject, UnityEngine.Material);
                },
                /*Spine.Unity.SkeletonExtensions.GetMaterial:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static start.*/
                /**
                 * Fills a Vector2 buffer with local vertices.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         va        The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetLocalVertices: function (va, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetLocalVertices", this ); }

                    var floatsCount = va.worldVerticesLength;
                    var bufferTargetSize = floatsCount >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", va.name, Bridge.box(floatsCount, System.Int32)), "buffer");
                    }

                    if (va.bones == null && slot.Deform.Count === 0) {
                        var localVerts = va.vertices;
                        for (var i = 0; i < bufferTargetSize; i = (i + 1) | 0) {
                            var j = Bridge.Int.mul(i, 2);
                            buffer[i] = new pc.Vec2( localVerts[j], localVerts[((j + 1) | 0)] );
                        }
                    } else {
                        var floats = System.Array.init(floatsCount, 0, System.Single);
                        va.computeWorldVertices( slot, 0, va.worldVerticesLength, floats, 0, 2 );

                        var sb = slot.bone;
                        var ia = { }, ib = { }, ic = { }, id = { }, bwx = sb.worldX, bwy = sb.worldY;
                        Spine.Unity.SkeletonExtensions.GetWorldToLocalMatrix(sb, ia, ib, ic, id);

                        for (var i1 = 0; i1 < bufferTargetSize; i1 = (i1 + 1) | 0) {
                            var j1 = Bridge.Int.mul(i1, 2);
                            var x = floats[j1] - bwx, y = floats[((j1 + 1) | 0)] - bwy;
                            buffer[i1] = new pc.Vec2( x * ia.v + y * ib.v, x * ic.v + y * id.v );
                        }
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetLocalVertices:static end.*/

                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static start.*/
                /**
                 * Calculates world vertices and fills a Vector2 buffer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonExtensions
                 * @memberof Spine.Unity.SkeletonExtensions
                 * @param   {spine.VertexAttachment}         a         The VertexAttachment
                 * @param   {Spine.Slot}                     slot      Slot where the attachment belongs.
                 * @param   {Array.<UnityEngine.Vector2>}    buffer    Correctly-sized buffer. Use attachment's .WorldVerticesLength to get the correct size. If null, a new Vector2[] of the correct size will be allocated.
                 * @return  {Array.<UnityEngine.Vector2>}
                 */
                GetWorldVertices: function (a, slot, buffer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonExtensions#GetWorldVertices", this ); }

                    var worldVertsLength = a.worldVerticesLength;
                    var bufferTargetSize = worldVertsLength >> 1;
                    buffer = buffer || System.Array.init(bufferTargetSize, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    if (buffer.length < bufferTargetSize) {
                        throw new System.ArgumentException.$ctor3(System.String.format("Vector2 buffer too small. {0} requires an array of size {1}. Use the attachment's .WorldVerticesLength to get the correct size.", a.name, Bridge.box(worldVertsLength, System.Int32)), "buffer");
                    }

                    var floats = System.Array.init(worldVertsLength, 0, System.Single);
                    a.computeWorldVertices( slot, 0, a.worldVerticesLength, floats, 0, 2 );

                    for (var i = 0, n = worldVertsLength >> 1; i < n; i = (i + 1) | 0) {
                        var j = Bridge.Int.mul(i, 2);
                        buffer[i] = new pc.Vec2( floats[j], floats[((j + 1) | 0)] );
                    }

                    return buffer;
                },
                /*Spine.Unity.SkeletonExtensions.GetWorldVertices:static end.*/


            }
        }
    });
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic.LayoutMode", {
        $kind: 1006,
        statics: {
            fields: {
                None: 0,
                WidthControlsHeight: 1,
                HeightControlsWidth: 2,
                FitInParent: 3,
                EnvelopeParent: 4
            }
        }
    });
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonGraphic: null,
            customMaterialOverrides: null,
            customTextureOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#init", this ); }

                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)).ctor();
                this.customTextureOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomMaterialOverride.setItem(atlasMaterialOverride.originalTexture, atlasMaterialOverride.replacementMaterial);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonGraphic.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalTexture, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomMaterialOverride.remove(atlasMaterialOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides start.*/
            SetCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#SetCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    if (atlasTextureOverride.overrideEnabled) {
                        this.skeletonGraphic.CustomTextureOverride.setItem(atlasTextureOverride.originalTexture, atlasTextureOverride.replacementTexture);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.SetCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides start.*/
            RemoveCustomTextureOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#RemoveCustomTextureOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                for (var i = 0; i < this.customTextureOverrides.Count; i = (i + 1) | 0) {
                    var atlasTextureOverride = this.customTextureOverrides.getItem(i).$clone();
                    var currentTexture = { };

                    if (!this.skeletonGraphic.CustomTextureOverride.tryGetValue(atlasTextureOverride.originalTexture, currentTexture)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentTexture.v, atlasTextureOverride.replacementTexture)) {
                        continue;
                    }

                    this.skeletonGraphic.CustomTextureOverride.remove(atlasTextureOverride.originalTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.RemoveCustomTextureOverrides end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.skeletonGraphic.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    UnityEngine.Debug.LogError$2("skeletonGraphic == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomTextureOverrides();
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideEnabled, this.originalTexture, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    Bridge.define("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride(); }
            }
        },
        fields: {
            overrideEnabled: false,
            originalTexture: null,
            replacementTexture: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonGraphicCustomMaterials$AtlasTextureOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#equalsT", this ); }

                return this.overrideEnabled === other.overrideEnabled && Bridge.referenceEquals(this.originalTexture, other.originalTexture) && Bridge.referenceEquals(this.replacementTexture, other.replacementTexture);
            },
            /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#getHashCode", this ); }

                var h = Bridge.addHash([8976735721, this.overrideEnabled, this.originalTexture, this.replacementTexture]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride();
                s.overrideEnabled = this.overrideEnabled;
                s.originalTexture = this.originalTexture;
                s.replacementTexture = this.replacementTexture;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasTextureOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator", {
        $kind: 1002,
        statics: {
            fields: {
                WeightEpsilon: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                    this.WeightEpsilon = 0.0001;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static start.*/
                AnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#AnimationTime", this ); }

                    var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.ToSpineAnimationTime(normalizedTime, clipLength, loop, reversed);
                    if (loop) {
                        return time;
                    }
                    var EndSnapEpsilon = 0.0333333351; // Workaround for end-duration keys not being applied.
                    return (clipLength - time < EndSnapEpsilon) ? clipLength : time; // return a time snapped to clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.AnimationTime:static end.*/

                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static start.*/
                ToSpineAnimationTime: function (normalizedTime, clipLength, loop, reversed) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ToSpineAnimationTime", this ); }

                    if (reversed) {
                        normalizedTime = (1 - normalizedTime);
                    }
                    if (normalizedTime < 0.0) {
                        normalizedTime = loop ? (normalizedTime % 1.0) + 1.0 : 0.0;
                    }
                    return normalizedTime * clipLength;
                },
                /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ToSpineAnimationTime:static end.*/


            }
        },
        fields: {
            autoReset: false,
            useCustomMixMode: false,
            layerMixModes: null,
            layerBlendModes: null,
            animationTable: null,
            clipNameHashCodeTable: null,
            previousAnimations: null,
            layerClipInfos: null,
            animator: null
        },
        events: {
            _OnClipApplied: null
        },
        props: {
            Animator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Animator#get", this ); }

                    return this.animator;
                }
            },
            MecanimLayerCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerCount#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return 0;
                    }
                    return this.animator.layerCount;
                }
            },
            MecanimLayerNames: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#MecanimLayerNames#get", this ); }

                    if (!UnityEngine.Object.op_Implicit(this.animator)) {
                        return System.Array.init(0, null, System.String);
                    }
                    var layerNames = System.Array.init(this.animator.layerCount, null, System.String);
                    for (var i = 0; i < this.animator.layerCount; i = (i + 1) | 0) {
                        layerNames[i] = this.animator.GetLayerName(i);
                    }
                    return layerNames;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#init", this ); }

                this.autoReset = true;
                this.useCustomMixMode = true;
                this.layerMixModes = System.Array.init(0, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                this.layerBlendModes = System.Array.init(0, 0, spine.MixBlend);
                this.animationTable = new (System.Collections.Generic.Dictionary$2(System.Int32,Spine.Animation)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer.Instance);
                this.clipNameHashCodeTable = new (System.Collections.Generic.Dictionary$2(UnityEngine.AnimationClip,System.Int32)).$ctor3(Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer.Instance);
                this.previousAnimations = new (System.Collections.Generic.List$1(Spine.Animation)).ctor();
                this.layerClipInfos = System.Array.init(0, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
            }
        },
        methods: {
            addOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#addOnClipApplied", this ); }

                this.add_OnClipApplied(value);
            },
            removeOnClipApplied: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#removeOnClipApplied", this ); }

                this.remove_OnClipApplied(value);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize start.*/
            Initialize: function (animator, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Initialize", this ); }

                var $t;
                this.animator = animator;

                this.previousAnimations.clear();

                this.animationTable.clear();
                var data = skeletonDataAsset.GetSkeletonData(true);
                $t = Bridge.getEnumerator(data.Animations);
                try {
                    while ($t.moveNext()) {
                        var a = $t.Current;
                        this.animationTable.add(Bridge.getHashCode(a.name), a);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.clipNameHashCodeTable.clear();
                this.ClearClipInfosForLayers();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation start.*/
            ApplyAnimation: function (skeleton, info, stateInfo, layerIndex, layerWeight, layerBlendMode, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }
                var weight = info.weight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation start.*/
            ApplyInterruptionAnimation: function (skeleton, interpolateWeightTo1, info, stateInfo, layerIndex, layerWeight, layerBlendMode, interruptingClipTimeAddition, useClipWeight1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ApplyInterruptionAnimation", this ); }

                if (useClipWeight1 === void 0) { useClipWeight1 = false; }

                var clipWeight = interpolateWeightTo1 ? (info.weight + 1.0) * 0.5 : info.weight;
                var weight = clipWeight * layerWeight;
                if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                    return false;
                }

                var clip = this.GetAnimation(info.clip);
                if (clip == null) {
                    return false;
                }

                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime + interruptingClipTimeAddition, info.clip.length, info.clip.isLooping, stateInfo.speed < 0);
                weight = useClipWeight1 ? layerWeight : weight;
                clip.apply(skeleton, 0, time, info.clip.isLooping, null, weight, layerBlendMode, spine.MixDirection.mixIn);
                if (!Bridge.staticEquals(this._OnClipApplied, null)) {
                    this.OnClipAppliedCallback(clip, stateInfo, layerIndex, time, info.clip.isLooping, weight);
                }
                return true;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ApplyInterruptionAnimation end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback start.*/
            OnClipAppliedCallback: function (clip, stateInfo, layerIndex, time, isLooping, weight) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#OnClipAppliedCallback", this ); }


                var speedFactor = stateInfo.speedMultiplier * stateInfo.speed;
                var lastTime = time - (UnityEngine.Time.deltaTime * speedFactor);
                var clipDuration = clip.duration;
                if (isLooping && clipDuration !== 0) {
                    time %= clipDuration;
                    lastTime %= clipDuration;
                }
                this._OnClipApplied(clip, layerIndex, weight, time, lastTime, speedFactor < 0);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.OnClipAppliedCallback end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply start.*/
            Apply: function (skeleton) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#Apply", this ); }


                if (this.layerMixModes.length < this.animator.layerCount) {
                    var oldSize = this.layerMixModes.length;
                    System.Array.resize(Bridge.ref(this, "layerMixModes"), this.animator.layerCount, 0, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode);
                    for (var layer = oldSize; layer < this.animator.layerCount; layer = (layer + 1) | 0) {
                        var isAdditiveLayer = false;
                        if (layer < this.layerBlendModes.length) {
                            isAdditiveLayer = this.layerBlendModes[layer] === spine.MixBlend.add;
                        }
                        this.layerMixModes[layer] = isAdditiveLayer ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                    }
                }

                this.InitClipInfosForLayers();
                for (var layer1 = 0, n = this.animator.layerCount; layer1 < n; layer1 = (layer1 + 1) | 0) {
                    this.GetStateUpdatesFromAnimator(layer1);
                }

                // Clear Previous
                if (this.autoReset) {
                    var previousAnimations = this.previousAnimations;
                    for (var i = 0, n1 = previousAnimations.Count; i < n1; i = (i + 1) | 0) {
                        previousAnimations.getItem(i).apply(skeleton, 0, 0, false, null, 0, spine.MixBlend.setup, spine.MixDirection.mixOut);
                    } // SetKeyedItemsToSetupPose

                    previousAnimations.clear();
                    for (var layer2 = 0, n2 = this.animator.layerCount; layer2 < n2; layer2 = (layer2 + 1) | 0) {
                        var layerWeight = (layer2 === 0) ? 1 : this.animator.GetLayerWeight(layer2); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.
                        if (layerWeight <= 0) {
                            continue;
                        }

                        var nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer2);

                        var hasNext = nextStateInfo.fullPathHash !== 0;

                        var clipInfoCount = { }, nextClipInfoCount = { }, interruptingClipInfoCount = { };
                        var clipInfo = { }, nextClipInfo = { }, interruptingClipInfo = { };
                        var isInterruptionActive = { }, shallInterpolateWeightTo1 = { };
                        this.GetAnimatorClipInfos(layer2, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1);

                        for (var c = 0; c < clipInfoCount.v; c = (c + 1) | 0) {
                            var info = System.Array.getItem(clipInfo.v, c, UnityEngine.AnimatorClipInfo).$clone();
                            var weight = info.weight * layerWeight;
                            if (weight < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                continue;
                            }
                            var clip = this.GetAnimation(info.clip);
                            if (clip != null) {
                                previousAnimations.add(clip);
                            }
                        }

                        if (hasNext) {
                            for (var c1 = 0; c1 < nextClipInfoCount.v; c1 = (c1 + 1) | 0) {
                                var info1 = System.Array.getItem(nextClipInfo.v, c1, UnityEngine.AnimatorClipInfo).$clone();
                                var weight1 = info1.weight * layerWeight;
                                if (weight1 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip1 = this.GetAnimation(info1.clip);
                                if (clip1 != null) {
                                    previousAnimations.add(clip1);
                                }
                            }
                        }

                        if (isInterruptionActive.v) {
                            for (var c2 = 0; c2 < interruptingClipInfoCount.v; c2 = (c2 + 1) | 0) {
                                var info2 = System.Array.getItem(interruptingClipInfo.v, c2, UnityEngine.AnimatorClipInfo).$clone();
                                var clipWeight = shallInterpolateWeightTo1.v ? (info2.weight + 1.0) * 0.5 : info2.weight;
                                var weight2 = clipWeight * layerWeight;
                                if (weight2 < Spine.Unity.SkeletonMecanim.MecanimTranslator.WeightEpsilon) {
                                    continue;
                                }
                                var clip2 = this.GetAnimation(info2.clip);
                                if (clip2 != null) {
                                    previousAnimations.add(clip2);
                                }
                            }
                        }
                    }
                }

                // Apply
                for (var layer3 = 0, n3 = this.animator.layerCount; layer3 < n3; layer3 = (layer3 + 1) | 0) {
                    var layerWeight1 = (layer3 === 0) ? 1 : this.animator.GetLayerWeight(layer3); // Animator.GetLayerWeight always returns 0 on the first layer. Should be interpreted as 1.

                    var isInterruptionActive1 = { };
                    var stateInfo = { };
                    var nextStateInfo1 = { };
                    var interruptingStateInfo = { };
                    var interruptingClipTimeAddition = { };
                    this.GetAnimatorStateInfos(layer3, isInterruptionActive1, stateInfo, nextStateInfo1, interruptingStateInfo, interruptingClipTimeAddition);

                    var hasNext1 = nextStateInfo1.v.fullPathHash !== 0;

                    var clipInfoCount1 = { }, nextClipInfoCount1 = { }, interruptingClipInfoCount1 = { };
                    var clipInfo1 = { }, nextClipInfo1 = { }, interruptingClipInfo1 = { };
                    var interpolateWeightTo1 = { };
                    this.GetAnimatorClipInfos(layer3, isInterruptionActive1, clipInfoCount1, nextClipInfoCount1, interruptingClipInfoCount1, clipInfo1, nextClipInfo1, interruptingClipInfo1, interpolateWeightTo1);

                    var layerBlendMode = (layer3 < this.layerBlendModes.length) ? this.layerBlendModes[layer3] : spine.MixBlend.replace;
                    var mode = this.GetMixMode(layer3, layerBlendMode);
                    if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix) {
                        // Always use Mix instead of Applying the first non-zero weighted clip.
                        for (var c3 = 0; c3 < clipInfoCount1.v; c3 = (c3 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c3, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }
                        if (hasNext1) {
                            for (var c4 = 0; c4 < nextClipInfoCount1.v; c4 = (c4 + 1) | 0) {
                                this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c4, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode);
                            }
                        }
                        if (isInterruptionActive1.v) {
                            for (var c5 = 0; c5 < interruptingClipInfoCount1.v; c5 = (c5 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c5, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    } else { // case MixNext || Hard
                        // Apply first non-zero weighted clip
                        var c6 = 0;
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            if (!this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode, true)) {
                                continue;
                            }
                            c6 = (c6 + 1) | 0;
                            break;
                        }
                        // Mix the rest
                        for (; c6 < clipInfoCount1.v; c6 = (c6 + 1) | 0) {
                            this.ApplyAnimation(skeleton, System.Array.getItem(clipInfo1.v, c6, UnityEngine.AnimatorClipInfo), stateInfo.v, layer3, layerWeight1, layerBlendMode);
                        }

                        c6 = 0;
                        if (hasNext1) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode, true)) {
                                        continue;
                                    }
                                    c6 = (c6 + 1) | 0;
                                    break;
                                }
                            }
                            // Mix the rest
                            for (; c6 < nextClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                if (!this.ApplyAnimation(skeleton, System.Array.getItem(nextClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), nextStateInfo1.v, layer3, layerWeight1, layerBlendMode)) {
                                    continue;
                                }
                            }
                        }

                        c6 = 0;
                        if (isInterruptionActive1.v) {
                            // Apply next clip directly instead of mixing (ie: no crossfade, ignores mecanim transition weights)
                            if (mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.Hard) {
                                for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                    if (this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v, true)) {

                                        c6 = (c6 + 1) | 0;
                                        break;
                                    }
                                }
                            }
                            // Mix the rest
                            for (; c6 < interruptingClipInfoCount1.v; c6 = (c6 + 1) | 0) {
                                this.ApplyInterruptionAnimation(skeleton, interpolateWeightTo1.v, System.Array.getItem(interruptingClipInfo1.v, c6, UnityEngine.AnimatorClipInfo), interruptingStateInfo.v, layer3, layerWeight1, layerBlendMode, interruptingClipTimeAddition.v);
                            }
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.Apply end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime start.*/
            GetActiveAnimationAndTime: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetActiveAnimationAndTime", this ); }

                if (layer >= this.layerClipInfos.length) {
                    return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(null, 0);
                }

                var layerInfos = this.layerClipInfos[layer];
                var isInterruptionActive = layerInfos.isInterruptionActive;
                var clip = null;
                var animation = null;
                var stateInfo;
                if (isInterruptionActive && layerInfos.interruptingClipInfoCount > 0) {
                    clip = layerInfos.interruptingClipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.interruptingStateInfo;
                } else {
                    clip = layerInfos.clipInfos.getItem(0).$clone().clip;
                    stateInfo = layerInfos.stateInfo;
                }
                animation = this.GetAnimation(clip);
                var time = Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationTime(stateInfo.normalizedTime, clip.length, clip.isLooping, stateInfo.speed < 0);
                return new (System.Collections.Generic.KeyValuePair$2(Spine.Animation,System.Single)).$ctor1(animation, time);
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetActiveAnimationAndTime end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers start.*/
            InitClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#InitClipInfosForLayers", this ); }

                if (this.layerClipInfos.length < this.animator.layerCount) {
                    System.Array.resize(Bridge.ref(this, "layerClipInfos"), this.animator.layerCount, null, Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos);
                    for (var layer = 0, n = this.animator.layerCount; layer < n; layer = (layer + 1) | 0) {
                        if (this.layerClipInfos[layer] == null) {
                            this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                        }
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.InitClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers start.*/
            ClearClipInfosForLayers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#ClearClipInfosForLayers", this ); }

                for (var layer = 0, n = this.layerClipInfos.length; layer < n; layer = (layer + 1) | 0) {
                    if (this.layerClipInfos[layer] == null) {
                        this.layerClipInfos[layer] = new Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos();
                    } else {
                        this.layerClipInfos[layer].isInterruptionActive = false;
                        this.layerClipInfos[layer].isLastFrameOfInterruption = false;
                        this.layerClipInfos[layer].clipInfos.clear();
                        this.layerClipInfos[layer].nextClipInfos.clear();
                        this.layerClipInfos[layer].interruptingClipInfos.clear();
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.ClearClipInfosForLayers end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode start.*/
            GetMixMode: function (layer, layerBlendMode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetMixMode", this ); }

                if (this.useCustomMixMode) {
                    var mode = this.layerMixModes[layer];
                    // Note: at additive blending it makes no sense to use constant weight 1 at a fadeout anim add1 as
                    // with override layers, so we use AlwaysMix instead to use the proper weights.
                    // AlwaysMix leads to the expected result = lower_layer + lerp(add1, add2, transition_weight).
                    if (layerBlendMode === spine.MixBlend.add && mode === Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext) {
                        mode = Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix;
                        this.layerMixModes[layer] = mode;
                    }
                    return mode;
                } else {
                    return layerBlendMode === spine.MixBlend.add ? Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.AlwaysMix : Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode.MixNext;
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetMixMode end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator start.*/
            GetStateUpdatesFromAnimator: function (layer) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetStateUpdatesFromAnimator", this ); }


                var layerInfos = this.layerClipInfos[layer];
                var clipInfoCount = this.animator.GetCurrentAnimatorClipInfoCount(layer);
                var nextClipInfoCount = this.animator.GetNextAnimatorClipInfoCount(layer);

                var clipInfos = layerInfos.clipInfos;
                var nextClipInfos = layerInfos.nextClipInfos;
                var interruptingClipInfos = layerInfos.interruptingClipInfos;

                layerInfos.isInterruptionActive = (clipInfoCount === 0 && clipInfos.Count !== 0 && nextClipInfoCount === 0 && nextClipInfos.Count !== 0);

                // Note: during interruption, GetCurrentAnimatorClipInfoCount and GetNextAnimatorClipInfoCount
                // are returning 0 in calls above. Therefore we keep previous clipInfos and nextClipInfos
                // until the interruption is over.
                if (layerInfos.isInterruptionActive) {

                    // Note: The last frame of a transition interruption
                    // will have fullPathHash set to 0, therefore we have to use previous
                    // frame's infos about interruption clips and correct some values
                    // accordingly (normalizedTime and weight).
                    var interruptingStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                    layerInfos.isLastFrameOfInterruption = interruptingStateInfo.fullPathHash === 0;
                    if (!layerInfos.isLastFrameOfInterruption) {
                        this.animator.GetNextAnimatorClipInfo(layer, interruptingClipInfos);
                        layerInfos.interruptingClipInfoCount = interruptingClipInfos.Count;
                        var oldTime = layerInfos.interruptingStateInfo.normalizedTime;
                        var newTime = interruptingStateInfo.normalizedTime;
                        layerInfos.interruptingClipTimeAddition = newTime - oldTime;
                        layerInfos.interruptingStateInfo = interruptingStateInfo;
                    }
                } else {
                    layerInfos.clipInfoCount = clipInfoCount;
                    layerInfos.nextClipInfoCount = nextClipInfoCount;
                    layerInfos.interruptingClipInfoCount = 0;
                    layerInfos.isLastFrameOfInterruption = false;

                    if (clipInfos.Capacity < clipInfoCount) {
                        clipInfos.Capacity = clipInfoCount;
                    }
                    if (nextClipInfos.Capacity < nextClipInfoCount) {
                        nextClipInfos.Capacity = nextClipInfoCount;
                    }

                    this.animator.GetCurrentAnimatorClipInfo(layer, clipInfos);
                    this.animator.GetNextAnimatorClipInfo(layer, nextClipInfos);

                    layerInfos.stateInfo = this.animator.GetCurrentAnimatorStateInfo(layer);
                    layerInfos.nextStateInfo = this.animator.GetNextAnimatorStateInfo(layer);
                }
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetStateUpdatesFromAnimator end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos start.*/
            GetAnimatorClipInfos: function (layer, isInterruptionActive, clipInfoCount, nextClipInfoCount, interruptingClipInfoCount, clipInfo, nextClipInfo, interruptingClipInfo, shallInterpolateWeightTo1) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorClipInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                clipInfoCount.v = layerInfos.clipInfoCount;
                nextClipInfoCount.v = layerInfos.nextClipInfoCount;
                interruptingClipInfoCount.v = layerInfos.interruptingClipInfoCount;

                clipInfo.v = layerInfos.clipInfos;
                nextClipInfo.v = layerInfos.nextClipInfos;
                interruptingClipInfo.v = isInterruptionActive.v ? layerInfos.interruptingClipInfos : null;
                shallInterpolateWeightTo1.v = layerInfos.isLastFrameOfInterruption;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorClipInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos start.*/
            GetAnimatorStateInfos: function (layer, isInterruptionActive, stateInfo, nextStateInfo, interruptingStateInfo, interruptingClipTimeAddition) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimatorStateInfos", this ); }


                var layerInfos = this.layerClipInfos[layer];
                isInterruptionActive.v = layerInfos.isInterruptionActive;

                stateInfo.v = layerInfos.stateInfo;
                nextStateInfo.v = layerInfos.nextStateInfo;
                interruptingStateInfo.v = layerInfos.interruptingStateInfo;
                interruptingClipTimeAddition.v = layerInfos.isLastFrameOfInterruption ? layerInfos.interruptingClipTimeAddition : 0;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimatorStateInfos end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation start.*/
            GetAnimation: function (clip) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator#GetAnimation", this ); }

                var clipNameHashCode = { };
                if (!this.clipNameHashCodeTable.tryGetValue(clip, clipNameHashCode)) {
                    clipNameHashCode.v = Bridge.getHashCode(clip.name);
                    this.clipNameHashCodeTable.add(clip, clipNameHashCode.v);
                }
                var animation = { };
                this.animationTable.tryGetValue(clipNameHashCode.v, animation);
                return animation.v;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator.GetAnimation end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(UnityEngine.AnimationClip)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$UnityEngine$AnimationClip$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#equals2", this ); }

                return x.GetInstanceID() === y.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer#getHashCode2", this ); }

                return o.GetInstanceID();
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(AnimationClip, AnimationClip)": "equals2",
            "GetHashCode(AnimationClip)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", {
        $kind: 1002,
        fields: {
            isInterruptionActive: false,
            isLastFrameOfInterruption: false,
            clipInfoCount: 0,
            nextClipInfoCount: 0,
            interruptingClipInfoCount: 0,
            clipInfos: null,
            nextClipInfos: null,
            interruptingClipInfos: null,
            stateInfo: null,
            nextStateInfo: null,
            interruptingStateInfo: null,
            interruptingClipTimeAddition: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos#init", this ); }

                this.isInterruptionActive = false;
                this.isLastFrameOfInterruption = false;
                this.clipInfoCount = 0;
                this.nextClipInfoCount = 0;
                this.interruptingClipInfoCount = 0;
                this.clipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.nextClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipInfos = new (System.Collections.Generic.List$1(UnityEngine.AnimatorClipInfo)).ctor();
                this.interruptingClipTimeAddition = 0;
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", {
        inherits: [System.Collections.Generic.IEqualityComparer$1(System.Int32)],
        $kind: 1002,
        statics: {
            fields: {
                Instance: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#init", this ); }

                    this.Instance = new Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer();
                }
            }
        },
        alias: [
            "equals2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$equals2", "System$Collections$Generic$IEqualityComparer$1$equals2"],
            "getHashCode2", ["System$Collections$Generic$IEqualityComparer$1$System$Int32$getHashCode2", "System$Collections$Generic$IEqualityComparer$1$getHashCode2"]
        ],
        methods: {
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 start.*/
            equals2: function (x, y) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#equals2", this ); }

                return x === y;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.equals2 end.*/

            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 start.*/
            getHashCode2: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer#getHashCode2", this ); }

                return o;
            },
            /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer.getHashCode2 end.*/


        },
        overloads: {
            "Equals(int, int)": "equals2",
            "GetHashCode(int)": "getHashCode2"
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", {
        $kind: 1006,
        statics: {
            fields: {
                AlwaysMix: 0,
                MixNext: 1,
                Hard: 2
            }
        }
    });
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate
     * @param   {Spine.Unity.SkeletonRootMotionBase}    component      
     * @param   {UnityEngine.Vector2}                   translation    
     * @param   {number}                                rotation
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRootMotionBase start.*/
    /**
     * Base class for skeleton root motion components.
     *
     * @abstract
     * @public
     * @class Spine.Unity.SkeletonRootMotionBase
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonRootMotionBase", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            rootMotionBoneName: null,
            transformPositionX: false,
            transformPositionY: false,
            transformRotation: false,
            rootMotionScaleX: 0,
            rootMotionScaleY: 0,
            rootMotionScaleRotation: 0,
            /**
             * Skeleton space X translation per skeleton space Y translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateXPerY: 0,
            /**
             * Skeleton space Y translation per skeleton space X translation root motion.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default 0
             * @type number
             */
            rootMotionTranslateYPerX: 0,
            rigidBody2D: null,
            applyRigidbody2DGravity: false,
            rigidBody: null,
            /**
             * When true, root-motion is not applied to the Transform or Rigidbody.
             Otherwise the delegate callbacks are issued additionally.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @default true
             * @type boolean
             */
            disableOnOverride: false,
            skeletonComponent: null,
            rootMotionBone: null,
            rootMotionBoneIndex: 0,
            transformConstraintIndices: null,
            transformConstraintLastPos: null,
            transformConstraintLastRotation: null,
            topLevelBones: null,
            initialOffset: null,
            accumulatedUntilFixedUpdate: false,
            tempSkeletonDisplacement: null,
            rigidbodyDisplacement: null,
            previousRigidbodyRootMotion: null,
            additionalRigidbody2DMovement: null,
            rigidbodyLocalRotation: null,
            rigidbody2DRotation: 0,
            initialOffsetRotation: 0,
            tempSkeletonRotation: 0
        },
        events: {
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised after evaluating
             this animation frame's root-motion, before it is potentially applied (see {@link })
             to either Transform or Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with
             this animation frame's skeleton-space root-motion (not cumulated). You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removeProcessRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link PhysicsUpdateRootMotionOverride}
             */
            ProcessRootMotionOverride: null,
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function addPhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            /**
             * This callback can be used to apply root-motion in a custom way. It is raised in FixedUpdate
             after (when {@link } is set to false) or instead of when root-motion
             would be applied at the Rigidbody.
             When {@link } is set to {@link }, multiple
             animation frames might take place before before <pre><code>FixedUpdate</code></pre> is called once.
             The callback parameters <pre><code>translation</code></pre> and <pre><code>rotation</code></pre> are filled out with the
             (cumulated) skeleton-space root-motion since the the last <pre><code>FixedUpdate</code></pre> call. You can use
             e.g. <pre><code>transform.TransformVector()</code></pre> to transform skeleton-space root-motion to world space.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRootMotionBase
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function removePhysicsUpdateRootMotionOverride
             * @param   {Spine.Unity.SkeletonRootMotionBase.RootMotionDelegate}    value
             * @return  {void}
             * @see {@link ProcessRootMotionOverride}
             */
            PhysicsUpdateRootMotionOverride: null
        },
        props: {
            RootMotionBone: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#RootMotionBone#get", this ); }

                    return this.rootMotionBone;
                }
            },
            UsesRigidbody: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UsesRigidbody#get", this ); }

                    return UnityEngine.Component.op_Inequality(this.rigidBody, null) || UnityEngine.Component.op_Inequality(this.rigidBody2D, null);
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector2.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             This can be necessary when multiple scripts call <pre><code>Rigidbody2D.MovePosition</code></pre>,
             where the last call overwrites the effect of preceding ones.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion2D
             * @type UnityEngine.Vector2
             */
            PreviousRigidbodyRootMotion2D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion2D#get", this ); }

                    return new pc.Vec2( this.previousRigidbodyRootMotion.x, this.previousRigidbodyRootMotion.y );
                }
            },
            /**
             * Root motion translation that has been applied in the preceding <pre><code>FixedUpdate</code></pre> call
             if a rigidbody is assigned at either <pre><code>rigidbody</code></pre> or <pre><code>rigidbody2D</code></pre>.
             Returns <pre><code>Vector3.zero</code></pre> when <pre><code>rigidbody</code></pre> and <pre><code>rigidbody2D</code></pre> are null.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function PreviousRigidbodyRootMotion3D
             * @type UnityEngine.Vector3
             */
            PreviousRigidbodyRootMotion3D: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PreviousRigidbodyRootMotion3D#get", this ); }

                    return this.previousRigidbodyRootMotion.$clone();
                }
            },
            /**
             * Additional translation to add to <pre><code>Rigidbody2D.MovePosition</code></pre>
             called in FixedUpdate. This can be necessary when multiple scripts call
             <pre><code>MovePosition</code></pre>, where the last call overwrites the effect of preceding ones.
             Has no effect if <pre><code>rigidBody2D</code></pre> is null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRootMotionBase
             * @function AdditionalRigidbody2DMovement
             * @type UnityEngine.Vector2
             */
            AdditionalRigidbody2DMovement: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#get", this ); }

                    return this.additionalRigidbody2DMovement.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalRigidbody2DMovement#set", this ); }

                    this.additionalRigidbody2DMovement = value.$clone();
                }
            },
            SkeletonAnimationUsesFixedUpdate: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SkeletonAnimationUsesFixedUpdate#get", this ); }

                    var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                    if (skeletonAnimation != null) {
                        return skeletonAnimation.Spine$Unity$ISkeletonAnimation$UpdateTiming === Spine.Unity.UpdateTiming.InFixedUpdate;
                    }
                    return false;
                }
            },
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdditionalScale#get", this ); }

                    return 1.0;
                }
            },
            TargetSkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            TargetSkeletonAnimationComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#TargetSkeletonAnimationComponent#get", this ); }

                    return Bridge.as(this.TargetSkeletonComponent, Spine.Unity.ISkeletonAnimation);
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#init", this ); }

                this.initialOffset = new UnityEngine.Vector2();
                this.tempSkeletonDisplacement = new UnityEngine.Vector2();
                this.rigidbodyDisplacement = new UnityEngine.Vector3();
                this.previousRigidbodyRootMotion = new UnityEngine.Vector3();
                this.additionalRigidbody2DMovement = new UnityEngine.Vector2();
                this.rigidbodyLocalRotation = new UnityEngine.Quaternion();
                this.rootMotionBoneName = "root";
                this.transformPositionX = true;
                this.transformPositionY = true;
                this.transformRotation = false;
                this.rootMotionScaleX = 1;
                this.rootMotionScaleY = 1;
                this.rootMotionScaleRotation = 1;
                this.rootMotionTranslateXPerY = 0;
                this.rootMotionTranslateYPerX = 0;
                this.applyRigidbody2DGravity = false;
                this.disableOnOverride = true;
                this.transformConstraintIndices = new (System.Collections.Generic.List$1(System.Int32)).ctor();
                this.transformConstraintLastPos = new (System.Collections.Generic.List$1(UnityEngine.Vector2)).ctor();
                this.transformConstraintLastRotation = new (System.Collections.Generic.List$1(System.Single)).ctor();
                this.topLevelBones = new (System.Collections.Generic.List$1(Spine.Bone)).ctor();
                this.initialOffset = pc.Vec2.ZERO.clone();
                this.accumulatedUntilFixedUpdate = false;
                this.previousRigidbodyRootMotion = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.additionalRigidbody2DMovement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotionBase.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Reset", this ); }

                this.FindRigidbodyComponent();
            },
            /*Spine.Unity.SkeletonRootMotionBase.Reset end.*/

            /*Spine.Unity.SkeletonRootMotionBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#Start", this ); }

                this.skeletonComponent = this.GetComponent(Spine.Unity.ISkeletonComponent);
                this.GatherTopLevelBones();
                this.SetRootMotionBone(this.rootMotionBoneName);
                if (this.rootMotionBone != null) {
                    this.initialOffset = new pc.Vec2( this.rootMotionBone.x, this.rootMotionBone.y );
                    this.initialOffsetRotation = this.rootMotionBone.rotation;
                }

                var skeletonAnimation = Bridge.as(this.skeletonComponent, Spine.Unity.ISkeletonAnimation);
                if (skeletonAnimation != null) {
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                    skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.HandleUpdateLocal));
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.Start end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FixedUpdate", this ); }

                // Root motion is only applied when component is enabled.
                if (!this.isActiveAndEnabled) {
                    return;
                }
                // When SkeletonAnimation component uses UpdateTiming.InFixedUpdate,
                // we directly call PhysicsUpdate in HandleUpdateLocal instead of here.
                if (!this.SkeletonAnimationUsesFixedUpdate) {
                    this.PhysicsUpdate(false);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FixedUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate start.*/
            PhysicsUpdate: function (skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#PhysicsUpdate", this ); }

                var callbackDisplacement = this.tempSkeletonDisplacement.$clone();
                var callbackRotation = this.tempSkeletonRotation;

                var isApplyAtRigidbodyAllowed = Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null) || !this.disableOnOverride;
                if (isApplyAtRigidbodyAllowed) {
                    if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                        var gravityAndVelocityMovement = pc.Vec2.ZERO.clone();
                        if (this.applyRigidbody2DGravity) {
                            var deltaTime = UnityEngine.Time.fixedDeltaTime;
                            var deltaTimeSquared = (deltaTime * deltaTime);

                            this.rigidBody2D.velocity = this.rigidBody2D.velocity.$clone().add( UnityEngine.Physics2D.gravity.$clone().scale( this.rigidBody2D.gravityScale ).scale( deltaTime ) );
                            gravityAndVelocityMovement = UnityEngine.Physics2D.gravity.$clone().scale( 0.5 * this.rigidBody2D.gravityScale ).scale( deltaTimeSquared ).add( this.rigidBody2D.velocity.$clone().scale( deltaTime ) );
                        }

                        var rigidbodyDisplacement2D = new pc.Vec2( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y );
                        this.rigidBody2D.MovePosition(gravityAndVelocityMovement.$clone().add( new pc.Vec2( this.rigidBody2D.position.x, this.rigidBody2D.position.y ) ).add( rigidbodyDisplacement2D ).add( this.additionalRigidbody2DMovement ));
                        this.rigidBody2D.MoveRotation(this.rigidbody2DRotation + this.rigidBody2D.rotation);
                    } else if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                        this.rigidBody.MovePosition(this.rigidBody.position.$clone().add( new pc.Vec3( this.rigidbodyDisplacement.x, this.rigidbodyDisplacement.y, this.rigidbodyDisplacement.z ) ));
                        this.rigidBody.MoveRotation(this.rigidBody.rotation.clone().mul( this.rigidbodyLocalRotation ));
                    }
                }

                this.previousRigidbodyRootMotion = this.rigidbodyDisplacement.$clone();
                if (this.accumulatedUntilFixedUpdate) {
                    var parentBoneScale = { v : new UnityEngine.Vector2() };
                    this.GetScaleAffectingRootMotion$1(parentBoneScale);
                    this.ClearEffectiveBoneOffsets(parentBoneScale.v);
                    this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.updateWorldTransform();
                }
                this.ClearRigidbodyTempMovement();

                if (!Bridge.staticEquals(this.PhysicsUpdateRootMotionOverride, null)) {
                    this.PhysicsUpdateRootMotionOverride(this, callbackDisplacement.$clone(), callbackRotation);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.PhysicsUpdate end.*/

            /*Spine.Unity.SkeletonRootMotionBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#OnDisable", this ); }

                this.ClearRigidbodyTempMovement();
            },
            /*Spine.Unity.SkeletonRootMotionBase.OnDisable end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent start.*/
            FindRigidbodyComponent: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindRigidbodyComponent", this ); }

                this.rigidBody2D = this.GetComponent(UnityEngine.Rigidbody2D);
                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                    this.rigidBody = this.GetComponent(UnityEngine.Rigidbody);
                }

                if (!UnityEngine.Object.op_Implicit(this.rigidBody2D) && !UnityEngine.Object.op_Implicit(this.rigidBody)) {
                    this.rigidBody2D = this.GetComponentInParent(UnityEngine.Rigidbody2D);
                    if (!UnityEngine.Object.op_Implicit(this.rigidBody2D)) {
                        this.rigidBody = this.GetComponentInParent(UnityEngine.Rigidbody);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindRigidbodyComponent end.*/

            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#CalculateAnimationsRotationDelta", this ); }

                return 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone start.*/
            SetRootMotionBone: function (name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetRootMotionBone", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var bone = skeleton.findBone(name);
                if (bone != null) {
                    this.rootMotionBoneIndex = bone.data.index;
                    this.rootMotionBone = bone;
                    this.FindTransformConstraintsAffectingBone();
                } else {
                    UnityEngine.Debug.Log$1("Bone named \"" + (name || "") + "\" could not be found.");
                    this.rootMotionBoneIndex = 0;
                    this.rootMotionBone = skeleton.getRootBone();
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetRootMotionBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance start.*/
            AdjustRootMotionToDistance: function (distanceToTarget, trackIndex, adjustX, adjustY, minX, maxX, minY, maxY, allowXTranslation, allowYTranslation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#AdjustRootMotionToDistance", this ); }

                if (trackIndex === void 0) { trackIndex = 0; }
                if (adjustX === void 0) { adjustX = true; }
                if (adjustY === void 0) { adjustY = true; }
                if (minX === void 0) { minX = 0.0; }
                if (maxX === void 0) { maxX = 3.40282347E+38; }
                if (minY === void 0) { minY = 0.0; }
                if (maxY === void 0) { maxY = 3.40282347E+38; }
                if (allowXTranslation === void 0) { allowXTranslation = false; }
                if (allowYTranslation === void 0) { allowYTranslation = false; }

                var distanceToTargetSkeletonSpace = UnityEngine.Vector2.FromVector3(this.transform.InverseTransformVector(UnityEngine.Vector3.FromVector2(distanceToTarget)));
                var scaleAffectingRootMotion = this.GetScaleAffectingRootMotion();
                if (this.UsesRigidbody) {
                    distanceToTargetSkeletonSpace = distanceToTargetSkeletonSpace.$clone().sub( this.tempSkeletonDisplacement.$clone() );
                }

                var remainingRootMotionSkeletonSpace = this.GetRemainingRootMotion(trackIndex);
                remainingRootMotionSkeletonSpace.mul( scaleAffectingRootMotion );
                if (remainingRootMotionSkeletonSpace.x === 0) {
                    remainingRootMotionSkeletonSpace.x = 0.0001;
                }
                if (remainingRootMotionSkeletonSpace.y === 0) {
                    remainingRootMotionSkeletonSpace.y = 0.0001;
                }

                if (adjustX) {
                    this.rootMotionScaleX = Math.min(maxX, Math.max(minX, distanceToTargetSkeletonSpace.x / remainingRootMotionSkeletonSpace.x));
                }
                if (adjustY) {
                    this.rootMotionScaleY = Math.min(maxY, Math.max(minY, distanceToTargetSkeletonSpace.y / remainingRootMotionSkeletonSpace.y));
                }

                if (allowXTranslation) {
                    this.rootMotionTranslateXPerY = (distanceToTargetSkeletonSpace.x - remainingRootMotionSkeletonSpace.x * this.rootMotionScaleX) / remainingRootMotionSkeletonSpace.y;
                }
                if (allowYTranslation) {
                    this.rootMotionTranslateYPerX = (distanceToTargetSkeletonSpace.y - remainingRootMotionSkeletonSpace.y * this.rootMotionScaleY) / remainingRootMotionSkeletonSpace.x;
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.AdjustRootMotionToDistance end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion start.*/
            GetAnimationRootMotion: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion", this ); }

                return this.GetAnimationRootMotion$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 start.*/
            GetAnimationRootMotion$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotion$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return pc.Vec2.ZERO.clone();
                }

                var translateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endPos = { v : pc.Vec2.ZERO.clone() };
                var startPos = { v : pc.Vec2.ZERO.clone() };
                if (translateTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, startTime);
                } else if (xTimeline != null || yTimeline != null) {
                    endPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime);
                    startPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, endTime, false, endPos);
                        this.ApplyConstraintToPos(animation, constraint, constraintIndex, startTime, true, startPos);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endPos.v.$clone().sub( startPos.v );

                // Looped additions
                if (startTime > endTime) {
                    var loopPos = { v : pc.Vec2.ZERO.clone() };
                    var zeroPos = { v : pc.Vec2.ZERO.clone() };
                    if (translateTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(translateTimeline, 0);
                    } else if (xTimeline != null || yTimeline != null) {
                        loopPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, animation.duration, false, loopPos);
                            this.ApplyConstraintToPos(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta = currentDelta.$clone().add( loopPos.v.$clone().sub( zeroPos.v ) );
                }
                this.UpdateLastConstraintPos(transformConstraintsItems);
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation start.*/
            GetAnimationRootMotionRotation: function (animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation", this ); }

                return this.GetAnimationRootMotionRotation$1(0, animation.duration, animation);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 start.*/
            GetAnimationRootMotionRotation$1: function (startTime, endTime, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionRotation$1", this ); }

                var $t, $t1;

                if (startTime === endTime) {
                    return 0;
                }

                var rotateTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.RotateTimeline, animation, this.rootMotionBoneIndex);

                // Non-looped base
                var endRotation = { v : 0 };
                var startRotation = { v : 0 };
                if (rotateTimeline != null) {
                    endRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, endTime);
                    startRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, startTime);
                }
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, endTime, false, endRotation);
                        this.ApplyConstraintToRotation(animation, constraint, constraintIndex, startTime, true, startRotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                var currentDelta = endRotation.v - startRotation.v;

                // Looped additions
                if (startTime > endTime) {
                    var loopRotation = { v : 0 };
                    var zeroPos = { v : 0 };
                    if (rotateTimeline != null) {
                        loopRotation.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, animation.duration);
                        zeroPos.v = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate(rotateTimeline, 0);
                    }
                    $t1 = Bridge.getEnumerator(this.transformConstraintIndices);
                    try {
                        while ($t1.moveNext()) {
                            var constraintIndex1 = $t1.Current;
                            var constraint1 = transformConstraintsItems[constraintIndex1];
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, animation.duration, false, loopRotation);
                            this.ApplyConstraintToRotation(animation, constraint1, constraintIndex1, 0, false, zeroPos);
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    currentDelta += loopRotation.v - zeroPos.v;
                }
                this.UpdateLastConstraintRotation(transformConstraintsItems);
                return currentDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionRotation$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos start.*/
            ApplyConstraintToPos: function (animation, constraint, constraintIndex, time, useLastConstraintPos, pos) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToPos", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var invMixXY = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateTranslateXYMix(timeline, time);
                var constraintPos = new UnityEngine.Vector2();
                if (useLastConstraintPos) {
                    constraintPos = this.transformConstraintLastPos.getItem(this.GetConstraintLastPosIndex(constraintIndex)).$clone();
                } else {
                    var targetBone = constraint.target;
                    constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                }
                pos.v = new pc.Vec2( pos.v.x * invMixXY.x + constraintPos.x * mixXY.x, pos.v.y * invMixXY.y + constraintPos.y * mixXY.y );
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation start.*/
            ApplyConstraintToRotation: function (animation, constraint, constraintIndex, time, useLastConstraintRotation, rotation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyConstraintToRotation", this ); }

                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTransformConstraintTimeline(animation, constraintIndex);
                if (timeline == null) {
                    return;
                }
                var mixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var invMixRotate = Spine.Unity.AnimationTools.TimelineExtensions.EvaluateRotateMix(timeline, time);
                var constraintRotation;
                if (useLastConstraintRotation) {
                    constraintRotation = this.transformConstraintLastRotation.getItem(this.GetConstraintLastPosIndex(constraintIndex));
                } else {
                    var targetBone = constraint.target;
                    constraintRotation = targetBone.rotation;
                }
                rotation.v = rotation.v * invMixRotate + constraintRotation * mixRotate;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyConstraintToRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos start.*/
            UpdateLastConstraintPos: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintPos", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastPos.setItem(this.GetConstraintLastPosIndex(constraintIndex), new pc.Vec2( targetBone.x, targetBone.y ));
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintPos end.*/

            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation start.*/
            UpdateLastConstraintRotation: function (transformConstraintsItems) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#UpdateLastConstraintRotation", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        var targetBone = constraint.target;
                        this.transformConstraintLastRotation.setItem(this.GetConstraintLastPosIndex(constraintIndex), targetBone.rotation);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.UpdateLastConstraintRotation end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo start.*/
            GetAnimationRootMotionInfo: function (animation, currentTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetAnimationRootMotionInfo", this ); }

                var rootMotion = new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                var duration = animation.duration;
                var mid = duration * 0.5;
                rootMotion.timeIsPastMid = currentTime > mid;
                var timeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTranslateTimelineForBone(animation, this.rootMotionBoneIndex);
                if (timeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$1(timeline, duration);
                    return rootMotion.$clone();
                }
                var xTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateXTimeline, animation, this.rootMotionBoneIndex);
                var yTimeline = Spine.Unity.AnimationTools.TimelineExtensions.FindTimelineForBone(spine.TranslateYTimeline, animation, this.rootMotionBoneIndex);
                if (xTimeline != null || yTimeline != null) {
                    rootMotion.start = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0);
                    rootMotion.current = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, currentTime);
                    rootMotion.mid = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, mid);
                    rootMotion.end = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, duration);
                    return rootMotion.$clone();
                }
                return rootMotion.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetAnimationRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex start.*/
            GetConstraintLastPosIndex: function (constraintIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetConstraintLastPosIndex", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                return this.transformConstraintIndices.FindIndex$2(function (addedIndex) {
                    return addedIndex === constraintIndex;
                });
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetConstraintLastPosIndex end.*/

            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone start.*/
            FindTransformConstraintsAffectingBone: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#FindTransformConstraintsAffectingBone", this ); }

                var constraints = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints;
                var constraintsItems = constraints.Items;
                for (var i = 0, n = constraints.Count; i < n; i = (i + 1) | 0) {
                    var constraint = constraintsItems[i];
                    if (constraint.Bones.Contains(this.rootMotionBone)) {
                        this.transformConstraintIndices.add(i);
                        var targetBone = constraint.target;
                        var constraintPos = new pc.Vec2( targetBone.x, targetBone.y );
                        this.transformConstraintLastPos.add(constraintPos.$clone());
                        this.transformConstraintLastRotation.add(targetBone.rotation);
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.FindTransformConstraintsAffectingBone end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta start.*/
            GetTimelineMovementDelta: function (startTime, endTime, xTimeline, yTimeline, animation) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetTimelineMovementDelta", this ); }


                var currentDelta = new UnityEngine.Vector2();
                if (startTime > endTime) {
                    currentDelta = (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, animation.duration).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) )).add( (Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, 0) )) );
                } else {
                    if (startTime !== endTime) {
                        currentDelta = Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, endTime).sub( Spine.Unity.AnimationTools.TimelineExtensions.Evaluate$2(xTimeline, yTimeline, startTime) );
                    } else {
                        currentDelta = pc.Vec2.ZERO.clone();
                    }
                }
                return currentDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetTimelineMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones start.*/
            GatherTopLevelBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GatherTopLevelBones", this ); }

                var $t;
                this.topLevelBones.clear();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(skeleton.bones);
                try {
                    while ($t.moveNext()) {
                        var bone = $t.Current;
                        if (bone.parent == null) {
                            this.topLevelBones.add(bone);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.GatherTopLevelBones end.*/

            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal start.*/
            HandleUpdateLocal: function (animatedSkeletonComponent) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#HandleUpdateLocal", this ); }

                if (!this.isActiveAndEnabled) {
                    return;
                } // Root motion is only applied when component is enabled.

                var boneLocalDelta = this.CalculateAnimationsMovementDelta();
                var parentBoneScale = { v : new UnityEngine.Vector2() };
                var totalScale = { v : new UnityEngine.Vector2() };
                var skeletonTranslationDelta = this.GetSkeletonSpaceMovementDelta(boneLocalDelta.$clone(), parentBoneScale, totalScale);
                var skeletonRotationDelta = 0;
                if (this.transformRotation) {
                    var boneLocalDeltaRotation = this.CalculateAnimationsRotationDelta();
                    boneLocalDeltaRotation *= this.rootMotionScaleRotation;
                    skeletonRotationDelta = this.GetSkeletonSpaceRotationDelta(boneLocalDeltaRotation, totalScale.v);
                }

                var usesFixedUpdate = this.SkeletonAnimationUsesFixedUpdate;
                this.ApplyRootMotion(skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale.v, usesFixedUpdate);

                if (usesFixedUpdate) {
                    this.PhysicsUpdate(usesFixedUpdate);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.HandleUpdateLocal end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion start.*/
            ApplyRootMotion: function (skeletonTranslationDelta, skeletonRotationDelta, parentBoneScale, skeletonAnimationUsesFixedUpdate) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyRootMotion", this ); }


                // Accumulated displacement is applied on the next Physics update in FixedUpdate.
                // Until the next Physics update, tempSkeletonDisplacement and tempSkeletonRotation
                // are offsetting bone locations to prevent stutter which would otherwise occur if
                // we don't move every Update.
                var usesRigidbody = this.UsesRigidbody;
                var applyToTransform = !usesRigidbody && (Bridge.staticEquals(this.ProcessRootMotionOverride, null) || !this.disableOnOverride);
                this.accumulatedUntilFixedUpdate = !applyToTransform && !skeletonAnimationUsesFixedUpdate;

                if (!Bridge.staticEquals(this.ProcessRootMotionOverride, null)) {
                    this.ProcessRootMotionOverride(this, skeletonTranslationDelta.$clone(), skeletonRotationDelta);
                }

                // Apply root motion to Transform or update values applied to RigidBody later (must happen in FixedUpdate).
                if (usesRigidbody) {
                    this.rigidbodyDisplacement = this.rigidbodyDisplacement.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        if (UnityEngine.Component.op_Inequality(this.rigidBody, null)) {
                            var addedWorldRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, skeletonRotationDelta );
                            this.rigidbodyLocalRotation = this.rigidbodyLocalRotation.clone().mul( addedWorldRotation );
                        } else if (UnityEngine.Component.op_Inequality(this.rigidBody2D, null)) {
                            var lossyScale = this.transform.lossyScale.$clone();
                            var rotationSign = lossyScale.x * lossyScale.y > 0 ? 1 : -1;
                            this.rigidbody2DRotation += rotationSign * skeletonRotationDelta;
                        }
                    }
                } else if (applyToTransform) {
                    this.transform.position = this.transform.position.$clone().add( this.transform.TransformVector(UnityEngine.Vector3.FromVector2(skeletonTranslationDelta)) );
                    if (skeletonRotationDelta !== 0.0) {
                        var lossyScale1 = this.transform.lossyScale.$clone();
                        var rotationSign1 = lossyScale1.x * lossyScale1.y > 0 ? 1 : -1;
                        this.transform.Rotate(0, 0, rotationSign1 * skeletonRotationDelta);
                    }
                }

                this.tempSkeletonDisplacement = this.tempSkeletonDisplacement.$clone().add( skeletonTranslationDelta.$clone() );
                this.tempSkeletonRotation += skeletonRotationDelta;
                if (this.accumulatedUntilFixedUpdate) {
                    this.SetEffectiveBoneOffsetsTo(this.tempSkeletonDisplacement, this.tempSkeletonRotation, parentBoneScale);
                } else {
                    this.ClearEffectiveBoneOffsets(parentBoneScale);
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints start.*/
            ApplyTransformConstraints: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ApplyTransformConstraints", this ); }

                var $t;
                this.rootMotionBone.ax = this.rootMotionBone.x;
                this.rootMotionBone.ay = this.rootMotionBone.y;
                this.rootMotionBone.arotation = this.rootMotionBone.rotation;
                var transformConstraintsItems = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton.TransformConstraints.Items;
                $t = Bridge.getEnumerator(this.transformConstraintIndices);
                try {
                    while ($t.moveNext()) {
                        var constraintIndex = $t.Current;
                        var constraint = transformConstraintsItems[constraintIndex];
                        // apply the constraint and sets Bone.ax, Bone.ay and Bone.arotation values.
                        constraint.update();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.ApplyTransformConstraints end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion start.*/
            GetScaleAffectingRootMotion: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion", this ); }

                var parentBoneScale = { v : new UnityEngine.Vector2() };
                return this.GetScaleAffectingRootMotion$1(parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 start.*/
            GetScaleAffectingRootMotion$1: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetScaleAffectingRootMotion$1", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var totalScale = pc.Vec2.ONE.clone();
                totalScale.x *= skeleton.scaleX;
                totalScale.y *= skeleton.scaleY;

                parentBoneScale.v = pc.Vec2.ONE.clone();
                var scaleBone = this.rootMotionBone;
                while (((scaleBone = scaleBone.parent)) != null) {
                    parentBoneScale.v.x *= scaleBone.scaleX;
                    parentBoneScale.v.y *= scaleBone.scaleY;
                }
                totalScale = new pc.Vec2( totalScale.x * parentBoneScale.v.x, totalScale.y * parentBoneScale.v.y );
                totalScale = totalScale.$clone().scale( this.AdditionalScale );
                return totalScale.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetScaleAffectingRootMotion$1 end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta start.*/
            GetSkeletonSpaceMovementDelta: function (boneLocalDelta, parentBoneScale, totalScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceMovementDelta", this ); }

                var skeletonDelta = boneLocalDelta.$clone();
                totalScale.v = this.GetScaleAffectingRootMotion$1(parentBoneScale);
                skeletonDelta.mul( totalScale.v );

                var rootMotionTranslation = new pc.Vec2( this.rootMotionTranslateXPerY * skeletonDelta.y, this.rootMotionTranslateYPerX * skeletonDelta.x );

                skeletonDelta.x *= this.rootMotionScaleX;
                skeletonDelta.y *= this.rootMotionScaleY;
                skeletonDelta.x += rootMotionTranslation.x;
                skeletonDelta.y += rootMotionTranslation.y;

                if (!this.transformPositionX) {
                    skeletonDelta.x = 0.0;
                }
                if (!this.transformPositionY) {
                    skeletonDelta.y = 0.0;
                }
                return skeletonDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta start.*/
            GetSkeletonSpaceRotationDelta: function (boneLocalDelta, totalScaleAffectingRootMotion) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#GetSkeletonSpaceRotationDelta", this ); }

                var rotationSign = totalScaleAffectingRootMotion.x * totalScaleAffectingRootMotion.y > 0 ? 1 : -1;
                return rotationSign * boneLocalDelta;
            },
            /*Spine.Unity.SkeletonRootMotionBase.GetSkeletonSpaceRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo start.*/
            SetEffectiveBoneOffsetsTo: function (displacementSkeletonSpace, rotationSkeletonSpace, parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#SetEffectiveBoneOffsetsTo", this ); }

                var $t;

                this.ApplyTransformConstraints();

                // Move top level bones in opposite direction of the root motion bone
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                $t = Bridge.getEnumerator(this.topLevelBones);
                try {
                    while ($t.moveNext()) {
                        var topLevelBone = $t.Current;
                        if (Bridge.referenceEquals(topLevelBone, this.rootMotionBone)) {
                            if (this.transformPositionX) {
                                topLevelBone.x = displacementSkeletonSpace.x / skeleton.scaleX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = displacementSkeletonSpace.y / skeleton.scaleY;
                            }
                            if (this.transformRotation) {
                                var rotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = rotationSign * rotationSkeletonSpace;
                            }
                        } else {
                            var useAppliedTransform = this.transformConstraintIndices.Count > 0;
                            var rootMotionBoneX = useAppliedTransform ? this.rootMotionBone.ax : this.rootMotionBone.x;
                            var rootMotionBoneY = useAppliedTransform ? this.rootMotionBone.ay : this.rootMotionBone.y;

                            var offsetX = (this.initialOffset.x - rootMotionBoneX) * parentBoneScale.x;
                            var offsetY = (this.initialOffset.y - rootMotionBoneY) * parentBoneScale.y;

                            if (this.transformPositionX) {
                                topLevelBone.x = (displacementSkeletonSpace.x / skeleton.scaleX) + offsetX;
                            }
                            if (this.transformPositionY) {
                                topLevelBone.y = (displacementSkeletonSpace.y / skeleton.scaleY) + offsetY;
                            }

                            if (this.transformRotation) {
                                var rootMotionBoneRotation = useAppliedTransform ? this.rootMotionBone.arotation : this.rootMotionBone.rotation;

                                var parentBoneRotationSign = (parentBoneScale.x * parentBoneScale.y > 0 ? 1 : -1);
                                var offsetRotation = (this.initialOffsetRotation - rootMotionBoneRotation) * parentBoneRotationSign;

                                var skeletonRotationSign = skeleton.scaleX * skeleton.scaleY > 0 ? 1 : -1;
                                topLevelBone.rotation = (rotationSkeletonSpace * skeletonRotationSign) + offsetRotation;
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRootMotionBase.SetEffectiveBoneOffsetsTo end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets start.*/
            ClearEffectiveBoneOffsets: function (parentBoneScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearEffectiveBoneOffsets", this ); }

                this.SetEffectiveBoneOffsetsTo(pc.Vec2.ZERO.clone(), 0, parentBoneScale);
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearEffectiveBoneOffsets end.*/

            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement start.*/
            ClearRigidbodyTempMovement: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase#ClearRigidbodyTempMovement", this ); }

                this.rigidbodyDisplacement = UnityEngine.Vector3.FromVector2(pc.Vec2.ZERO.clone());
                this.tempSkeletonDisplacement = pc.Vec2.ZERO.clone();
                this.rigidbodyLocalRotation = pc.Quat.IDENTITY.clone();
                this.rigidbody2DRotation = 0;
                this.tempSkeletonRotation = 0;
            },
            /*Spine.Unity.SkeletonRootMotionBase.ClearRigidbodyTempMovement end.*/


        },
        overloads: {
            "GetAnimationRootMotion(float, float, Animation)": "GetAnimationRootMotion$1",
            "GetAnimationRootMotionRotation(float, float, Animation)": "GetAnimationRootMotionRotation$1",
            "GetScaleAffectingRootMotion(Vector2)": "GetScaleAffectingRootMotion$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate
     * @param   {Spine.Unity.SkeletonPartsRenderer}    skeletonPartsRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonPartsRenderer start.*/
    Bridge.define("Spine.Unity.SkeletonPartsRenderer", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static start.*/
                NewPartsRendererGameObject: function (parent, name, sortingOrder) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#NewPartsRendererGameObject", this ); }

                    if (sortingOrder === void 0) { sortingOrder = 0; }
                    var go = new UnityEngine.GameObject.$ctor4(name, [UnityEngine.MeshFilter, UnityEngine.MeshRenderer]);
                    go.transform.SetParent(parent, false);
                    var returnComponent = go.AddComponent(Spine.Unity.SkeletonPartsRenderer);
                    returnComponent.MeshRenderer.sortingOrder = sortingOrder;

                    return returnComponent;
                },
                /*Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject:static end.*/


            }
        },
        fields: {
            meshGenerator: null,
            meshRenderer: null,
            meshFilter: null,
            buffers: null,
            currentInstructions: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonPartsRenderer
             * @memberof Spine.Unity.SkeletonPartsRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonPartsRenderer.SkeletonPartsRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshGenerator#get", this ); }

                    this.LazyIntialize();
                    return this.meshGenerator;
                }
            },
            MeshRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshRenderer#get", this ); }

                    this.LazyIntialize();
                    return this.meshRenderer;
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#MeshFilter#get", this ); }

                    this.LazyIntialize();
                    return this.meshFilter;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#init", this ); }

                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize start.*/
            LazyIntialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#LazyIntialize", this ); }

                if (this.buffers == null) {
                    this.buffers = new Spine.Unity.MeshRendererBuffers();
                    this.buffers.Initialize();

                    if (this.meshGenerator != null) {
                        return;
                    }
                    this.meshGenerator = new Spine.Unity.MeshGenerator();
                    this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                    this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                    this.currentInstructions.Clear();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.LazyIntialize end.*/

            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#OnDestroy", this ); }

                if (this.buffers != null) {
                    this.buffers.Dispose();
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh start.*/
            ClearMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#ClearMesh", this ); }

                this.LazyIntialize();
                this.meshFilter.sharedMesh = null;
            },
            /*Spine.Unity.SkeletonPartsRenderer.ClearMesh end.*/

            /*Spine.Unity.SkeletonPartsRenderer.RenderParts start.*/
            RenderParts: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#RenderParts", this ); }

                this.LazyIntialize();

                // STEP 1: Create instruction
                var smartMesh = this.buffers.GetNextMesh();
                this.currentInstructions.SetWithSubset(instructions, startSubmesh, endSubmesh);
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(this.currentInstructions, smartMesh.instructionUsed);

                // STEP 2: Generate mesh buffers.
                var currentInstructionsSubmeshesItems = this.currentInstructions.submeshInstructions.Items;
                this.meshGenerator.Begin();
                if (this.currentInstructions.hasActiveClipping) {
                    for (var i = 0; i < this.currentInstructions.submeshInstructions.Count; i = (i + 1) | 0) {
                        this.meshGenerator.AddSubmesh(currentInstructionsSubmeshesItems[i], updateTriangles);
                    }
                } else {
                    this.meshGenerator.BuildMeshWithArrays(this.currentInstructions, updateTriangles);
                }

                this.buffers.UpdateSharedMaterials(this.currentInstructions.submeshInstructions);

                // STEP 3: modify mesh.
                var mesh = smartMesh.mesh;

                if (this.meshGenerator.VertexCount <= 0) { // Clear an empty mesh
                    updateTriangles = false;
                    mesh.Clear();
                } else {
                    this.meshGenerator.FillVertexData(mesh);
                    if (updateTriangles) {
                        this.meshGenerator.FillTriangles(mesh);
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    } else if (this.buffers.MaterialsChangedInLastUpdate()) {
                        this.meshRenderer.sharedMaterials = this.buffers.GetUpdatedSharedMaterialsArray();
                    }
                    this.meshGenerator.FillLateVertexData(mesh);
                }

                this.meshFilter.sharedMesh = mesh;
                smartMesh.instructionUsed.Set(this.currentInstructions);

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonPartsRenderer.RenderParts end.*/

            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock start.*/
            SetPropertyBlock: function (block) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonPartsRenderer#SetPropertyBlock", this ); }

                this.LazyIntialize();
                this.meshRenderer.SetPropertyBlock(block);
            },
            /*Spine.Unity.SkeletonPartsRenderer.SetPropertyBlock end.*/


        }
    });
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", {
        $kind: 1002,
        fields: {
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsMaskDisabled: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsInsideMask: null,
            /**
             * Material references for switching material sets at runtime when {@link } changes to {@link }.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             * @type Array.<UnityEngine.Material>
             */
            materialsOutsideMask: null
        },
        props: {
            AnyMaterialCreated: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#AnyMaterialCreated#get", this ); }

                    return this.materialsMaskDisabled.length > 0 || this.materialsInsideMask.length > 0 || this.materialsOutsideMask.length > 0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials#init", this ); }

                this.materialsMaskDisabled = System.Array.init(0, null, UnityEngine.Material);
                this.materialsInsideMask = System.Array.init(0, null, UnityEngine.Material);
                this.materialsOutsideMask = System.Array.init(0, null, UnityEngine.Material);
            }
        }
    });
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            skeletonRenderer: null,
            customSlotMaterials: null,
            customMaterialOverrides: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#init", this ); }

                this.customSlotMaterials = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)).ctor();
                this.customMaterialOverrides = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials start.*/
            SetCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (slotMaterialOverride.overrideDisabled || System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject != null) {
                        this.skeletonRenderer.CustomSlotMaterials.setItem(slotObject, slotMaterialOverride.material);
                    }
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials start.*/
            RemoveCustomSlotMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomSlotMaterials", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customSlotMaterials.Count; i = (i + 1) | 0) {
                    var slotMaterialOverride = this.customSlotMaterials.getItem(i).$clone();
                    if (System.String.isNullOrEmpty(slotMaterialOverride.slotName)) {
                        continue;
                    }

                    var slotObject = this.skeletonRenderer.skeleton.findSlot(slotMaterialOverride.slotName);
                    if (slotObject == null) {
                        continue;
                    }
                    var currentMaterial = { };
                    if (!this.skeletonRenderer.CustomSlotMaterials.tryGetValue(slotObject, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, slotMaterialOverride.material)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomSlotMaterials.remove(slotObject);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomSlotMaterials end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides start.*/
            SetCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#SetCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    if (atlasMaterialOverride.overrideDisabled) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.setItem(atlasMaterialOverride.originalMaterial, atlasMaterialOverride.replacementMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.SetCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides start.*/
            RemoveCustomMaterialOverrides: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#RemoveCustomMaterialOverrides", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                for (var i = 0; i < this.customMaterialOverrides.Count; i = (i + 1) | 0) {
                    var atlasMaterialOverride = this.customMaterialOverrides.getItem(i).$clone();
                    var currentMaterial = { };

                    if (!this.skeletonRenderer.CustomMaterialOverride.tryGetValue(atlasMaterialOverride.originalMaterial, currentMaterial)) {
                        continue;
                    }

                    // Do not revert the material if it was changed by something else
                    if (!Bridge.referenceEquals(currentMaterial.v, atlasMaterialOverride.replacementMaterial)) {
                        continue;
                    }

                    this.skeletonRenderer.CustomMaterialOverride.remove(atlasMaterialOverride.originalMaterial);
                }
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.RemoveCustomMaterialOverrides end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.skeletonRenderer.Initialize(false);
                this.SetCustomMaterialOverrides();
                this.SetCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnEnable end.*/

            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    UnityEngine.Debug.LogError$2("skeletonRenderer == null");
                    return;
                }

                this.RemoveCustomMaterialOverrides();
                this.RemoveCustomSlotMaterials();
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            originalMaterial: null,
            replacementMaterial: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$AtlasMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.originalMaterial, other.originalMaterial) && Bridge.referenceEquals(this.replacementMaterial, other.replacementMaterial);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([8608216668, this.overrideDisabled, this.originalMaterial, this.replacementMaterial]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.originalMaterial = this.originalMaterial;
                s.replacementMaterial = this.replacementMaterial;
                return s;
            }
        },
        overloads: {
            "Equals(AtlasMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    Bridge.define("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", {
        inherits: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#inherits", this ); }
 return [System.IEquatable$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride)]; },
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride(); }
            }
        },
        fields: {
            overrideDisabled: false,
            slotName: null,
            material: null
        },
        alias: ["equalsT", "System$IEquatable$1$Spine$Unity$SkeletonRendererCustomMaterials$SlotMaterialOverride$equalsT"],
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#equalsT", this ); }

                return this.overrideDisabled === other.overrideDisabled && Bridge.referenceEquals(this.slotName, other.slotName) && Bridge.referenceEquals(this.material, other.material);
            },
            /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride.equalsT end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#getHashCode", this ); }

                var h = Bridge.addHash([9094239955, this.overrideDisabled, this.slotName, this.material]);
                return h;
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride();
                s.overrideDisabled = this.overrideDisabled;
                s.slotName = this.slotName;
                s.material = this.material;
                return s;
            }
        },
        overloads: {
            "Equals(SlotMaterialOverride)": "equalsT"
        }
    });
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    /**
     * Instructions used by a SkeletonRenderer to render a mesh.
     *
     * @public
     * @class Spine.Unity.SkeletonRendererInstruction
     */
    Bridge.define("Spine.Unity.SkeletonRendererInstruction", {
        statics: {
            methods: {
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static start.*/
                GeometryNotEqual: function (a, b) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#GeometryNotEqual", this ); }


                    if (a.hasActiveClipping || b.hasActiveClipping) {
                        return true;
                    } // Triangles are unpredictable when clipping is active.

                    // Everything below assumes the raw vertex and triangle counts were used. (ie, no clipping was done)
                    if (a.rawVertexCount !== b.rawVertexCount) {
                        return true;
                    }

                    if (a.immutableTriangles !== b.immutableTriangles) {
                        return true;
                    }

                    var attachmentCountB = b.attachments.Count;
                    if (a.attachments.Count !== attachmentCountB) {
                        return true;
                    } // Bounds check for the looped storedAttachments count below.

                    // Submesh count changed
                    var submeshCountA = a.submeshInstructions.Count;
                    var submeshCountB = b.submeshInstructions.Count;
                    if (submeshCountA !== submeshCountB) {
                        return true;
                    }

                    // Submesh Instruction mismatch
                    var submeshInstructionsItemsA = a.submeshInstructions.Items;
                    var submeshInstructionsItemsB = b.submeshInstructions.Items;

                    var attachmentsA = a.attachments.Items;
                    var attachmentsB = b.attachments.Items;
                    for (var i = 0; i < attachmentCountB; i = (i + 1) | 0) {
                        if (!Bridge.referenceEquals(attachmentsA[i], attachmentsB[i])) {
                            return true;
                        }
                    }

                    for (var i1 = 0; i1 < submeshCountB; i1 = (i1 + 1) | 0) {
                        var submeshA = submeshInstructionsItemsA[i1].$clone();
                        var submeshB = submeshInstructionsItemsB[i1].$clone();

                        if (!(submeshA.rawVertexCount === submeshB.rawVertexCount && submeshA.startSlot === submeshB.startSlot && submeshA.endSlot === submeshB.endSlot && submeshA.rawTriangleCount === submeshB.rawTriangleCount && submeshA.rawFirstVertexIndex === submeshB.rawFirstVertexIndex)) {
                            return true;
                        }
                    }

                    return false;
                },
                /*Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual:static end.*/


            }
        },
        fields: {
            submeshInstructions: null,
            immutableTriangles: false,
            hasActiveClipping: false,
            rawVertexCount: 0,
            attachments: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#init", this ); }

                this.submeshInstructions = new (Spine.ExposedList$1(Spine.Unity.SubmeshInstruction)).ctor();
                this.rawVertexCount = -1;
                this.attachments = new (Spine.ExposedList$1(spine.Attachment)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRendererInstruction.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Clear", this ); }

                this.attachments.Clear(false);
                this.rawVertexCount = -1;
                this.hasActiveClipping = false;
                this.submeshInstructions.Clear(false);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Clear end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Dispose start.*/
            Dispose: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Dispose", this ); }

                this.attachments.Clear(true);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Dispose end.*/

            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset start.*/
            SetWithSubset: function (instructions, startSubmesh, endSubmesh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#SetWithSubset", this ); }

                var runningVertexCount = 0;

                var submeshes = this.submeshInstructions;
                submeshes.Clear(false);
                var submeshCount = (endSubmesh - startSubmesh) | 0;
                submeshes.Resize(submeshCount);
                var submeshesItems = submeshes.Items;
                var instructionsItems = instructions.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var instruction = instructionsItems[((startSubmesh + i) | 0)].$clone();
                    submeshesItems[i] = instruction.$clone();
                    this.hasActiveClipping = !!(this.hasActiveClipping | instruction.hasClipping);
                    submeshesItems[i].rawFirstVertexIndex = runningVertexCount; // Ensure current instructions have correct cached values.
                    runningVertexCount = (runningVertexCount + instruction.rawVertexCount) | 0; // vertexCount will also be used for the rest of this method.
                }
                this.rawVertexCount = runningVertexCount;

                // assumption: instructions are contiguous. start and end are valid within instructions.

                var startSlot = instructionsItems[startSubmesh].startSlot;
                var endSlot = instructionsItems[((endSubmesh - 1) | 0)].endSlot;
                this.attachments.Clear(false);
                var attachmentCount = (endSlot - startSlot) | 0;
                this.attachments.Resize(attachmentCount);
                var attachmentsItems = this.attachments.Items;

                var drawOrderItems = instructionsItems[0].skeleton.DrawOrder.Items;
                for (var i1 = 0; i1 < attachmentCount; i1 = (i1 + 1) | 0) {
                    var slot = drawOrderItems[((startSlot + i1) | 0)];
                    if (!slot.bone.isActive()) {
                        continue;
                    }
                    attachmentsItems[i1] = slot.getAttachment();
                }

            },
            /*Spine.Unity.SkeletonRendererInstruction.SetWithSubset end.*/

            /*Spine.Unity.SkeletonRendererInstruction.Set start.*/
            Set: function (other) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRendererInstruction#Set", this ); }

                this.immutableTriangles = other.immutableTriangles;

                this.hasActiveClipping = other.hasActiveClipping;
                this.rawVertexCount = other.rawVertexCount;
                this.attachments.Clear(false);
                this.attachments.EnsureCapacity(other.attachments.Capacity);
                this.attachments.Count = other.attachments.Count;
                other.attachments.CopyTo(this.attachments.Items);

                this.submeshInstructions.Clear(false);
                this.submeshInstructions.EnsureCapacity(other.submeshInstructions.Capacity);
                this.submeshInstructions.Count = other.submeshInstructions.Count;
                other.submeshInstructions.CopyTo(this.submeshInstructions.Items);
            },
            /*Spine.Unity.SkeletonRendererInstruction.Set end.*/


        }
    });
    /*Spine.Unity.SkeletonRendererInstruction end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonRenderer}    skeletonRenderer
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderSeparator start.*/
    Bridge.define("Spine.Unity.SkeletonRenderSeparator", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                DefaultSortingOrderIncrement: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                    this.DefaultSortingOrderIncrement = 5;
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static start.*/
                /**
                 * Adds a SkeletonRenderSeparator and child SkeletonPartsRenderer GameObjects to a given SkeletonRenderer.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderSeparator
                 * @memberof Spine.Unity.SkeletonRenderSeparator
                 * @param   {Spine.Unity.SkeletonRenderer}           skeletonRenderer            The target SkeletonRenderer or SkeletonAnimation.
                 * @param   {number}                                 sortingLayerID              Sorting layer to be used for the parts renderers.
                 * @param   {number}                                 extraPartsRenderers         Number of additional SkeletonPartsRenderers on top of the ones determined by counting the number of separator slots.
                 * @param   {number}                                 sortingOrderIncrement       The integer to increment the sorting order per SkeletonPartsRenderer to separate them.
                 * @param   {number}                                 baseSortingOrder            The sorting order value of the first SkeletonPartsRenderer.
                 * @param   {boolean}                                addMinimumPartsRenderers    If set to <pre><code>true</code></pre>, a minimum number of SkeletonPartsRenderer GameObjects (determined by separatorSlots.Count + 1) will be added.
                 * @return  {Spine.Unity.SkeletonRenderSeparator}                                The to skeleton renderer.
                 */
                AddToSkeletonRenderer: function (skeletonRenderer, sortingLayerID, extraPartsRenderers, sortingOrderIncrement, baseSortingOrder, addMinimumPartsRenderers) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddToSkeletonRenderer", this ); }

                    if (sortingLayerID === void 0) { sortingLayerID = 0; }
                    if (extraPartsRenderers === void 0) { extraPartsRenderers = 0; }
                    if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                    if (baseSortingOrder === void 0) { baseSortingOrder = 0; }
                    if (addMinimumPartsRenderers === void 0) { addMinimumPartsRenderers = true; }
                    if (UnityEngine.MonoBehaviour.op_Equality(skeletonRenderer, null)) {
                        UnityEngine.Debug.Log$1("Tried to add SkeletonRenderSeparator to a null SkeletonRenderer reference.");
                        return null;
                    }

                    var srs = skeletonRenderer.gameObject.AddComponent(Spine.Unity.SkeletonRenderSeparator);
                    srs.skeletonRenderer = skeletonRenderer;

                    skeletonRenderer.Initialize(false);
                    var count = extraPartsRenderers;
                    if (addMinimumPartsRenderers) {
                        count = (((extraPartsRenderers + skeletonRenderer.separatorSlots.Count) | 0) + 1) | 0;
                    }

                    var skeletonRendererTransform = skeletonRenderer.transform;
                    var componentRenderers = srs.partsRenderers;

                    for (var i = 0; i < count; i = (i + 1) | 0) {
                        var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(skeletonRendererTransform, Bridge.toString(i));
                        var mr = spr.MeshRenderer;
                        mr.sortingLayerID = sortingLayerID;
                        mr.sortingOrder = (baseSortingOrder + (Bridge.Int.mul(i, sortingOrderIncrement))) | 0;
                        componentRenderers.add(spr);
                    }

                    srs.OnEnable();


                    return srs;
                },
                /*Spine.Unity.SkeletonRenderSeparator.AddToSkeletonRenderer:static end.*/


            }
        },
        fields: {
            skeletonRenderer: null,
            mainMeshRenderer: null,
            copyPropertyBlock: false,
            copyMeshRendererFlags: false,
            partsRenderers: null,
            copiedBlock: null
        },
        events: {
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#SkeletonRenderer#set", this ); }

                    if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                        this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                    }

                    this.skeletonRenderer = value;
                    if (UnityEngine.MonoBehaviour.op_Equality(value, null)) {
                        this.enabled = false;
                    }
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#init", this ); }

                this.copyPropertyBlock = true;
                this.copyMeshRendererFlags = true;
                this.partsRenderers = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonPartsRenderer)).ctor();
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer start.*/
            /**
             * Add a child SkeletonPartsRenderer GameObject to this SkeletonRenderSeparator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderSeparator
             * @memberof Spine.Unity.SkeletonRenderSeparator
             * @param   {number}                               sortingOrderIncrement    
             * @param   {string}                               name
             * @return  {Spine.Unity.SkeletonPartsRenderer}
             */
            AddPartsRenderer: function (sortingOrderIncrement, name) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#AddPartsRenderer", this ); }

                if (sortingOrderIncrement === void 0) { sortingOrderIncrement = 5; }
                if (name === void 0) { name = null; }
                var sortingLayerID = 0;
                var sortingOrder = 0;
                if (this.partsRenderers.Count > 0) {
                    var previous = this.partsRenderers.getItem(((this.partsRenderers.Count - 1) | 0));
                    var previousMeshRenderer = previous.MeshRenderer;
                    sortingLayerID = previousMeshRenderer.sortingLayerID;
                    sortingOrder = (previousMeshRenderer.sortingOrder + sortingOrderIncrement) | 0;
                }

                if (System.String.isNullOrEmpty(name)) {
                    name = Bridge.toString(this.partsRenderers.Count);
                }

                var spr = Spine.Unity.SkeletonPartsRenderer.NewPartsRendererGameObject(this.skeletonRenderer.transform, name);
                this.partsRenderers.add(spr);

                var mr = spr.MeshRenderer;
                mr.sortingLayerID = sortingLayerID;
                mr.sortingOrder = sortingOrder;

                return spr;
            },
            /*Spine.Unity.SkeletonRenderSeparator.AddPartsRenderer end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                if (this.copiedBlock == null) {
                    this.copiedBlock = new UnityEngine.MaterialPropertyBlock();
                }
                this.mainMeshRenderer = this.skeletonRenderer.GetComponent(UnityEngine.MeshRenderer);

                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.addGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));

                if (this.copyMeshRendererFlags) {
                    var lightProbeUsage = this.mainMeshRenderer.lightProbeUsage;
                    var receiveShadows = this.mainMeshRenderer.receiveShadows;
                    var reflectionProbeUsage = this.mainMeshRenderer.reflectionProbeUsage;
                    var shadowCastingMode = this.mainMeshRenderer.shadowCastingMode;
                    var motionVectorGenerationMode = this.mainMeshRenderer.motionVectorGenerationMode;
                    var probeAnchor = this.mainMeshRenderer.probeAnchor;

                    for (var i = 0; i < this.partsRenderers.Count; i = (i + 1) | 0) {
                        var currentRenderer = this.partsRenderers.getItem(i);
                        if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                            continue;
                        } // skip null items.

                        var mr = currentRenderer.MeshRenderer;
                        mr.lightProbeUsage = lightProbeUsage;
                        mr.receiveShadows = receiveShadows;
                        mr.reflectionProbeUsage = reflectionProbeUsage;
                        mr.shadowCastingMode = shadowCastingMode;
                        mr.motionVectorGenerationMode = motionVectorGenerationMode;
                        mr.probeAnchor = probeAnchor;
                    }
                }

                if (this.skeletonRenderer.updateWhenInvisible !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.skeletonRenderer.LateUpdateMesh();
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnEnable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    return;
                }
                this.skeletonRenderer.removeGenerateMeshOverride(Bridge.fn.cacheBind(this, this.HandleRender));
                this.skeletonRenderer.LateUpdateMesh();
                this.ClearPartsRendererMeshes();
            },
            /*Spine.Unity.SkeletonRenderSeparator.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderSeparator.HandleRender start.*/
            HandleRender: function (instruction) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#HandleRender", this ); }

                var $t;
                var rendererCount = this.partsRenderers.Count;
                if (rendererCount <= 0) {
                    return;
                }

                var assignPropertyBlock = this.copyPropertyBlock && this.mainMeshRenderer.HasPropertyBlock();
                if (assignPropertyBlock) {
                    this.mainMeshRenderer.GetPropertyBlock(this.copiedBlock);
                }

                var settings = ($t = new Spine.Unity.MeshGenerator.Settings(), $t.addNormals = this.skeletonRenderer.addNormals, $t.calculateTangents = this.skeletonRenderer.calculateTangents, $t.immutableTriangles = false, $t.pmaVertexColors = this.skeletonRenderer.pmaVertexColors, $t.tintBlack = this.skeletonRenderer.tintBlack, $t.useClipping = true, $t.zSpacing = this.skeletonRenderer.zSpacing, $t);

                var submeshInstructions = instruction.submeshInstructions;
                var submeshInstructionsItems = submeshInstructions.Items;
                var lastSubmeshInstruction = (submeshInstructions.Count - 1) | 0;

                var rendererIndex = 0;
                var currentRenderer = this.partsRenderers.getItem(rendererIndex);
                for (var si = 0, start = 0; si <= lastSubmeshInstruction; si = (si + 1) | 0) {
                    if (UnityEngine.MonoBehaviour.op_Equality(currentRenderer, null)) {
                        continue;
                    }
                    if (submeshInstructionsItems[si].forceSeparate || si === lastSubmeshInstruction) {
                        // Apply properties
                        var meshGenerator = currentRenderer.MeshGenerator;
                        meshGenerator.settings = settings.$clone();

                        if (assignPropertyBlock) {
                            currentRenderer.SetPropertyBlock(this.copiedBlock);
                        }
                        // Render
                        currentRenderer.RenderParts(instruction.submeshInstructions, start, ((si + 1) | 0));

                        start = (si + 1) | 0;
                        rendererIndex = (rendererIndex + 1) | 0;
                        if (rendererIndex < rendererCount) {
                            currentRenderer = this.partsRenderers.getItem(rendererIndex);
                        } else {
                            // Not enough renderers. Skip the rest of the instructions.
                            break;
                        }
                    }
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this.skeletonRenderer);
                }

                // Clear extra renderers if they exist.
                for (; rendererIndex < rendererCount; rendererIndex = (rendererIndex + 1) | 0) {
                    currentRenderer = this.partsRenderers.getItem(rendererIndex);
                    if (UnityEngine.MonoBehaviour.op_Inequality(currentRenderer, null)) {
                        this.partsRenderers.getItem(rendererIndex).ClearMesh();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.HandleRender end.*/

            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes start.*/
            ClearPartsRendererMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderSeparator#ClearPartsRendererMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.partsRenderers);
                try {
                    while ($t.moveNext()) {
                        var partsRenderer = $t.Current;
                        if (UnityEngine.MonoBehaviour.op_Inequality(partsRenderer, null)) {
                            partsRenderer.ClearMesh();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderSeparator.ClearPartsRendererMeshes end.*/


        }
    });
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    Bridge.define("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getDefaultValue", this ); }
 return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo(); }
            }
        },
        fields: {
            start: null,
            current: null,
            mid: null,
            end: null,
            timeIsPastMid: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#init", this ); }

                this.start = new UnityEngine.Vector2();
                this.current = new UnityEngine.Vector2();
                this.mid = new UnityEngine.Vector2();
                this.end = new UnityEngine.Vector2();
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#getHashCode", this ); }

                var h = Bridge.addHash([5573033076, this.start, this.current, this.mid, this.end, this.timeIsPastMid]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SkeletonRootMotionBase.RootMotionInfo)) {
                    return false;
                }
                return Bridge.equals(this.start, o.start) && Bridge.equals(this.current, o.current) && Bridge.equals(this.mid, o.mid) && Bridge.equals(this.end, o.end) && Bridge.equals(this.timeIsPastMid, o.timeIsPastMid);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotionBase.RootMotionInfo#$clone", this ); }

                var s = to || new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                s.start = this.start.$clone();
                s.current = this.current.$clone();
                s.mid = this.mid.$clone();
                s.end = this.end.$clone();
                s.timeIsPastMid = this.timeIsPastMid;
                return s;
            }
        }
    });
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    /**
     * A minimal MaskableGraphic subclass for rendering multiple submeshes
     at a {@link }.
     *
     * @public
     * @class Spine.Unity.SkeletonSubmeshGraphic
     * @augments UnityEngine.UI.MaskableGraphic
     */
    Bridge.define("Spine.Unity.SkeletonSubmeshGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic],
        methods: {
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty start.*/
            SetMaterialDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetMaterialDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetMaterialDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty start.*/
            SetVerticesDirty: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#SetVerticesDirty", this ); }
 },
            /*Spine.Unity.SkeletonSubmeshGraphic.SetVerticesDirty end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh start.*/
            OnPopulateMesh: function (vh) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnPopulateMesh", this ); }

                vh.Clear();
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnPopulateMesh end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnDisable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                this.canvasRenderer.cull = true;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonSubmeshGraphic#OnEnable", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.OnEnable.call(this);
                this.canvasRenderer.cull = false;
            },
            /*Spine.Unity.SkeletonSubmeshGraphic.OnEnable end.*/


        }
    });
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    Bridge.define("Spine.Unity.SkeletonUtility", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static start.*/
                AddBoundingBoxGameObject: function (skeleton, skinName, slotName, attachmentName, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var skin = System.String.isNullOrEmpty(skinName) ? skeleton.data.defaultSkin : skeleton.data.findSkin(skinName);
                    if (skin == null) {
                        UnityEngine.Debug.LogError$2("Skin " + (skinName || "") + " not found!");
                        return null;
                    }

                    var slot = skeleton.findSlot(slotName);
                    var attachment = slot != null ? skin.getAttachment(slot.data.index, attachmentName) : null;
                    if (attachment == null) {
                        UnityEngine.Debug.LogFormat("Attachment in slot '{0}' named '{1}' not found in skin '{2}'.", [slotName, attachmentName, skin.name]);
                        return null;
                    }

                    var box = Bridge.as(attachment, spine.BoundingBoxAttachment);
                    if (box != null) {
                        return Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1(box.name, box, slot, parent, isTrigger);
                    } else {
                        UnityEngine.Debug.LogFormat("Attachment '{0}' was not a Bounding Box.", [attachmentName]);
                        return null;
                    }
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static start.*/
                AddBoundingBoxGameObject$1: function (name, box, slot, parent, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxGameObject$1", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    var go = new UnityEngine.GameObject.$ctor2("[BoundingBox]" + ((System.String.isNullOrEmpty(name) ? box.name : name) || ""));
                    var got = go.transform;
                    got.parent = parent;
                    got.localPosition = pc.Vec3.ZERO.clone();
                    got.localRotation = pc.Quat.IDENTITY.clone();
                    got.localScale = new pc.Vec3( 1, 1, 1 );
                    return Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent(box, slot, go, isTrigger);
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject$1:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static start.*/
                AddBoundingBoxAsComponent: function (box, slot, gameObject, isTrigger) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoundingBoxAsComponent", this ); }

                    if (isTrigger === void 0) { isTrigger = true; }
                    if (box == null) {
                        return null;
                    }
                    var collider = gameObject.AddComponent(UnityEngine.PolygonCollider2D);
                    collider.isTrigger = isTrigger;
                    Spine.Unity.SkeletonUtility.SetColliderPointsLocal(collider, slot, box);
                    return collider;
                },
                /*Spine.Unity.SkeletonUtility.AddBoundingBoxAsComponent:static end.*/

                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static start.*/
                SetColliderPointsLocal: function (collider, slot, box, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SetColliderPointsLocal", this ); }

                    if (scale === void 0) { scale = 1.0; }
                    if (box == null) {
                        return;
                    }
                    if (Spine.SpineSkeletonExtensions.IsWeighted(box)) {
                        UnityEngine.Debug.LogWarning$1("UnityEngine.PolygonCollider2D does not support weighted or animated points. Collider points will not be animated and may have incorrect orientation. If you want to use it as a collider, please remove weights and animations from the bounding box in Spine editor.");
                    }
                    var verts = Spine.Unity.SkeletonExtensions.GetLocalVertices(box, slot, null);
                    if (scale !== 1.0) {
                        for (var i = 0, n = verts.length; i < n; i = (i + 1) | 0) {
                            verts[i] = verts[i].$clone().scale( scale );
                        }
                    }
                    collider.SetPath$1(0, verts);
                },
                /*Spine.Unity.SkeletonUtility.SetColliderPointsLocal:static end.*/

                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static start.*/
                GetBoundingBoxBounds: function (boundingBox, depth) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoundingBoxBounds", this ); }

                    if (depth === void 0) { depth = 0.0; }
                    var floats = boundingBox.vertices;
                    var floatCount = floats.length;

                    var bounds = new pc.BoundingBox.ctor();

                    bounds.center = new pc.Vec3( floats[0], floats[1], 0 );
                    for (var i = 2; i < floatCount; i = (i + 2) | 0) {
                        bounds.expandToPoint( new pc.Vec3( floats[i], floats[((i + 1) | 0)], 0 ) );
                    }

                    var size = bounds.halfExtents.$clone().scale( 2 ).$clone();
                    size.z = depth;
                    bounds.halfExtents = size.$clone().$clone().scale( 0.5 );

                    return bounds;
                },
                /*Spine.Unity.SkeletonUtility.GetBoundingBoxBounds:static end.*/

                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static start.*/
                AddBoneRigidbody2D: function (gameObject, isKinematic, gravityScale) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#AddBoneRigidbody2D", this ); }

                    if (isKinematic === void 0) { isKinematic = true; }
                    if (gravityScale === void 0) { gravityScale = 0.0; }
                    var rb = gameObject.GetComponent(UnityEngine.Rigidbody2D);
                    if (UnityEngine.Component.op_Equality(rb, null)) {
                        rb = gameObject.AddComponent(UnityEngine.Rigidbody2D);
                        rb.isKinematic = isKinematic;
                        rb.gravityScale = gravityScale;
                    }
                    return rb;
                },
                /*Spine.Unity.SkeletonUtility.AddBoneRigidbody2D:static end.*/


            }
        },
        fields: {
            boneRoot: null,
            /**
             * If true, {@link } and {@link } are followed
             by 180 degree rotation. If false, negative Transform scale is used.
             Note that using negative scale is consistent with previous behaviour (hence the default),
             however causes serious problems with rigidbodies and physics. Therefore, it is recommended to
             enable this parameter where possible. When creating hinge chains for a chain of skeleton bones
             via {@link }, it is mandatory to have <pre><code>flipBy180DegreeRotation</code></pre> enabled.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtility
             * @default false
             * @type boolean
             */
            flipBy180DegreeRotation: false,
            skeletonRenderer: null,
            skeletonGraphic: null,
            skeletonAnimation: null,
            skeletonComponent: null,
            boneComponents: null,
            constraintComponents: null,
            positionScale: 0,
            hasOverrideBones: false,
            hasConstraints: false,
            needToReprocessBones: false
        },
        events: {
            OnReset: null
        },
        props: {
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SkeletonComponent#get", this ); }

                    if (this.skeletonComponent == null) {
                        this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                    }
                    return this.skeletonComponent;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Skeleton#get", this ); }

                    if (this.SkeletonComponent == null) {
                        return null;
                    }
                    return this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#IsValid#get", this ); }

                    return (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid) || (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) && this.skeletonGraphic.IsValid);
                }
            },
            PositionScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#PositionScale#get", this ); }

                    return this.positionScale;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#init", this ); }

                this.flipBy180DegreeRotation = false;
                this.boneComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityBone)).ctor();
                this.constraintComponents = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonUtilityConstraint)).ctor();
                this.positionScale = 1.0;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtility.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Update", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton != null && UnityEngine.Component.op_Inequality(this.boneRoot, null)) {

                    if (this.flipBy180DegreeRotation) {
                        this.boneRoot.localScale = new pc.Vec3( Math.abs(skeleton.scaleX), Math.abs(skeleton.scaleY), 1.0 );
                        this.boneRoot.eulerAngles = new pc.Vec3( skeleton.scaleY > 0 ? 0 : 180, skeleton.scaleX > 0 ? 0 : 180, 0 );
                    } else {
                        this.boneRoot.localScale = new pc.Vec3( skeleton.scaleX, skeleton.scaleY, 1.0 );
                    }
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.positionScale = this.skeletonGraphic.MeshScale;
                }
            },
            /*Spine.Unity.SkeletonUtility.Update end.*/

            /*Spine.Unity.SkeletonUtility.ResubscribeEvents start.*/
            ResubscribeEvents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#ResubscribeEvents", this ); }

                this.OnDisable();
                this.OnEnable();
            },
            /*Spine.Unity.SkeletonUtility.ResubscribeEvents end.*/

            /*Spine.Unity.SkeletonUtility.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer = this.GetComponent(Spine.Unity.SkeletonRenderer);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
                }
                if (this.skeletonAnimation == null) {
                    this.skeletonAnimation = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonAnimation) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonAnimation) : this.GetComponent(Spine.Unity.ISkeletonAnimation);
                }
                if (this.skeletonComponent == null) {
                    this.skeletonComponent = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) ? this.skeletonRenderer.GetComponent(Spine.Unity.ISkeletonComponent) : UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null) ? this.skeletonGraphic.GetComponent(Spine.Unity.ISkeletonComponent) : this.GetComponent(Spine.Unity.ISkeletonComponent);
                }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                    this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                } else if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                    this.skeletonGraphic.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                }

                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.OnEnable end.*/

            /*Spine.Unity.SkeletonUtility.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#Start", this ); }

                //recollect because order of operations failure when switching between game mode and edit mode...
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.Start end.*/

            /*Spine.Unity.SkeletonUtility.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset$1));
                }
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    this.skeletonGraphic.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRendererReset));
                }

                if (this.skeletonAnimation != null) {
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateLocal(Bridge.fn.cacheBind(this, this.UpdateLocal));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                    this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                }
            },
            /*Spine.Unity.SkeletonUtility.OnDisable end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 start.*/
            HandleRendererReset$1: function (r) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset$1", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset$1 end.*/

            /*Spine.Unity.SkeletonUtility.HandleRendererReset start.*/
            HandleRendererReset: function (g) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#HandleRendererReset", this ); }

                if (!Bridge.staticEquals(this.OnReset, null)) {
                    this.OnReset();
                }
                this.CollectBones();
            },
            /*Spine.Unity.SkeletonUtility.HandleRendererReset end.*/

            /*Spine.Unity.SkeletonUtility.RegisterBone start.*/
            RegisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterBone", this ); }

                if (this.boneComponents.contains(bone)) {
                    return;
                } else {
                    this.boneComponents.add(bone);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterBone end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterBone start.*/
            UnregisterBone: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterBone", this ); }

                this.boneComponents.remove(bone);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterBone end.*/

            /*Spine.Unity.SkeletonUtility.RegisterConstraint start.*/
            RegisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#RegisterConstraint", this ); }

                if (this.constraintComponents.contains(constraint)) {
                    return;
                } else {
                    this.constraintComponents.add(constraint);
                    this.needToReprocessBones = true;
                }
            },
            /*Spine.Unity.SkeletonUtility.RegisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.UnregisterConstraint start.*/
            UnregisterConstraint: function (constraint) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UnregisterConstraint", this ); }

                this.constraintComponents.remove(constraint);
            },
            /*Spine.Unity.SkeletonUtility.UnregisterConstraint end.*/

            /*Spine.Unity.SkeletonUtility.CollectBones start.*/
            CollectBones: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#CollectBones", this ); }

                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                if (skeleton == null) {
                    return;
                }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    var constraintTargets = new (System.Collections.Generic.List$1(System.Object)).ctor();
                    var ikConstraints = skeleton.IkConstraints;
                    for (var i = 0, n = ikConstraints.Count; i < n; i = (i + 1) | 0) {
                        constraintTargets.add(ikConstraints.Items[i].target);
                    }

                    var transformConstraints = skeleton.TransformConstraints;
                    for (var i1 = 0, n1 = transformConstraints.Count; i1 < n1; i1 = (i1 + 1) | 0) {
                        constraintTargets.add(transformConstraints.Items[i1].target);
                    }

                    var boneComponents = this.boneComponents;
                    for (var i2 = 0, n2 = boneComponents.Count; i2 < n2; i2 = (i2 + 1) | 0) {
                        var b = boneComponents.getItem(i2);
                        if (b.bone == null) {
                            b.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
                            if (b.bone == null) {
                                continue;
                            }
                        }
                        this.hasOverrideBones = !!(this.hasOverrideBones | (b.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override));
                        this.hasConstraints = !!(this.hasConstraints | constraintTargets.contains(b.bone));
                    }

                    this.hasConstraints = !!(this.hasConstraints | this.constraintComponents.Count > 0);

                    if (this.skeletonAnimation != null) {
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$removeUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));

                        if (this.hasOverrideBones || this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateWorld(Bridge.fn.cacheBind(this, this.UpdateWorld));
                        }

                        if (this.hasConstraints) {
                            this.skeletonAnimation.Spine$Unity$ISkeletonAnimation$addUpdateComplete(Bridge.fn.cacheBind(this, this.UpdateComplete));
                        }
                    }

                    this.needToReprocessBones = false;
                } else {
                    this.boneComponents.clear();
                    this.constraintComponents.clear();
                }
            },
            /*Spine.Unity.SkeletonUtility.CollectBones end.*/

            /*Spine.Unity.SkeletonUtility.UpdateLocal start.*/
            UpdateLocal: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateLocal", this ); }

                if (this.needToReprocessBones) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).transformLerpComplete = false;
                }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtility.UpdateLocal end.*/

            /*Spine.Unity.SkeletonUtility.UpdateWorld start.*/
            UpdateWorld: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateWorld", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.World);
                for (var i = 0, n = this.constraintComponents.Count; i < n; i = (i + 1) | 0) {
                    this.constraintComponents.getItem(i).DoUpdate();
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateWorld end.*/

            /*Spine.Unity.SkeletonUtility.UpdateComplete start.*/
            UpdateComplete: function (anim) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateComplete", this ); }

                this.UpdateAllBones(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete);
            },
            /*Spine.Unity.SkeletonUtility.UpdateComplete end.*/

            /*Spine.Unity.SkeletonUtility.UpdateAllBones start.*/
            UpdateAllBones: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#UpdateAllBones", this ); }

                if (UnityEngine.Component.op_Equality(this.boneRoot, null)) {
                    this.CollectBones();
                }

                var boneComponents = this.boneComponents;
                if (boneComponents == null) {
                    return;
                }
                for (var i = 0, n = boneComponents.Count; i < n; i = (i + 1) | 0) {
                    boneComponents.getItem(i).DoUpdate(phase);
                }
            },
            /*Spine.Unity.SkeletonUtility.UpdateAllBones end.*/

            /*Spine.Unity.SkeletonUtility.GetBoneRoot start.*/
            GetBoneRoot: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#GetBoneRoot", this ); }

                if (UnityEngine.Component.op_Inequality(this.boneRoot, null)) {
                    return this.boneRoot;
                }

                var boneRootObject = new UnityEngine.GameObject.$ctor2("SkeletonUtility-SkeletonRoot");
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    boneRootObject.AddComponent(UnityEngine.RectTransform);
                }

                this.boneRoot = boneRootObject.transform;
                this.boneRoot.SetParent(this.transform);
                this.boneRoot.localPosition = pc.Vec3.ZERO.clone();
                this.boneRoot.localRotation = pc.Quat.IDENTITY.clone();
                this.boneRoot.localScale = new pc.Vec3( 1, 1, 1 );

                return this.boneRoot;
            },
            /*Spine.Unity.SkeletonUtility.GetBoneRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnRoot start.*/
            SpawnRoot: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnRoot", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;

                var go = this.SpawnBone(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnRoot end.*/

            /*Spine.Unity.SkeletonUtility.SpawnHierarchy start.*/
            SpawnHierarchy: function (mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnHierarchy", this ); }

                this.GetBoneRoot();
                var skeleton = this.skeletonComponent.Spine$Unity$ISkeletonComponent$Skeleton;
                var go = this.SpawnBoneRecursively(skeleton.getRootBone(), this.boneRoot, mode, pos, rot, sca);
                this.CollectBones();
                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnHierarchy end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively start.*/
            SpawnBoneRecursively: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBoneRecursively", this ); }

                var go = this.SpawnBone(bone, parent, mode, pos, rot, sca);

                var childrenBones = bone.Children;
                for (var i = 0, n = childrenBones.Count; i < n; i = (i + 1) | 0) {
                    var child = childrenBones.Items[i];
                    this.SpawnBoneRecursively(child, go.transform, mode, pos, rot, sca);
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBoneRecursively end.*/

            /*Spine.Unity.SkeletonUtility.SpawnBone start.*/
            SpawnBone: function (bone, parent, mode, pos, rot, sca) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtility#SpawnBone", this ); }

                var go = new UnityEngine.GameObject.$ctor2(bone.data.name);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonGraphic, null)) {
                    go.AddComponent(UnityEngine.RectTransform);
                }

                var goTransform = go.transform;
                goTransform.SetParent(parent);

                var b = go.AddComponent(Spine.Unity.SkeletonUtilityBone);
                b.hierarchy = this;
                b.position = pos;
                b.rotation = rot;
                b.scale = sca;
                b.mode = mode;
                b.zPosition = true;
                b.Reset();
                b.bone = bone;
                b.boneName = bone.data.name;
                b.valid = true;

                if (mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (rot) {
                        goTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, b.bone.arotation );
                    }
                    if (pos) {
                        goTransform.localPosition = new pc.Vec3( b.bone.x * this.positionScale, b.bone.y * this.positionScale, 0 );
                    }
                    goTransform.localScale = new pc.Vec3( b.bone.scaleX, b.bone.scaleY, 0 );
                }

                return go;
            },
            /*Spine.Unity.SkeletonUtility.SpawnBone end.*/


        },
        overloads: {
            "HandleRendererReset(SkeletonRenderer)": "HandleRendererReset$1"
        }
    });
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    /**
     * Sets a GameObject's transform to match a bone on a Spine skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonUtilityBone
     * @augments UnityEngine.MonoBehaviour
     */
    Bridge.define("Spine.Unity.SkeletonUtilityBone", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static start.*/
                BoneTransformModeIncompatible: function (bone) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#BoneTransformModeIncompatible", this ); }

                    return !Spine.SpineSkeletonExtensions.InheritsScale(bone.data.transformMode);
                },
                /*Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible:static end.*/


            }
        },
        fields: {
            /**
             * If a bone isn't set, boneName is used to find the bone.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonUtilityBone
             * @type string
             */
            boneName: null,
            parentReference: null,
            mode: 0,
            position: false,
            rotation: false,
            scale: false,
            zPosition: false,
            overrideAlpha: 0,
            hierarchy: null,
            bone: null,
            transformLerpComplete: false,
            valid: false,
            cachedTransform: null,
            skeletonTransform: null,
            incompatibleTransformMode: false
        },
        props: {
            IncompatibleTransformMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#IncompatibleTransformMode#get", this ); }

                    return this.incompatibleTransformMode;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#init", this ); }

                this.zPosition = true;
                this.overrideAlpha = 1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityBone.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#Reset", this ); }

                this.bone = null;
                this.cachedTransform = this.transform;
                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null) && this.hierarchy.IsValid;
                if (!this.valid) {
                    return;
                }
                this.skeletonTransform = this.hierarchy.transform;
                this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                this.DoUpdate(Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local);
            },
            /*Spine.Unity.SkeletonUtilityBone.Reset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnEnable", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                }
                if (UnityEngine.MonoBehaviour.op_Equality(this.hierarchy, null)) {
                    return;
                }

                this.hierarchy.RegisterBone(this);
                this.hierarchy.addOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
            },
            /*Spine.Unity.SkeletonUtilityBone.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset start.*/
            HandleOnReset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#HandleOnReset", this ); }

                this.Reset();
            },
            /*Spine.Unity.SkeletonUtilityBone.HandleOnReset end.*/

            /*Spine.Unity.SkeletonUtilityBone.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#OnDisable", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.hierarchy, null)) {
                    this.hierarchy.removeOnReset(Bridge.fn.cacheBind(this, this.HandleOnReset));
                    this.hierarchy.UnregisterBone(this);
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.OnDisable end.*/

            /*Spine.Unity.SkeletonUtilityBone.DoUpdate start.*/
            DoUpdate: function (phase) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#DoUpdate", this ); }

                var $t;
                if (!this.valid) {
                    this.Reset();
                    return;
                }

                var skeleton = this.hierarchy.Skeleton;

                if (this.bone == null) {
                    if (System.String.isNullOrEmpty(this.boneName)) {
                        return;
                    }
                    this.bone = skeleton.findBone(this.boneName);
                    if (this.bone == null) {
                        UnityEngine.Debug.LogError$2("Bone not found: " + (this.boneName || ""), this);
                        return;
                    }
                }
                if (!this.bone.isActive()) {
                    return;
                }

                var positionScale = this.hierarchy.PositionScale;

                var thisTransform = this.cachedTransform;
                var skeletonFlipRotation = ($t = skeleton.scaleX * skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Follow) {
                    switch (phase) {
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Local: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.x * positionScale, this.bone.y * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.rotation );
                                } else {
                                    var euler = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler.x, euler.y, euler.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.scaleX, this.bone.scaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.World: 
                        case Spine.Unity.SkeletonUtilityBone.UpdatePhase.Complete: 
                            if (this.position) {
                                thisTransform.localPosition = new pc.Vec3( this.bone.ax * positionScale, this.bone.ay * positionScale, 0 );
                            }
                            if (this.rotation) {
                                if (Spine.SpineSkeletonExtensions.InheritsRotation(this.bone.data.transformMode)) {
                                    thisTransform.localRotation = new pc.Quat().setFromEulerAngles_Unity( 0, 0, this.bone.arotation );
                                } else {
                                    var euler1 = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                                    thisTransform.rotation = new pc.Quat().setFromEulerAngles_Unity( euler1.x, euler1.y, euler1.z + (this.bone.getWorldRotationX() * skeletonFlipRotation) );
                                }
                            }
                            if (this.scale) {
                                thisTransform.localScale = new pc.Vec3( this.bone.ascaleX, this.bone.ascaleY, 1.0 );
                                this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                            }
                            break;
                    }

                } else if (this.mode === Spine.Unity.SkeletonUtilityBone.Mode.Override) {
                    if (this.transformLerpComplete) {
                        return;
                    }

                    if (UnityEngine.Component.op_Equality(this.parentReference, null)) {
                        if (this.position) {
                            var clp = thisTransform.localPosition.$clone().scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, clp.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, clp.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle = UnityEngine.Mathf.LerpAngle(this.bone.rotation, thisTransform.localRotation.getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle;
                            this.bone.arotation = angle;
                        }

                        if (this.scale) {
                            var cls = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls.y, this.overrideAlpha);
                        }

                    } else {
                        if (this.transformLerpComplete) {
                            return;
                        }

                        if (this.position) {
                            var pos = this.parentReference.InverseTransformPoint(thisTransform.position).scale( 1.0 / ( positionScale ) );
                            this.bone.x = pc.math.lerp(this.bone.x, pos.x, this.overrideAlpha);
                            this.bone.y = pc.math.lerp(this.bone.y, pos.y, this.overrideAlpha);
                        }

                        if (this.rotation) {
                            var angle1 = UnityEngine.Mathf.LerpAngle(this.bone.rotation, new pc.Quat().lookRotation( new pc.Vec3( 0, 0, 1 ), this.parentReference.InverseTransformDirection(thisTransform.up) ).getPositiveEulerAngles().z, this.overrideAlpha);
                            this.bone.rotation = angle1;
                            this.bone.arotation = angle1;
                        }

                        if (this.scale) {
                            var cls1 = thisTransform.localScale.$clone();
                            this.bone.scaleX = pc.math.lerp(this.bone.scaleX, cls1.x, this.overrideAlpha);
                            this.bone.scaleY = pc.math.lerp(this.bone.scaleY, cls1.y, this.overrideAlpha);
                        }

                        this.incompatibleTransformMode = Spine.Unity.SkeletonUtilityBone.BoneTransformModeIncompatible(this.bone);
                    }

                    this.transformLerpComplete = true;
                }
            },
            /*Spine.Unity.SkeletonUtilityBone.DoUpdate end.*/

            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox start.*/
            AddBoundingBox: function (skinName, slotName, attachmentName) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityBone#AddBoundingBox", this ); }

                Spine.Unity.SkeletonUtility.AddBoneRigidbody2D(this.transform.gameObject);
                Spine.Unity.SkeletonUtility.AddBoundingBoxGameObject(this.bone.skeleton, skinName, slotName, attachmentName, this.transform);
            },
            /*Spine.Unity.SkeletonUtilityBone.AddBoundingBox end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.Mode", {
        $kind: 1006,
        statics: {
            fields: {
                Follow: 0,
                Override: 1
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityBone.UpdatePhase", {
        $kind: 1006,
        statics: {
            fields: {
                Local: 0,
                World: 1,
                Complete: 2
            }
        }
    });
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    Bridge.define("Spine.Unity.SkeletonUtilityConstraint", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bone: null,
            hierarchy: null
        },
        methods: {
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnEnable", this ); }

                this.bone = this.GetComponent(Spine.Unity.SkeletonUtilityBone);
                this.hierarchy = this.transform.GetComponentInParent(Spine.Unity.SkeletonUtility);
                this.hierarchy.RegisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnEnable end.*/

            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonUtilityConstraint#OnDisable", this ); }

                this.hierarchy.UnregisterConstraint(this);
            },
            /*Spine.Unity.SkeletonUtilityConstraint.OnDisable end.*/


        }
    });
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    Bridge.define("Spine.Unity.SpineAttributeBase", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            dataField: null,
            startsWith: null,
            includeNone: false,
            fallbackToTextField: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttributeBase#init", this ); }

                this.dataField = "";
                this.startsWith = "";
                this.includeNone = true;
                this.fallbackToTextField = false;
            }
        }
    });
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    Bridge.define("Spine.Unity.SpineAtlasRegion", {
        inherits: [UnityEngine.PropertyAttribute],
        fields: {
            atlasAssetField: null
        },
        ctors: {
            ctor: function (atlasAssetField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasRegion#ctor", this ); }

                if (atlasAssetField === void 0) { atlasAssetField = ""; }

                this.$initialize();
                UnityEngine.PropertyAttribute.ctor.call(this);
                this.atlasAssetField = atlasAssetField;
            }
        }
    });
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    /**
     * A struct that represents 3 strings that help identify and locate an attachment in a skeleton.
     *
     * @public
     * @class Spine.Unity.SpineAttachment.Hierarchy
     */
    Bridge.define("Spine.Unity.SpineAttachment.Hierarchy", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getDefaultValue", this ); }
 return new Spine.Unity.SpineAttachment.Hierarchy(); }
            }
        },
        fields: {
            skin: null,
            slot: null,
            name: null
        },
        ctors: {
            $ctor1: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$ctor1", this ); }

                this.$initialize();
                var chunks = System.String.split(fullPath, System.Array.init([47], System.Char).map(function (i) {{ return String.fromCharCode(i); }}), null, 1);
                if (chunks.length === 0) {
                    this.skin = "";
                    this.slot = "";
                    this.name = "";
                    return;
                } else if (chunks.length < 2) {
                    throw new System.Exception("Cannot generate Attachment Hierarchy from string! Not enough components! [" + (fullPath || "") + "]");
                }
                this.skin = chunks[0];
                this.slot = chunks[1];
                this.name = "";
                for (var i = 2; i < chunks.length; i = (i + 1) | 0) {
                    this.name = (this.name || "") + (chunks[i] || "");
                }
            },
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#getHashCode", this ); }

                var h = Bridge.addHash([3670596642, this.skin, this.slot, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SpineAttachment.Hierarchy)) {
                    return false;
                }
                return Bridge.equals(this.skin, o.skin) && Bridge.equals(this.slot, o.slot) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment.Hierarchy#$clone", this ); }

                var s = to || new Spine.Unity.SpineAttachment.Hierarchy();
                s.skin = this.skin;
                s.slot = this.slot;
                s.name = this.name;
                return s;
            }
        }
    });
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineMesh start.*/
    Bridge.define("Spine.Unity.SpineMesh", {
        statics: {
            fields: {
                MeshHideflags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#init", this ); }

                    this.MeshHideflags = 20;
                }
            },
            methods: {
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static start.*/
                /**
                 * Factory method for creating a new mesh for use in Spine components. This can be called in field initializers.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineMesh
                 * @memberof Spine.Unity.SpineMesh
                 * @return  {UnityEngine.Mesh}
                 */
                NewSkeletonMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineMesh#NewSkeletonMesh", this ); }

                    var m = new UnityEngine.Mesh.ctor();
                    m.MarkDynamic();
                    m.name = "Skeleton Mesh";
                    m.hideFlags = Spine.Unity.SpineMesh.MeshHideflags;
                    return m;
                },
                /*Spine.Unity.SpineMesh.NewSkeletonMesh:static end.*/


            }
        }
    });
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", {
        $kind: 1002,
        fields: {
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            packingRotation: 0
        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    /**
     * Instructions for how to generate a mesh or submesh: "Render this skeleton's slots: start slot, up to but not including endSlot, using this material."
     *
     * @public
     * @class Spine.Unity.SubmeshInstruction
     */
    Bridge.define("Spine.Unity.SubmeshInstruction", {
        $kind: 4,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getDefaultValue", this ); }
 return new Spine.Unity.SubmeshInstruction(); }
            }
        },
        fields: {
            skeleton: null,
            startSlot: 0,
            endSlot: 0,
            material: null,
            forceSeparate: false,
            preActiveClippingSlotSource: 0,
            rawTriangleCount: 0,
            rawVertexCount: 0,
            rawFirstVertexIndex: 0,
            hasClipping: false,
            hasPMAAdditiveSlot: false
        },
        props: {
            /**
             * The number of slots in this SubmeshInstruction's range. Not necessarily the number of attachments.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SubmeshInstruction
             * @function SlotCount
             * @type number
             */
            SlotCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#SlotCount#get", this ); }

                    return ((this.endSlot - this.startSlot) | 0);
                }
            }
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*Spine.Unity.SubmeshInstruction.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#toString", this ); }

                return System.String.format("[SubmeshInstruction: slots {0} to {1}. (Material){2}. preActiveClippingSlotSource:{3}]", Bridge.box(this.startSlot, System.Int32), Bridge.box(((this.endSlot - 1) | 0), System.Int32), this.material == null ? "<none>" : this.material.name, Bridge.box(this.preActiveClippingSlotSource, System.Int32));
            },
            /*Spine.Unity.SubmeshInstruction.toString end.*/

            getHashCode: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#getHashCode", this ); }

                var h = Bridge.addHash([6756249098, this.skeleton, this.startSlot, this.endSlot, this.material, this.forceSeparate, this.preActiveClippingSlotSource, this.rawTriangleCount, this.rawVertexCount, this.rawFirstVertexIndex, this.hasClipping, this.hasPMAAdditiveSlot]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#equals", this ); }

                if (!Bridge.is(o, Spine.Unity.SubmeshInstruction)) {
                    return false;
                }
                return Bridge.equals(this.skeleton, o.skeleton) && Bridge.equals(this.startSlot, o.startSlot) && Bridge.equals(this.endSlot, o.endSlot) && Bridge.equals(this.material, o.material) && Bridge.equals(this.forceSeparate, o.forceSeparate) && Bridge.equals(this.preActiveClippingSlotSource, o.preActiveClippingSlotSource) && Bridge.equals(this.rawTriangleCount, o.rawTriangleCount) && Bridge.equals(this.rawVertexCount, o.rawVertexCount) && Bridge.equals(this.rawFirstVertexIndex, o.rawFirstVertexIndex) && Bridge.equals(this.hasClipping, o.hasClipping) && Bridge.equals(this.hasPMAAdditiveSlot, o.hasPMAAdditiveSlot);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "Spine.Unity.SubmeshInstruction#$clone", this ); }

                var s = to || new Spine.Unity.SubmeshInstruction();
                s.skeleton = this.skeleton;
                s.startSlot = this.startSlot;
                s.endSlot = this.endSlot;
                s.material = this.material;
                s.forceSeparate = this.forceSeparate;
                s.preActiveClippingSlotSource = this.preActiveClippingSlotSource;
                s.rawTriangleCount = this.rawTriangleCount;
                s.rawVertexCount = this.rawVertexCount;
                s.rawFirstVertexIndex = this.rawFirstVertexIndex;
                s.hasClipping = this.hasClipping;
                s.hasPMAAdditiveSlot = this.hasPMAAdditiveSlot;
                return s;
            }
        },
        overloads: {
            "ToString()": "toString"
        }
    });
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.UpdateMode start.*/
    Bridge.define("Spine.Unity.UpdateMode", {
        $kind: 6,
        statics: {
            fields: {
                Nothing: 0,
                OnlyAnimationStatus: 1,
                OnlyEventTimelines: 4,
                EverythingExceptMesh: 2,
                FullUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    Bridge.define("Spine.Unity.UpdateTiming", {
        $kind: 6,
        statics: {
            fields: {
                ManualUpdate: 0,
                InUpdate: 1,
                InFixedUpdate: 2,
                InLateUpdate: 3
            }
        }
    });
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    /**
     * Use this as a condition-blocking yield instruction for Unity Coroutines.
     The routine will pause until the AnimationState fires an event matching the given event name or EventData reference.
     *
     * @public
     * @class Spine.Unity.WaitForSpineEvent
     * @implements  System.Collections.IEnumerator
     */
    Bridge.define("Spine.Unity.WaitForSpineEvent", {
        inherits: [System.Collections.IEnumerator],
        fields: {
            m_TargetEvent: null,
            m_EventName: null,
            m_AnimationState: null,
            m_WasFired: false,
            m_unsubscribeAfterFiring: false
        },
        props: {
            /**
             * By default, WaitForSpineEvent will unsubscribe from the event immediately after it fires a correct matching event.
             If you want to reuse this WaitForSpineEvent instance on the same event, you can set this to false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.WaitForSpineEvent
             * @function WillUnsubscribeAfterFiring
             * @type boolean
             */
            WillUnsubscribeAfterFiring: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#get", this ); }

                    return this.m_unsubscribeAfterFiring;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#WillUnsubscribeAfterFiring#set", this ); }

                    this.m_unsubscribeAfterFiring = value;
                }
            },
            System$Collections$IEnumerator$Current: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$Current#get", this ); }

                    return null;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#init", this ); }

                this.m_WasFired = false;
                this.m_unsubscribeAfterFiring = false;
            },
            ctor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#ctor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor2: function (skeletonAnimation, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor2", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.Subscribe(skeletonAnimation.state, eventDataReference, unsubscribeAfterFiring);
            },
            $ctor1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);
            },
            $ctor3: function (skeletonAnimation, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#$ctor3", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }

                this.$initialize();
                // If skeletonAnimation is invalid, its state will be null. Subscribe handles null states just fine.
                this.SubscribeByName(skeletonAnimation.state, eventName, unsubscribeAfterFiring);
            }
        },
        methods: {
            /*Spine.Unity.WaitForSpineEvent.Subscribe start.*/
            Subscribe: function (state, eventDataReference, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Subscribe", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (eventDataReference == null) {
                    UnityEngine.Debug.LogWarning$1("eventDataReference argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_TargetEvent = eventDataReference;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));

                this.m_unsubscribeAfterFiring = unsubscribe;

            },
            /*Spine.Unity.WaitForSpineEvent.Subscribe end.*/

            /*Spine.Unity.WaitForSpineEvent.SubscribeByName start.*/
            SubscribeByName: function (state, eventName, unsubscribe) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#SubscribeByName", this ); }

                if (state == null) {
                    UnityEngine.Debug.LogWarning$1("AnimationState argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                } else if (System.String.isNullOrEmpty(eventName)) {
                    UnityEngine.Debug.LogWarning$1("eventName argument was null. Coroutine will continue immediately.");
                    this.m_WasFired = true;
                    return;
                }

                this.m_AnimationState = state;
                this.m_EventName = eventName;
                state.addEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));

                this.m_unsubscribeAfterFiring = unsubscribe;
            },
            /*Spine.Unity.WaitForSpineEvent.SubscribeByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName start.*/
            HandleAnimationStateEventByName: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEventByName", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data.name, this.m_EventName))); // Check event name string match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
                } // Unsubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEventByName end.*/

            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent start.*/
            HandleAnimationStateEvent: function (trackEntry, e) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#HandleAnimationStateEvent", this ); }

                this.m_WasFired = !!(this.m_WasFired | (Bridge.referenceEquals(e.data, this.m_TargetEvent))); // Check event data reference match.
                if (this.m_WasFired && this.m_unsubscribeAfterFiring) {
                    this.m_AnimationState.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                } // Usubscribe after correct event fires.
            },
            /*Spine.Unity.WaitForSpineEvent.HandleAnimationStateEvent end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor start.*/
            NowWaitFor: function (state, eventDataReference, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.Subscribe(state, eventDataReference, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor end.*/

            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 start.*/
            NowWaitFor$1: function (state, eventName, unsubscribeAfterFiring) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#NowWaitFor$1", this ); }

                if (unsubscribeAfterFiring === void 0) { unsubscribeAfterFiring = true; }
                Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset();
                this.Clear(state);
                this.SubscribeByName(state, eventName, unsubscribeAfterFiring);

                return this;
            },
            /*Spine.Unity.WaitForSpineEvent.NowWaitFor$1 end.*/

            /*Spine.Unity.WaitForSpineEvent.Clear start.*/
            Clear: function (state) {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#Clear", this ); }

                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEvent));
                state.removeEvent(Bridge.fn.cacheBind(this, this.HandleAnimationStateEventByName));
            },
            /*Spine.Unity.WaitForSpineEvent.Clear end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext start.*/
            System$Collections$IEnumerator$moveNext: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$moveNext", this ); }

                if (this.m_WasFired) {
                    Bridge.cast(this, System.Collections.IEnumerator).System$Collections$IEnumerator$reset(); // auto-reset for YieldInstruction reuse
                    return false;
                }

                return true;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$moveNext end.*/

            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset start.*/
            System$Collections$IEnumerator$reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.WaitForSpineEvent#System$Collections$IEnumerator$reset", this ); }

                this.m_WasFired = false;
            },
            /*Spine.Unity.WaitForSpineEvent.System$Collections$IEnumerator$reset end.*/


        },
        overloads: {
            "NowWaitFor(Spine.AnimationState, string, bool)": "NowWaitFor$1"
        }
    });
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*StarSystem start.*/
    Bridge.define("StarSystem", {
        inherits: [UnityEngine.MonoBehaviour],
        statics: {
            fields: {
                CURRENT_STAR: null
            },
            events: {
                OnAddStarEvent: null,
                OnMinusStarEvent: null,
                OnSetStarEvent: null,
                ActionChangeValue: null
            },
            props: {
                CurrentStar: {
                    get: function () {
if ( TRACE ) { TRACE( "StarSystem#CurrentStar#get", this ); }

                        return VirtueSky.DataStorage.GameData.Get(System.Int32, StarSystem.CURRENT_STAR, 0);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "StarSystem#CurrentStar#set", this ); }

                        VirtueSky.DataStorage.GameData.Set(System.Int32, StarSystem.CURRENT_STAR, value);
                        VirtueSky.DataStorage.GameData.Save();
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "StarSystem#init", this ); }

                    this.CURRENT_STAR = "CURRENT_STAR";
                }
            },
            methods: {
                /*StarSystem.AddStar:static start.*/
                AddStar: function (value, posGenerateCoin, resourceType, resourceReason, placement, isGenerate) {
if ( TRACE ) { TRACE( "StarSystem#AddStar", this ); }

                    if (isGenerate === void 0) { isGenerate = true; }
                    !Bridge.staticEquals(StarSystem.OnAddStarEvent, null) ? StarSystem.OnAddStarEvent(value, posGenerateCoin.$clone(), resourceType, TrackingEnum.EResourceName.star, resourceReason, placement, isGenerate) : null;
                },
                /*StarSystem.AddStar:static end.*/

                /*StarSystem.MinusStar:static start.*/
                MinusStar: function (value, resourceType, resourceReason, placement) {
if ( TRACE ) { TRACE( "StarSystem#MinusStar", this ); }

                    !Bridge.staticEquals(StarSystem.OnMinusStarEvent, null) ? StarSystem.OnMinusStarEvent(value, resourceType, TrackingEnum.EResourceName.star, resourceReason, placement) : null;
                },
                /*StarSystem.MinusStar:static end.*/

                /*StarSystem.SetStar:static start.*/
                SetStar: function (value, posGenerateCoin, resourceType, resourceReason, placement) {
if ( TRACE ) { TRACE( "StarSystem#SetStar", this ); }

                    !Bridge.staticEquals(StarSystem.OnSetStarEvent, null) ? StarSystem.OnSetStarEvent(value, posGenerateCoin.$clone(), resourceType, TrackingEnum.EResourceName.star, resourceReason, placement) : null;
                },
                /*StarSystem.SetStar:static end.*/

                /*StarSystem.GetCurrentStar:static start.*/
                GetCurrentStar: function () {
if ( TRACE ) { TRACE( "StarSystem#GetCurrentStar", this ); }

                    return StarSystem.CurrentStar;
                },
                /*StarSystem.GetCurrentStar:static end.*/


            }
        },
        fields: {
            generateStarEvent: null,
            addStarEvent: null,
            minusStarEvent: null,
            addStarCompleteEvent: null,
            balanceAmount: null
        },
        methods: {
            /*StarSystem.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "StarSystem#Awake", this ); }

                StarSystem.addOnAddStarEvent(Bridge.fn.cacheBind(this, this.InternalAddStar));
                StarSystem.addOnMinusStarEvent(Bridge.fn.cacheBind(this, this.InternalMinusStar));
                StarSystem.addOnSetStarEvent(Bridge.fn.cacheBind(this, this.InternalSetStar));
            },
            /*StarSystem.Awake end.*/

            /*StarSystem.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "StarSystem#OnDestroy", this ); }

                StarSystem.removeOnAddStarEvent(Bridge.fn.cacheBind(this, this.InternalAddStar));
                StarSystem.removeOnMinusStarEvent(Bridge.fn.cacheBind(this, this.InternalMinusStar));
                StarSystem.removeOnSetStarEvent(Bridge.fn.cacheBind(this, this.InternalSetStar));
            },
            /*StarSystem.OnDestroy end.*/

            /*StarSystem.InternalSetStar start.*/
            InternalSetStar: function (value, posGenerateCoin, resourceType, resourceName, resourceReason, placement) {
if ( TRACE ) { TRACE( "StarSystem#InternalSetStar", this ); }

                if (value > StarSystem.CurrentStar) {
                    var valueChange = (value - StarSystem.CurrentStar) | 0;

                    StarSystem.CurrentStar = value;
                    this.OnChangeValue(StarSystem.CurrentStar);
                    this.addStarEvent.Raise();

                    if (!pc.Vec3.equals( posGenerateCoin, Bridge.getDefaultValue(UnityEngine.Vector3) )) {
                        this.generateStarEvent.Raise(posGenerateCoin.$clone());
                    }
                } else if (value < StarSystem.CurrentStar) {
                    var valueChange1 = (StarSystem.CurrentStar - value) | 0;

                    StarSystem.CurrentStar = value;
                    this.OnChangeValue(StarSystem.CurrentStar);
                    this.minusStarEvent.Raise();
                }
            },
            /*StarSystem.InternalSetStar end.*/

            /*StarSystem.InternalAddStar start.*/
            InternalAddStar: function (value, posGenerateCoin, resourceType, resourceName, resourceReason, placement, isGenerate) {
if ( TRACE ) { TRACE( "StarSystem#InternalAddStar", this ); }

                if (isGenerate === void 0) { isGenerate = true; }

                StarSystem.CurrentStar = (StarSystem.CurrentStar + value) | 0;
                this.OnChangeValue(StarSystem.CurrentStar);
                if (isGenerate) {
                    this.addStarEvent.Raise();
                } else {
                    this.addStarCompleteEvent != null ? this.addStarCompleteEvent.Raise() : null;
                }

                if (!pc.Vec3.equals( posGenerateCoin, Bridge.getDefaultValue(UnityEngine.Vector3) )) {
                    this.generateStarEvent.Raise(posGenerateCoin.$clone());
                }
            },
            /*StarSystem.InternalAddStar end.*/

            /*StarSystem.InternalMinusStar start.*/
            InternalMinusStar: function (value, resourceType, resourceName, resourceReason, placement) {
if ( TRACE ) { TRACE( "StarSystem#InternalMinusStar", this ); }

                StarSystem.CurrentStar = (StarSystem.CurrentStar - value) | 0;
                this.OnChangeValue(StarSystem.CurrentStar);
                this.minusStarEvent.Raise();
            },
            /*StarSystem.InternalMinusStar end.*/

            /*StarSystem.OnChangeValue start.*/
            OnChangeValue: function (value) {
if ( TRACE ) { TRACE( "StarSystem#OnChangeValue", this ); }

                this.balanceAmount.Value = value;
                !Bridge.staticEquals(StarSystem.ActionChangeValue, null) ? StarSystem.ActionChangeValue() : null;
            },
            /*StarSystem.OnChangeValue end.*/


        }
    });
    /*StarSystem end.*/

    /*StarUpdater start.*/
    Bridge.define("StarUpdater", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            CurrencyAmountText: null,
            iconStar: null,
            moveOneStarDone: null,
            moveAllStarDone: null,
            decreaseStarEvent: null,
            updateStartTextEvent: null,
            addTargetToStarGenerateEvent: null,
            removeTargetToStarGenerateEvent: null,
            _isProcessingBuilding: false,
            _isFirstCoinMoveDone: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "StarUpdater#init", this ); }

                this._isFirstCoinMoveDone = false;
            }
        },
        methods: {
            /*StarUpdater.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "StarUpdater#OnEnable", this ); }

                this._isProcessingBuilding = false;
                this.moveOneStarDone.AddListener(Bridge.fn.cacheBind(this, this.MoveOneCoinDone));
                this.decreaseStarEvent.AddListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.moveAllStarDone.AddListener(Bridge.fn.cacheBind(this, this.MoveAllCoinDone));
                this.addTargetToStarGenerateEvent.Raise(this.iconStar);
                this.updateStartTextEvent.AddListener(Bridge.fn.cacheBind(this, this.UpdateTextCoin));
                this.CurrencyAmountText.text = Bridge.toString(StarSystem.GetCurrentStar());
            },
            /*StarUpdater.OnEnable end.*/

            /*StarUpdater.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "StarUpdater#OnDisable", this ); }

                this.moveOneStarDone.RemoveListener(Bridge.fn.cacheBind(this, this.MoveOneCoinDone));
                this.moveAllStarDone.RemoveListener(Bridge.fn.cacheBind(this, this.MoveAllCoinDone));
                this.decreaseStarEvent.RemoveListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.updateStartTextEvent.RemoveListener(Bridge.fn.cacheBind(this, this.UpdateTextCoin));
                this.removeTargetToStarGenerateEvent.Raise(this.iconStar);
            },
            /*StarUpdater.OnDisable end.*/

            /*StarUpdater.OnBuildingProcessing start.*/
            OnBuildingProcessing: function (isProcessing) {
if ( TRACE ) { TRACE( "StarUpdater#OnBuildingProcessing", this ); }

                this._isProcessingBuilding = isProcessing;
            },
            /*StarUpdater.OnBuildingProcessing end.*/

            /*StarUpdater.MoveOneCoinDone start.*/
            MoveOneCoinDone: function () {
if ( TRACE ) { TRACE( "StarUpdater#MoveOneCoinDone", this ); }

                if (!this._isFirstCoinMoveDone) {
                    this._isFirstCoinMoveDone = true;
                    this.UpdateTextCoin();
                }
            },
            /*StarUpdater.MoveOneCoinDone end.*/

            /*StarUpdater.MoveAllCoinDone start.*/
            MoveAllCoinDone: function () {
if ( TRACE ) { TRACE( "StarUpdater#MoveAllCoinDone", this ); }

                this._isFirstCoinMoveDone = false;
            },
            /*StarUpdater.MoveAllCoinDone end.*/

            /*StarUpdater.DecreaseCoin start.*/
            DecreaseCoin: function () {
if ( TRACE ) { TRACE( "StarUpdater#DecreaseCoin", this ); }

                this.UpdateTextCoin();
            },
            /*StarUpdater.DecreaseCoin end.*/

            /*StarUpdater.UpdateTextCoin start.*/
            UpdateTextCoin: function () {
if ( TRACE ) { TRACE( "StarUpdater#UpdateTextCoin", this ); }

                var starCoin = System.Int32.parse(this.CurrencyAmountText.text);
                var coinChange = starCoin;
                DG.Tweening.TweenSettingsExtensions.OnUpdate(DG.Tweening.Core.TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions), DG.Tweening.DOTween.To$2(function () {
                    return starCoin;
                }, function (x) {
                    starCoin = x;
                }, StarSystem.GetCurrentStar(), 0.5), Bridge.fn.bind(this, function () {
                    coinChange = starCoin;
                    this.CurrencyAmountText.text = Bridge.toString(coinChange);
                }));
            },
            /*StarUpdater.UpdateTextCoin end.*/

            /*StarUpdater.OnClickPlus start.*/
            OnClickPlus: function () {
if ( TRACE ) { TRACE( "StarUpdater#OnClickPlus", this ); }

                if (this._isProcessingBuilding) {
                    return;
                }
            },
            /*StarUpdater.OnClickPlus end.*/


        }
    });
    /*StarUpdater end.*/

    /*Switcher start.*/
    Bridge.define("Switcher", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            SwitchState: 0,
            IsOn: false,
            SettingType: 0,
            On: null,
            Off: null,
            Switch: null,
            OffPos: null,
            OnPos: null,
            SwitchText: null,
            TimeSwitching: 0,
            musicChangedVariable: null,
            soundFxChangeVariable: null
        },
        props: {
            MusicChanged: {
                get: function () {
if ( TRACE ) { TRACE( "Switcher#MusicChanged#get", this ); }

                    return this.musicChangedVariable.Value === 1;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Switcher#MusicChanged#set", this ); }

                    this.musicChangedVariable.Value = value ? 1 : 0;
                }
            },
            SoundFxChanged: {
                get: function () {
if ( TRACE ) { TRACE( "Switcher#SoundFxChanged#get", this ); }

                    return this.soundFxChangeVariable.Value === 1;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Switcher#SoundFxChanged#set", this ); }

                    this.soundFxChangeVariable.Value = value ? 1 : 0;
                }
            },
            VibrateChanged: {
                get: function () {
if ( TRACE ) { TRACE( "Switcher#VibrateChanged#get", this ); }

                    return VirtueSky.Vibration.Vibration.EnableVibration;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Switcher#VibrateChanged#set", this ); }

                    VirtueSky.Vibration.Vibration.EnableVibration = value;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Switcher#init", this ); }

                this.SwitchState = SwitchState.Idle;
                this.TimeSwitching = 0.5;
            }
        },
        methods: {
            /*Switcher.SetupData start.*/
            SetupData: function () {
if ( TRACE ) { TRACE( "Switcher#SetupData", this ); }

                switch (this.SettingType) {
                    case SettingType.BackgroundMusic: 
                        this.IsOn = this.MusicChanged;
                        break;
                    case SettingType.SoundFx: 
                        this.IsOn = this.SoundFxChanged;
                        break;
                    case SettingType.Vibration: 
                        this.IsOn = this.VibrateChanged;
                        break;
                }
            },
            /*Switcher.SetupData end.*/

            /*Switcher.SetupUI start.*/
            SetupUI: function () {
if ( TRACE ) { TRACE( "Switcher#SetupUI", this ); }

                if (UnityEngine.Object.op_Implicit(this.SwitchText)) {
                    this.SwitchText.text = this.IsOn ? "On" : "Off";
                }
                if (this.IsOn) {
                    this.Switch.sprite = this.On;
                } else {
                    this.Switch.sprite = this.Off;
                }
            },
            /*Switcher.SetupUI end.*/

            /*Switcher.Setup start.*/
            Setup: function () {
if ( TRACE ) { TRACE( "Switcher#Setup", this ); }

                this.SetupData();
                this.SetupUI();
            },
            /*Switcher.Setup end.*/

            /*Switcher.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "Switcher#OnEnable", this ); }

                this.Setup();
                this.Switch.transform.position = this.IsOn ? this.OnPos.position.$clone() : this.OffPos.position.$clone();
            },
            /*Switcher.OnEnable end.*/

            /*Switcher.Switching start.*/
            Switching: function () {
if ( TRACE ) { TRACE( "Switcher#Switching", this ); }

                if (this.SwitchState === SwitchState.Moving) {
                    return;
                }
                this.SwitchState = SwitchState.Moving;
                if (this.IsOn) {
                    DG.Tweening.ShortcutExtensions.DOMove(this.Switch.transform, this.OffPos.position.$clone(), this.TimeSwitching);
                } else {
                    DG.Tweening.ShortcutExtensions.DOMove(this.Switch.transform, this.OnPos.position.$clone(), this.TimeSwitching);
                }
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.AppendCallback(DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.AppendInterval(DG.Tweening.DOTween.Sequence(), this.TimeSwitching / 2.0), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                    switch (this.SettingType) {
                        case SettingType.BackgroundMusic: 
                            this.MusicChanged = !this.IsOn;
                            break;
                        case SettingType.SoundFx: 
                            this.SoundFxChanged = !this.IsOn;
                            break;
                        case SettingType.Vibration: 
                            this.VibrateChanged = !this.IsOn;
                            break;
                    }

                    this.Setup();
                })), Bridge.fn.bind(this, function () {
                    this.SwitchState = SwitchState.Idle;
                }));
            },
            /*Switcher.Switching end.*/


        }
    });
    /*Switcher end.*/

    /*SwitchState start.*/
    Bridge.define("SwitchState", {
        $kind: 6,
        statics: {
            fields: {
                Idle: 0,
                Moving: 1
            }
        }
    });
    /*SwitchState end.*/

    /*TargetFrameRate start.*/
    Bridge.define("TargetFrameRate", {
        $kind: 6,
        statics: {
            fields: {
                ByDevice: -1,
                Frame60: 60,
                Frame120: 120,
                Frame240: 240
            }
        }
    });
    /*TargetFrameRate end.*/

    /*TheBeginning.Data.UserData start.*/
    Bridge.define("TheBeginning.Data.UserData", {
        $kind: 4,
        statics: {
            fields: {
                IdItemUnlocked: null
            },
            props: {
                IsFirstOpenGame: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsFirstOpenGame#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Int32, Constant.IS_FIRST_OPEN_GAME, 0) === 1;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsFirstOpenGame#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Int32, Constant.IS_FIRST_OPEN_GAME, value ? 1 : 0);
                    }
                },
                ProgressAmount: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#ProgressAmount#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Int32, Constant.PROGRESS_AMOUNT, 0);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#ProgressAmount#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Int32, Constant.PROGRESS_AMOUNT, value);
                    }
                },
                LastSessiontime: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastSessiontime#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.LAST_SESSION_TIME, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastSessiontime#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.LAST_SESSION_TIME, value);
                    }
                },
                CurrentMonthBattlePass: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#CurrentMonthBattlePass#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.CURRENT_MONTH_BATTLE_PASS, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#CurrentMonthBattlePass#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.CURRENT_MONTH_BATTLE_PASS, value);
                    }
                },
                DayStartWinStreak: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#DayStartWinStreak#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.LAST_WIN_STREAK_START, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#DayStartWinStreak#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.LAST_WIN_STREAK_START, value);
                    }
                },
                IsStartLoopingDailyReward: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsStartLoopingDailyReward#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Int32, Constant.IS_START_LOOPING_DAILY_REWARD, 0) === 1;
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsStartLoopingDailyReward#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Int32, Constant.IS_START_LOOPING_DAILY_REWARD, value ? 1 : 0);
                    }
                },
                DateTimeStart: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#DateTimeStart#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.DATE_TIME_START, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#DateTimeStart#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.DATE_TIME_START, value);
                    }
                },
                TotalPlayedDays: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#TotalPlayedDays#get", this ); }

                        return ((Bridge.Int.clip32((System.DateTime.subdd(System.DateTime.getNow(), System.DateTime.parse(TheBeginning.Data.UserData.DateTimeStart))).getTotalDays()) + 1) | 0);
                    }
                },
                DailyRewardDayIndex: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#DailyRewardDayIndex#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Int32, Constant.DAILY_REWARD_DAY_INDEX, 1);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#DailyRewardDayIndex#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Int32, Constant.DAILY_REWARD_DAY_INDEX, value);
                    }
                },
                LastDailyRewardClaimed: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyRewardClaimed#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.LAST_DAILY_REWARD_CLAIM, System.DateTime.format(System.DateTime.addDays(System.DateTime.getNow(), -1)));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyRewardClaimed#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.LAST_DAILY_REWARD_CLAIM, value);
                    }
                },
                LastDailyMainGiftClaimed: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyMainGiftClaimed#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.LAST_DAILY_GIFT_CLAIM, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyMainGiftClaimed#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.LAST_DAILY_GIFT_CLAIM, value);
                    }
                },
                LastDailyGift: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyGift#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.LAST_DAILY_GIFT, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyGift#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.LAST_DAILY_GIFT, value);
                    }
                },
                LastDailyInfinity: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyInfinity#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.String, Constant.LAST_DAILY_INFINITY, System.DateTime.format(System.DateTime.getNow()));
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#LastDailyInfinity#set", this ); }

                        TheBeginning.Data.UserData.Set(System.String, Constant.LAST_DAILY_INFINITY, value);
                    }
                },
                TotalClaimDailyReward: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#TotalClaimDailyReward#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Int32, Constant.TOTAL_CLAIM_DAILY_REWARD, 0);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#TotalClaimDailyReward#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Int32, Constant.TOTAL_CLAIM_DAILY_REWARD, value);
                    }
                },
                IsItemUnlocked: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsItemUnlocked#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Boolean, System.String.format("{0}_{1}", Constant.UNLOCK_ITEM, TheBeginning.Data.UserData.IdItemUnlocked), false);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsItemUnlocked#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Boolean, System.String.format("{0}_{1}", Constant.UNLOCK_ITEM, TheBeginning.Data.UserData.IdItemUnlocked), value);
                    }
                },
                PercentWinGift: {
                    get: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#PercentWinGift#get", this ); }

                        return TheBeginning.Data.UserData.Get(System.Int32, Constant.PERCENT_WIN_GIFT, 0);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#PercentWinGift#set", this ); }

                        TheBeginning.Data.UserData.Set(System.Int32, Constant.PERCENT_WIN_GIFT, value);
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#init", this ); }

                    this.IdItemUnlocked = "";
                }
            },
            methods: {
                /*TheBeginning.Data.UserData.GetNumberShowGameObject:static start.*/
                GetNumberShowGameObject: function (gameObjectID) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetNumberShowGameObject", this ); }

                    return TheBeginning.Data.UserData.Get(System.Int32, System.String.format("{0}_{1}", Constant.GAMEOBJECT_SHOW, gameObjectID), 0);
                },
                /*TheBeginning.Data.UserData.GetNumberShowGameObject:static end.*/

                /*TheBeginning.Data.UserData.IncreaseNumberShowGameObject:static start.*/
                IncreaseNumberShowGameObject: function (gameObjectID) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IncreaseNumberShowGameObject", this ); }

                    var value = TheBeginning.Data.UserData.GetNumberShowGameObject(gameObjectID);
                    TheBeginning.Data.UserData.Set(System.Int32, System.String.format("{0}_{1}", Constant.GAMEOBJECT_SHOW, gameObjectID), ((value = (value + 1) | 0)));
                },
                /*TheBeginning.Data.UserData.IncreaseNumberShowGameObject:static end.*/

                /*TheBeginning.Data.UserData.GetBoosterAmount:static start.*/
                GetBoosterAmount: function (key, defaultValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetBoosterAmount", this ); }

                    return TheBeginning.Data.UserData.Get(System.Int32, key, defaultValue);
                },
                /*TheBeginning.Data.UserData.GetBoosterAmount:static end.*/

                /*TheBeginning.Data.UserData.SetBoosterAmount:static start.*/
                SetBoosterAmount: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetBoosterAmount", this ); }

                    TheBeginning.Data.UserData.Set(System.Int32, key, value);
                },
                /*TheBeginning.Data.UserData.SetBoosterAmount:static end.*/

                /*TheBeginning.Data.UserData.GetBoosterUnlock:static start.*/
                GetBoosterUnlock: function (key, defaultValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetBoosterUnlock", this ); }

                    return TheBeginning.Data.UserData.Get(System.Boolean, key, defaultValue);
                },
                /*TheBeginning.Data.UserData.GetBoosterUnlock:static end.*/

                /*TheBeginning.Data.UserData.SetBoosterUnlock:static start.*/
                SetBoosterUnlock: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetBoosterUnlock", this ); }

                    TheBeginning.Data.UserData.Set(System.Boolean, key, value);
                },
                /*TheBeginning.Data.UserData.SetBoosterUnlock:static end.*/

                /*TheBeginning.Data.UserData.GetSkinMakeupUnlocked:static start.*/
                GetSkinMakeupUnlocked: function (key, defaultValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetSkinMakeupUnlocked", this ); }

                    return TheBeginning.Data.UserData.Get(System.Boolean, key, defaultValue);
                },
                /*TheBeginning.Data.UserData.GetSkinMakeupUnlocked:static end.*/

                /*TheBeginning.Data.UserData.SetSkinMakeupUnlocked:static start.*/
                SetSkinMakeupUnlocked: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetSkinMakeupUnlocked", this ); }

                    TheBeginning.Data.UserData.Set(System.Boolean, key, value);
                },
                /*TheBeginning.Data.UserData.SetSkinMakeupUnlocked:static end.*/

                /*TheBeginning.Data.UserData.GetSkinMakeupUnlockedSelectName:static start.*/
                GetSkinMakeupUnlockedSelectName: function (key, defaultValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetSkinMakeupUnlockedSelectName", this ); }

                    return TheBeginning.Data.UserData.Get(System.String, key, defaultValue);
                },
                /*TheBeginning.Data.UserData.GetSkinMakeupUnlockedSelectName:static end.*/

                /*TheBeginning.Data.UserData.SetSkinMakeupUnlockedSelectName:static start.*/
                SetSkinMakeupUnlockedSelectName: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetSkinMakeupUnlockedSelectName", this ); }

                    TheBeginning.Data.UserData.Set(System.String, key, value);
                },
                /*TheBeginning.Data.UserData.SetSkinMakeupUnlockedSelectName:static end.*/

                /*TheBeginning.Data.UserData.SetInitData:static start.*/
                SetInitData: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetInitData", this ); }

                    TheBeginning.Data.UserData.Set(System.Boolean, key, value);
                },
                /*TheBeginning.Data.UserData.SetInitData:static end.*/

                /*TheBeginning.Data.UserData.GetInitData:static start.*/
                GetInitData: function (key) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetInitData", this ); }

                    return TheBeginning.Data.UserData.Get(System.Boolean, key, false);
                },
                /*TheBeginning.Data.UserData.GetInitData:static end.*/

                /*TheBeginning.Data.UserData.GetCurrentSelectRoom:static start.*/
                GetCurrentSelectRoom: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetCurrentSelectRoom", this ); }

                    return TheBeginning.Data.UserData.Get(System.Int32, "ROOM_SELECT", 0);
                },
                /*TheBeginning.Data.UserData.GetCurrentSelectRoom:static end.*/

                /*TheBeginning.Data.UserData.SetCurrentSelectRoom:static start.*/
                SetCurrentSelectRoom: function (value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetCurrentSelectRoom", this ); }

                    TheBeginning.Data.UserData.Set(System.Int32, "ROOM_SELECT", value);
                    VirtueSky.DataStorage.GameData.Save();
                },
                /*TheBeginning.Data.UserData.SetCurrentSelectRoom:static end.*/

                /*TheBeginning.Data.UserData.SetItemBattlePassClaimed:static start.*/
                SetItemBattlePassClaimed: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetItemBattlePassClaimed", this ); }

                    TheBeginning.Data.UserData.Set(System.Boolean, key, value);
                },
                /*TheBeginning.Data.UserData.SetItemBattlePassClaimed:static end.*/

                /*TheBeginning.Data.UserData.GetItemBattlePassClaimed:static start.*/
                GetItemBattlePassClaimed: function (key) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetItemBattlePassClaimed", this ); }

                    return TheBeginning.Data.UserData.Get(System.Boolean, key, false);
                },
                /*TheBeginning.Data.UserData.GetItemBattlePassClaimed:static end.*/

                /*TheBeginning.Data.UserData.SetStatValue:static start.*/
                SetStatValue: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetStatValue", this ); }

                    TheBeginning.Data.UserData.Set(System.Int32, key, value);
                },
                /*TheBeginning.Data.UserData.SetStatValue:static end.*/

                /*TheBeginning.Data.UserData.GetStatValue:static start.*/
                GetStatValue: function (key, defauleValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetStatValue", this ); }

                    return TheBeginning.Data.UserData.Get(System.Int32, key, defauleValue);
                },
                /*TheBeginning.Data.UserData.GetStatValue:static end.*/

                /*TheBeginning.Data.UserData.SetUnlockWinStreakGift:static start.*/
                SetUnlockWinStreakGift: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetUnlockWinStreakGift", this ); }

                    TheBeginning.Data.UserData.Set(System.Boolean, "WinStreakGift" + (key || ""), value);
                },
                /*TheBeginning.Data.UserData.SetUnlockWinStreakGift:static end.*/

                /*TheBeginning.Data.UserData.GetUnlockWinStreakGift:static start.*/
                GetUnlockWinStreakGift: function (key) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetUnlockWinStreakGift", this ); }

                    return TheBeginning.Data.UserData.Get(System.Boolean, "WinStreakGift" + (key || ""), false);
                },
                /*TheBeginning.Data.UserData.GetUnlockWinStreakGift:static end.*/

                /*TheBeginning.Data.UserData.SetPlayerProfileFrameThemeLag:static start.*/
                SetPlayerProfileFrameThemeLag: function (key, value) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetPlayerProfileFrameThemeLag", this ); }

                    TheBeginning.Data.UserData.Set(System.String, key, value);
                },
                /*TheBeginning.Data.UserData.SetPlayerProfileFrameThemeLag:static end.*/

                /*TheBeginning.Data.UserData.GetPlayerProfileFrameThemeFlag:static start.*/
                GetPlayerProfileFrameThemeFlag: function (key, defaultValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#GetPlayerProfileFrameThemeFlag", this ); }

                    return TheBeginning.Data.UserData.Get(System.String, key, defaultValue);
                },
                /*TheBeginning.Data.UserData.GetPlayerProfileFrameThemeFlag:static end.*/

                /*TheBeginning.Data.UserData.Get:static start.*/
                Get: function (T, key, defaultValue) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#Get", this ); }

                    if (defaultValue === void 0) { defaultValue = Bridge.getDefaultValue(T); }
                    return VirtueSky.DataStorage.GameData.Get(T, key, Bridge.rValue(defaultValue));
                },
                /*TheBeginning.Data.UserData.Get:static end.*/

                /*TheBeginning.Data.UserData.Set:static start.*/
                Set: function (T, key, data) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#Set", this ); }

                    VirtueSky.DataStorage.GameData.Set(T, key, Bridge.rValue(data));
                },
                /*TheBeginning.Data.UserData.Set:static end.*/

                /*TheBeginning.Data.UserData.IsClaimedTodayDailyReward:static start.*/
                IsClaimedTodayDailyReward: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsClaimedTodayDailyReward", this ); }

                    var date = System.DateTime.getNow();
                    if (!System.String.isNullOrEmpty(TheBeginning.Data.UserData.LastDailyRewardClaimed)) {
                        try {
                            date = System.DateTime.parse(TheBeginning.Data.UserData.LastDailyRewardClaimed);
                        } catch ($e1) {
                            $e1 = System.Exception.create($e1);
                            date = System.DateTime.getNow();
                        }
                    }

                    return Bridge.Int.clip32((System.DateTime.subdd(System.DateTime.getNow(), date)).getTotalDays()) === 0;
                },
                /*TheBeginning.Data.UserData.IsClaimedTodayDailyReward:static end.*/

                /*TheBeginning.Data.UserData.IsItemEquipped:static start.*/
                IsItemEquipped: function (itemIdentity) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#IsItemEquipped", this ); }

                    return TheBeginning.Data.UserData.Get(System.Boolean, System.String.format("{0}_{1}", Constant.EQUIP_ITEM, TheBeginning.Data.UserData.IdItemUnlocked), false);
                },
                /*TheBeginning.Data.UserData.IsItemEquipped:static end.*/

                /*TheBeginning.Data.UserData.SetItemEquipped:static start.*/
                SetItemEquipped: function (itemIdentity, isEquipped) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#SetItemEquipped", this ); }

                    if (isEquipped === void 0) { isEquipped = true; }
                    TheBeginning.Data.UserData.Set(System.Boolean, System.String.format("{0}_{1}", Constant.EQUIP_ITEM, TheBeginning.Data.UserData.IdItemUnlocked), isEquipped);
                },
                /*TheBeginning.Data.UserData.SetItemEquipped:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#getDefaultValue", this ); }
 return new TheBeginning.Data.UserData(); }
            }
        },
        methods: {
            $clone: function (to) {
if ( TRACE ) { TRACE( "TheBeginning.Data.UserData#$clone", this ); }
 return this; }
        }
    });
    /*TheBeginning.Data.UserData end.*/

    /*TheBeginning.LevelSystem.LevelSettings start.*/
    Bridge.define("TheBeginning.LevelSystem.LevelSettings", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            maxLevel: 0,
            startLoopLevel: 0,
            levelFormat: null,
            listLevels: null
        },
        props: {
            MaxLevel: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelSettings#MaxLevel#get", this ); }

                    return this.maxLevel;
                }
            },
            StartLoopLevel: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelSettings#StartLoopLevel#get", this ); }

                    return this.startLoopLevel;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelSettings#init", this ); }

                this.levelFormat = "Level {0}";
                this.listLevels = new (System.Collections.Generic.List$1(TheBeginning.LevelSystem.Level)).ctor();
            }
        },
        methods: {
            /*TheBeginning.LevelSystem.LevelSettings.GePrefabLevel start.*/
            GePrefabLevel: function (index) {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelSettings#GePrefabLevel", this ); }

                return this.GePrefabLevel$1(System.String.format(this.levelFormat, [Bridge.box(index, System.Int32)]));
            },
            /*TheBeginning.LevelSystem.LevelSettings.GePrefabLevel end.*/

            /*TheBeginning.LevelSystem.LevelSettings.GePrefabLevel$1 start.*/
            GePrefabLevel$1: function (levelName) {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelSettings#GePrefabLevel$1", this ); }

                return System.Linq.Enumerable.from(this.listLevels, TheBeginning.LevelSystem.Level).firstOrDefault(Bridge.fn.bind(this, function (item) {
                        return Bridge.referenceEquals(item.name, levelName);
                    }), null);
            },
            /*TheBeginning.LevelSystem.LevelSettings.GePrefabLevel$1 end.*/


        },
        overloads: {
            "GePrefabLevel(string)": "GePrefabLevel$1"
        }
    });
    /*TheBeginning.LevelSystem.LevelSettings end.*/

    /*TheBeginning.Services.ServiceInitialization start.*/
    Bridge.define("TheBeginning.Services.ServiceInitialization", {
        inherits: [UnityEngine.MonoBehaviour]
    });
    /*TheBeginning.Services.ServiceInitialization end.*/

    /*TheBeginning.Services.RuntimeInitialization start.*/
    Bridge.define("TheBeginning.Services.RuntimeInitialization", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            serviceInitializations: null
        },
        methods: {
            /*TheBeginning.Services.RuntimeInitialization.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TheBeginning.Services.RuntimeInitialization#Awake", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.serviceInitializations);
                try {
                    while ($t.moveNext()) {
                        var serviceInitialization = $t.Current;
                        serviceInitialization.Initialization();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*TheBeginning.Services.RuntimeInitialization.Awake end.*/


        }
    });
    /*TheBeginning.Services.RuntimeInitialization end.*/

    /*TheBeginning.UI.HideAnimationType start.*/
    Bridge.define("TheBeginning.UI.HideAnimationType", {
        $kind: 6,
        statics: {
            fields: {
                InBack: 0,
                Fade: 1,
                Move: 2,
                InBackToPoint: 3
            }
        }
    });
    /*TheBeginning.UI.HideAnimationType end.*/

    /*TheBeginning.UI.MovePopupType start.*/
    Bridge.define("TheBeginning.UI.MovePopupType", {
        $kind: 6,
        statics: {
            fields: {
                Left: 0,
                Right: 1,
                Up: 2,
                Down: 3
            }
        }
    });
    /*TheBeginning.UI.MovePopupType end.*/

    /*TheBeginning.UI.PopupSettings start.*/
    Bridge.define("TheBeginning.UI.PopupSettings", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            pathLoad: null,
            listUiPopups: null
        },
        props: {
            ItemPopupConfigs: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupSettings#ItemPopupConfigs#get", this ); }

                    return this.listUiPopups;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupSettings#init", this ); }

                this.pathLoad = "Assets/_Project/Prefabs/Popups";
            }
        },
        methods: {
            /*TheBeginning.UI.PopupSettings.GetPrefabPopup start.*/
            GetPrefabPopup: function (popupName) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupSettings#GetPrefabPopup", this ); }

                return System.Linq.Enumerable.from(this.listUiPopups, TheBeginning.UI.UIPopup).firstOrDefault(Bridge.fn.bind(this, function (item) {
                        return Bridge.referenceEquals(item.name, popupName);
                    }), null);
            },
            /*TheBeginning.UI.PopupSettings.GetPrefabPopup end.*/


        }
    });
    /*TheBeginning.UI.PopupSettings end.*/

    /*TheBeginning.UI.ShowAnimationType start.*/
    Bridge.define("TheBeginning.UI.ShowAnimationType", {
        $kind: 6,
        statics: {
            fields: {
                OutBack: 0,
                Flip: 1,
                Move: 2,
                Fade: 3,
                OutBackFromPoint: 4
            }
        }
    });
    /*TheBeginning.UI.ShowAnimationType end.*/

    /*TrackingEnum start.*/
    Bridge.define("TrackingEnum");
    /*TrackingEnum end.*/

    /*TrackingEnum+EAdEndType start.*/
    Bridge.define("TrackingEnum.EAdEndType", {
        $kind: 1006,
        statics: {
            fields: {
                quit: 0,
                done: 1
            }
        }
    });
    /*TrackingEnum+EAdEndType end.*/

    /*TrackingEnum+EConnection start.*/
    Bridge.define("TrackingEnum.EConnection", {
        $kind: 1006,
        statics: {
            fields: {
                offline: 0,
                online: 1
            }
        }
    });
    /*TrackingEnum+EConnection end.*/

    /*TrackingEnum+EIapShowType start.*/
    Bridge.define("TrackingEnum.EIapShowType", {
        $kind: 1006,
        statics: {
            fields: {
                shop: 0,
                pack: 1
            }
        }
    });
    /*TrackingEnum+EIapShowType end.*/

    /*TrackingEnum+ELevelLoseBy start.*/
    Bridge.define("TrackingEnum.ELevelLoseBy", {
        $kind: 1006,
        statics: {
            fields: {
                out_of_time: 0,
                bomb_explode: 1,
                shutter_gate_closed: 2
            }
        }
    });
    /*TrackingEnum+ELevelLoseBy end.*/

    /*TrackingEnum+ELevelResult start.*/
    Bridge.define("TrackingEnum.ELevelResult", {
        $kind: 1006,
        statics: {
            fields: {
                win: 0,
                lose: 1,
                quit: 2,
                exit: 3,
                replay: 4,
                tutorial: 5
            }
        }
    });
    /*TrackingEnum+ELevelResult end.*/

    /*TrackingEnum+ELoadType start.*/
    Bridge.define("TrackingEnum.ELoadType", {
        $kind: 1006,
        statics: {
            fields: {
                success: 1,
                fail: 0
            }
        }
    });
    /*TrackingEnum+ELoadType end.*/

    /*TrackingEnum+EPlacement start.*/
    Bridge.define("TrackingEnum.EPlacement", {
        $kind: 1006,
        statics: {
            fields: {
                none: 0,
                home_icon: 1,
                home_shop: 2,
                out_of_time_popup: 3,
                daily_gift: 4,
                win_popup_extra_reward: 5,
                buy_freeze_time: 6,
                buy_magnet: 7,
                buy_hammer: 8,
                buy_booster_in_game: 9,
                refill_life: 10,
                add_time: 11,
                level_end: 12,
                win_popup: 13,
                in_game: 14,
                debug: 15,
                unlocked_building: 16,
                building: 17,
                win_streak_popup: 18,
                keep_streak_popup: 19,
                battle_pass: 20,
                golden_ticket_popup: 21,
                glam_rush_popup: 22,
                welcome_back_popup: 23,
                starter_pack_popup: 24,
                one_time_recharge_popup: 25,
                daily_mission_popup: 26,
                vip_pack_popup: 27,
                endless_treasure_popup: 28,
                app_open: 29,
                coin_icon_in_home: 30
            }
        }
    });
    /*TrackingEnum+EPlacement end.*/

    /*TrackingEnum+EPlayType start.*/
    Bridge.define("TrackingEnum.EPlayType", {
        $kind: 1006,
        statics: {
            fields: {
                home: 0,
                win_continue: 1,
                restart: 2
            }
        }
    });
    /*TrackingEnum+EPlayType end.*/

    /*TrackingEnum+EResourceName start.*/
    Bridge.define("TrackingEnum.EResourceName", {
        $kind: 1006,
        statics: {
            fields: {
                gold: 0,
                star: 1,
                heart: 2,
                freeze_time: 3,
                magnet: 4,
                hammer: 5,
                heart_immortal: 6,
                level_time: 7
            }
        }
    });
    /*TrackingEnum+EResourceName end.*/

    /*TrackingEnum+EResourceReason start.*/
    Bridge.define("TrackingEnum.EResourceReason", {
        $kind: 1006,
        statics: {
            fields: {
                reward: 0,
                exchange: 1,
                purchase: 2,
                use: 3,
                watch_ads: 4
            }
        }
    });
    /*TrackingEnum+EResourceReason end.*/

    /*TrackingEnum+EResourceType start.*/
    Bridge.define("TrackingEnum.EResourceType", {
        $kind: 1006,
        statics: {
            fields: {
                currency: 0,
                item: 1,
                booster: 2
            }
        }
    });
    /*TrackingEnum+EResourceType end.*/

    /*TrackingParameter start.*/
    Bridge.define("TrackingParameter", {
        fields: {
            Name: null,
            Value: null
        },
        ctors: {
            $ctor3: function (name, stringValue) {
if ( TRACE ) { TRACE( "TrackingParameter#$ctor3", this ); }

                this.$initialize();
                this.Name = name;
                this.Value = stringValue;
            },
            $ctor2: function (name, longValue) {
if ( TRACE ) { TRACE( "TrackingParameter#$ctor2", this ); }

                this.$initialize();
                this.Name = name;
                this.Value = longValue;
            },
            $ctor1: function (name, doubleValue) {
if ( TRACE ) { TRACE( "TrackingParameter#$ctor1", this ); }

                this.$initialize();
                this.Name = name;
                this.Value = Bridge.box(doubleValue, System.Double, System.Double.format, System.Double.getHashCode);
            },
            ctor: function (name, boolValue) {
if ( TRACE ) { TRACE( "TrackingParameter#ctor", this ); }

                this.$initialize();
                this.Name = name;
                this.Value = Bridge.box(boolValue, System.Boolean, System.Boolean.toString);
            }
        }
    });
    /*TrackingParameter end.*/

    /*VirtueSky.Events.IEvent$1 start.*/
    Bridge.definei("VirtueSky.Events.IEvent$1", function (T) { return {
        $kind: 3
    }; });
    /*VirtueSky.Events.IEvent$1 end.*/

    /*VirtueSky.Audio.AudioHelper start.*/
    Bridge.define("VirtueSky.Audio.AudioHelper", {
        statics: {
            methods: {
                /*VirtueSky.Audio.AudioHelper.PlaySfx:static start.*/
                PlaySfx: function (soundData, playSfxEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#PlaySfx", this ); }

                    return playSfxEvent.Raise(soundData);
                },
                /*VirtueSky.Audio.AudioHelper.PlaySfx:static end.*/

                /*VirtueSky.Audio.AudioHelper.PauseSfx:static start.*/
                PauseSfx: function (soundCache, pauseSfxEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#PauseSfx", this ); }

                    pauseSfxEvent.Raise(soundCache);
                },
                /*VirtueSky.Audio.AudioHelper.PauseSfx:static end.*/

                /*VirtueSky.Audio.AudioHelper.StopSfx:static start.*/
                StopSfx: function (soundCache, stopSfxEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#StopSfx", this ); }

                    stopSfxEvent.Raise(soundCache);
                },
                /*VirtueSky.Audio.AudioHelper.StopSfx:static end.*/

                /*VirtueSky.Audio.AudioHelper.ResumeSfx:static start.*/
                ResumeSfx: function (soundCache, resumeSfxEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#ResumeSfx", this ); }

                    resumeSfxEvent.Raise(soundCache);
                },
                /*VirtueSky.Audio.AudioHelper.ResumeSfx:static end.*/

                /*VirtueSky.Audio.AudioHelper.FinishSfx:static start.*/
                FinishSfx: function (soundCache, finishSfxEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#FinishSfx", this ); }

                    finishSfxEvent.Raise(soundCache);
                },
                /*VirtueSky.Audio.AudioHelper.FinishSfx:static end.*/

                /*VirtueSky.Audio.AudioHelper.StopAllSfx:static start.*/
                StopAllSfx: function (stopAllSfxEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#StopAllSfx", this ); }

                    stopAllSfxEvent.Raise();
                },
                /*VirtueSky.Audio.AudioHelper.StopAllSfx:static end.*/

                /*VirtueSky.Audio.AudioHelper.PlayMusic:static start.*/
                PlayMusic: function (soundData, playMusicEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#PlayMusic", this ); }

                    playMusicEvent.Raise(soundData);
                },
                /*VirtueSky.Audio.AudioHelper.PlayMusic:static end.*/

                /*VirtueSky.Audio.AudioHelper.StopMusic:static start.*/
                StopMusic: function (stopMusicEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#StopMusic", this ); }

                    stopMusicEvent.Raise();
                },
                /*VirtueSky.Audio.AudioHelper.StopMusic:static end.*/

                /*VirtueSky.Audio.AudioHelper.PauseMusic:static start.*/
                PauseMusic: function (pauseMusicEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#PauseMusic", this ); }

                    pauseMusicEvent.Raise();
                },
                /*VirtueSky.Audio.AudioHelper.PauseMusic:static end.*/

                /*VirtueSky.Audio.AudioHelper.ResumeMusic:static start.*/
                ResumeMusic: function (resumeMusicEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioHelper#ResumeMusic", this ); }

                    resumeMusicEvent.Raise();
                },
                /*VirtueSky.Audio.AudioHelper.ResumeMusic:static end.*/


            }
        }
    });
    /*VirtueSky.Audio.AudioHelper end.*/

    /*VirtueSky.Variables.IGuidVariable start.*/
    Bridge.define("VirtueSky.Variables.IGuidVariable", {
        $kind: 3
    });
    /*VirtueSky.Variables.IGuidVariable end.*/

    /*VirtueSky.Variables.IVariable$1 start.*/
    Bridge.definei("VirtueSky.Variables.IVariable$1", function (TType) { return {
        $kind: 3
    }; });
    /*VirtueSky.Variables.IVariable$1 end.*/

    /*VirtueSky.Events.IEvent start.*/
    Bridge.define("VirtueSky.Events.IEvent", {
        $kind: 3
    });
    /*VirtueSky.Events.IEvent end.*/

    /*VirtueSky.Events.IEvent$2 start.*/
    Bridge.definei("VirtueSky.Events.IEvent$2", function (T, TResult) { return {
        $kind: 3
    }; });
    /*VirtueSky.Events.IEvent$2 end.*/

    /*VirtueSky.Component.DirectionFollowTarget start.*/
    Bridge.define("VirtueSky.Component.DirectionFollowTarget", {
        $kind: 6,
        statics: {
            fields: {
                XYZ: 0,
                XY: 1,
                XZ: 2,
                YZ: 3,
                X: 4,
                Y: 5,
                Z: 6
            }
        }
    });
    /*VirtueSky.Component.DirectionFollowTarget end.*/

    /*VirtueSky.Component.SafeAreaComponent+SimDevice start.*/
    /** @namespace VirtueSky.Component */

    /**
     * Simulation device that uses safe area due to a physical notch or software home bar. For use in Editor only.
     *
     * @public
     * @class number
     */
    Bridge.define("VirtueSky.Component.SafeAreaComponent.SimDevice", {
        $kind: 1006,
        statics: {
            fields: {
                /**
                 * Don't use a simulated safe area - GUI will be full screen as normal.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 0
                 * @type number
                 */
                None: 0,
                /**
                 * Simulate the iPhone X and Xs (identical safe areas).
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 1
                 * @type number
                 */
                iPhoneX: 1,
                /**
                 * Simulate the iPhone Xs Max and XR (identical safe areas).
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 2
                 * @type number
                 */
                iPhoneXsMax: 2,
                /**
                 * Simulate the Google Pixel 3 XL using landscape left.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 3
                 * @type number
                 */
                Pixel3XL_LSL: 3,
                /**
                 * Simulate the Google Pixel 3 XL using landscape right.
                 *
                 * @static
                 * @public
                 * @memberof number
                 * @constant
                 * @default 4
                 * @type number
                 */
                Pixel3XL_LSR: 4
            }
        }
    });
    /*VirtueSky.Component.SafeAreaComponent+SimDevice end.*/

    /*VirtueSky.Component.TypeFollowTarget start.*/
    Bridge.define("VirtueSky.Component.TypeFollowTarget", {
        $kind: 6,
        statics: {
            fields: {
                SetPosition: 0,
                Lerp: 1,
                SmoothDamp: 2
            }
        }
    });
    /*VirtueSky.Component.TypeFollowTarget end.*/
    /** @namespace System */

    /**
     * @memberof System
     * @callback System.Action
     * @return  {void}
     */


    /*VirtueSky.Core.App start.*/
    Bridge.define("VirtueSky.Core.App", {
        $kind: 4,
        statics: {
            fields: {
                _monoGlobal: null
            },
            methods: {
                /*VirtueSky.Core.App.InitMonoGlobalComponent:static start.*/
                InitMonoGlobalComponent: function (monoGlobal) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#InitMonoGlobalComponent", this ); }

                    VirtueSky.Core.App._monoGlobal = monoGlobal;
                },
                /*VirtueSky.Core.App.InitMonoGlobalComponent:static end.*/

                /*VirtueSky.Core.App.AddPauseCallback:static start.*/
                AddPauseCallback: function (callback) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#AddPauseCallback", this ); }

                    VirtueSky.Core.App._monoGlobal.removeOnGamePause(callback);
                    VirtueSky.Core.App._monoGlobal.addOnGamePause(callback);
                },
                /*VirtueSky.Core.App.AddPauseCallback:static end.*/

                /*VirtueSky.Core.App.RemovePauseCallback:static start.*/
                RemovePauseCallback: function (callback) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#RemovePauseCallback", this ); }

                    VirtueSky.Core.App._monoGlobal.removeOnGamePause(callback);
                },
                /*VirtueSky.Core.App.RemovePauseCallback:static end.*/

                /*VirtueSky.Core.App.AddFocusCallback:static start.*/
                AddFocusCallback: function (callback) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#AddFocusCallback", this ); }

                    VirtueSky.Core.App._monoGlobal.removeOnGameFocus(callback);
                    VirtueSky.Core.App._monoGlobal.addOnGameFocus(callback);
                },
                /*VirtueSky.Core.App.AddFocusCallback:static end.*/

                /*VirtueSky.Core.App.RemoveFocusCallback:static start.*/
                RemoveFocusCallback: function (callback) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#RemoveFocusCallback", this ); }

                    VirtueSky.Core.App._monoGlobal.removeOnGameFocus(callback);
                },
                /*VirtueSky.Core.App.RemoveFocusCallback:static end.*/

                /*VirtueSky.Core.App.AddQuitCallback:static start.*/
                AddQuitCallback: function (callback) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#AddQuitCallback", this ); }

                    VirtueSky.Core.App._monoGlobal.removeOnGameQuit(callback);
                    VirtueSky.Core.App._monoGlobal.addOnGameQuit(callback);
                },
                /*VirtueSky.Core.App.AddQuitCallback:static end.*/

                /*VirtueSky.Core.App.RemoveQuitCallback:static start.*/
                RemoveQuitCallback: function (callback) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#RemoveQuitCallback", this ); }

                    VirtueSky.Core.App._monoGlobal.removeOnGameQuit(callback);
                },
                /*VirtueSky.Core.App.RemoveQuitCallback:static end.*/

                /*VirtueSky.Core.App.SubTick$1:static start.*/
                SubTick$1: function (tick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#SubTick$1", this ); }

                    VirtueSky.Core.App._monoGlobal.AddTick$1(tick);
                },
                /*VirtueSky.Core.App.SubTick$1:static end.*/

                /*VirtueSky.Core.App.SubTick:static start.*/
                SubTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#SubTick", this ); }

                    VirtueSky.Core.App._monoGlobal.AddTick(action);
                },
                /*VirtueSky.Core.App.SubTick:static end.*/

                /*VirtueSky.Core.App.SubFixedTick$1:static start.*/
                SubFixedTick$1: function (fixedTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#SubFixedTick$1", this ); }

                    VirtueSky.Core.App._monoGlobal.AddFixedTick$1(fixedTick);
                },
                /*VirtueSky.Core.App.SubFixedTick$1:static end.*/

                /*VirtueSky.Core.App.SubFixedTick:static start.*/
                SubFixedTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#SubFixedTick", this ); }

                    VirtueSky.Core.App._monoGlobal.AddFixedTick(action);
                },
                /*VirtueSky.Core.App.SubFixedTick:static end.*/

                /*VirtueSky.Core.App.SubLateTick$1:static start.*/
                SubLateTick$1: function (lateTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#SubLateTick$1", this ); }

                    VirtueSky.Core.App._monoGlobal.AddLateTick$1(lateTick);
                },
                /*VirtueSky.Core.App.SubLateTick$1:static end.*/

                /*VirtueSky.Core.App.SubLateTick:static start.*/
                SubLateTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#SubLateTick", this ); }

                    VirtueSky.Core.App._monoGlobal.AddLateTick(action);
                },
                /*VirtueSky.Core.App.SubLateTick:static end.*/

                /*VirtueSky.Core.App.UnSubTick$1:static start.*/
                UnSubTick$1: function (tick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#UnSubTick$1", this ); }

                    VirtueSky.Core.App._monoGlobal.RemoveTick$1(tick);
                },
                /*VirtueSky.Core.App.UnSubTick$1:static end.*/

                /*VirtueSky.Core.App.UnSubTick:static start.*/
                UnSubTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#UnSubTick", this ); }

                    VirtueSky.Core.App._monoGlobal.RemoveTick(action);
                },
                /*VirtueSky.Core.App.UnSubTick:static end.*/

                /*VirtueSky.Core.App.UnSubFixedTick$1:static start.*/
                UnSubFixedTick$1: function (fixedTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#UnSubFixedTick$1", this ); }

                    VirtueSky.Core.App._monoGlobal.RemoveFixedTick$1(fixedTick);
                },
                /*VirtueSky.Core.App.UnSubFixedTick$1:static end.*/

                /*VirtueSky.Core.App.UnSubFixedTick:static start.*/
                UnSubFixedTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#UnSubFixedTick", this ); }

                    VirtueSky.Core.App._monoGlobal.RemoveFixedTick(action);
                },
                /*VirtueSky.Core.App.UnSubFixedTick:static end.*/

                /*VirtueSky.Core.App.UnSubLateTick$1:static start.*/
                UnSubLateTick$1: function (lateTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#UnSubLateTick$1", this ); }

                    VirtueSky.Core.App._monoGlobal.RemoveLateTick$1(lateTick);
                },
                /*VirtueSky.Core.App.UnSubLateTick$1:static end.*/

                /*VirtueSky.Core.App.UnSubLateTick:static start.*/
                UnSubLateTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#UnSubLateTick", this ); }

                    VirtueSky.Core.App._monoGlobal.RemoveLateTick(action);
                },
                /*VirtueSky.Core.App.UnSubLateTick:static end.*/

                /*VirtueSky.Core.App.Delay:static start.*/
                /**
                 * Delay call
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Core.App
                 * @memberof VirtueSky.Core.App
                 * @param   {number}                        duration       The duration to wait before the DelayHandle fires.
                 * @param   {System.Action}                 onComplete     The action to run when the DelayHandle elapses.
                 * @param   {System.Action}                 onUpdate       A function to call each tick of the DelayHandle. Takes the number of seconds elapsed since
                 the start of the current cycle.
                 * @param   {boolean}                       isLooped       Whether the DelayHandle should restart after executing.
                 * @param   {boolean}                       useRealTime    Whether the DelayHandle uses real-time(not affected by slow-mo or pausing) or
                 game-time(affected by time scale changes).
                 * @return  {VirtueSky.Core.DelayHandle}
                 */
                Delay: function (duration, onComplete, onUpdate, isLooped, useRealTime) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#Delay", this ); }

                    if (onUpdate === void 0) { onUpdate = null; }
                    if (isLooped === void 0) { isLooped = false; }
                    if (useRealTime === void 0) { useRealTime = false; }
                    var timer = new VirtueSky.Core.DelayHandle(duration, onComplete, onUpdate, isLooped, useRealTime, null);
                    VirtueSky.Core.App._monoGlobal.RegisterDelayHandle(timer);
                    return timer;
                },
                /*VirtueSky.Core.App.Delay:static end.*/

                /*VirtueSky.Core.App.Delay$1:static start.*/
                /**
                 * Safe Delay call when it had target, progress delay will be cancel when target was destroyed
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Core.App
                 * @memberof VirtueSky.Core.App
                 * @param   {UnityEngine.MonoBehaviour}     target         The target (behaviour) to attach this DelayHandle to.
                 * @param   {number}                        duration       The duration to wait before the DelayHandle fires.
                 * @param   {System.Action}                 onComplete     The action to run when the DelayHandle elapses.
                 * @param   {System.Action}                 onUpdate       A function to call each tick of the DelayHandle. Takes the number of seconds elapsed since
                 the start of the current cycle.
                 * @param   {boolean}                       isLooped       Whether the DelayHandle should restart after executing.
                 * @param   {boolean}                       useRealTime    Whether the DelayHandle uses real-time(not affected by slow-mo or pausing) or
                 game-time(affected by time scale changes).
                 * @return  {VirtueSky.Core.DelayHandle}
                 */
                Delay$1: function (target, duration, onComplete, onUpdate, isLooped, useRealTime) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#Delay$1", this ); }

                    if (onUpdate === void 0) { onUpdate = null; }
                    if (isLooped === void 0) { isLooped = false; }
                    if (useRealTime === void 0) { useRealTime = false; }
                    var timer = new VirtueSky.Core.DelayHandle(duration, onComplete, onUpdate, isLooped, useRealTime, target);
                    VirtueSky.Core.App._monoGlobal.RegisterDelayHandle(timer);
                    return timer;
                },
                /*VirtueSky.Core.App.Delay$1:static end.*/

                /*VirtueSky.Core.App.CancelDelay:static start.*/
                CancelDelay: function (delayHandle) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#CancelDelay", this ); }

                    delayHandle != null ? delayHandle.Cancel() : null;
                },
                /*VirtueSky.Core.App.CancelDelay:static end.*/

                /*VirtueSky.Core.App.PauseDelay:static start.*/
                PauseDelay: function (delayHandle) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#PauseDelay", this ); }

                    delayHandle != null ? delayHandle.Pause() : null;
                },
                /*VirtueSky.Core.App.PauseDelay:static end.*/

                /*VirtueSky.Core.App.ResumeDelay:static start.*/
                ResumeDelay: function (delayHandle) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#ResumeDelay", this ); }

                    delayHandle != null ? delayHandle.Resume() : null;
                },
                /*VirtueSky.Core.App.ResumeDelay:static end.*/

                /*VirtueSky.Core.App.CancelAllDelay:static start.*/
                CancelAllDelay: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#CancelAllDelay", this ); }

                    VirtueSky.Core.App._monoGlobal.CancelAllDelayHandle();
                },
                /*VirtueSky.Core.App.CancelAllDelay:static end.*/

                /*VirtueSky.Core.App.PauseAllDelay:static start.*/
                PauseAllDelay: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#PauseAllDelay", this ); }

                    VirtueSky.Core.App._monoGlobal.PauseAllDelayHandle();
                },
                /*VirtueSky.Core.App.PauseAllDelay:static end.*/

                /*VirtueSky.Core.App.ResumeAllDelay:static start.*/
                ResumeAllDelay: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#ResumeAllDelay", this ); }

                    VirtueSky.Core.App._monoGlobal.ResumeAllDelayHandle();
                },
                /*VirtueSky.Core.App.ResumeAllDelay:static end.*/

                /*VirtueSky.Core.App.StartCoroutine:static start.*/
                StartCoroutine: function (routine) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StartCoroutine", this ); }

                    return VirtueSky.Core.App._monoGlobal.StartCoroutineImpl(routine);
                },
                /*VirtueSky.Core.App.StartCoroutine:static end.*/

                /*VirtueSky.Core.App.StartCoroutine$2:static start.*/
                StartCoroutine$2: function (methodName, value) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StartCoroutine$2", this ); }

                    return VirtueSky.Core.App._monoGlobal.StartCoroutineImpl$2(methodName, value);
                },
                /*VirtueSky.Core.App.StartCoroutine$2:static end.*/

                /*VirtueSky.Core.App.StartCoroutine$1:static start.*/
                StartCoroutine$1: function (methodName) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StartCoroutine$1", this ); }

                    return VirtueSky.Core.App._monoGlobal.StartCoroutineImpl$1(methodName);
                },
                /*VirtueSky.Core.App.StartCoroutine$1:static end.*/

                /*VirtueSky.Core.App.StopCoroutine:static start.*/
                StopCoroutine: function (routine) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StopCoroutine", this ); }

                    VirtueSky.Core.App._monoGlobal.StopCoroutineImpl(routine);
                },
                /*VirtueSky.Core.App.StopCoroutine:static end.*/

                /*VirtueSky.Core.App.StopCoroutine$2:static start.*/
                StopCoroutine$2: function (routine) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StopCoroutine$2", this ); }

                    VirtueSky.Core.App._monoGlobal.StopCoroutineImpl$2(routine);
                },
                /*VirtueSky.Core.App.StopCoroutine$2:static end.*/

                /*VirtueSky.Core.App.StopCoroutine$1:static start.*/
                StopCoroutine$1: function (methodName) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StopCoroutine$1", this ); }

                    VirtueSky.Core.App._monoGlobal.StopCoroutineImpl$1(methodName);
                },
                /*VirtueSky.Core.App.StopCoroutine$1:static end.*/

                /*VirtueSky.Core.App.StopAllCoroutine:static start.*/
                StopAllCoroutine: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#StopAllCoroutine", this ); }

                    VirtueSky.Core.App._monoGlobal.StopAllCoroutinesImpl();
                },
                /*VirtueSky.Core.App.StopAllCoroutine:static end.*/

                /*VirtueSky.Core.App.ToMainThread:static start.*/
                ToMainThread: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#ToMainThread", this ); }

                    return VirtueSky.Core.App._monoGlobal.ToMainThreadImpl(action);
                },
                /*VirtueSky.Core.App.ToMainThread:static end.*/

                /*VirtueSky.Core.App.ToMainThread$1:static start.*/
                ToMainThread$1: function (T, action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#ToMainThread$1", this ); }

                    return VirtueSky.Core.App._monoGlobal.ToMainThreadImpl$1(T, action);
                },
                /*VirtueSky.Core.App.ToMainThread$1:static end.*/

                /*VirtueSky.Core.App.ToMainThread$2:static start.*/
                ToMainThread$2: function (T1, T2, action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#ToMainThread$2", this ); }

                    return VirtueSky.Core.App._monoGlobal.ToMainThreadImpl$2(T1, T2, action);
                },
                /*VirtueSky.Core.App.ToMainThread$2:static end.*/

                /*VirtueSky.Core.App.ToMainThread$3:static start.*/
                ToMainThread$3: function (T1, T2, T3, action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#ToMainThread$3", this ); }

                    return VirtueSky.Core.App._monoGlobal.ToMainThreadImpl$3(T1, T2, T3, action);
                },
                /*VirtueSky.Core.App.ToMainThread$3:static end.*/

                /*VirtueSky.Core.App.RunOnMainThread:static start.*/
                RunOnMainThread: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#RunOnMainThread", this ); }

                    VirtueSky.Core.App._monoGlobal.RunOnMainThreadImpl(action);
                },
                /*VirtueSky.Core.App.RunOnMainThread:static end.*/

                getDefaultValue: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#getDefaultValue", this ); }
 return new VirtueSky.Core.App(); }
            }
        },
        methods: {
            $clone: function (to) {
if ( TRACE ) { TRACE( "VirtueSky.Core.App#$clone", this ); }
 return this; }
        }
    });
    /*VirtueSky.Core.App end.*/

    /*VirtueSky.Core.DelayHandle start.*/
    Bridge.define("VirtueSky.Core.DelayHandle", {
        fields: {
            /**
             * How long the timer takes to complete from start to finish.
             *
             * @instance
             * @public
             * @memberof VirtueSky.Core.DelayHandle
             * @function Duration
             * @type number
             */
            Duration: 0,
            /**
             * Whether the timer will run again after completion.
             *
             * @instance
             * @public
             * @memberof VirtueSky.Core.DelayHandle
             * @function IsLooped
             * @type boolean
             */
            IsLooped: false,
            /**
             * Whether or not the timer completed running. This is false if the timer was cancelled.
             *
             * @instance
             * @public
             * @memberof VirtueSky.Core.DelayHandle
             * @function IsCompleted
             * @type boolean
             */
            IsCompleted: false,
            /**
             * Whether the timer uses real-time or game-time. Real time is unaffected by changes to the timescale
             of the game(e.g. pausing, slow-mo), while game time is affected.
             *
             * @instance
             * @public
             * @memberof VirtueSky.Core.DelayHandle
             * @function UsesRealTime
             * @type boolean
             */
            UsesRealTime: false,
            _onComplete: null,
            _onUpdate: null,
            _startTime: 0,
            _lastUpdateTime: 0,
            _timeElapsedBeforeCancel: null,
            _timeElapsedBeforePause: null,
            _autoDestroyOwner: null,
            _hasAutoDestroyOwner: false
        },
        props: {
            /**
             * Whether the timer is currently paused.
             *
             * @instance
             * @public
             * @readonly
             * @memberof VirtueSky.Core.DelayHandle
             * @function IsPaused
             * @type boolean
             */
            IsPaused: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#IsPaused#get", this ); }

                    return System.Nullable.hasValue(this._timeElapsedBeforePause);
                }
            },
            /**
             * Whether or not the timer was cancelled.
             *
             * @instance
             * @public
             * @readonly
             * @memberof VirtueSky.Core.DelayHandle
             * @function IsCancelled
             * @type boolean
             */
            IsCancelled: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#IsCancelled#get", this ); }

                    return System.Nullable.hasValue(this._timeElapsedBeforeCancel);
                }
            },
            /**
             * Get whether or not the timer has finished running for any reason.
             *
             * @instance
             * @public
             * @readonly
             * @memberof VirtueSky.Core.DelayHandle
             * @function IsDone
             * @type boolean
             */
            IsDone: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#IsDone#get", this ); }

                    return this.IsCompleted || this.IsCancelled || this.IsOwnerDestroyed;
                }
            },
            IsOwnerDestroyed: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#IsOwnerDestroyed#get", this ); }

                    return this._hasAutoDestroyOwner && UnityEngine.MonoBehaviour.op_Equality(this._autoDestroyOwner, null);
                }
            }
        },
        ctors: {
            ctor: function (duration, onComplete, onUpdate, isLooped, usesRealTime, autoDestroyOwner) {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#ctor", this ); }

                this.$initialize();
                this.Duration = duration;
                this._onComplete = onComplete;
                this._onUpdate = onUpdate;

                this.IsLooped = isLooped;
                this.UsesRealTime = usesRealTime;

                this._autoDestroyOwner = autoDestroyOwner;
                this._hasAutoDestroyOwner = UnityEngine.MonoBehaviour.op_Inequality(autoDestroyOwner, null);

                this._startTime = this.GetWorldTime();
                this._lastUpdateTime = this._startTime;
            }
        },
        methods: {
            /*VirtueSky.Core.DelayHandle.Cancel start.*/
            /**
             * Stop a timer that is in-progress or paused. The timer's on completion callback will not be called.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {void}
             */
            Cancel: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#Cancel", this ); }

                if (this.IsDone) {
                    return;
                }

                this._timeElapsedBeforeCancel = this.GetTimeElapsed();
                this._timeElapsedBeforePause = null;
            },
            /*VirtueSky.Core.DelayHandle.Cancel end.*/

            /*VirtueSky.Core.DelayHandle.Pause start.*/
            /**
             * Pause a running timer. A paused timer can be resumed from the same point it was paused.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {void}
             */
            Pause: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#Pause", this ); }

                if (this.IsPaused || this.IsDone) {
                    return;
                }

                this._timeElapsedBeforePause = this.GetTimeElapsed();
            },
            /*VirtueSky.Core.DelayHandle.Pause end.*/

            /*VirtueSky.Core.DelayHandle.Resume start.*/
            /**
             * Continue a paused timer. Does nothing if the timer has not been paused.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {void}
             */
            Resume: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#Resume", this ); }

                if (!this.IsPaused || this.IsDone) {
                    return;
                }

                this._timeElapsedBeforePause = null;
            },
            /*VirtueSky.Core.DelayHandle.Resume end.*/

            /*VirtueSky.Core.DelayHandle.GetTimeElapsed start.*/
            /**
             * Get how many seconds have elapsed since the start of this timer's current cycle.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {number}        The number of seconds that have elapsed since the start of this timer's current cycle, i.e.
             the current loop if the timer is looped, or the start if it isn't.
             If the timer has finished running, this is equal to the duration.
             If the timer was cancelled/paused, this is equal to the number of seconds that passed between the timer
             starting and when it was cancelled/paused.
             */
            GetTimeElapsed: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetTimeElapsed", this ); }

                var $t, $t1;
                if (this.IsCompleted || this.GetWorldTime() >= this.GetFireTime()) {
                    return this.Duration;
                }

                return ($t = this._timeElapsedBeforeCancel, $t != null ? $t : ($t1 = this._timeElapsedBeforePause, $t1 != null ? $t1 : this.GetWorldTime() - this._startTime));
            },
            /*VirtueSky.Core.DelayHandle.GetTimeElapsed end.*/

            /*VirtueSky.Core.DelayHandle.GetTimeRemaining start.*/
            /**
             * Get how many seconds remain before the timer completes.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {number}        The number of seconds that remain to be elapsed until the timer is completed. A timer
             is only elapsing time if it is not paused, cancelled, or completed. This will be equal to zero
             if the timer completed.
             */
            GetTimeRemaining: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetTimeRemaining", this ); }

                return this.Duration - this.GetTimeElapsed();
            },
            /*VirtueSky.Core.DelayHandle.GetTimeRemaining end.*/

            /*VirtueSky.Core.DelayHandle.GetRatioComplete start.*/
            /**
             * Get how much progress the timer has made from start to finish as a ratio.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {number}        A value from 0 to 1 indicating how much of the timer's duration has been elapsed.
             */
            GetRatioComplete: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetRatioComplete", this ); }

                return this.GetTimeElapsed() / this.Duration;
            },
            /*VirtueSky.Core.DelayHandle.GetRatioComplete end.*/

            /*VirtueSky.Core.DelayHandle.GetRatioRemaining start.*/
            /**
             * Get how much progress the timer has left to make as a ratio.
             *
             * @instance
             * @public
             * @this VirtueSky.Core.DelayHandle
             * @memberof VirtueSky.Core.DelayHandle
             * @return  {number}        A value from 0 to 1 indicating how much of the timer's duration remains to be elapsed.
             */
            GetRatioRemaining: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetRatioRemaining", this ); }

                return this.GetTimeRemaining() / this.Duration;
            },
            /*VirtueSky.Core.DelayHandle.GetRatioRemaining end.*/

            /*VirtueSky.Core.DelayHandle.GetWorldTime start.*/
            GetWorldTime: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetWorldTime", this ); }

                return this.UsesRealTime ? UnityEngine.Time.realtimeSinceStartup : UnityEngine.Time.time;
            },
            /*VirtueSky.Core.DelayHandle.GetWorldTime end.*/

            /*VirtueSky.Core.DelayHandle.GetFireTime start.*/
            GetFireTime: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetFireTime", this ); }

                return this._startTime + this.Duration;
            },
            /*VirtueSky.Core.DelayHandle.GetFireTime end.*/

            /*VirtueSky.Core.DelayHandle.GetTimeDelta start.*/
            GetTimeDelta: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#GetTimeDelta", this ); }

                return this.GetWorldTime() - this._lastUpdateTime;
            },
            /*VirtueSky.Core.DelayHandle.GetTimeDelta end.*/

            /*VirtueSky.Core.DelayHandle.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.DelayHandle#Update", this ); }

                if (this.IsDone) {
                    return;
                }

                if (this.IsPaused) {
                    this._startTime += this.GetTimeDelta();
                    this._lastUpdateTime = this.GetWorldTime();
                    return;
                }

                this._lastUpdateTime = this.GetWorldTime();
                !Bridge.staticEquals(this._onUpdate, null) ? this._onUpdate(this.GetTimeElapsed()) : null;

                if (this.GetWorldTime() >= this.GetFireTime()) {
                    !Bridge.staticEquals(this._onComplete, null) ? this._onComplete() : null;

                    if (this.IsLooped) {
                        this._startTime = this.GetWorldTime();
                    } else {
                        this.IsCompleted = true;
                    }
                }
            },
            /*VirtueSky.Core.DelayHandle.Update end.*/


        }
    });
    /*VirtueSky.Core.DelayHandle end.*/

    /*VirtueSky.Core.MonoGlobal start.*/
    Bridge.define("VirtueSky.Core.MonoGlobal", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            _toMainThreads: null,
            _isToMainThreadQueueEmpty: false,
            _localToMainThreads: null,
            _timers: null,
            _timersToAdd: null
        },
        events: {
            OnGamePause: null,
            OnGameQuit: null,
            OnGameFocus: null,
            OnTick: null,
            OnFixedTick: null,
            OnLateTick: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#init", this ); }

                this._toMainThreads = new (System.Collections.Generic.List$1(Function)).ctor();
                this._isToMainThreadQueueEmpty = true;
                this._localToMainThreads = new (System.Collections.Generic.List$1(Function)).ctor();
                this._timers = new (System.Collections.Generic.List$1(VirtueSky.Core.DelayHandle)).ctor();
                this._timersToAdd = new (System.Collections.Generic.List$1(VirtueSky.Core.DelayHandle)).ctor();
            }
        },
        methods: {
            /*VirtueSky.Core.MonoGlobal.AddTick$1 start.*/
            AddTick$1: function (tick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#AddTick$1", this ); }

                this.addOnTick(Bridge.fn.cacheBind(tick, tick.VirtueSky$Core$IEntity$Tick));
            },
            /*VirtueSky.Core.MonoGlobal.AddTick$1 end.*/

            /*VirtueSky.Core.MonoGlobal.AddTick start.*/
            AddTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#AddTick", this ); }

                this.addOnTick(action);
            },
            /*VirtueSky.Core.MonoGlobal.AddTick end.*/

            /*VirtueSky.Core.MonoGlobal.AddFixedTick$1 start.*/
            AddFixedTick$1: function (fixedTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#AddFixedTick$1", this ); }

                this.addOnFixedTick(Bridge.fn.cacheBind(fixedTick, fixedTick.VirtueSky$Core$IEntity$FixedTick));
            },
            /*VirtueSky.Core.MonoGlobal.AddFixedTick$1 end.*/

            /*VirtueSky.Core.MonoGlobal.AddFixedTick start.*/
            AddFixedTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#AddFixedTick", this ); }

                this.addOnFixedTick(action);
            },
            /*VirtueSky.Core.MonoGlobal.AddFixedTick end.*/

            /*VirtueSky.Core.MonoGlobal.AddLateTick$1 start.*/
            AddLateTick$1: function (lateTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#AddLateTick$1", this ); }

                this.addOnLateTick(Bridge.fn.cacheBind(lateTick, lateTick.VirtueSky$Core$IEntity$LateTick));
            },
            /*VirtueSky.Core.MonoGlobal.AddLateTick$1 end.*/

            /*VirtueSky.Core.MonoGlobal.AddLateTick start.*/
            AddLateTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#AddLateTick", this ); }

                this.addOnLateTick(action);
            },
            /*VirtueSky.Core.MonoGlobal.AddLateTick end.*/

            /*VirtueSky.Core.MonoGlobal.RemoveTick$1 start.*/
            RemoveTick$1: function (tick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RemoveTick$1", this ); }

                this.removeOnTick(Bridge.fn.cacheBind(tick, tick.VirtueSky$Core$IEntity$Tick));
            },
            /*VirtueSky.Core.MonoGlobal.RemoveTick$1 end.*/

            /*VirtueSky.Core.MonoGlobal.RemoveTick start.*/
            RemoveTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RemoveTick", this ); }

                this.removeOnTick(action);
            },
            /*VirtueSky.Core.MonoGlobal.RemoveTick end.*/

            /*VirtueSky.Core.MonoGlobal.RemoveFixedTick$1 start.*/
            RemoveFixedTick$1: function (fixedTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RemoveFixedTick$1", this ); }

                this.removeOnFixedTick(Bridge.fn.cacheBind(fixedTick, fixedTick.VirtueSky$Core$IEntity$FixedTick));
            },
            /*VirtueSky.Core.MonoGlobal.RemoveFixedTick$1 end.*/

            /*VirtueSky.Core.MonoGlobal.RemoveFixedTick start.*/
            RemoveFixedTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RemoveFixedTick", this ); }

                this.removeOnFixedTick(action);
            },
            /*VirtueSky.Core.MonoGlobal.RemoveFixedTick end.*/

            /*VirtueSky.Core.MonoGlobal.RemoveLateTick$1 start.*/
            RemoveLateTick$1: function (lateTick) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RemoveLateTick$1", this ); }

                this.removeOnLateTick(Bridge.fn.cacheBind(lateTick, lateTick.VirtueSky$Core$IEntity$LateTick));
            },
            /*VirtueSky.Core.MonoGlobal.RemoveLateTick$1 end.*/

            /*VirtueSky.Core.MonoGlobal.RemoveLateTick start.*/
            RemoveLateTick: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RemoveLateTick", this ); }

                this.removeOnLateTick(action);
            },
            /*VirtueSky.Core.MonoGlobal.RemoveLateTick end.*/

            /*VirtueSky.Core.MonoGlobal.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#Update", this ); }

                !Bridge.staticEquals(this.OnTick, null) ? this.OnTick() : null;
                this.UpdateAllDelayHandle();

                if (this._isToMainThreadQueueEmpty) {
                    return;
                }
                this._localToMainThreads.clear();
                this._toMainThreads;
                {
                    for (var i = 0; i < this._toMainThreads.Count; i = (i + 1) | 0) {
                        this._localToMainThreads.add(this._toMainThreads.getItem(i));
                    }

                    this._toMainThreads.clear();
                    this._isToMainThreadQueueEmpty = true;
                }

                for (var i1 = 0; i1 < this._localToMainThreads.Count; i1 = (i1 + 1) | 0) {
                    this._localToMainThreads.getItem(i1)();
                }
            },
            /*VirtueSky.Core.MonoGlobal.Update end.*/

            /*VirtueSky.Core.MonoGlobal.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#FixedUpdate", this ); }

                !Bridge.staticEquals(this.OnFixedTick, null) ? this.OnFixedTick() : null;
            },
            /*VirtueSky.Core.MonoGlobal.FixedUpdate end.*/

            /*VirtueSky.Core.MonoGlobal.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#LateUpdate", this ); }

                !Bridge.staticEquals(this.OnLateTick, null) ? this.OnLateTick() : null;
            },
            /*VirtueSky.Core.MonoGlobal.LateUpdate end.*/

            /*VirtueSky.Core.MonoGlobal.OnApplicationFocus start.*/
            OnApplicationFocus: function (hasFocus) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#OnApplicationFocus", this ); }

                !Bridge.staticEquals(this.OnGameFocus, null) ? this.OnGameFocus(hasFocus) : null;
            },
            /*VirtueSky.Core.MonoGlobal.OnApplicationFocus end.*/

            /*VirtueSky.Core.MonoGlobal.OnApplicationPause start.*/
            OnApplicationPause: function (pauseStatus) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#OnApplicationPause", this ); }

                !Bridge.staticEquals(this.OnGamePause, null) ? this.OnGamePause(pauseStatus) : null;
                if (pauseStatus && VirtueSky.DataStorage.GameData.IsAutoSave) {
                    VirtueSky.DataStorage.GameData.Save();
                }
            },
            /*VirtueSky.Core.MonoGlobal.OnApplicationPause end.*/

            /*VirtueSky.Core.MonoGlobal.OnApplicationQuit start.*/
            OnApplicationQuit: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#OnApplicationQuit", this ); }

                !Bridge.staticEquals(this.OnGameQuit, null) ? this.OnGameQuit() : null;
                if (VirtueSky.DataStorage.GameData.IsAutoSave) {
                    VirtueSky.DataStorage.GameData.Save();
                }
            },
            /*VirtueSky.Core.MonoGlobal.OnApplicationQuit end.*/

            /*VirtueSky.Core.MonoGlobal.RegisterDelayHandle start.*/
            RegisterDelayHandle: function (delayHandle) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RegisterDelayHandle", this ); }

                this._timersToAdd.add(delayHandle);
            },
            /*VirtueSky.Core.MonoGlobal.RegisterDelayHandle end.*/

            /*VirtueSky.Core.MonoGlobal.CancelAllDelayHandle start.*/
            CancelAllDelayHandle: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#CancelAllDelayHandle", this ); }

                for (var i = 0; i < this._timers.Count; i = (i + 1) | 0) {
                    this._timers.getItem(i).Cancel();
                }

                this._timers = new (System.Collections.Generic.List$1(VirtueSky.Core.DelayHandle)).ctor();
                this._timersToAdd = new (System.Collections.Generic.List$1(VirtueSky.Core.DelayHandle)).ctor();
            },
            /*VirtueSky.Core.MonoGlobal.CancelAllDelayHandle end.*/

            /*VirtueSky.Core.MonoGlobal.PauseAllDelayHandle start.*/
            PauseAllDelayHandle: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#PauseAllDelayHandle", this ); }

                for (var i = 0; i < this._timers.Count; i = (i + 1) | 0) {
                    this._timers.getItem(i).Pause();
                }
            },
            /*VirtueSky.Core.MonoGlobal.PauseAllDelayHandle end.*/

            /*VirtueSky.Core.MonoGlobal.ResumeAllDelayHandle start.*/
            ResumeAllDelayHandle: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#ResumeAllDelayHandle", this ); }

                for (var i = 0; i < this._timers.Count; i = (i + 1) | 0) {
                    this._timers.getItem(i).Resume();
                }
            },
            /*VirtueSky.Core.MonoGlobal.ResumeAllDelayHandle end.*/

            /*VirtueSky.Core.MonoGlobal.UpdateAllDelayHandle start.*/
            UpdateAllDelayHandle: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#UpdateAllDelayHandle", this ); }

                if (this._timersToAdd.Count > 0) {
                    for (var i = 0; i < this._timersToAdd.Count; i = (i + 1) | 0) {
                        this._timers.add(this._timersToAdd.getItem(i));
                    }

                    this._timersToAdd.clear();
                }

                for (var i1 = 0; i1 < this._timers.Count; i1 = (i1 + 1) | 0) {
                    this._timers.getItem(i1).Update();
                }

                this._timers.RemoveAll(function (t) {
                    return t.IsDone;
                });
            },
            /*VirtueSky.Core.MonoGlobal.UpdateAllDelayHandle end.*/

            /*VirtueSky.Core.MonoGlobal.StartCoroutineImpl start.*/
            StartCoroutineImpl: function (routine) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StartCoroutineImpl", this ); }

                if (routine != null) {
                    return this.StartCoroutine$1(routine);
                }

                return null;
            },
            /*VirtueSky.Core.MonoGlobal.StartCoroutineImpl end.*/

            /*VirtueSky.Core.MonoGlobal.StartCoroutineImpl$2 start.*/
            StartCoroutineImpl$2: function (methodName, value) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StartCoroutineImpl$2", this ); }

                if (!System.String.isNullOrEmpty(methodName)) {
                    return this.StartCoroutine$2(methodName, [value]);
                }

                return null;
            },
            /*VirtueSky.Core.MonoGlobal.StartCoroutineImpl$2 end.*/

            /*VirtueSky.Core.MonoGlobal.StartCoroutineImpl$1 start.*/
            StartCoroutineImpl$1: function (methodName) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StartCoroutineImpl$1", this ); }

                if (!System.String.isNullOrEmpty(methodName)) {
                    return this.StartCoroutine$2(methodName);
                }

                return null;
            },
            /*VirtueSky.Core.MonoGlobal.StartCoroutineImpl$1 end.*/

            /*VirtueSky.Core.MonoGlobal.StopCoroutineImpl start.*/
            StopCoroutineImpl: function (routine) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StopCoroutineImpl", this ); }

                if (routine != null) {
                    this.StopCoroutine(routine);
                }
            },
            /*VirtueSky.Core.MonoGlobal.StopCoroutineImpl end.*/

            /*VirtueSky.Core.MonoGlobal.StopCoroutineImpl$2 start.*/
            StopCoroutineImpl$2: function (routine) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StopCoroutineImpl$2", this ); }

                if (routine != null) {
                    this.StopCoroutine$2(routine);
                }
            },
            /*VirtueSky.Core.MonoGlobal.StopCoroutineImpl$2 end.*/

            /*VirtueSky.Core.MonoGlobal.StopCoroutineImpl$1 start.*/
            StopCoroutineImpl$1: function (methodName) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StopCoroutineImpl$1", this ); }

                if (!System.String.isNullOrEmpty(methodName)) {
                    this.StopCoroutine$1(methodName);
                }
            },
            /*VirtueSky.Core.MonoGlobal.StopCoroutineImpl$1 end.*/

            /*VirtueSky.Core.MonoGlobal.StopAllCoroutinesImpl start.*/
            StopAllCoroutinesImpl: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#StopAllCoroutinesImpl", this ); }

                this.StopAllCoroutines();
            },
            /*VirtueSky.Core.MonoGlobal.StopAllCoroutinesImpl end.*/

            /*VirtueSky.Core.MonoGlobal.RunOnMainThreadImpl start.*/
            /**
             * Schedules the specifies action to be run on the main thread (game thread).
             The action will be invoked upon the next Unity Update event.
             *
             * @instance
             * @this VirtueSky.Core.MonoGlobal
             * @memberof VirtueSky.Core.MonoGlobal
             * @param   {System.Action}    action    Action.
             * @return  {void}
             */
            RunOnMainThreadImpl: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#RunOnMainThreadImpl", this ); }

                this._toMainThreads;
                {
                    this._toMainThreads.add(action);
                    this._isToMainThreadQueueEmpty = false;
                }
            },
            /*VirtueSky.Core.MonoGlobal.RunOnMainThreadImpl end.*/

            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl start.*/
            /**
             * Converts the specified action to one that runs on the main thread.
             The converted action will be invoked upon the next Unity Update event.
             *
             * @instance
             * @this VirtueSky.Core.MonoGlobal
             * @memberof VirtueSky.Core.MonoGlobal
             * @param   {System.Action}    action    Act.
             * @return  {System.Action}              The main thread.
             */
            ToMainThreadImpl: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#ToMainThreadImpl", this ); }

                if (Bridge.staticEquals(action, null)) {
                    return function () { };
                }
                return Bridge.fn.bind(this, function () {
                    this.RunOnMainThreadImpl(action);
                });
            },
            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl end.*/

            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl$1 start.*/
            /**
             * Converts the specified action to one that runs on the main thread.
             The converted action will be invoked upon the next Unity Update event.
             *
             * @instance
             * @this VirtueSky.Core.MonoGlobal
             * @memberof VirtueSky.Core.MonoGlobal
             * @param   {Function}         T         The 1st type parameter.
             * @param   {System.Action}    action    Act.
             * @return  {System.Action}              The main thread.
             */
            ToMainThreadImpl$1: function (T, action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#ToMainThreadImpl$1", this ); }

                if (Bridge.staticEquals(action, null)) {
                    return function () { };
                }
                return Bridge.fn.bind(this, function (arg) {
                    this.RunOnMainThreadImpl(function () {
                        action(Bridge.rValue(arg));
                    });
                });
            },
            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl$1 end.*/

            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl$2 start.*/
            /**
             * Converts the specified action to one that runs on the main thread.
             The converted action will be invoked upon the next Unity Update event.
             *
             * @instance
             * @this VirtueSky.Core.MonoGlobal
             * @memberof VirtueSky.Core.MonoGlobal
             * @param   {Function}         T1        The 1st type parameter.
             * @param   {Function}         T2        The 2nd type parameter.
             * @param   {System.Action}    action    Act.
             * @return  {System.Action}              The main thread.
             */
            ToMainThreadImpl$2: function (T1, T2, action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#ToMainThreadImpl$2", this ); }

                if (Bridge.staticEquals(action, null)) {
                    return function () { };
                }
                return Bridge.fn.bind(this, function (arg1, arg2) {
                    this.RunOnMainThreadImpl(function () {
                        action(Bridge.rValue(arg1), Bridge.rValue(arg2));
                    });
                });
            },
            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl$2 end.*/

            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl$3 start.*/
            /**
             * Converts the specified action to one that runs on the main thread.
             The converted action will be invoked upon the next Unity Update event.
             *
             * @instance
             * @this VirtueSky.Core.MonoGlobal
             * @memberof VirtueSky.Core.MonoGlobal
             * @param   {Function}         T1        The 1st type parameter.
             * @param   {Function}         T2        The 2nd type parameter.
             * @param   {Function}         T3        The 3rd type parameter.
             * @param   {System.Action}    action    Act.
             * @return  {System.Action}              The main thread.
             */
            ToMainThreadImpl$3: function (T1, T2, T3, action) {
if ( TRACE ) { TRACE( "VirtueSky.Core.MonoGlobal#ToMainThreadImpl$3", this ); }

                if (Bridge.staticEquals(action, null)) {
                    return function () { };
                }
                return Bridge.fn.bind(this, function (arg1, arg2, arg3) {
                    this.RunOnMainThreadImpl(function () {
                        action(Bridge.rValue(arg1), Bridge.rValue(arg2), Bridge.rValue(arg3));
                    });
                });
            },
            /*VirtueSky.Core.MonoGlobal.ToMainThreadImpl$3 end.*/


        },
        overloads: {
            "AddTick(IEntity)": "AddTick$1",
            "AddFixedTick(IEntity)": "AddFixedTick$1",
            "AddLateTick(IEntity)": "AddLateTick$1",
            "RemoveTick(IEntity)": "RemoveTick$1",
            "RemoveFixedTick(IEntity)": "RemoveFixedTick$1",
            "RemoveLateTick(IEntity)": "RemoveLateTick$1",
            "StartCoroutineImpl(string, object)": "StartCoroutineImpl$2",
            "StartCoroutineImpl(string)": "StartCoroutineImpl$1",
            "StopCoroutineImpl(Coroutine)": "StopCoroutineImpl$2",
            "StopCoroutineImpl(string)": "StopCoroutineImpl$1",
            "ToMainThreadImpl(Action<T>)": "ToMainThreadImpl$1",
            "ToMainThreadImpl(Action<T1, T2>)": "ToMainThreadImpl$2",
            "ToMainThreadImpl(Action<T1, T2, T3>)": "ToMainThreadImpl$3"
        }
    });
    /*VirtueSky.Core.MonoGlobal end.*/

    /*VirtueSky.Core.RuntimeInitialize start.*/
    Bridge.define("VirtueSky.Core.RuntimeInitialize", {
        statics: {
            methods: {
                /*VirtueSky.Core.RuntimeInitialize.AutoInitialize:static start.*/
                AutoInitialize: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.RuntimeInitialize#AutoInitialize", this ); }

                    var app = new UnityEngine.GameObject.$ctor2("MonoGlobal");
                    VirtueSky.Core.App.InitMonoGlobalComponent(app.AddComponent(VirtueSky.Core.MonoGlobal));
                    VirtueSky.DataStorage.GameData.Init();
                    UnityEngine.Object.DontDestroyOnLoad(app);
                },
                /*VirtueSky.Core.RuntimeInitialize.AutoInitialize:static end.*/


            }
        }
    });
    /*VirtueSky.Core.RuntimeInitialize end.*/

    /*VirtueSky.DataStorage.GameData start.*/
    Bridge.define("VirtueSky.DataStorage.GameData", {
        statics: {
            fields: {
                INIT_SIZE: 0,
                isInitialized: false,
                profile: 0,
                datas: null,
                IsAutoSave: false
            },
            events: {
                OnSaveEvent: null
            },
            props: {
                GetPath: {
                    get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#GetPath#get", this ); }

                        return VirtueSky.DataStorage.GameData.GetDataPath(System.String.format("data_{0}.sun", [Bridge.box(VirtueSky.DataStorage.GameData.profile, System.Int32)]));
                    }
                },
                IsInitialized: {
                    get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#IsInitialized#get", this ); }

                        return VirtueSky.DataStorage.GameData.isInitialized;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#init", this ); }

                    this.INIT_SIZE = 64;
                    this.datas = new (System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte))).ctor();
                    this.IsAutoSave = true;
                }
            },
            methods: {
                /*VirtueSky.DataStorage.GameData.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Init", this ); }

                    if (VirtueSky.DataStorage.GameData.isInitialized) {
                        return;
                    }
                    VirtueSky.DataStorage.GameData.isInitialized = true;
                    VirtueSky.DataStorage.GameData.Load();
                },
                /*VirtueSky.DataStorage.GameData.Init:static end.*/

                /*VirtueSky.DataStorage.GameData.Serialize:static start.*/
                Serialize: function (T, data) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Serialize", this ); }

                    return VirtueSky.DataStorage.SerializeAdapter.ToBinary(T, Bridge.rValue(data));
                },
                /*VirtueSky.DataStorage.GameData.Serialize:static end.*/

                /*VirtueSky.DataStorage.GameData.Deserialize:static start.*/
                Deserialize: function (T, bytes) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Deserialize", this ); }

                    return VirtueSky.DataStorage.SerializeAdapter.FromBinary(T, bytes);
                },
                /*VirtueSky.DataStorage.GameData.Deserialize:static end.*/

                /*VirtueSky.DataStorage.GameData.RequireNullCheck:static start.*/
                RequireNullCheck: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#RequireNullCheck", this ); }

                    if (VirtueSky.DataStorage.GameData.datas == null) {
                        VirtueSky.DataStorage.GameData.Load();
                    }
                    if (VirtueSky.DataStorage.GameData.datas == null) {
                        throw new System.NullReferenceException.ctor();
                    }
                },
                /*VirtueSky.DataStorage.GameData.RequireNullCheck:static end.*/

                /*VirtueSky.DataStorage.GameData.GetDataPath:static start.*/
                GetDataPath: function (name) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#GetDataPath", this ); }

                    var persistentDataPath = VirtueSky.DataStorage.GameData.GetPersistentDataPath();
                    if (!System.IO.Directory.Exists(persistentDataPath)) {
                        System.IO.Directory.CreateDirectory(persistentDataPath);
                    }

                    return System.IO.Path.Combine(persistentDataPath, name);
                },
                /*VirtueSky.DataStorage.GameData.GetDataPath:static end.*/

                /*VirtueSky.DataStorage.GameData.GetPersistentDataPath:static start.*/
                GetPersistentDataPath: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#GetPersistentDataPath", this ); }

                    return "";
                },
                /*VirtueSky.DataStorage.GameData.GetPersistentDataPath:static end.*/

                /*VirtueSky.DataStorage.GameData.ChangeProfile:static start.*/
                ChangeProfile: function (profile) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#ChangeProfile", this ); }

                    if (VirtueSky.DataStorage.GameData.profile === profile) {
                        return;
                    }

                    VirtueSky.DataStorage.GameData.Save();
                    VirtueSky.DataStorage.GameData.profile = profile;
                    VirtueSky.DataStorage.GameData.Load();
                },
                /*VirtueSky.DataStorage.GameData.ChangeProfile:static end.*/

                /*VirtueSky.DataStorage.GameData.VerifyProfile:static start.*/
                VerifyProfile: function (profile) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#VerifyProfile", this ); }

                    return VirtueSky.DataStorage.GameData.profile === profile;
                },
                /*VirtueSky.DataStorage.GameData.VerifyProfile:static end.*/

                /*VirtueSky.DataStorage.GameData.Save:static start.*/
                Save: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Save", this ); }

                    !Bridge.staticEquals(VirtueSky.DataStorage.GameData.OnSaveEvent, null) ? VirtueSky.DataStorage.GameData.OnSaveEvent() : null;

                    var bytes = VirtueSky.DataStorage.GameData.Serialize(System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte)), VirtueSky.DataStorage.GameData.datas);
                    System.IO.File.WriteAllBytes(VirtueSky.DataStorage.GameData.GetPath, bytes);
                },
                /*VirtueSky.DataStorage.GameData.Save:static end.*/

                /*VirtueSky.DataStorage.GameData.SaveAsync:static start.*/
                SaveAsync: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#SaveAsync", this ); }

                    var $step = 0,
                        $task1, 
                        $jumpFromFinally, 
                        bytes, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1], $step);
                                switch ($step) {
                                    case 0: {
                                        !Bridge.staticEquals(VirtueSky.DataStorage.GameData.OnSaveEvent, null) ? VirtueSky.DataStorage.GameData.OnSaveEvent() : null;

                                        bytes = VirtueSky.DataStorage.GameData.Serialize(System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte)), VirtueSky.DataStorage.GameData.datas);
                                        $task1 = System.IO.File.WriteAllBytesAsync(VirtueSky.DataStorage.GameData.GetPath, bytes);
                                        $step = 1;
                                        if ($task1.isCompleted()) {
                                            continue;
                                        }
                                        $task1.continue($asyncBody);
                                        return;
                                    }
                                    case 1: {
                                        $task1.getAwaitedResult();
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    $asyncBody();
                },
                /*VirtueSky.DataStorage.GameData.SaveAsync:static end.*/

                /*VirtueSky.DataStorage.GameData.Load:static start.*/
                Load: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Load", this ); }

                    if (!System.IO.File.Exists(VirtueSky.DataStorage.GameData.GetPath)) {
                        var stream = System.IO.File.Create(VirtueSky.DataStorage.GameData.GetPath);
                        stream.Close();
                    }

                    var bytes = System.IO.File.ReadAllBytes(VirtueSky.DataStorage.GameData.GetPath);
                    if (bytes.length === 0) {
                        VirtueSky.DataStorage.GameData.datas.clear();
                        return;
                    }

                    VirtueSky.DataStorage.GameData.datas = VirtueSky.DataStorage.GameData.Deserialize(System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte)), bytes) || new (System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte))).$ctor4(VirtueSky.DataStorage.GameData.INIT_SIZE);
                },
                /*VirtueSky.DataStorage.GameData.Load:static end.*/

                /*VirtueSky.DataStorage.GameData.LoadAsync:static start.*/
                LoadAsync: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#LoadAsync", this ); }

                    var $step = 0,
                        $task1, 
                        $taskResult1, 
                        $jumpFromFinally, 
                        stream, 
                        bytes, 
                        $asyncBody = Bridge.fn.bind(this, function () {
                            for (;;) {
                                $step = System.Array.min([0,1], $step);
                                switch ($step) {
                                    case 0: {
                                        if (!System.IO.File.Exists(VirtueSky.DataStorage.GameData.GetPath)) {
                                            stream = System.IO.File.Create(VirtueSky.DataStorage.GameData.GetPath);
                                            stream.Close();
                                        }

                                        $task1 = System.IO.File.ReadAllBytesAsync(VirtueSky.DataStorage.GameData.GetPath);
                                        $step = 1;
                                        if ($task1.isCompleted()) {
                                            continue;
                                        }
                                        $task1.continue($asyncBody);
                                        return;
                                    }
                                    case 1: {
                                        $taskResult1 = $task1.getAwaitedResult();
                                        bytes = $taskResult1;
                                        if (bytes.length === 0) {
                                            VirtueSky.DataStorage.GameData.datas.clear();
                                            return;
                                        }

                                        VirtueSky.DataStorage.GameData.datas = VirtueSky.DataStorage.GameData.Deserialize(System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte)), bytes) || new (System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte))).$ctor4(VirtueSky.DataStorage.GameData.INIT_SIZE);
                                        return;
                                    }
                                    default: {
                                        return;
                                    }
                                }
                            }
                        }, arguments);

                    $asyncBody();
                },
                /*VirtueSky.DataStorage.GameData.LoadAsync:static end.*/

                /*VirtueSky.DataStorage.GameData.Get:static start.*/
                /**
                 * @static
                 * @public
                 * @this VirtueSky.DataStorage.GameData
                 * @memberof VirtueSky.DataStorage.GameData
                 * @param   {Function}    T          
                 * @param   {string}      key        
                 * @param   {T}           default    If value of <b>default</b> can not be found or empty! will return the default value of data type!
                 * @return  {T}
                 */
                Get: function (T, key, $default) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Get", this ); }

                    if ($default === void 0) { $default = Bridge.getDefaultValue(T); }
                    VirtueSky.DataStorage.GameData.RequireNullCheck();
                    var value = { };

                    VirtueSky.DataStorage.GameData.datas.tryGetValue(key, value);
                    if (value.v == null || value.v.length === 0) {
                        return Bridge.rValue($default);
                    }

                    return VirtueSky.DataStorage.GameData.Deserialize(T, value.v);
                },
                /*VirtueSky.DataStorage.GameData.Get:static end.*/

                /*VirtueSky.DataStorage.GameData.TryGet:static start.*/
                TryGet: function (T, key, data) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#TryGet", this ); }

                    VirtueSky.DataStorage.GameData.RequireNullCheck();

                    var hasKey;
                    var value = { };
                    if (VirtueSky.DataStorage.GameData.datas.tryGetValue(key, value)) {
                        data.v = Bridge.rValue(VirtueSky.DataStorage.GameData.Deserialize(T, value.v));
                        hasKey = true;
                    } else {
                        data.v = Bridge.getDefaultValue(T);
                        hasKey = false;
                    }

                    return hasKey;
                },
                /*VirtueSky.DataStorage.GameData.TryGet:static end.*/

                /*VirtueSky.DataStorage.GameData.Set:static start.*/
                Set: function (T, key, data) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Set", this ); }

                    VirtueSky.DataStorage.GameData.RequireNullCheck();
                    var bytes = VirtueSky.DataStorage.GameData.Serialize(T, Bridge.rValue(data));
                    if (System.Collections.Generic.CollectionExtensions.TryAdd(System.String, System.Array.type(System.Byte), VirtueSky.DataStorage.GameData.datas, key, bytes)) {
                        return;
                    }
                    VirtueSky.DataStorage.GameData.datas.setItem(key, bytes);
                },
                /*VirtueSky.DataStorage.GameData.Set:static end.*/

                /*VirtueSky.DataStorage.GameData.HasKey:static start.*/
                HasKey: function (key) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#HasKey", this ); }

                    return VirtueSky.DataStorage.GameData.datas.containsKey(key);
                },
                /*VirtueSky.DataStorage.GameData.HasKey:static end.*/

                /*VirtueSky.DataStorage.GameData.DeleteKey:static start.*/
                DeleteKey: function (key) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#DeleteKey", this ); }

                    VirtueSky.DataStorage.GameData.datas.remove(key);
                },
                /*VirtueSky.DataStorage.GameData.DeleteKey:static end.*/

                /*VirtueSky.DataStorage.GameData.DeleteAll:static start.*/
                DeleteAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#DeleteAll", this ); }

                    VirtueSky.DataStorage.GameData.datas.clear();
                },
                /*VirtueSky.DataStorage.GameData.DeleteAll:static end.*/

                /*VirtueSky.DataStorage.GameData.DeleteFileData:static start.*/
                DeleteFileData: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#DeleteFileData", this ); }

                    if (System.IO.File.Exists(VirtueSky.DataStorage.GameData.GetPath)) {
                        System.IO.File.Delete(VirtueSky.DataStorage.GameData.GetPath);
                    }
                },
                /*VirtueSky.DataStorage.GameData.DeleteFileData:static end.*/

                /*VirtueSky.DataStorage.GameData.Backup:static start.*/
                /**
                 * Get raw byte[] of all data of profile
                 *
                 * @static
                 * @public
                 * @this VirtueSky.DataStorage.GameData
                 * @memberof VirtueSky.DataStorage.GameData
                 * @return  {Array.<number>}
                 */
                Backup: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Backup", this ); }

                    return VirtueSky.DataStorage.SerializeAdapter.ToBinary(System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte)), VirtueSky.DataStorage.GameData.datas);
                },
                /*VirtueSky.DataStorage.GameData.Backup:static end.*/

                /*VirtueSky.DataStorage.GameData.Restore:static start.*/
                /**
                 * Load from byte[]
                 *
                 * @static
                 * @public
                 * @this VirtueSky.DataStorage.GameData
                 * @memberof VirtueSky.DataStorage.GameData
                 * @param   {Array.<number>}    bytes
                 * @return  {void}
                 */
                Restore: function (bytes) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.GameData#Restore", this ); }

                    VirtueSky.DataStorage.GameData.datas = VirtueSky.DataStorage.SerializeAdapter.FromBinary(System.Collections.Generic.Dictionary$2(System.String,System.Array.type(System.Byte)), bytes);
                },
                /*VirtueSky.DataStorage.GameData.Restore:static end.*/


            }
        }
    });
    /*VirtueSky.DataStorage.GameData end.*/

    /*VirtueSky.DataStorage.SerializeAdapter start.*/
    Bridge.define("VirtueSky.DataStorage.SerializeAdapter", {
        statics: {
            methods: {
                /*VirtueSky.DataStorage.SerializeAdapter.ToBinary:static start.*/
                /**
                 * Serializes the object to JSON string and converts it to byte array.
                 *
                 * @static
                 * @public
                 * @this VirtueSky.DataStorage.SerializeAdapter
                 * @memberof VirtueSky.DataStorage.SerializeAdapter
                 * @param   {Function}          T      
                 * @param   {T}                 obj
                 * @return  {Array.<number>}
                 */
                ToBinary: function (T, obj) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.SerializeAdapter#ToBinary", this ); }

                    var json = UnityEngine.JsonUtility.ToJson(obj);
                    return System.Text.Encoding.UTF8.GetBytes$2(json);
                },
                /*VirtueSky.DataStorage.SerializeAdapter.ToBinary:static end.*/

                /*VirtueSky.DataStorage.SerializeAdapter.FromBinary:static start.*/
                /**
                 * Deserializes the byte array (JSON string) to the specified type.
                 *
                 * @static
                 * @public
                 * @this VirtueSky.DataStorage.SerializeAdapter
                 * @memberof VirtueSky.DataStorage.SerializeAdapter
                 * @param   {Function}          T                  
                 * @param   {Array.<number>}    serializedBytes
                 * @return  {T}
                 */
                FromBinary: function (T, serializedBytes) {
if ( TRACE ) { TRACE( "VirtueSky.DataStorage.SerializeAdapter#FromBinary", this ); }

                    var json = System.Text.Encoding.UTF8.GetString(serializedBytes);
                    return UnityEngine.JsonUtility.FromJson(T, json);
                },
                /*VirtueSky.DataStorage.SerializeAdapter.FromBinary:static end.*/


            }
        }
    });
    /*VirtueSky.DataStorage.SerializeAdapter end.*/

    /*VirtueSky.DataType.ShortDouble start.*/
    Bridge.define("VirtueSky.DataType.ShortDouble", {
        inherits: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#inherits", this ); }
 return [System.IFormattable,System.IComparable$1(VirtueSky.DataType.ShortDouble),System.IEquatable$1(VirtueSky.DataType.ShortDouble),System.IComparable]; },
        $kind: 4,
        statics: {
            fields: {
                _unitFinder: null
            },
            ctors: {
                ctor: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#ctor", this ); }

                    VirtueSky.DataType.ShortDouble._unitFinder = VirtueSky.DataType.ShortDouble.Unit0.Find;
                }
            },
            methods: {
                /*VirtueSky.DataType.ShortDouble.Max:static start.*/
                Max: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Max", this ); }

                    return VirtueSky.DataType.ShortDouble.op_GreaterThan(a.$clone(), b.$clone()) ? a.$clone() : b.$clone();
                },
                /*VirtueSky.DataType.ShortDouble.Max:static end.*/

                /*VirtueSky.DataType.ShortDouble.Min:static start.*/
                Min: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Min", this ); }

                    return VirtueSky.DataType.ShortDouble.op_GreaterThan(a.$clone(), b.$clone()) ? b.$clone() : a.$clone();
                },
                /*VirtueSky.DataType.ShortDouble.Min:static end.*/

                /*VirtueSky.DataType.ShortDouble.Clamp:static start.*/
                Clamp: function (value, min, max) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Clamp", this ); }

                    return VirtueSky.DataType.ShortDouble.op_LessThan(value.$clone(), min.$clone()) ? min.$clone() : (VirtueSky.DataType.ShortDouble.op_GreaterThan(value.$clone(), max.$clone()) ? max.$clone() : value.$clone());
                },
                /*VirtueSky.DataType.ShortDouble.Clamp:static end.*/

                /*VirtueSky.DataType.ShortDouble.SetUnit:static start.*/
                SetUnit: function (u) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#SetUnit", this ); }

                    if (u === 0) {
                        VirtueSky.DataType.ShortDouble._unitFinder = VirtueSky.DataType.ShortDouble.Unit0.Find;
                    } else if (u === 1) {
                        VirtueSky.DataType.ShortDouble._unitFinder = VirtueSky.DataType.ShortDouble.Unit1.Find;
                    } else {
                        VirtueSky.DataType.ShortDouble._unitFinder = VirtueSky.DataType.ShortDouble.Unit2.Find;
                    }
                },
                /*VirtueSky.DataType.ShortDouble.SetUnit:static end.*/

                /*VirtueSky.DataType.ShortDouble.FindUnit:static start.*/
                FindUnit: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#FindUnit", this ); }

                    return VirtueSky.DataType.ShortDouble._unitFinder(value);
                },
                /*VirtueSky.DataType.ShortDouble.FindUnit:static end.*/

                op_Implicit$1: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_Implicit$1", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(value);
                },
                op_Implicit: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_Implicit", this ); }

                    return value.Value;
                },
                op_Addition: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_Addition", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(a.Value + b.Value);
                },
                op_Subtraction: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_Subtraction", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(a.Value - b.Value);
                },
                op_Multiply: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_Multiply", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(a.Value * b.Value);
                },
                op_Division: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_Division", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(a.Value / b.Value);
                },
                op_GreaterThan: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_GreaterThan", this ); }

                    return a.Value > b.Value;
                },
                op_GreaterThanOrEqual: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_GreaterThanOrEqual", this ); }

                    return a.Value >= b.Value;
                },
                op_LessThan: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_LessThan", this ); }

                    return a.Value < b.Value;
                },
                op_LessThanOrEqual: function (a, b) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#op_LessThanOrEqual", this ); }

                    return a.Value <= b.Value;
                },
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#getDefaultValue", this ); }
 return new VirtueSky.DataType.ShortDouble(); }
            }
        },
        fields: {
            value: 0
        },
        props: {
            Value: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Value#get", this ); }

                    return this.value;
                }
            },
            Floor: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Floor#get", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(Math.floor(this.Value));
                }
            },
            Ceiling: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Ceiling#get", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(Math.ceil(this.Value));
                }
            },
            Round: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Round#get", this ); }

                    return new VirtueSky.DataType.ShortDouble.$ctor1(Bridge.Math.round(this.Value, 0, 6));
                }
            },
            True: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#True#get", this ); }

                    return this.AsBool();
                }
            }
        },
        alias: [
            "compareTo$1", ["System$IComparable$1$VirtueSky$DataType$ShortDouble$compareTo", "System$IComparable$1$compareTo"],
            "compareTo", "System$IComparable$compareTo",
            "equalsT", "System$IEquatable$1$VirtueSky$DataType$ShortDouble$equalsT",
            "format", "System$IFormattable$format"
        ],
        ctors: {
            $ctor1: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#$ctor1", this ); }

                if (value === void 0) { value = 0.0; }

                this.$initialize();
                this.value = value;
            },
            ctor: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            /*VirtueSky.DataType.ShortDouble.AsFloat start.*/
            AsFloat: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#AsFloat", this ); }

                return this.Value;
            },
            /*VirtueSky.DataType.ShortDouble.AsFloat end.*/

            /*VirtueSky.DataType.ShortDouble.AsLong start.*/
            AsLong: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#AsLong", this ); }

                return Bridge.Int.clip64(this.Value);
            },
            /*VirtueSky.DataType.ShortDouble.AsLong end.*/

            /*VirtueSky.DataType.ShortDouble.AsBool start.*/
            AsBool: function (eps) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#AsBool", this ); }

                if (eps === void 0) { eps = 0.3; }
                return this.Value > eps;
            },
            /*VirtueSky.DataType.ShortDouble.AsBool end.*/

            /*VirtueSky.DataType.ShortDouble.AsInt start.*/
            AsInt: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#AsInt", this ); }

                return Bridge.Int.clip32(this.Value);
            },
            /*VirtueSky.DataType.ShortDouble.AsInt end.*/

            /*VirtueSky.DataType.ShortDouble.Pow start.*/
            Pow: function (p) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#Pow", this ); }

                return new VirtueSky.DataType.ShortDouble.$ctor1(Math.pow(this.Value, p));
            },
            /*VirtueSky.DataType.ShortDouble.Pow end.*/

            /*VirtueSky.DataType.ShortDouble.compareTo$1 start.*/
            compareTo$1: function (other) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#compareTo$1", this ); }

                return Bridge.compare(this.Value, other.Value);
            },
            /*VirtueSky.DataType.ShortDouble.compareTo$1 end.*/

            /*VirtueSky.DataType.ShortDouble.compareTo start.*/
            compareTo: function (obj) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#compareTo", this ); }

                return Bridge.compare(this.Value, obj);
            },
            /*VirtueSky.DataType.ShortDouble.compareTo end.*/

            /*VirtueSky.DataType.ShortDouble.equalsT start.*/
            equalsT: function (other) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#equalsT", this ); }

                return this.Value === other.Value;
            },
            /*VirtueSky.DataType.ShortDouble.equalsT end.*/

            /*VirtueSky.DataType.ShortDouble.equals start.*/
            equals: function (other) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#equals", this ); }

                if (other == null || !Bridge.referenceEquals(VirtueSky.DataType.ShortDouble, Bridge.getType(other))) {
                    return false;
                }
                return this.Value === System.Nullable.getValue(Bridge.cast(Bridge.unbox(other, VirtueSky.DataType.ShortDouble), VirtueSky.DataType.ShortDouble)).Value;
            },
            /*VirtueSky.DataType.ShortDouble.equals end.*/

            /*VirtueSky.DataType.ShortDouble.getHashCode start.*/
            getHashCode: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#getHashCode", this ); }

                return System.Double.getHashCode(this.Value);
            },
            /*VirtueSky.DataType.ShortDouble.getHashCode end.*/

            /*VirtueSky.DataType.ShortDouble.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#toString", this ); }

                return this.ToString$2(VirtueSky.DataType.ShortDouble.FindUnit(this.Value), "0.#");
            },
            /*VirtueSky.DataType.ShortDouble.toString end.*/

            /*VirtueSky.DataType.ShortDouble.ToString$1 start.*/
            ToString$1: function (format) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#ToString$1", this ); }

                return this.ToString$2(VirtueSky.DataType.ShortDouble.FindUnit(this.Value), format);
            },
            /*VirtueSky.DataType.ShortDouble.ToString$1 end.*/

            /*VirtueSky.DataType.ShortDouble.ToString start.*/
            ToString: function (provider) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#ToString", this ); }

                return System.Double.format(this.Value, "G", provider);
            },
            /*VirtueSky.DataType.ShortDouble.ToString end.*/

            /*VirtueSky.DataType.ShortDouble.format start.*/
            format: function (format, provider) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#format", this ); }

                return this.ToString$3(VirtueSky.DataType.ShortDouble.FindUnit(this.Value), format, provider);
            },
            /*VirtueSky.DataType.ShortDouble.format end.*/

            /*VirtueSky.DataType.ShortDouble.ToString$2 start.*/
            ToString$2: function (unit, format) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#ToString$2", this ); }

                if (format === void 0) { format = "0.##"; }
                if ((Math.abs(this.Value) === Number.POSITIVE_INFINITY) || isNaN(this.Value)) {
                    return "Infinity or NaN";
                }

                return (System.Double.format((this.Value / Math.pow(10, unit.exponent)), format) || "") + (unit.name || "");
            },
            /*VirtueSky.DataType.ShortDouble.ToString$2 end.*/

            /*VirtueSky.DataType.ShortDouble.ToString$3 start.*/
            ToString$3: function (unit, format, provider) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#ToString$3", this ); }

                if ((Math.abs(this.Value) === Number.POSITIVE_INFINITY) || isNaN(this.Value)) {
                    return "Infinity or NaN";
                }

                return (System.Double.format((this.Value / Math.pow(10, unit.exponent)), format, provider) || "") + (unit.name || "");
            },
            /*VirtueSky.DataType.ShortDouble.ToString$3 end.*/

            $clone: function (to) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble#$clone", this ); }

                var s = to || new VirtueSky.DataType.ShortDouble();
                s.value = this.value;
                return s;
            }
        },
        overloads: {
            "CompareTo(ShortDouble)": "compareTo$1",
            "CompareTo(object)": "compareTo",
            "Equals(ShortDouble)": "equalsT",
            "Equals(object)": "equals",
            "GetHashCode()": "getHashCode",
            "ToString()": "toString",
            "ToString(string)": "ToString$1",
            "ToString(string, IFormatProvider)": "format",
            "ToString(Unit, string)": "ToString$2",
            "ToString(Unit, string, IFormatProvider)": "ToString$3"
        }
    });
    /*VirtueSky.DataType.ShortDouble end.*/

    /*VirtueSky.DataType.ShortDouble+Unit start.*/
    Bridge.define("VirtueSky.DataType.ShortDouble.Unit", {
        $kind: 1004,
        statics: {
            methods: {
                getDefaultValue: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit#getDefaultValue", this ); }
 return new VirtueSky.DataType.ShortDouble.Unit(); }
            }
        },
        fields: {
            exponent: 0,
            name: null
        },
        ctors: {
            ctor: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit#ctor", this ); }

                this.$initialize();
            }
        },
        methods: {
            getHashCode: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit#getHashCode", this ); }

                var h = Bridge.addHash([1953066581, this.exponent, this.name]);
                return h;
            },
            equals: function (o) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit#equals", this ); }

                if (!Bridge.is(o, VirtueSky.DataType.ShortDouble.Unit)) {
                    return false;
                }
                return Bridge.equals(this.exponent, o.exponent) && Bridge.equals(this.name, o.name);
            },
            $clone: function (to) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit#$clone", this ); }

                var s = to || new VirtueSky.DataType.ShortDouble.Unit();
                s.exponent = this.exponent;
                s.name = this.name;
                return s;
            }
        }
    });
    /*VirtueSky.DataType.ShortDouble+Unit end.*/

    /*VirtueSky.DataType.ShortDouble+Unit0 start.*/
    Bridge.define("VirtueSky.DataType.ShortDouble.Unit0", {
        $kind: 1002,
        statics: {
            fields: {
                Units: null,
                Infinity: null,
                Zero: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit0#init", this ); }

                    this.Infinity = new VirtueSky.DataType.ShortDouble.Unit();
                    this.Zero = new VirtueSky.DataType.ShortDouble.Unit();
                },
                ctor: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit0#ctor", this ); }

                    VirtueSky.DataType.ShortDouble.Unit0.Infinity.$clone().exponent = 0;
                    VirtueSky.DataType.ShortDouble.Unit0.Infinity.$clone().name = "(VeryBIG)";
                    VirtueSky.DataType.ShortDouble.Unit0.Zero.$clone().exponent = 0;
                    VirtueSky.DataType.ShortDouble.Unit0.Zero.$clone().name = "";

                    VirtueSky.DataType.ShortDouble.Unit0.Units = System.Array.init(120, function (){
                        return new VirtueSky.DataType.ShortDouble.Unit();
                    }, VirtueSky.DataType.ShortDouble.Unit);
                    var i = 0;

                    VirtueSky.DataType.ShortDouble.Unit0.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "";
                    VirtueSky.DataType.ShortDouble.Unit0.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit0.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "k";
                    VirtueSky.DataType.ShortDouble.Unit0.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit0.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "m";
                    VirtueSky.DataType.ShortDouble.Unit0.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit0.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "b";
                    VirtueSky.DataType.ShortDouble.Unit0.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit0.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "t";
                    VirtueSky.DataType.ShortDouble.Unit0.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);


                    for (var c0 = 97; c0 <= 122; c0 = (c0 + 1) & 65535) {
                        for (var c1 = c0; c1 <= 122; c1 = (c1 + 1) & 65535) {
                            if (i >= VirtueSky.DataType.ShortDouble.Unit0.Units.length) {
                                break;
                            }

                            VirtueSky.DataType.ShortDouble.Unit0.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = (String.fromCharCode(c0) || "") + (String.fromCharCode(c1) || "");
                            VirtueSky.DataType.ShortDouble.Unit0.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);
                        }
                    }
                }
            },
            methods: {
                /*VirtueSky.DataType.ShortDouble+Unit0.Find:static start.*/
                Find: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit0#Find", this ); }

                    //extract

                    var e = Bridge.Math.logWithBase(Math.abs(value), 10.0);
                    var fe = Math.floor(e);
                    var _discard1 = { };

                    var exponent = System.Int64.divRem(Bridge.Int.clip64(fe), System.Int64(3), _discard1).mul(System.Int64(3));

                    //find
                    if (exponent.lt(System.Int64(0))) {
                        return VirtueSky.DataType.ShortDouble.Unit0.Zero.$clone();
                    }
                    return exponent.div(System.Int64(3)).lt(System.Int64(VirtueSky.DataType.ShortDouble.Unit0.Units.length)) ? VirtueSky.DataType.ShortDouble.Unit0.Units[System.Int64.toNumber(exponent.div(System.Int64(3)))].$clone() : VirtueSky.DataType.ShortDouble.Unit0.Infinity.$clone();
                },
                /*VirtueSky.DataType.ShortDouble+Unit0.Find:static end.*/


            }
        }
    });
    /*VirtueSky.DataType.ShortDouble+Unit0 end.*/

    /*VirtueSky.DataType.ShortDouble+Unit1 start.*/
    Bridge.define("VirtueSky.DataType.ShortDouble.Unit1", {
        $kind: 1002,
        statics: {
            fields: {
                Units: null,
                Infinity: null,
                Zero: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit1#init", this ); }

                    this.Infinity = new VirtueSky.DataType.ShortDouble.Unit();
                    this.Zero = new VirtueSky.DataType.ShortDouble.Unit();
                },
                ctor: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit1#ctor", this ); }

                    VirtueSky.DataType.ShortDouble.Unit1.Infinity.$clone().exponent = 0;
                    VirtueSky.DataType.ShortDouble.Unit1.Infinity.$clone().name = "(VeryBIG)";
                    VirtueSky.DataType.ShortDouble.Unit1.Zero.$clone().exponent = 0;
                    VirtueSky.DataType.ShortDouble.Unit1.Zero.$clone().name = "";

                    VirtueSky.DataType.ShortDouble.Unit1.Units = System.Array.init(304, function (){
                        return new VirtueSky.DataType.ShortDouble.Unit();
                    }, VirtueSky.DataType.ShortDouble.Unit);
                    var i = 0;

                    VirtueSky.DataType.ShortDouble.Unit1.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "";
                    VirtueSky.DataType.ShortDouble.Unit1.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit1.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "K";
                    VirtueSky.DataType.ShortDouble.Unit1.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit1.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "M";
                    VirtueSky.DataType.ShortDouble.Unit1.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit1.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "B";
                    VirtueSky.DataType.ShortDouble.Unit1.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    VirtueSky.DataType.ShortDouble.Unit1.Units[Bridge.identity(i, ((i = (i + 1) | 0)))].name = "T";
                    VirtueSky.DataType.ShortDouble.Unit1.Units[((i - 1) | 0)].exponent = Bridge.Int.mul((((i - 1) | 0)), 3);

                    var exp = 14;
                    for (var j = i; j < VirtueSky.DataType.ShortDouble.Unit1.Units.length; j = (j + 1) | 0) {
                        VirtueSky.DataType.ShortDouble.Unit1.Units[j].name = "e" + (((exp = (exp + 1) | 0)));
                        VirtueSky.DataType.ShortDouble.Unit1.Units[j].exponent = exp;
                    }
                }
            },
            methods: {
                /*VirtueSky.DataType.ShortDouble+Unit1.Find:static start.*/
                Find: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit1#Find", this ); }

                    //extract
                    var exponent;

                    var e = Bridge.Math.logWithBase(Math.abs(value), 10.0);
                    var fe = Math.floor(e);

                    if (fe < 15) {
                        var _discard2 = { };
                        exponent = System.Int64.divRem(Bridge.Int.clip64(fe), System.Int64(3), _discard2).mul(System.Int64(3));
                    } else {
                        exponent = Bridge.Int.clip64(fe);
                    }

                    //find
                    if (exponent.lt(System.Int64(0))) {
                        return VirtueSky.DataType.ShortDouble.Unit1.Zero.$clone();
                    }
                    if (exponent.lt(System.Int64(15))) {
                        return VirtueSky.DataType.ShortDouble.Unit1.Units[System.Int64.toNumber(exponent.div(System.Int64(3)))].$clone();
                    }
                    return exponent.lt(System.Int64(VirtueSky.DataType.ShortDouble.Unit1.Units.length + 5)) ? VirtueSky.DataType.ShortDouble.Unit1.Units[System.Int64.toNumber(System.Int64(5).add(exponent).sub(System.Int64(15)))].$clone() : VirtueSky.DataType.ShortDouble.Unit1.Infinity.$clone();
                },
                /*VirtueSky.DataType.ShortDouble+Unit1.Find:static end.*/


            }
        }
    });
    /*VirtueSky.DataType.ShortDouble+Unit1 end.*/

    /*VirtueSky.DataType.ShortDouble+Unit2 start.*/
    Bridge.define("VirtueSky.DataType.ShortDouble.Unit2", {
        $kind: 1002,
        statics: {
            fields: {
                Units: null,
                Infinity: null,
                Zero: null,
                Signs: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit2#init", this ); }

                    this.Infinity = new VirtueSky.DataType.ShortDouble.Unit();
                    this.Zero = new VirtueSky.DataType.ShortDouble.Unit();
                    this.Signs = System.Array.init([
                        "", 
                        "k", 
                        "m", 
                        "b", 
                        "t", 
                        "q", 
                        "Q", 
                        "s", 
                        "S", 
                        "o", 
                        "n", 
                        "d", 
                        "u", 
                        "Du", 
                        "Tr", 
                        "Qu", 
                        "Qi", 
                        "Sx", 
                        "Sp", 
                        "Oc", 
                        "No", 
                        "Vi", 
                        "Ce"
                    ], System.String);
                },
                ctor: function () {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit2#ctor", this ); }

                    VirtueSky.DataType.ShortDouble.Unit2.Infinity.$clone().exponent = 0;
                    VirtueSky.DataType.ShortDouble.Unit2.Infinity.$clone().name = "(VeryBIG)";
                    VirtueSky.DataType.ShortDouble.Unit2.Zero.$clone().exponent = 0;
                    VirtueSky.DataType.ShortDouble.Unit2.Zero.$clone().name = "";

                    VirtueSky.DataType.ShortDouble.Unit2.Units = System.Array.init(VirtueSky.DataType.ShortDouble.Unit2.Signs.length, function (){
                        return new VirtueSky.DataType.ShortDouble.Unit();
                    }, VirtueSky.DataType.ShortDouble.Unit);
                    for (var i = 0; i < VirtueSky.DataType.ShortDouble.Unit2.Signs.length; i = (i + 1) | 0) {
                        VirtueSky.DataType.ShortDouble.Unit2.Units[i].name = VirtueSky.DataType.ShortDouble.Unit2.Signs[i];
                        VirtueSky.DataType.ShortDouble.Unit2.Units[i].exponent = Bridge.Int.mul(i, 3);
                    }
                }
            },
            methods: {
                /*VirtueSky.DataType.ShortDouble+Unit2.Find:static start.*/
                Find: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.DataType.ShortDouble.Unit2#Find", this ); }

                    var e = Bridge.Math.logWithBase(Math.abs(value), 10.0);
                    var fe = Math.floor(e);
                    var remainder = { };

                    var exponent = System.Int64.divRem(Bridge.Int.clip64(fe), System.Int64(3), remainder).mul(System.Int64(3));

                    if (exponent.lt(System.Int64(0))) {
                        return VirtueSky.DataType.ShortDouble.Unit2.Zero.$clone();
                    }
                    return exponent.div(System.Int64(3)).lt(System.Int64(VirtueSky.DataType.ShortDouble.Unit2.Units.length)) ? VirtueSky.DataType.ShortDouble.Unit2.Units[System.Int64.toNumber(exponent.div(System.Int64(3)))].$clone() : VirtueSky.DataType.ShortDouble.Unit2.Infinity.$clone();
                },
                /*VirtueSky.DataType.ShortDouble+Unit2.Find:static end.*/


            }
        }
    });
    /*VirtueSky.DataType.ShortDouble+Unit2 end.*/

    /*VirtueSky.Events.IEventListener start.*/
    Bridge.define("VirtueSky.Events.IEventListener", {
        $kind: 3
    });
    /*VirtueSky.Events.IEventListener end.*/

    /*VirtueSky.Events.EventListenerMono start.*/
    Bridge.define("VirtueSky.Events.EventListenerMono", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            bindingListener: 0
        },
        methods: {
            /*VirtueSky.Events.EventListenerMono.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventListenerMono#Awake", this ); }

                if (this.bindingListener === VirtueSky.Events.BindingListener.UNTIL_DESTROY) {
                    this.ToggleListenerEvent(true);
                }
            },
            /*VirtueSky.Events.EventListenerMono.Awake end.*/

            /*VirtueSky.Events.EventListenerMono.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventListenerMono#OnEnable", this ); }

                if (this.bindingListener === VirtueSky.Events.BindingListener.UNTIL_DISABLE) {
                    this.ToggleListenerEvent(true);
                }
            },
            /*VirtueSky.Events.EventListenerMono.OnEnable end.*/

            /*VirtueSky.Events.EventListenerMono.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventListenerMono#OnDisable", this ); }

                if (this.bindingListener === VirtueSky.Events.BindingListener.UNTIL_DISABLE) {
                    this.ToggleListenerEvent(false);
                }
            },
            /*VirtueSky.Events.EventListenerMono.OnDisable end.*/

            /*VirtueSky.Events.EventListenerMono.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventListenerMono#OnDestroy", this ); }

                if (this.bindingListener === VirtueSky.Events.BindingListener.UNTIL_DESTROY) {
                    this.ToggleListenerEvent(false);
                }
            },
            /*VirtueSky.Events.EventListenerMono.OnDestroy end.*/


        }
    });
    /*VirtueSky.Events.EventListenerMono end.*/

    /*VirtueSky.Events.IEventListener$1 start.*/
    Bridge.definei("VirtueSky.Events.IEventListener$1", function (TType) { return {
        $kind: 3
    }; });
    /*VirtueSky.Events.IEventListener$1 end.*/

    /*VirtueSky.Events.IEventListener$2 start.*/
    Bridge.definei("VirtueSky.Events.IEventListener$2", function (TType, TResult) { return {
        $kind: 3
    }; });
    /*VirtueSky.Events.IEventListener$2 end.*/

    /*VirtueSky.Events.IEventResponse start.*/
    Bridge.define("VirtueSky.Events.IEventResponse", {
        $kind: 3
    });
    /*VirtueSky.Events.IEventResponse end.*/

    /*VirtueSky.Events.BindingListener start.*/
    Bridge.define("VirtueSky.Events.BindingListener", {
        $kind: 6,
        statics: {
            fields: {
                UNTIL_DISABLE: 0,
                UNTIL_DESTROY: 1
            }
        }
    });
    /*VirtueSky.Events.BindingListener end.*/

    /*VirtueSky.Misc.Common start.*/
    Bridge.define("VirtueSky.Misc.Common", {
        statics: {
            fields: {
                internetConnectionCoroutine: null
            },
            methods: {
                /*VirtueSky.Misc.Common.Format:static start.*/
                Format: function (fmt, args) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#Format", this ); }

                    if (args === void 0) { args = []; }
                    return System.String.formatProvider.apply(System.String, [System.Globalization.CultureInfo.invariantCulture.numberFormat, fmt].concat(args));
                },
                /*VirtueSky.Misc.Common.Format:static end.*/

                /*VirtueSky.Misc.Common.IsInteger:static start.*/
                IsInteger: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#IsInteger", this ); }

                    return (value === Bridge.Int.clip32(value));
                },
                /*VirtueSky.Misc.Common.IsInteger:static end.*/

                /*VirtueSky.Misc.Common.GetNumberInAString:static start.*/
                GetNumberInAString: function (str) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetNumberInAString", this ); }

                    try {
                        var getNumb = System.Text.RegularExpressions.Regex.match(str, "\\d+").getValue();
                        return System.Int32.parse(getNumb);
                    } catch (e) {
                        e = System.Exception.create(e);
                        return -1;
                    }

                },
                /*VirtueSky.Misc.Common.GetNumberInAString:static end.*/

                /*VirtueSky.Misc.Common.GetScreenRatio:static start.*/
                GetScreenRatio: function () {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetScreenRatio", this ); }

                    return (1.77777779) / (UnityEngine.Screen.height / UnityEngine.Screen.width);
                },
                /*VirtueSky.Misc.Common.GetScreenRatio:static end.*/

                /*VirtueSky.Misc.Common.CallActionAndClean:static start.*/
                CallActionAndClean: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#CallActionAndClean", this ); }

                    if (Bridge.staticEquals(action.v, null)) {
                        return;
                    }
                    var a = action.v;
                    a();
                    action.v = null;
                },
                /*VirtueSky.Misc.Common.CallActionAndClean:static end.*/

                /*VirtueSky.Misc.Common.CallActionAndClean$1:static start.*/
                CallActionAndClean$1: function (T, action, _value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#CallActionAndClean$1", this ); }

                    if (Bridge.staticEquals(action.v, null)) {
                        return;
                    }
                    var a = action.v;
                    a(Bridge.rValue(_value));
                    action.v = null;
                },
                /*VirtueSky.Misc.Common.CallActionAndClean$1:static end.*/

                /*VirtueSky.Misc.Common.StopCheckInternetConnection:static start.*/
                StopCheckInternetConnection: function () {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#StopCheckInternetConnection", this ); }

                    VirtueSky.Core.App.StopCoroutine(VirtueSky.Misc.Common.internetConnectionCoroutine);
                },
                /*VirtueSky.Misc.Common.StopCheckInternetConnection:static end.*/

                /*VirtueSky.Misc.Common.CheckInternetConnection:static start.*/
                CheckInternetConnection: function (actionConnected, actionDisconnected) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#CheckInternetConnection", this ); }

                    if (VirtueSky.Misc.Common.internetConnectionCoroutine != null) {
                        VirtueSky.Core.App.StopCoroutine(VirtueSky.Misc.Common.internetConnectionCoroutine);
                    }
                    VirtueSky.Misc.Common.internetConnectionCoroutine = VirtueSky.Misc.Common.InternetConnection(function (isConnected) {
                        if (isConnected) {
                            !Bridge.staticEquals(actionConnected, null) ? actionConnected() : null;
                        } else {
                            !Bridge.staticEquals(actionDisconnected, null) ? actionDisconnected() : null;
                        }
                    });
                    VirtueSky.Core.App.StartCoroutine(VirtueSky.Misc.Common.internetConnectionCoroutine);
                },
                /*VirtueSky.Misc.Common.CheckInternetConnection:static end.*/

                /*VirtueSky.Misc.Common.InternetConnection:static start.*/
                InternetConnection: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#InternetConnection", this ); }

                    var $step = 0,
                        $jumpFromFinally,
                        $returnValue,
                        result,
                        url,
                        request,
                        $async_e,
                        $async_e1;

                    var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                        try {
                            for (;;) {
                                switch ($step) {
                                    case 0: {
                                        url = "https://google.com";

                                            request = UnityEngine.Networking.UnityWebRequest.Head(url);
                                        $step = 1;
                                        continue;
                                    }
                                    case 1: {
                                        $enumerator.current = request.SendWebRequest();
                                            $step = 2;
                                            return true;
                                    }
                                    case 2: {
                                        result = !request.isNetworkError && !request.isHttpError && request.responseCode.equals(System.Int64(200)) && request.error == null;
                                        $step = 3;
                                        continue;
                                    }
                                    case 3: {
                                        if (Bridge.hasValue(request)) request.System$IDisposable$Dispose();

                                            if ($jumpFromFinally > -1) {
                                                $step = $jumpFromFinally;
                                                $jumpFromFinally = null;
                                            } else if ($async_e) {
                                                throw $async_e;
                                                return;
                                            } else if (Bridge.isDefined($returnValue)) {
                                                $tcs.setResult($returnValue);
                                                return;
                                            }
                                        $step = 4;
                                        continue;
                                    }
                                    case 4: {
                                        action(result);
                                            VirtueSky.Misc.Common.internetConnectionCoroutine = null;

                                    }
                                    default: {
                                        return false;
                                    }
                                }
                            }
                        } catch($async_e1) {
                            $async_e = System.Exception.create($async_e1);
                            if ($step >= 1 && $step <= 2){

                                $step = 3;
                                $enumerator.moveNext();
                                return;
                            }
                            throw $async_e;
                        }
                    }), function () {
                        if ($step >= 1 && $step <= 2){

                            $step = 3;
                            $enumerator.moveNext();
                            return;
                        }

                    });
                    return $enumerator;
                },
                /*VirtueSky.Misc.Common.InternetConnection:static end.*/

                /*VirtueSky.Misc.Common.Delay:static start.*/
                /**
                 * Attach a DelayHandle on to the behaviour. If the behaviour is destroyed before the DelayHandle is completed,
                 e.g. through a scene change, the DelayHandle callback will not execute.
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Misc.Common
                 * @memberof VirtueSky.Misc.Common
                 * @param   {UnityEngine.MonoBehaviour}     target         The behaviour to attach this DelayHandle to.
                 * @param   {number}                        duration       The duration to wait before the DelayHandle fires.
                 * @param   {System.Action}                 onComplete     The action to run when the DelayHandle elapses.
                 * @param   {System.Action}                 onUpdate       A function to call each tick of the DelayHandle. Takes the number of seconds elapsed since
                 the start of the current cycle.
                 * @param   {boolean}                       isLooped       Whether the DelayHandle should restart after executing.
                 * @param   {boolean}                       useRealTime    Whether the DelayHandle uses real-time(not affected by slow-mo or pausing) or
                 game-time(affected by time scale changes).
                 * @return  {VirtueSky.Core.DelayHandle}
                 */
                Delay: function (target, duration, onComplete, onUpdate, isLooped, useRealTime) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#Delay", this ); }

                    if (onUpdate === void 0) { onUpdate = null; }
                    if (isLooped === void 0) { isLooped = false; }
                    if (useRealTime === void 0) { useRealTime = false; }
                    return VirtueSky.Core.App.Delay$1(target, duration, onComplete, onUpdate, isLooped, useRealTime);
                },
                /*VirtueSky.Misc.Common.Delay:static end.*/

                /*VirtueSky.Misc.Common.SetAlpha:static start.*/
                SetAlpha: function (graphic, a) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetAlpha", this ); }

                    var colorCache = graphic.color.$clone();
                    colorCache.a = a;
                    graphic.color = colorCache.$clone();
                    return graphic;
                },
                /*VirtueSky.Misc.Common.SetAlpha:static end.*/

                /*VirtueSky.Misc.Common.ClearTransform:static start.*/
                ClearTransform: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#ClearTransform", this ); }

                    var childs = transform.childCount;
                    for (var i = (childs - 1) | 0; i >= 0; i = (i - 1) | 0) {
                        UnityEngine.Object.DestroyImmediate$1(transform.GetChild(i).gameObject, true);
                    }

                    return transform;
                },
                /*VirtueSky.Misc.Common.ClearTransform:static end.*/

                /*VirtueSky.Misc.Common.ToWorldPosition:static start.*/
                /**
                 * Convert UI positon to world position
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Misc.Common
                 * @memberof VirtueSky.Misc.Common
                 * @param   {UnityEngine.RectTransform}    transform    transform is transform in canvas space (RectTransfom
                 * @param   {UnityEngine.Camera}           camera
                 * @return  {UnityEngine.Vector2}
                 */
                ToWorldPosition: function (transform, camera) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#ToWorldPosition", this ); }

                    if (camera === void 0) { camera = null; }
                    var cam = camera;
                    if (UnityEngine.Component.op_Equality(cam, null)) {
                        cam = UnityEngine.Camera.main;
                    }
                    if (UnityEngine.Component.op_Equality(cam, null)) {
                        return pc.Vec2.ZERO.clone();
                    }
                    var pos = cam.ViewportToWorldPoint(transform.position.$clone());
                    var worldPosition = cam.WorldToViewportPoint(pos);
                    return UnityEngine.Vector2.FromVector3(worldPosition.$clone());
                },
                /*VirtueSky.Misc.Common.ToWorldPosition:static end.*/

                /*VirtueSky.Misc.Common.SetPosition:static start.*/
                SetPosition: function (transform, v3) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPosition", this ); }

                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPosition:static end.*/

                /*VirtueSky.Misc.Common.SetPositionX:static start.*/
                SetPositionX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionX", this ); }

                    var v3 = transform.position.$clone();
                    v3.x = x;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPositionX:static end.*/

                /*VirtueSky.Misc.Common.SetPositionY:static start.*/
                SetPositionY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionY", this ); }

                    var v3 = transform.position.$clone();
                    v3.y = y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPositionY:static end.*/

                /*VirtueSky.Misc.Common.SetPositionZ:static start.*/
                SetPositionZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionZ", this ); }

                    var v3 = transform.position.$clone();
                    v3.z = z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPositionZ:static end.*/

                /*VirtueSky.Misc.Common.SetPositionXY$2:static start.*/
                SetPositionXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionXY$2", this ); }

                    transform.position = new pc.Vec3( v2.x, v2.y, transform.position.z );
                },
                /*VirtueSky.Misc.Common.SetPositionXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetPositionXY:static start.*/
                SetPositionXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionXY", this ); }

                    transform.position = new pc.Vec3( x, y, transform.position.z );
                },
                /*VirtueSky.Misc.Common.SetPositionXY:static end.*/

                /*VirtueSky.Misc.Common.SetPositionXY$1:static start.*/
                SetPositionXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionXY$1", this ); }

                    var v3 = target.position.$clone();
                    v3.z = transform.position.z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPositionXY$1:static end.*/

                /*VirtueSky.Misc.Common.GetPositionXZ:static start.*/
                GetPositionXZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetPositionXZ", this ); }

                    var v3 = transform.position.$clone();
                    v2.v.x = v3.x;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetPositionXZ:static end.*/

                /*VirtueSky.Misc.Common.GetPositionXZ$1:static start.*/
                GetPositionXZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetPositionXZ$1", this ); }

                    var v3 = transform.position.$clone();
                    return new pc.Vec2( v3.x, v3.z );
                },
                /*VirtueSky.Misc.Common.GetPositionXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetPositionXZ$2:static start.*/
                SetPositionXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionXZ$2", this ); }

                    transform.position = new pc.Vec3( v2.x, transform.position.y, v2.y );
                },
                /*VirtueSky.Misc.Common.SetPositionXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetPositionXZ:static start.*/
                SetPositionXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionXZ", this ); }

                    transform.position = new pc.Vec3( x, transform.position.y, z );
                },
                /*VirtueSky.Misc.Common.SetPositionXZ:static end.*/

                /*VirtueSky.Misc.Common.SetPositionXZ$1:static start.*/
                SetPositionXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionXZ$1", this ); }

                    var v3 = target.position.$clone();
                    v3.y = transform.position.y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPositionXZ$1:static end.*/

                /*VirtueSky.Misc.Common.GetPositionYZ:static start.*/
                GetPositionYZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetPositionYZ", this ); }

                    var v3 = transform.position.$clone();
                    v2.v.x = v3.y;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetPositionYZ:static end.*/

                /*VirtueSky.Misc.Common.GetPositionYZ$1:static start.*/
                GetPositionYZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetPositionYZ$1", this ); }

                    var v3 = transform.position.$clone();
                    return new pc.Vec2( v3.y, v3.z );
                },
                /*VirtueSky.Misc.Common.GetPositionYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetPositionYZ$2:static start.*/
                SetPositionYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionYZ$2", this ); }

                    transform.position = new pc.Vec3( transform.position.x, v2.x, v2.y );
                },
                /*VirtueSky.Misc.Common.SetPositionYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetPositionYZ:static start.*/
                SetPositionYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionYZ", this ); }

                    transform.position = new pc.Vec3( transform.position.x, y, z );
                },
                /*VirtueSky.Misc.Common.SetPositionYZ:static end.*/

                /*VirtueSky.Misc.Common.SetPositionYZ$1:static start.*/
                SetPositionYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetPositionYZ$1", this ); }

                    var v3 = target.position.$clone();
                    v3.x = transform.position.x;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetPositionYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePosition:static start.*/
                SetRelativePosition: function (transform, v3) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePosition", this ); }

                    transform.position = transform.position.$clone().add( v3.$clone() );
                },
                /*VirtueSky.Misc.Common.SetRelativePosition:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionX:static start.*/
                SetRelativePositionX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionX", this ); }

                    var v3 = transform.position.$clone();
                    v3.x += x;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionX:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionY:static start.*/
                SetRelativePositionY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionY", this ); }

                    var v3 = transform.position.$clone();
                    v3.y += y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionZ:static start.*/
                SetRelativePositionZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionZ", this ); }

                    var v3 = transform.position.$clone();
                    v3.z += z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionXY$2:static start.*/
                SetRelativePositionXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionXY$2", this ); }

                    var v3 = transform.position.$clone();
                    v3.x += v2.x;
                    v3.y += v2.y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionXY:static start.*/
                SetRelativePositionXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionXY", this ); }

                    var v3 = transform.position.$clone();
                    v3.x += x;
                    v3.y += y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionXY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionXY$1:static start.*/
                SetRelativePositionXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionXY$1", this ); }

                    var v3 = transform.position.$clone();
                    var targetV3 = target.position.$clone();
                    v3.x += targetV3.x;
                    v3.y += targetV3.y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionXY$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionXZ$2:static start.*/
                SetRelativePositionXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionXZ$2", this ); }

                    var v3 = transform.position.$clone();
                    v3.x += v2.x;
                    v3.z += v2.y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionXZ:static start.*/
                SetRelativePositionXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionXZ", this ); }

                    var v3 = transform.position.$clone();
                    v3.x += x;
                    v3.z += z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionXZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionXZ$1:static start.*/
                SetRelativePositionXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionXZ$1", this ); }

                    var v3 = transform.position.$clone();
                    var targetV3 = target.position.$clone();
                    v3.x += targetV3.x;
                    v3.z += targetV3.z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionYZ$2:static start.*/
                SetRelativePositionYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionYZ$2", this ); }

                    var v3 = transform.position.$clone();
                    v3.y += v2.x;
                    v3.z += v2.y;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionYZ:static start.*/
                SetRelativePositionYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionYZ", this ); }

                    var v3 = transform.position.$clone();
                    v3.y += y;
                    v3.z += z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionYZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativePositionYZ$1:static start.*/
                SetRelativePositionYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativePositionYZ$1", this ); }

                    var v3 = transform.position.$clone();
                    var targetV3 = target.position.$clone();
                    v3.y += targetV3.y;
                    v3.z += targetV3.z;
                    transform.position = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativePositionYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionX:static start.*/
                SetLocalPositionX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionX", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.x = x;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalPositionX:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionY:static start.*/
                SetLocalPositionY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionY", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.y = y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalPositionY:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionZ:static start.*/
                SetLocalPositionZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionZ", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.z = z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalPositionZ:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionXY$2:static start.*/
                SetLocalPositionXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionXY$2", this ); }

                    transform.localPosition = new pc.Vec3( v2.x, v2.y, transform.localPosition.z );
                },
                /*VirtueSky.Misc.Common.SetLocalPositionXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionXY:static start.*/
                SetLocalPositionXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionXY", this ); }

                    transform.localPosition = new pc.Vec3( x, y, transform.localPosition.z );
                },
                /*VirtueSky.Misc.Common.SetLocalPositionXY:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionXY$1:static start.*/
                SetLocalPositionXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionXY$1", this ); }

                    var v3 = target.localPosition.$clone();
                    v3.z = transform.localPosition.z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalPositionXY$1:static end.*/

                /*VirtueSky.Misc.Common.GetLocalPositionXZ:static start.*/
                GetLocalPositionXZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalPositionXZ", this ); }

                    var v3 = transform.localPosition.$clone();
                    v2.v.x = v3.x;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetLocalPositionXZ:static end.*/

                /*VirtueSky.Misc.Common.GetLocalPositionXZ$1:static start.*/
                GetLocalPositionXZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalPositionXZ$1", this ); }

                    var v3 = transform.localPosition.$clone();
                    return new pc.Vec2( v3.x, v3.z );
                },
                /*VirtueSky.Misc.Common.GetLocalPositionXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionXZ$2:static start.*/
                SetLocalPositionXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionXZ$2", this ); }

                    transform.localPosition = new pc.Vec3( v2.x, transform.localPosition.y, v2.y );
                },
                /*VirtueSky.Misc.Common.SetLocalPositionXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionXZ:static start.*/
                SetLocalPositionXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionXZ", this ); }

                    transform.localPosition = new pc.Vec3( x, transform.localPosition.y, z );
                },
                /*VirtueSky.Misc.Common.SetLocalPositionXZ:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionXZ$1:static start.*/
                SetLocalPositionXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionXZ$1", this ); }

                    var v3 = target.localPosition.$clone();
                    v3.y = transform.localPosition.y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalPositionXZ$1:static end.*/

                /*VirtueSky.Misc.Common.GetLocalPositionYZ:static start.*/
                GetLocalPositionYZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalPositionYZ", this ); }

                    var v3 = transform.localPosition.$clone();
                    v2.v.x = v3.y;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetLocalPositionYZ:static end.*/

                /*VirtueSky.Misc.Common.GetLocalPositionYZ$1:static start.*/
                GetLocalPositionYZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalPositionYZ$1", this ); }

                    var v3 = transform.localPosition.$clone();
                    return new pc.Vec2( v3.y, v3.z );
                },
                /*VirtueSky.Misc.Common.GetLocalPositionYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionYZ$2:static start.*/
                SetLocalPositionYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionYZ$2", this ); }

                    transform.localPosition = new pc.Vec3( transform.localPosition.x, v2.x, v2.y );
                },
                /*VirtueSky.Misc.Common.SetLocalPositionYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionYZ:static start.*/
                SetLocalPositionYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionYZ", this ); }

                    transform.localPosition = new pc.Vec3( transform.localPosition.x, y, z );
                },
                /*VirtueSky.Misc.Common.SetLocalPositionYZ:static end.*/

                /*VirtueSky.Misc.Common.SetLocalPositionYZ$1:static start.*/
                SetLocalPositionYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalPositionYZ$1", this ); }

                    var v3 = target.localPosition.$clone();
                    v3.x = transform.localPosition.x;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalPositionYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionX:static start.*/
                SetRelativeLocalPositionX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionX", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.x += x;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionX:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionY:static start.*/
                SetRelativeLocalPositionY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionY", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.y += y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionZ:static start.*/
                SetRelativeLocalPositionZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionZ", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.z += z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXY$2:static start.*/
                SetRelativeLocalPositionXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionXY$2", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.x += v2.x;
                    v3.y += v2.y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXY:static start.*/
                SetRelativeLocalPositionXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionXY", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.x += x;
                    v3.y += y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXY$1:static start.*/
                SetRelativeLocalPositionXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionXY$1", this ); }

                    var v3 = transform.localPosition.$clone();
                    var targetV3 = target.localPosition.$clone();
                    v3.x += targetV3.x;
                    v3.y += targetV3.y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXY$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXZ$2:static start.*/
                SetRelativeLocalPositionXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionXZ$2", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.x += v2.x;
                    v3.z += v2.y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXZ:static start.*/
                SetRelativeLocalPositionXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionXZ", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.x += x;
                    v3.z += z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXZ$1:static start.*/
                SetRelativeLocalPositionXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionXZ$1", this ); }

                    var v3 = transform.localPosition.$clone();
                    var targetV3 = target.localPosition.$clone();
                    v3.x += targetV3.x;
                    v3.z += targetV3.z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionYZ$2:static start.*/
                SetRelativeLocalPositionYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionYZ$2", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.y += v2.x;
                    v3.z += v2.y;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionYZ:static start.*/
                SetRelativeLocalPositionYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionYZ", this ); }

                    var v3 = transform.localPosition.$clone();
                    v3.y += y;
                    v3.z += z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionYZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalPositionYZ$1:static start.*/
                SetRelativeLocalPositionYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalPositionYZ$1", this ); }

                    var v3 = transform.localPosition.$clone();
                    var targetV3 = target.localPosition.$clone();
                    v3.y += targetV3.y;
                    v3.z += targetV3.z;
                    transform.localPosition = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalPositionYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetScaleX:static start.*/
                SetScaleX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleX", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x = x;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetScaleX:static end.*/

                /*VirtueSky.Misc.Common.SetScaleY:static start.*/
                SetScaleY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleY", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.y = y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetScaleY:static end.*/

                /*VirtueSky.Misc.Common.SetScaleZ:static start.*/
                SetScaleZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleZ", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.z = z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetScaleZ:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXY$3:static start.*/
                SetScaleXY$3: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXY$3", this ); }

                    transform.localScale = new pc.Vec3( v2.x, v2.y, transform.localScale.z );
                },
                /*VirtueSky.Misc.Common.SetScaleXY$3:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXY$1:static start.*/
                SetScaleXY$1: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXY$1", this ); }

                    transform.localScale = new pc.Vec3( x, y, transform.localScale.z );
                },
                /*VirtueSky.Misc.Common.SetScaleXY$1:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXY:static start.*/
                SetScaleXY: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXY", this ); }

                    transform.localScale = new pc.Vec3( value, value, transform.localScale.z );
                },
                /*VirtueSky.Misc.Common.SetScaleXY:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXY$2:static start.*/
                SetScaleXY$2: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXY$2", this ); }

                    var v3 = target.localScale.$clone();
                    v3.z = transform.localScale.z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetScaleXY$2:static end.*/

                /*VirtueSky.Misc.Common.GetScaleXZ:static start.*/
                GetScaleXZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetScaleXZ", this ); }

                    var v3 = transform.localScale.$clone();
                    v2.v.x = v3.x;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetScaleXZ:static end.*/

                /*VirtueSky.Misc.Common.GetScaleXZ$1:static start.*/
                GetScaleXZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetScaleXZ$1", this ); }

                    var v3 = transform.localScale.$clone();
                    return new pc.Vec2( v3.x, v3.z );
                },
                /*VirtueSky.Misc.Common.GetScaleXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXZ$3:static start.*/
                SetScaleXZ$3: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXZ$3", this ); }

                    transform.localScale = new pc.Vec3( v2.x, transform.localScale.y, v2.y );
                },
                /*VirtueSky.Misc.Common.SetScaleXZ$3:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXZ$1:static start.*/
                SetScaleXZ$1: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXZ$1", this ); }

                    transform.localScale = new pc.Vec3( x, transform.localScale.y, z );
                },
                /*VirtueSky.Misc.Common.SetScaleXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXZ:static start.*/
                SetScaleXZ: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXZ", this ); }

                    transform.localScale = new pc.Vec3( value, transform.localScale.y, value );
                },
                /*VirtueSky.Misc.Common.SetScaleXZ:static end.*/

                /*VirtueSky.Misc.Common.SetScaleXZ$2:static start.*/
                SetScaleXZ$2: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleXZ$2", this ); }

                    var v3 = target.localScale.$clone();
                    v3.y = transform.localScale.y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetScaleXZ$2:static end.*/

                /*VirtueSky.Misc.Common.GetScaleYZ:static start.*/
                GetScaleYZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetScaleYZ", this ); }

                    var v3 = transform.localScale.$clone();
                    v2.v.x = v3.y;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetScaleYZ:static end.*/

                /*VirtueSky.Misc.Common.GetScaleYZ$1:static start.*/
                GetScaleYZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetScaleYZ$1", this ); }

                    var v3 = transform.localScale.$clone();
                    return new pc.Vec2( v3.y, v3.z );
                },
                /*VirtueSky.Misc.Common.GetScaleYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetScaleYZ$3:static start.*/
                SetScaleYZ$3: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleYZ$3", this ); }

                    transform.localScale = new pc.Vec3( transform.localScale.x, v2.x, v2.y );
                },
                /*VirtueSky.Misc.Common.SetScaleYZ$3:static end.*/

                /*VirtueSky.Misc.Common.SetScaleYZ$1:static start.*/
                SetScaleYZ$1: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleYZ$1", this ); }

                    transform.localScale = new pc.Vec3( transform.localScale.x, y, z );
                },
                /*VirtueSky.Misc.Common.SetScaleYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetScaleYZ:static start.*/
                SetScaleYZ: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleYZ", this ); }

                    transform.localScale = new pc.Vec3( transform.localScale.x, value, value );
                },
                /*VirtueSky.Misc.Common.SetScaleYZ:static end.*/

                /*VirtueSky.Misc.Common.SetScaleYZ$2:static start.*/
                SetScaleYZ$2: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScaleYZ$2", this ); }

                    var v3 = target.localScale.$clone();
                    v3.x = transform.localScale.x;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetScaleYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetScale:static start.*/
                SetScale: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetScale", this ); }

                    transform.localScale = new pc.Vec3( value, value, value );
                },
                /*VirtueSky.Misc.Common.SetScale:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleX:static start.*/
                SetRelativeScaleX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleX", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += x;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleX:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleY:static start.*/
                SetRelativeScaleY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleY", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.y += y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleZ:static start.*/
                SetRelativeScaleZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleZ", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.z += z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXY$3:static start.*/
                SetRelativeScaleXY$3: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXY$3", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += v2.x;
                    v3.y += v2.y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXY$3:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXY$1:static start.*/
                SetRelativeScaleXY$1: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXY$1", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += x;
                    v3.y += y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXY$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXY:static start.*/
                SetRelativeScaleXY: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXY", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += value;
                    v3.y += value;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXY$2:static start.*/
                SetRelativeScaleXY$2: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXY$2", this ); }

                    var v3 = transform.localScale.$clone();
                    var targetV3 = target.localScale.$clone();
                    v3.x += targetV3.x;
                    v3.y += targetV3.y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXZ$3:static start.*/
                SetRelativeScaleXZ$3: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXZ$3", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += v2.x;
                    v3.z += v2.y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXZ$3:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXZ$1:static start.*/
                SetRelativeScaleXZ$1: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXZ$1", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += x;
                    v3.z += z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXZ:static start.*/
                SetRelativeScaleXZ: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXZ", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.x += value;
                    v3.z += value;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleXZ$2:static start.*/
                SetRelativeScaleXZ$2: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleXZ$2", this ); }

                    var v3 = transform.localScale.$clone();
                    var targetV3 = target.localScale.$clone();
                    v3.x += targetV3.x;
                    v3.z += targetV3.z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleYZ$3:static start.*/
                SetRelativeScaleYZ$3: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleYZ$3", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.y += v2.x;
                    v3.z += v2.y;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleYZ$3:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleYZ$1:static start.*/
                SetRelativeScaleYZ$1: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleYZ$1", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.y += y;
                    v3.z += z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleYZ:static start.*/
                SetRelativeScaleYZ: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleYZ", this ); }

                    var v3 = transform.localScale.$clone();
                    v3.y += value;
                    v3.z += value;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleYZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScaleYZ$2:static start.*/
                SetRelativeScaleYZ$2: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScaleYZ$2", this ); }

                    var v3 = transform.localScale.$clone();
                    var targetV3 = target.localScale.$clone();
                    v3.y += targetV3.y;
                    v3.z += targetV3.z;
                    transform.localScale = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeScaleYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeScale:static start.*/
                SetRelativeScale: function (transform, value) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeScale", this ); }

                    transform.localScale = transform.localScale.$clone().add( new pc.Vec3( value, value, value ) );
                },
                /*VirtueSky.Misc.Common.SetRelativeScale:static end.*/

                /*VirtueSky.Misc.Common.SetRotationX:static start.*/
                SetRotationX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationX", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.x = x;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRotationX:static end.*/

                /*VirtueSky.Misc.Common.SetRotationY:static start.*/
                SetRotationY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationY", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.y = y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRotationY:static end.*/

                /*VirtueSky.Misc.Common.SetRotationZ:static start.*/
                SetRotationZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationZ", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.z = z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRotationZ:static end.*/

                /*VirtueSky.Misc.Common.SetRotationXY$2:static start.*/
                SetRotationXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationXY$2", this ); }

                    transform.eulerAngles = new pc.Vec3( v2.x, v2.y, transform.eulerAngles.z );
                },
                /*VirtueSky.Misc.Common.SetRotationXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetRotationXY:static start.*/
                SetRotationXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationXY", this ); }

                    transform.eulerAngles = new pc.Vec3( x, y, transform.eulerAngles.z );
                },
                /*VirtueSky.Misc.Common.SetRotationXY:static end.*/

                /*VirtueSky.Misc.Common.SetRotationXY$1:static start.*/
                SetRotationXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationXY$1", this ); }

                    var v3 = target.eulerAngles.$clone();
                    v3.z = transform.eulerAngles.z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRotationXY$1:static end.*/

                /*VirtueSky.Misc.Common.GetRotationXZ:static start.*/
                GetRotationXZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetRotationXZ", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v2.v.x = v3.x;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetRotationXZ:static end.*/

                /*VirtueSky.Misc.Common.GetRotationXZ$1:static start.*/
                GetRotationXZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetRotationXZ$1", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    return new pc.Vec2( v3.x, v3.z );
                },
                /*VirtueSky.Misc.Common.GetRotationXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRotationXZ$2:static start.*/
                SetRotationXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationXZ$2", this ); }

                    transform.eulerAngles = new pc.Vec3( v2.x, transform.eulerAngles.y, v2.y );
                },
                /*VirtueSky.Misc.Common.SetRotationXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRotationXZ:static start.*/
                SetRotationXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationXZ", this ); }

                    transform.eulerAngles = new pc.Vec3( x, transform.eulerAngles.y, z );
                },
                /*VirtueSky.Misc.Common.SetRotationXZ:static end.*/

                /*VirtueSky.Misc.Common.SetRotationXZ$1:static start.*/
                SetRotationXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationXZ$1", this ); }

                    var v3 = target.eulerAngles.$clone();
                    v3.y = transform.eulerAngles.y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRotationXZ$1:static end.*/

                /*VirtueSky.Misc.Common.GetRotationYZ:static start.*/
                GetRotationYZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetRotationYZ", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v2.v.x = v3.y;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetRotationYZ:static end.*/

                /*VirtueSky.Misc.Common.GetRotationYZ$1:static start.*/
                GetRotationYZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetRotationYZ$1", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    return new pc.Vec2( v3.y, v3.z );
                },
                /*VirtueSky.Misc.Common.GetRotationYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRotationYZ$2:static start.*/
                SetRotationYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationYZ$2", this ); }

                    transform.eulerAngles = new pc.Vec3( transform.eulerAngles.x, v2.x, v2.y );
                },
                /*VirtueSky.Misc.Common.SetRotationYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRotationYZ:static start.*/
                SetRotationYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationYZ", this ); }

                    transform.eulerAngles = new pc.Vec3( transform.eulerAngles.x, y, z );
                },
                /*VirtueSky.Misc.Common.SetRotationYZ:static end.*/

                /*VirtueSky.Misc.Common.SetRotationYZ$1:static start.*/
                SetRotationYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRotationYZ$1", this ); }

                    var v3 = target.eulerAngles.$clone();
                    v3.x = transform.eulerAngles.x;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRotationYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationX:static start.*/
                SetRelativeRotationX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationX", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.x += x;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationX:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationY:static start.*/
                SetRelativeRotationY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationY", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.y += y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationZ:static start.*/
                SetRelativeRotationZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationZ", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.z += z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationXY$2:static start.*/
                SetRelativeRotationXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationXY$2", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.x += v2.x;
                    v3.y += v2.y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationXY:static start.*/
                SetRelativeRotationXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationXY", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.x += x;
                    v3.y += y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationXY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationXY$1:static start.*/
                SetRelativeRotationXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationXY$1", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    var targetV3 = target.eulerAngles.$clone();
                    v3.x += targetV3.x;
                    v3.y += targetV3.y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationXY$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationXZ$2:static start.*/
                SetRelativeRotationXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationXZ$2", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.x += v2.x;
                    v3.z += v2.y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationXZ:static start.*/
                SetRelativeRotationXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationXZ", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.x += x;
                    v3.z += z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationXZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationXZ$1:static start.*/
                SetRelativeRotationXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationXZ$1", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    var targetV3 = target.eulerAngles.$clone();
                    v3.x += targetV3.x;
                    v3.z += targetV3.z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationYZ$2:static start.*/
                SetRelativeRotationYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationYZ$2", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.y += v2.x;
                    v3.z += v2.y;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationYZ:static start.*/
                SetRelativeRotationYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationYZ", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    v3.y += y;
                    v3.z += z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationYZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeRotationYZ$1:static start.*/
                SetRelativeRotationYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeRotationYZ$1", this ); }

                    var v3 = transform.eulerAngles.$clone();
                    var targetV3 = target.eulerAngles.$clone();
                    v3.y += targetV3.y;
                    v3.z += targetV3.z;
                    transform.eulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeRotationYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationX:static start.*/
                SetLocalRotationX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationX", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.x = x;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalRotationX:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationY:static start.*/
                SetLocalRotationY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationY", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.y = y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalRotationY:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationZ:static start.*/
                SetLocalRotationZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationZ", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.z = z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalRotationZ:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationXY$2:static start.*/
                SetLocalRotationXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationXY$2", this ); }

                    transform.localEulerAngles = new pc.Vec3( v2.x, v2.y, transform.localEulerAngles.z );
                },
                /*VirtueSky.Misc.Common.SetLocalRotationXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationXY:static start.*/
                SetLocalRotationXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationXY", this ); }

                    transform.localEulerAngles = new pc.Vec3( x, y, transform.localEulerAngles.z );
                },
                /*VirtueSky.Misc.Common.SetLocalRotationXY:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationXY$1:static start.*/
                SetLocalRotationXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationXY$1", this ); }

                    var v3 = target.localEulerAngles.$clone();
                    v3.z = transform.localEulerAngles.z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalRotationXY$1:static end.*/

                /*VirtueSky.Misc.Common.GetLocalRotationXZ:static start.*/
                GetLocalRotationXZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalRotationXZ", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v2.v.x = v3.x;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetLocalRotationXZ:static end.*/

                /*VirtueSky.Misc.Common.GetLocalRotationXZ$1:static start.*/
                GetLocalRotationXZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalRotationXZ$1", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    return new pc.Vec2( v3.x, v3.z );
                },
                /*VirtueSky.Misc.Common.GetLocalRotationXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationXZ$2:static start.*/
                SetLocalRotationXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationXZ$2", this ); }

                    transform.localEulerAngles = new pc.Vec3( v2.x, transform.localEulerAngles.y, v2.y );
                },
                /*VirtueSky.Misc.Common.SetLocalRotationXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationXZ:static start.*/
                SetLocalRotationXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationXZ", this ); }

                    transform.localEulerAngles = new pc.Vec3( x, transform.localEulerAngles.y, z );
                },
                /*VirtueSky.Misc.Common.SetLocalRotationXZ:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationXZ$1:static start.*/
                SetLocalRotationXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationXZ$1", this ); }

                    var v3 = target.localEulerAngles.$clone();
                    v3.y = transform.localEulerAngles.y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalRotationXZ$1:static end.*/

                /*VirtueSky.Misc.Common.GetLocalRotationYZ:static start.*/
                GetLocalRotationYZ: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalRotationYZ", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v2.v.x = v3.y;
                    v2.v.y = v3.z;
                },
                /*VirtueSky.Misc.Common.GetLocalRotationYZ:static end.*/

                /*VirtueSky.Misc.Common.GetLocalRotationYZ$1:static start.*/
                GetLocalRotationYZ$1: function (transform) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#GetLocalRotationYZ$1", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    return new pc.Vec2( v3.y, v3.z );
                },
                /*VirtueSky.Misc.Common.GetLocalRotationYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationYZ$2:static start.*/
                SetLocalRotationYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationYZ$2", this ); }

                    transform.localEulerAngles = new pc.Vec3( transform.localEulerAngles.x, v2.x, v2.y );
                },
                /*VirtueSky.Misc.Common.SetLocalRotationYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationYZ:static start.*/
                SetLocalRotationYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationYZ", this ); }

                    transform.localEulerAngles = new pc.Vec3( transform.localEulerAngles.x, y, z );
                },
                /*VirtueSky.Misc.Common.SetLocalRotationYZ:static end.*/

                /*VirtueSky.Misc.Common.SetLocalRotationYZ$1:static start.*/
                SetLocalRotationYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetLocalRotationYZ$1", this ); }

                    var v3 = target.localEulerAngles.$clone();
                    v3.x = transform.localEulerAngles.x;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetLocalRotationYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationX:static start.*/
                SetRelativeLocalRotationX: function (transform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationX", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.x += x;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationX:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationY:static start.*/
                SetRelativeLocalRotationY: function (transform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationY", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.y += y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationZ:static start.*/
                SetRelativeLocalRotationZ: function (transform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationZ", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.z += z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXY$2:static start.*/
                SetRelativeLocalRotationXY$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationXY$2", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.x += v2.x;
                    v3.y += v2.y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXY$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXY:static start.*/
                SetRelativeLocalRotationXY: function (transform, x, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationXY", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.x += x;
                    v3.y += y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXY$1:static start.*/
                SetRelativeLocalRotationXY$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationXY$1", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    var targetV3 = target.localEulerAngles.$clone();
                    v3.x += targetV3.x;
                    v3.y += targetV3.y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXY$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXZ$2:static start.*/
                SetRelativeLocalRotationXZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationXZ$2", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.x += v2.x;
                    v3.z += v2.y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXZ:static start.*/
                SetRelativeLocalRotationXZ: function (transform, x, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationXZ", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.x += x;
                    v3.z += z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXZ$1:static start.*/
                SetRelativeLocalRotationXZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationXZ$1", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    var targetV3 = target.localEulerAngles.$clone();
                    v3.x += targetV3.x;
                    v3.z += targetV3.z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationXZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationYZ$2:static start.*/
                SetRelativeLocalRotationYZ$2: function (transform, v2) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationYZ$2", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.y += v2.x;
                    v3.z += v2.y;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationYZ$2:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationYZ:static start.*/
                SetRelativeLocalRotationYZ: function (transform, y, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationYZ", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    v3.y += y;
                    v3.z += z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationYZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeLocalRotationYZ$1:static start.*/
                SetRelativeLocalRotationYZ$1: function (transform, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeLocalRotationYZ$1", this ); }

                    var v3 = transform.localEulerAngles.$clone();
                    var targetV3 = target.localEulerAngles.$clone();
                    v3.y += targetV3.y;
                    v3.z += targetV3.z;
                    transform.localEulerAngles = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeLocalRotationYZ$1:static end.*/

                /*VirtueSky.Misc.Common.SetAnchoredPositionX:static start.*/
                SetAnchoredPositionX: function (rectTransform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetAnchoredPositionX", this ); }

                    var v2 = rectTransform.anchoredPosition.$clone();
                    v2.x = x;
                    rectTransform.anchoredPosition = v2.$clone();
                },
                /*VirtueSky.Misc.Common.SetAnchoredPositionX:static end.*/

                /*VirtueSky.Misc.Common.SetAnchoredPositionY:static start.*/
                SetAnchoredPositionY: function (rectTransform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetAnchoredPositionY", this ); }

                    var v2 = rectTransform.anchoredPosition.$clone();
                    v2.y = y;
                    rectTransform.anchoredPosition = v2.$clone();
                },
                /*VirtueSky.Misc.Common.SetAnchoredPositionY:static end.*/

                /*VirtueSky.Misc.Common.SetAnchoredPositionZ:static start.*/
                SetAnchoredPositionZ: function (rectTransform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetAnchoredPositionZ", this ); }

                    var v3 = rectTransform.anchoredPosition3D.$clone();
                    v3.z = z;
                    rectTransform.anchoredPosition3D = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetAnchoredPositionZ:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeAnchoredPositionX:static start.*/
                SetRelativeAnchoredPositionX: function (rectTransform, x) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeAnchoredPositionX", this ); }

                    var v2 = rectTransform.anchoredPosition.$clone();
                    v2.x += x;
                    rectTransform.anchoredPosition = v2.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeAnchoredPositionX:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeAnchoredPositionY:static start.*/
                SetRelativeAnchoredPositionY: function (rectTransform, y) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeAnchoredPositionY", this ); }

                    var v2 = rectTransform.anchoredPosition.$clone();
                    v2.y += y;
                    rectTransform.anchoredPosition = v2.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeAnchoredPositionY:static end.*/

                /*VirtueSky.Misc.Common.SetRelativeAnchoredPositionZ:static start.*/
                SetRelativeAnchoredPositionZ: function (rectTransform, z) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.Common#SetRelativeAnchoredPositionZ", this ); }

                    var v3 = rectTransform.anchoredPosition3D.$clone();
                    v3.z += z;
                    rectTransform.anchoredPosition3D = v3.$clone();
                },
                /*VirtueSky.Misc.Common.SetRelativeAnchoredPositionZ:static end.*/


            }
        }
    });
    /*VirtueSky.Misc.Common end.*/

    /*VirtueSky.Misc.SkeletonGraphicExtensions start.*/
    Bridge.define("VirtueSky.Misc.SkeletonGraphicExtensions", {
        statics: {
            methods: {
                /*VirtueSky.Misc.SkeletonGraphicExtensions.Duration$1:static start.*/
                Duration$1: function (skeletonGraphic, animationName) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#Duration$1", this ); }

                    var $t;
                    var animation = null;
                    $t = Bridge.getEnumerator(skeletonGraphic.AnimationState.data.skeletonData.Animations.Items);
                    try {
                        while ($t.moveNext()) {
                            var animationsItem = $t.Current;
                            if (System.String.equals(animationsItem.name, animationName)) {
                                animation = animationsItem;
                                break;
                            }
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    if (animation == null) {
                        return 0;
                    }
                    return animation.duration;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.Duration$1:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.Duration:static start.*/
                Duration: function (skeletonGraphic, track) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#Duration", this ); }

                    if (track === void 0) { track = 0; }
                    var animation = skeletonGraphic.AnimationState.getCurrent(track);
                    if (animation == null) {
                        return 0;
                    }
                    return animation.animation.duration;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.Duration:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.OnComplete:static start.*/
                OnComplete: function (skeletonGraphic, onComplete, trackIndex, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#OnComplete", this ); }

                    if (trackIndex === void 0) { trackIndex = 0; }
                    if (target === void 0) { target = null; }
                    VirtueSky.Core.App.Delay$1(UnityEngine.MonoBehaviour.op_Inequality(target, null) ? target : skeletonGraphic, VirtueSky.Misc.SkeletonGraphicExtensions.Duration(skeletonGraphic, trackIndex), function () {
                        if (UnityEngine.MonoBehaviour.op_Inequality(skeletonGraphic, null)) {
                            !Bridge.staticEquals(onComplete, null) ? onComplete() : null;
                        }
                    });
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.OnComplete:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.OnUpdate:static start.*/
                OnUpdate: function (skeletonGraphic, onUpdate, trackIndex, target) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#OnUpdate", this ); }

                    if (trackIndex === void 0) { trackIndex = 0; }
                    if (target === void 0) { target = null; }
                    VirtueSky.Core.App.Delay$1(UnityEngine.MonoBehaviour.op_Inequality(target, null) ? target : skeletonGraphic, VirtueSky.Misc.SkeletonGraphicExtensions.Duration(skeletonGraphic, trackIndex), null, onUpdate);
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.OnUpdate:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.Play:static start.*/
                Play: function (skeletonGraphic, animationName, loop, trackIndex) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#Play", this ); }

                    if (loop === void 0) { loop = false; }
                    if (trackIndex === void 0) { trackIndex = 0; }
                    skeletonGraphic.Clear();
                    skeletonGraphic.startingAnimation = animationName;
                    skeletonGraphic.startingLoop = loop;
                    skeletonGraphic.AnimationState.setAnimation(trackIndex, animationName, loop);
                    skeletonGraphic.LateUpdate();
                    skeletonGraphic.Initialize(true);
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.Play:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.PlayOnly:static start.*/
                PlayOnly: function (skeletonGraphic, animationName, loop, trackIndex) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#PlayOnly", this ); }

                    if (loop === void 0) { loop = false; }
                    if (trackIndex === void 0) { trackIndex = 0; }
                    skeletonGraphic.startingAnimation = animationName;
                    skeletonGraphic.AnimationState.setAnimation(trackIndex, animationName, loop);
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.PlayOnly:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.AddAnimation:static start.*/
                AddAnimation: function (skeletonGraphic, trackIndex, animationName, loop, timeDelay, mixDuration) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#AddAnimation", this ); }

                    if (timeDelay === void 0) { timeDelay = 0.0; }
                    if (mixDuration === void 0) { mixDuration = 0.0; }
                    var track = skeletonGraphic.AnimationState.addAnimation(trackIndex, animationName, loop, timeDelay);
                    track.mixDuration = mixDuration;
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.AddAnimation:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.SetSkin$1:static start.*/
                SetSkin$1: function (skeletonGraphic, skinName) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#SetSkin$1", this ); }

                    var skin = new Spine.Skin("temp");
                    skin.addSkin(skeletonGraphic.Skeleton.data.findSkin(skinName));
                    skeletonGraphic.Skeleton.setSkin(skin);
                    skeletonGraphic.Skeleton.setSlotsToSetupPose();
                    skeletonGraphic.LateUpdate();
                    skeletonGraphic.AnimationState.apply(skeletonGraphic.Skeleton);
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.SetSkin$1:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.SetSkin:static start.*/
                SetSkin: function (skeletonGraphic, skinNames) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#SetSkin", this ); }

                    var $t;
                    var skin = new Spine.Skin("temp");
                    var skeletonData = skeletonGraphic.Skeleton.data;
                    $t = Bridge.getEnumerator(skinNames);
                    try {
                        while ($t.moveNext()) {
                            var skinName = $t.Current;
                            skin.addSkin(skeletonData.findSkin(skinName));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    skeletonGraphic.initialSkinName = "temp";
                    skeletonGraphic.Skeleton.setSkin(skin);
                    skeletonGraphic.Skeleton.setSlotsToSetupPose();
                    skeletonGraphic.LateUpdate();
                    skeletonGraphic.AnimationState.apply(skeletonGraphic.Skeleton);

                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.SetSkin:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.ChangeAttachment$1:static start.*/
                ChangeAttachment$1: function (skeletonGraphic, slotName, attachmentName) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#ChangeAttachment$1", this ); }

                    var slotIndex = skeletonGraphic.Skeleton.data.findSlot(slotName).index;
                    var attachment = skeletonGraphic.Skeleton.getAttachment(slotIndex, attachmentName);
                    var skin = new Spine.Skin("temp");
                    skin.setAttachment(slotIndex, slotName, attachment);
                    skeletonGraphic.Skeleton.setSkin(skin);
                    skeletonGraphic.Skeleton.setSlotsToSetupPose();
                    skeletonGraphic.LateUpdate();
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.ChangeAttachment$1:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.ChangeAttachment:static start.*/
                ChangeAttachment: function (skeletonGraphic, slotName, attachmentNames) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#ChangeAttachment", this ); }

                    var $t;
                    var slotIndex = skeletonGraphic.Skeleton.data.findSlot(slotName).index;
                    var skin = new Spine.Skin("temp");
                    $t = Bridge.getEnumerator(attachmentNames);
                    try {
                        while ($t.moveNext()) {
                            var attachmentName = $t.Current;
                            var attachment = skeletonGraphic.Skeleton.getAttachment(slotIndex, attachmentName);
                            skin.setAttachment(slotIndex, slotName, attachment);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    skeletonGraphic.Skeleton.setSkin(skin);
                    skeletonGraphic.Skeleton.setSlotsToSetupPose();
                    skeletonGraphic.LateUpdate();
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.ChangeAttachment:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.MixSkin$1:static start.*/
                MixSkin$1: function (skeletonGraphic, mixSkinName) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#MixSkin$1", this ); }

                    var skin = new Spine.Skin("temp");
                    skin.addSkin(skeletonGraphic.Skeleton.data.findSkin(mixSkinName));
                    skeletonGraphic.Skeleton.setSkin(skin);
                    skeletonGraphic.Skeleton.setSlotsToSetupPose();
                    skeletonGraphic.AnimationState.apply(skeletonGraphic.Skeleton);
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.MixSkin$1:static end.*/

                /*VirtueSky.Misc.SkeletonGraphicExtensions.MixSkin:static start.*/
                MixSkin: function (skeletonGraphic, mixSkinNames) {
if ( TRACE ) { TRACE( "VirtueSky.Misc.SkeletonGraphicExtensions#MixSkin", this ); }

                    var $t;
                    var skin = new Spine.Skin("temp");
                    $t = Bridge.getEnumerator(mixSkinNames);
                    try {
                        while ($t.moveNext()) {
                            var mixSkinName = $t.Current;
                            skin.addSkin(skeletonGraphic.Skeleton.data.findSkin(mixSkinName));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }

                    skeletonGraphic.Skeleton.setSkin(skin);
                    skeletonGraphic.Skeleton.setSlotsToSetupPose();
                    skeletonGraphic.AnimationState.apply(skeletonGraphic.Skeleton);
                    return skeletonGraphic;
                },
                /*VirtueSky.Misc.SkeletonGraphicExtensions.MixSkin:static end.*/


            }
        }
    });
    /*VirtueSky.Misc.SkeletonGraphicExtensions end.*/

    /*VirtueSky.ObjectPooling.Pool start.*/
    Bridge.define("VirtueSky.ObjectPooling.Pool", {
        statics: {
            fields: {
                _poolHandle: null
            },
            methods: {
                /*VirtueSky.ObjectPooling.Pool.InitPool:static start.*/
                InitPool: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#InitPool", this ); }

                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        VirtueSky.ObjectPooling.Pool._poolHandle = new VirtueSky.ObjectPooling.PoolHandle();
                        VirtueSky.ObjectPooling.Pool._poolHandle.Initialize();
                    }
                },
                /*VirtueSky.ObjectPooling.Pool.InitPool:static end.*/

                /*VirtueSky.ObjectPooling.Pool.PreSpawn:static start.*/
                PreSpawn: function (poolData) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#PreSpawn", this ); }

                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return;
                    }

                    VirtueSky.ObjectPooling.Pool._poolHandle.PreSpawn(poolData);
                },
                /*VirtueSky.ObjectPooling.Pool.PreSpawn:static end.*/

                /*VirtueSky.ObjectPooling.Pool.Spawn$2:static start.*/
                Spawn$2: function (prefab, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#Spawn$2", this ); }

                    if (parent === void 0) { parent = null; }
                    if (worldPositionStays === void 0) { worldPositionStays = true; }
                    if (initialize === void 0) { initialize = true; }
                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return null;
                    }

                    return VirtueSky.ObjectPooling.Pool._poolHandle.Spawn$2(prefab, parent, worldPositionStays, initialize);
                },
                /*VirtueSky.ObjectPooling.Pool.Spawn$2:static end.*/

                /*VirtueSky.ObjectPooling.Pool.Spawn:static start.*/
                Spawn: function (T, type, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#Spawn", this ); }

                    if (parent === void 0) { parent = null; }
                    if (worldPositionStays === void 0) { worldPositionStays = true; }
                    if (initialize === void 0) { initialize = true; }
                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return null;
                    }

                    return VirtueSky.ObjectPooling.Pool._poolHandle.Spawn(T, Bridge.rValue(type), parent, worldPositionStays, initialize).GetComponent(T);
                },
                /*VirtueSky.ObjectPooling.Pool.Spawn:static end.*/

                /*VirtueSky.ObjectPooling.Pool.Spawn$3:static start.*/
                Spawn$3: function (prefab, position, rotation, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#Spawn$3", this ); }

                    if (parent === void 0) { parent = null; }
                    if (worldPositionStays === void 0) { worldPositionStays = true; }
                    if (initialize === void 0) { initialize = true; }
                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return null;
                    }

                    return VirtueSky.ObjectPooling.Pool._poolHandle.Spawn$3(prefab, position, rotation, parent, worldPositionStays, initialize);
                },
                /*VirtueSky.ObjectPooling.Pool.Spawn$3:static end.*/

                /*VirtueSky.ObjectPooling.Pool.Spawn$1:static start.*/
                Spawn$1: function (T, type, position, rotation, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#Spawn$1", this ); }

                    if (parent === void 0) { parent = null; }
                    if (worldPositionStays === void 0) { worldPositionStays = true; }
                    if (initialize === void 0) { initialize = true; }
                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return null;
                    }

                    return VirtueSky.ObjectPooling.Pool._poolHandle.Spawn$1(T, Bridge.rValue(type), position, rotation, parent, worldPositionStays, initialize).GetComponent(T);
                },
                /*VirtueSky.ObjectPooling.Pool.Spawn$1:static end.*/

                /*VirtueSky.ObjectPooling.Pool.DeSpawn:static start.*/
                DeSpawn: function (gameObject, destroy, worldPositionStays) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#DeSpawn", this ); }

                    if (destroy === void 0) { destroy = false; }
                    if (worldPositionStays === void 0) { worldPositionStays = true; }
                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return;
                    }

                    VirtueSky.ObjectPooling.Pool._poolHandle.DeSpawn(gameObject, destroy, worldPositionStays);
                },
                /*VirtueSky.ObjectPooling.Pool.DeSpawn:static end.*/

                /*VirtueSky.ObjectPooling.Pool.DeSpawn$1:static start.*/
                DeSpawn$1: function (T, type, destroy, worldPositionStays) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#DeSpawn$1", this ); }

                    if (destroy === void 0) { destroy = false; }
                    if (worldPositionStays === void 0) { worldPositionStays = true; }
                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return;
                    }

                    VirtueSky.ObjectPooling.Pool._poolHandle.DeSpawn$1(T, Bridge.rValue(type), destroy, worldPositionStays);
                },
                /*VirtueSky.ObjectPooling.Pool.DeSpawn$1:static end.*/

                /*VirtueSky.ObjectPooling.Pool.DeSpawnAll:static start.*/
                DeSpawnAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#DeSpawnAll", this ); }

                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return;
                    }

                    VirtueSky.ObjectPooling.Pool._poolHandle.DeSpawnAll();
                },
                /*VirtueSky.ObjectPooling.Pool.DeSpawnAll:static end.*/

                /*VirtueSky.ObjectPooling.Pool.DestroyAll:static start.*/
                DestroyAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#DestroyAll", this ); }

                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return;
                    }

                    VirtueSky.ObjectPooling.Pool._poolHandle.DestroyAll();
                },
                /*VirtueSky.ObjectPooling.Pool.DestroyAll:static end.*/

                /*VirtueSky.ObjectPooling.Pool.DestroyAllWaitPools:static start.*/
                DestroyAllWaitPools: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.Pool#DestroyAllWaitPools", this ); }

                    if (VirtueSky.ObjectPooling.Pool._poolHandle == null) {
                        return;
                    }

                    VirtueSky.ObjectPooling.Pool._poolHandle.DestroyAllWaitPools();
                },
                /*VirtueSky.ObjectPooling.Pool.DestroyAllWaitPools:static end.*/


            }
        }
    });
    /*VirtueSky.ObjectPooling.Pool end.*/

    /*VirtueSky.ObjectPooling.PoolData start.*/
    Bridge.define("VirtueSky.ObjectPooling.PoolData", {
        fields: {
            prefab: null,
            count: 0
        }
    });
    /*VirtueSky.ObjectPooling.PoolData end.*/

    /*VirtueSky.ObjectPooling.PooledObjectId start.*/
    Bridge.define("VirtueSky.ObjectPooling.PooledObjectId", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            prefab: null
        }
    });
    /*VirtueSky.ObjectPooling.PooledObjectId end.*/

    /*VirtueSky.ObjectPooling.PoolHandle start.*/
    Bridge.define("VirtueSky.ObjectPooling.PoolHandle", {
        fields: {
            waitPool: null,
            activePool: null,
            container: null,
            initialized: false
        },
        methods: {
            /*VirtueSky.ObjectPooling.PoolHandle.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#Initialize", this ); }

                if (this.initialized) {
                    return;
                }
                this.initialized = true;

                this.waitPool = new (System.Collections.Generic.Dictionary$2(UnityEngine.GameObject,System.Collections.Generic.Queue$1(UnityEngine.GameObject))).ctor();
                this.activePool = new (System.Collections.Generic.LinkedList$1(UnityEngine.GameObject)).ctor();
                this.container = new UnityEngine.GameObject.$ctor2("PoolContainer").transform;
                UnityEngine.Object.DontDestroyOnLoad(this.container.gameObject);
            },
            /*VirtueSky.ObjectPooling.PoolHandle.Initialize end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.PreSpawn start.*/
            PreSpawn: function (poolData) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#PreSpawn", this ); }

                for (var i = 0; i < poolData.count; i = (i + 1) | 0) {
                    this.SpawnNew(poolData.prefab);
                }
            },
            /*VirtueSky.ObjectPooling.PoolHandle.PreSpawn end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.SpawnNew start.*/
            SpawnNew: function (prefab) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#SpawnNew", this ); }

                var gameObject = UnityEngine.Object.Instantiate(UnityEngine.GameObject, prefab);
                var id = gameObject.AddComponent(VirtueSky.ObjectPooling.PooledObjectId);
                id.prefab = prefab;

                this.activePool.AddLast(gameObject);

                this.DeSpawn(gameObject, false);
            },
            /*VirtueSky.ObjectPooling.PoolHandle.SpawnNew end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.DeSpawn$1 start.*/
            DeSpawn$1: function (T, type, destroy, worldPositionStays) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#DeSpawn$1", this ); }

                if (destroy === void 0) { destroy = false; }
                if (worldPositionStays === void 0) { worldPositionStays = true; }
                this.DeSpawn(Bridge.rValue(type).gameObject, destroy, worldPositionStays);
            },
            /*VirtueSky.ObjectPooling.PoolHandle.DeSpawn$1 end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.DeSpawn start.*/
            DeSpawn: function (gameObject, destroy, worldPositionStays) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#DeSpawn", this ); }

                if (destroy === void 0) { destroy = false; }
                if (worldPositionStays === void 0) { worldPositionStays = true; }
                var id = gameObject.GetComponent(VirtueSky.ObjectPooling.PooledObjectId);
                if (UnityEngine.MonoBehaviour.op_Equality(id, null)) {
                    UnityEngine.Debug.LogError$2(System.String.format("{0} is not a pooled object!", [gameObject.name]));
                    return;
                }

                if (!this.activePool.contains(gameObject)) {
                    UnityEngine.Debug.LogError$2(System.String.format("{0} is not in active pool!", [gameObject.name]));
                    return;
                }

                this.activePool.remove(gameObject);
                if (!this.waitPool.containsKey(id.prefab)) {
                    this.waitPool.add(id.prefab, new (System.Collections.Generic.Queue$1(UnityEngine.GameObject)).ctor());
                }

                var stack = this.waitPool.getItem(id.prefab);
                if (stack.Contains(gameObject)) {
                    UnityEngine.Debug.LogError$2(System.String.format("{0} is already pooled!", [gameObject.name]));
                    return;
                }

                this.CleanUp(gameObject);
                if (destroy) {
                    UnityEngine.Object.Destroy(gameObject);
                } else {
                    gameObject.SetActive(false);
                    gameObject.transform.SetParent(this.container, worldPositionStays);
                    stack.Enqueue(gameObject);
                }
            },
            /*VirtueSky.ObjectPooling.PoolHandle.DeSpawn end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.DeSpawnAll start.*/
            DeSpawnAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#DeSpawnAll", this ); }

                var $t, $t1;
                var arr = ($t = UnityEngine.GameObject, System.Linq.Enumerable.from(this.activePool, $t).ToArray($t));
                $t1 = Bridge.getEnumerator(arr);
                try {
                    while ($t1.moveNext()) {
                        var o = $t1.Current;
                        if (UnityEngine.GameObject.op_Inequality(o, null)) {
                            this.DeSpawn(o);
                        }
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }
            },
            /*VirtueSky.ObjectPooling.PoolHandle.DeSpawnAll end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.DestroyAllWaitPools start.*/
            DestroyAllWaitPools: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#DestroyAllWaitPools", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.waitPool);
                try {
                    while ($t.moveNext()) {
                        var _d1 = $t.Current;
                        var key = { };
                        var queue = { };
                        _d1.Deconstruct(key, queue);
                        $t1 = Bridge.getEnumerator(queue.v);
                        try {
                            while ($t1.moveNext()) {
                                var go = $t1.Current;
                                this.CleanUp(go);
                                UnityEngine.Object.DestroyImmediate(go);
                            }
                        } finally {
                            if (Bridge.is($t1, System.IDisposable)) {
                                $t1.System$IDisposable$Dispose();
                            }
                        }

                        queue.v.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                this.waitPool.clear();
            },
            /*VirtueSky.ObjectPooling.PoolHandle.DestroyAllWaitPools end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.DestroyAll start.*/
            DestroyAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#DestroyAll", this ); }

                var arr = System.Linq.Enumerable.from(this.waitPool.Values, System.Collections.Generic.Queue$1(UnityEngine.GameObject)).selectMany(function (g) {
                        return g;
                    }).ToArray(UnityEngine.GameObject);
                for (var i = 0; i < arr.length; i = (i + 1) | 0) {
                    UnityEngine.Object.Destroy(arr[i].gameObject);
                }

                this.waitPool.clear();
            },
            /*VirtueSky.ObjectPooling.PoolHandle.DestroyAll end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.Spawn start.*/
            Spawn: function (T, type, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#Spawn", this ); }

                if (parent === void 0) { parent = null; }
                if (worldPositionStays === void 0) { worldPositionStays = true; }
                if (initialize === void 0) { initialize = true; }
                return this.Spawn$2(Bridge.rValue(type).gameObject, parent, worldPositionStays, initialize).GetComponent(T);
            },
            /*VirtueSky.ObjectPooling.PoolHandle.Spawn end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.Spawn$2 start.*/
            Spawn$2: function (prefab, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#Spawn$2", this ); }

                if (parent === void 0) { parent = null; }
                if (worldPositionStays === void 0) { worldPositionStays = true; }
                if (initialize === void 0) { initialize = true; }
                if (!this.waitPool.containsKey(prefab)) {
                    this.waitPool.add(prefab, new (System.Collections.Generic.Queue$1(UnityEngine.GameObject)).ctor());
                }

                var stack = this.waitPool.getItem(prefab);
                if (stack.Count === 0) {
                    this.SpawnNew(prefab);
                }

                var gameObject = stack.Dequeue();

                gameObject.transform.SetParent(parent, worldPositionStays);

                if (UnityEngine.Component.op_Equality(parent, null)) {
                    //SceneManager.MoveGameObjectToScene(gameObject, SceneManager.GetActiveScene());
                }

                gameObject.SetActive(true);

                if (initialize) {
                    this.InitializeObj(gameObject);
                }

                this.activePool.AddLast(gameObject);

                return gameObject;
            },
            /*VirtueSky.ObjectPooling.PoolHandle.Spawn$2 end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.Spawn$1 start.*/
            Spawn$1: function (T, type, position, rotation, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#Spawn$1", this ); }

                if (parent === void 0) { parent = null; }
                if (worldPositionStays === void 0) { worldPositionStays = true; }
                if (initialize === void 0) { initialize = true; }
                return this.Spawn$3(Bridge.rValue(type).gameObject, position, rotation, parent, worldPositionStays, initialize).GetComponent(T);
            },
            /*VirtueSky.ObjectPooling.PoolHandle.Spawn$1 end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.Spawn$3 start.*/
            Spawn$3: function (prefab, position, rotation, parent, worldPositionStays, initialize) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#Spawn$3", this ); }

                if (parent === void 0) { parent = null; }
                if (worldPositionStays === void 0) { worldPositionStays = true; }
                if (initialize === void 0) { initialize = true; }
                if (!this.waitPool.containsKey(prefab)) {
                    this.waitPool.add(prefab, new (System.Collections.Generic.Queue$1(UnityEngine.GameObject)).ctor());
                }

                var stack = this.waitPool.getItem(prefab);
                if (stack.Count === 0) {
                    this.SpawnNew(prefab);
                }

                var gameObject = stack.Dequeue();

                gameObject.transform.SetParent(parent, worldPositionStays);
                gameObject.transform.SetPositionAndRotation(position, rotation);

                if (UnityEngine.Component.op_Equality(parent, null)) {
                    //SceneManager.MoveGameObjectToScene(gameObject, SceneManager.GetActiveScene());
                }

                gameObject.SetActive(true);

                if (initialize) {
                    this.InitializeObj(gameObject);
                }

                this.activePool.AddLast(gameObject);

                return gameObject;
            },
            /*VirtueSky.ObjectPooling.PoolHandle.Spawn$3 end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.InitializeObj start.*/
            InitializeObj: function (go) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#InitializeObj", this ); }

                var $t;
                var monos = go.GetComponentsInChildren(VirtueSky.Core.BaseMono, true);
                $t = Bridge.getEnumerator(monos);
                try {
                    while ($t.moveNext()) {
                        var mono = $t.Current;
                        mono.Initialize();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*VirtueSky.ObjectPooling.PoolHandle.InitializeObj end.*/

            /*VirtueSky.ObjectPooling.PoolHandle.CleanUp start.*/
            CleanUp: function (go) {
if ( TRACE ) { TRACE( "VirtueSky.ObjectPooling.PoolHandle#CleanUp", this ); }

                var $t;
                var monos = go.GetComponentsInChildren(VirtueSky.Core.BaseMono, true);
                $t = Bridge.getEnumerator(monos);
                try {
                    while ($t.moveNext()) {
                        var mono = $t.Current;
                        mono.CleanUp();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*VirtueSky.ObjectPooling.PoolHandle.CleanUp end.*/


        },
        overloads: {
            "DeSpawn(T, bool, bool)": "DeSpawn$1",
            "Spawn(GameObject, Transform, bool, bool)": "Spawn$2",
            "Spawn(T, Vector3, Quaternion, Transform, bool, bool)": "Spawn$1",
            "Spawn(GameObject, Vector3, Quaternion, Transform, bool, bool)": "Spawn$3"
        }
    });
    /*VirtueSky.ObjectPooling.PoolHandle end.*/

    /*VirtueSky.TouchInput.TouchInputManager start.*/
    Bridge.define("VirtueSky.TouchInput.TouchInputManager", {
        inherits: [UnityEngine.MonoBehaviour],
        fields: {
            inputEventTouchBegin: null,
            inputEventTouchMove: null,
            inputEventTouchStationary: null,
            inputEventTouchEnd: null,
            inputEventTouchCancel: null,
            inputPreventTouchVariable: null,
            touchPosition: null,
            preventTouch: false,
            _mouseDown: false,
            _mouseUpdate: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#init", this ); }

                this.touchPosition = new UnityEngine.Vector3();
                this.preventTouch = false;
            }
        },
        methods: {
            /*VirtueSky.TouchInput.TouchInputManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#OnEnable", this ); }

                if (this.inputPreventTouchVariable != null) {
                    this.inputPreventTouchVariable.Value = this.preventTouch;
                    this.inputPreventTouchVariable.AddListener$1(Bridge.fn.cacheBind(this, this.OnChangePreventTouch));
                }
            },
            /*VirtueSky.TouchInput.TouchInputManager.OnEnable end.*/

            /*VirtueSky.TouchInput.TouchInputManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#OnDisable", this ); }

                if (this.inputPreventTouchVariable != null) {
                    this.inputPreventTouchVariable.RemoveListener$1(Bridge.fn.cacheBind(this, this.OnChangePreventTouch));
                }
            },
            /*VirtueSky.TouchInput.TouchInputManager.OnDisable end.*/

            /*VirtueSky.TouchInput.TouchInputManager.OnChangePreventTouch start.*/
            OnChangePreventTouch: function (prevent) {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#OnChangePreventTouch", this ); }

                this.preventTouch = prevent;
            },
            /*VirtueSky.TouchInput.TouchInputManager.OnChangePreventTouch end.*/

            /*VirtueSky.TouchInput.TouchInputManager.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#Update", this ); }

                if (this.preventTouch) {
                    return;
                }
                this.HandleTouch();
            },
            /*VirtueSky.TouchInput.TouchInputManager.Update end.*/

            /*VirtueSky.TouchInput.TouchInputManager.HandleTouch start.*/
            HandleTouch: function () {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#HandleTouch", this ); }

                if (UnityEngine.Input.touchCount > 0) {
                    var touch = UnityEngine.Input.GetTouch(0);
                    switch (touch.phase) {
                        case UnityEngine.TouchPhase.Began: 
                            if (this.inputEventTouchBegin != null) {
                                this.inputEventTouchBegin.Raise(UnityEngine.Vector3.FromVector2(touch.position.$clone()));
                            }
                            break;
                        case UnityEngine.TouchPhase.Moved: 
                            if (this.inputEventTouchMove != null) {
                                this.inputEventTouchMove.Raise(UnityEngine.Vector3.FromVector2(touch.position.$clone()));
                            }
                            break;
                        case UnityEngine.TouchPhase.Stationary: 
                            if (this.inputEventTouchStationary != null) {
                                this.inputEventTouchStationary.Raise(UnityEngine.Vector3.FromVector2(touch.position.$clone()));
                            }
                            break;
                        case UnityEngine.TouchPhase.Ended: 
                            if (this.inputEventTouchEnd != null) {
                                this.inputEventTouchEnd.Raise(UnityEngine.Vector3.FromVector2(touch.position.$clone()));
                            }
                            break;
                        case UnityEngine.TouchPhase.Canceled: 
                            if (this.inputEventTouchCancel != null) {
                                this.inputEventTouchCancel.Raise(UnityEngine.Vector3.FromVector2(touch.position.$clone()));
                            }
                            break;
                    }

                    this.touchPosition = UnityEngine.Vector3.FromVector2(touch.position.$clone());
                }
            },
            /*VirtueSky.TouchInput.TouchInputManager.HandleTouch end.*/

            /*VirtueSky.TouchInput.TouchInputManager.HandleMouse start.*/
            HandleMouse: function () {
if ( TRACE ) { TRACE( "VirtueSky.TouchInput.TouchInputManager#HandleMouse", this ); }

                if (UnityEngine.Input.GetMouseButtonDown(0)) {
                    if (!this._mouseDown) {
                        this._mouseDown = true;
                        this._mouseUpdate = true;
                        if (this.inputEventTouchBegin != null) {
                            this.inputEventTouchBegin.Raise(UnityEngine.Input.mousePosition.$clone());
                        }

                        this.touchPosition = UnityEngine.Input.mousePosition.$clone();
                    }
                } else if (UnityEngine.Input.GetMouseButtonUp(0)) {
                    this._mouseDown = false;
                    this._mouseUpdate = false;
                    if (this.inputEventTouchEnd != null) {
                        this.inputEventTouchEnd.Raise(UnityEngine.Input.mousePosition.$clone());
                    }

                    this.touchPosition = UnityEngine.Input.mousePosition.$clone();
                }

                if (this._mouseDown && this._mouseUpdate) {
                    if (this.inputEventTouchMove != null) {
                        this.inputEventTouchMove.Raise(UnityEngine.Input.mousePosition.$clone());
                    }

                    this.touchPosition = UnityEngine.Input.mousePosition.$clone();
                }
            },
            /*VirtueSky.TouchInput.TouchInputManager.HandleMouse end.*/


        }
    });
    /*VirtueSky.TouchInput.TouchInputManager end.*/

    /*VirtueSky.UIButton.ButtonCustom start.*/
    Bridge.define("VirtueSky.UIButton.ButtonCustom", {
        inherits: [UnityEngine.UI.Button],
        fields: {
            clickButtonEvent: null,
            isMotion: false,
            easingTypes: 0,
            scale: 0,
            isShrugOver: false,
            timeShrug: 0,
            strength: 0,
            useSoundFx: false,
            playSfxEvent: null,
            soundDataClickButton: null,
            originScale: null,
            canShrug: false,
            _tween: null
        },
        alias: [
            "OnPointerDown", "UnityEngine$EventSystems$IPointerDownHandler$OnPointerDown",
            "OnPointerUp", "UnityEngine$EventSystems$IPointerUpHandler$OnPointerUp",
            "OnPointerExit", "UnityEngine$EventSystems$IPointerExitHandler$OnPointerExit"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#init", this ); }

                this.originScale = new UnityEngine.Vector3();
                this.isMotion = true;
                this.easingTypes = DG.Tweening.Ease.OutQuint;
                this.scale = 0.9;
                this.timeShrug = 0.2;
                this.strength = 0.2;
                this.originScale = new pc.Vec3( 1, 1, 1 );
                this.canShrug = true;
            }
        },
        methods: {
            /*VirtueSky.UIButton.ButtonCustom.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#OnEnable", this ); }

                UnityEngine.UI.Button.prototype.OnEnable.call(this);
                this.originScale = this.transform.localScale.$clone();
            },
            /*VirtueSky.UIButton.ButtonCustom.OnEnable end.*/

            /*VirtueSky.UIButton.ButtonCustom.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#OnDisable", this ); }

                UnityEngine.UI.Button.prototype.OnDisable.call(this);
                this.ResetScale();
            },
            /*VirtueSky.UIButton.ButtonCustom.OnDisable end.*/

            /*VirtueSky.UIButton.ButtonCustom.OnPointerDown start.*/
            OnPointerDown: function (eventData) {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#OnPointerDown", this ); }

                UnityEngine.UI.Button.prototype.OnPointerDown.call(this, eventData);
                this.DoScale();
                if (this.useSoundFx) {
                    VirtueSky.Audio.AudioHelper.PlaySfx(this.soundDataClickButton, this.playSfxEvent);
                }

                if (this.clickButtonEvent != null) {
                    this.clickButtonEvent.Raise();
                } else {
                    UnityEngine.Debug.Log$1(System.String.format("Click button event ({0}) null", [this.gameObject.name]));
                }
            },
            /*VirtueSky.UIButton.ButtonCustom.OnPointerDown end.*/

            /*VirtueSky.UIButton.ButtonCustom.OnPointerUp start.*/
            OnPointerUp: function (eventData) {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#OnPointerUp", this ); }

                UnityEngine.UI.Button.prototype.OnPointerUp.call(this, eventData);
                this.ResetScale();
            },
            /*VirtueSky.UIButton.ButtonCustom.OnPointerUp end.*/

            /*VirtueSky.UIButton.ButtonCustom.OnPointerExit start.*/
            OnPointerExit: function (eventData) {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#OnPointerExit", this ); }

                UnityEngine.UI.Button.prototype.OnPointerExit.call(this, eventData);
                this.Shrug();
            },
            /*VirtueSky.UIButton.ButtonCustom.OnPointerExit end.*/

            /*VirtueSky.UIButton.ButtonCustom.DoScale start.*/
            DoScale: function () {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#DoScale", this ); }

                if (this.isMotion) {
                    this._tween = DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.transform, this.originScale.$clone().clone().scale( this.scale ), 0.15), this.easingTypes);
                }
            },
            /*VirtueSky.UIButton.ButtonCustom.DoScale end.*/

            /*VirtueSky.UIButton.ButtonCustom.Shrug start.*/
            Shrug: function () {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#Shrug", this ); }

                if (this.isMotion && this.isShrugOver && this.canShrug) {
                    this.canShrug = false;
                    if (this.isMotion && this.isShrugOver) {
                    }
                }
            },
            /*VirtueSky.UIButton.ButtonCustom.Shrug end.*/

            /*VirtueSky.UIButton.ButtonCustom.ResetScale start.*/
            ResetScale: function () {
if ( TRACE ) { TRACE( "VirtueSky.UIButton.ButtonCustom#ResetScale", this ); }

                if (this.isMotion) {
                    DG.Tweening.TweenExtensions.Kill(this._tween);
                    this.transform.localScale = this.originScale.$clone();
                }
            },
            /*VirtueSky.UIButton.ButtonCustom.ResetScale end.*/


        }
    });
    /*VirtueSky.UIButton.ButtonCustom end.*/

    /*VirtueSky.Variables.IReference start.*/
    Bridge.define("VirtueSky.Variables.IReference", {
        $kind: 3
    });
    /*VirtueSky.Variables.IReference end.*/

    /*VirtueSky.Variables.TypeId start.*/
    Bridge.define("VirtueSky.Variables.TypeId", {
        $kind: 6,
        statics: {
            fields: {
                Guid: 0,
                CustomId: 1
            }
        }
    });
    /*VirtueSky.Variables.TypeId end.*/

    /*VirtueSky.Vfx.VfxData start.*/
    Bridge.define("VirtueSky.Vfx.VfxData", {
        inherits: [UnityEngine.ScriptableObject],
        fields: {
            timeDestroy: 0,
            listVfx: null
        },
        props: {
            TimeDestroy: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxData#TimeDestroy#get", this ); }

                    return this.timeDestroy;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxData#init", this ); }

                this.timeDestroy = 3;
            }
        },
        methods: {
            /*VirtueSky.Vfx.VfxData.GetVfxRandom start.*/
            GetVfxRandom: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxData#GetVfxRandom", this ); }

                return this.PickRandom(this.listVfx);
            },
            /*VirtueSky.Vfx.VfxData.GetVfxRandom end.*/

            /*VirtueSky.Vfx.VfxData.GetVfxByIndex start.*/
            GetVfxByIndex: function (index) {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxData#GetVfxByIndex", this ); }

                return this.listVfx.getItem(Math.max(0, Math.min(index, ((this.listVfx.Count - 1) | 0))));
            },
            /*VirtueSky.Vfx.VfxData.GetVfxByIndex end.*/

            /*VirtueSky.Vfx.VfxData.PickRandom start.*/
            PickRandom: function (collection) {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxData#PickRandom", this ); }

                return collection.Count === 0 ? null : collection.getItem(UnityEngine.Random.Range(0, collection.Count));
            },
            /*VirtueSky.Vfx.VfxData.PickRandom end.*/


        }
    });
    /*VirtueSky.Vfx.VfxData end.*/

    /*VirtueSky.Vfx.VfxSpawner start.*/
    Bridge.define("VirtueSky.Vfx.VfxSpawner", {
        statics: {
            methods: {
                /*VirtueSky.Vfx.VfxSpawner.Spawn$2:static start.*/
                Spawn$2: function (vfxData, parent, position, quaternion, localScale, index) {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxSpawner#Spawn$2", this ); }

                    if (index === void 0) { index = -1; }
                    if (vfxData == null) {
                        return;
                    }
                    var vfxPrefab = index < 0 ? vfxData.GetVfxRandom() : vfxData.GetVfxByIndex(index);
                    var vfxSpawn = VirtueSky.ObjectPooling.Pool.Spawn$3(vfxPrefab, position.$clone(), quaternion.$clone(), parent, false);
                    vfxSpawn.transform.localScale = localScale.$clone();
                    VirtueSky.Core.App.Delay(vfxData.TimeDestroy, function () {
                        VirtueSky.ObjectPooling.Pool.DeSpawn(vfxSpawn);
                    });
                },
                /*VirtueSky.Vfx.VfxSpawner.Spawn$2:static end.*/

                /*VirtueSky.Vfx.VfxSpawner.Spawn$1:static start.*/
                Spawn$1: function (vfxData, parent, position, quaternion, index) {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxSpawner#Spawn$1", this ); }

                    if (index === void 0) { index = -1; }
                    if (vfxData == null) {
                        return;
                    }
                    var vfxPrefab = index < 0 ? vfxData.GetVfxRandom() : vfxData.GetVfxByIndex(index);
                    var vfxSpawn = VirtueSky.ObjectPooling.Pool.Spawn$3(vfxPrefab, position.$clone(), quaternion.$clone(), parent, false);
                    VirtueSky.Core.App.Delay(vfxData.TimeDestroy, function () {
                        VirtueSky.ObjectPooling.Pool.DeSpawn(vfxSpawn);
                    });
                },
                /*VirtueSky.Vfx.VfxSpawner.Spawn$1:static end.*/

                /*VirtueSky.Vfx.VfxSpawner.Spawn:static start.*/
                Spawn: function (vfxData, parent, index) {
if ( TRACE ) { TRACE( "VirtueSky.Vfx.VfxSpawner#Spawn", this ); }

                    if (index === void 0) { index = -1; }
                    if (vfxData == null) {
                        return;
                    }
                    var vfxPrefab = index < 0 ? vfxData.GetVfxRandom() : vfxData.GetVfxByIndex(index);
                    var vfxSpawn = VirtueSky.ObjectPooling.Pool.Spawn$2(vfxPrefab, parent, false);
                    VirtueSky.Core.App.Delay(vfxData.TimeDestroy, function () {
                        VirtueSky.ObjectPooling.Pool.DeSpawn(vfxSpawn);
                    });
                },
                /*VirtueSky.Vfx.VfxSpawner.Spawn:static end.*/


            }
        }
    });
    /*VirtueSky.Vfx.VfxSpawner end.*/

    /*VirtueSky.Vibration.ImpactFeedbackStyle start.*/
    Bridge.define("VirtueSky.Vibration.ImpactFeedbackStyle", {
        $kind: 6,
        statics: {
            fields: {
                Heavy: 0,
                Medium: 1,
                Light: 2,
                Rigid: 3,
                Soft: 4
            }
        }
    });
    /*VirtueSky.Vibration.ImpactFeedbackStyle end.*/

    /*VirtueSky.Vibration.NotificationFeedbackStyle start.*/
    Bridge.define("VirtueSky.Vibration.NotificationFeedbackStyle", {
        $kind: 6,
        statics: {
            fields: {
                Error: 0,
                Success: 1,
                Warning: 2
            }
        }
    });
    /*VirtueSky.Vibration.NotificationFeedbackStyle end.*/

    /*VirtueSky.Vibration.Vibration start.*/
    Bridge.define("VirtueSky.Vibration.Vibration", {
        statics: {
            fields: {
                initialized: false
            },
            props: {
                EnableVibration: {
                    get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#EnableVibration#get", this ); }

                        return VirtueSky.DataStorage.GameData.Get(System.Boolean, "ENABLE_VIBRATION", true);
                    },
                    set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#EnableVibration#set", this ); }

                        VirtueSky.DataStorage.GameData.Set(System.Boolean, "ENABLE_VIBRATION", value);
                    }
                },
                AndroidVersion: {
                    get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#AndroidVersion#get", this ); }

                        var iVersionNumber = 0;
                        if (UnityEngine.Application.platform === UnityEngine.RuntimePlatform.Android) {
                            var androidVersion = UnityEngine.SystemInfo.operatingSystem;
                            var sdkPos = System.String.indexOf(androidVersion, "API-");
                            iVersionNumber = System.Int32.parse(Bridge.toString(androidVersion.substr(((sdkPos + 4) | 0), 2)));
                        }

                        return iVersionNumber;
                    }
                }
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#init", this ); }

                    this.initialized = false;
                }
            },
            methods: {
                /*VirtueSky.Vibration.Vibration.Init:static start.*/
                Init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#Init", this ); }

                    if (VirtueSky.Vibration.Vibration.initialized) {
                        return;
                    }


                    VirtueSky.Vibration.Vibration.initialized = true;
                },
                /*VirtueSky.Vibration.Vibration.Init:static end.*/

                /*VirtueSky.Vibration.Vibration.VibrateIOS:static start.*/
                VibrateIOS: function (style) {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#VibrateIOS", this ); }
 },
                /*VirtueSky.Vibration.Vibration.VibrateIOS:static end.*/

                /*VirtueSky.Vibration.Vibration.VibrateIOS$1:static start.*/
                VibrateIOS$1: function (style) {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#VibrateIOS$1", this ); }
 },
                /*VirtueSky.Vibration.Vibration.VibrateIOS$1:static end.*/

                /*VirtueSky.Vibration.Vibration.VibrateIOS_SelectionChanged:static start.*/
                VibrateIOS_SelectionChanged: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#VibrateIOS_SelectionChanged", this ); }
 },
                /*VirtueSky.Vibration.Vibration.VibrateIOS_SelectionChanged:static end.*/

                /*VirtueSky.Vibration.Vibration.VibratePop:static start.*/
                /**
                 * Tiny pop vibration
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Vibration.Vibration
                 * @memberof VirtueSky.Vibration.Vibration
                 * @return  {void}
                 */
                VibratePop: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#VibratePop", this ); }

                    if (UnityEngine.Application.isMobilePlatform && VirtueSky.Vibration.Vibration.EnableVibration) {
                    }
                },
                /*VirtueSky.Vibration.Vibration.VibratePop:static end.*/

                /*VirtueSky.Vibration.Vibration.VibratePeek:static start.*/
                /**
                 * Small peek vibration
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Vibration.Vibration
                 * @memberof VirtueSky.Vibration.Vibration
                 * @return  {void}
                 */
                VibratePeek: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#VibratePeek", this ); }

                    if (UnityEngine.Application.isMobilePlatform && VirtueSky.Vibration.Vibration.EnableVibration) {
                    }
                },
                /*VirtueSky.Vibration.Vibration.VibratePeek:static end.*/

                /*VirtueSky.Vibration.Vibration.VibrateNope:static start.*/
                /**
                 * 3 small vibrations
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Vibration.Vibration
                 * @memberof VirtueSky.Vibration.Vibration
                 * @return  {void}
                 */
                VibrateNope: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#VibrateNope", this ); }

                    if (UnityEngine.Application.isMobilePlatform && VirtueSky.Vibration.Vibration.EnableVibration) {
                    }
                },
                /*VirtueSky.Vibration.Vibration.VibrateNope:static end.*/

                /*VirtueSky.Vibration.Vibration.CancelAndroid:static start.*/
                /**
                 * Only on Android
                 *
                 * @static
                 * @public
                 * @this VirtueSky.Vibration.Vibration
                 * @memberof VirtueSky.Vibration.Vibration
                 * @return  {void}
                 */
                CancelAndroid: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#CancelAndroid", this ); }

                    if (UnityEngine.Application.isMobilePlatform) {
                    }
                },
                /*VirtueSky.Vibration.Vibration.CancelAndroid:static end.*/

                /*VirtueSky.Vibration.Vibration.HasVibrator:static start.*/
                HasVibrator: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#HasVibrator", this ); }

                    if (UnityEngine.Application.isMobilePlatform) {
                        return false;
                    } else {
                        return false;
                    }
                },
                /*VirtueSky.Vibration.Vibration.HasVibrator:static end.*/

                /*VirtueSky.Vibration.Vibration.Vibrate:static start.*/
                Vibrate: function () {
if ( TRACE ) { TRACE( "VirtueSky.Vibration.Vibration#Vibrate", this ); }
 },
                /*VirtueSky.Vibration.Vibration.Vibrate:static end.*/


            }
        }
    });
    /*VirtueSky.Vibration.Vibration end.*/

    /*VirtueSky.Core.BaseMono start.*/
    Bridge.define("VirtueSky.Core.BaseMono", {
        inherits: [UnityEngine.MonoBehaviour,VirtueSky.Core.IEntity],
        alias: [
            "Initialize", "VirtueSky$Core$IEntity$Initialize",
            "Tick", "VirtueSky$Core$IEntity$Tick",
            "LateTick", "VirtueSky$Core$IEntity$LateTick",
            "FixedTick", "VirtueSky$Core$IEntity$FixedTick",
            "CleanUp", "VirtueSky$Core$IEntity$CleanUp"
        ],
        methods: {
            /*VirtueSky.Core.BaseMono.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#OnEnable", this ); }

                this.SubTick();
            },
            /*VirtueSky.Core.BaseMono.OnEnable end.*/

            /*VirtueSky.Core.BaseMono.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#OnDisable", this ); }

                this.UnSubTick();
            },
            /*VirtueSky.Core.BaseMono.OnDisable end.*/

            /*VirtueSky.Core.BaseMono.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#Initialize", this ); }
 },
            /*VirtueSky.Core.BaseMono.Initialize end.*/

            /*VirtueSky.Core.BaseMono.Tick start.*/
            Tick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#Tick", this ); }
 },
            /*VirtueSky.Core.BaseMono.Tick end.*/

            /*VirtueSky.Core.BaseMono.LateTick start.*/
            LateTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#LateTick", this ); }
 },
            /*VirtueSky.Core.BaseMono.LateTick end.*/

            /*VirtueSky.Core.BaseMono.FixedTick start.*/
            FixedTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#FixedTick", this ); }
 },
            /*VirtueSky.Core.BaseMono.FixedTick end.*/

            /*VirtueSky.Core.BaseMono.CleanUp start.*/
            CleanUp: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#CleanUp", this ); }
 },
            /*VirtueSky.Core.BaseMono.CleanUp end.*/

            /*VirtueSky.Core.BaseMono.SubTick start.*/
            SubTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#SubTick", this ); }

                VirtueSky.Core.App.SubTick$1(this);
                VirtueSky.Core.App.SubLateTick$1(this);
                VirtueSky.Core.App.SubFixedTick$1(this);
            },
            /*VirtueSky.Core.BaseMono.SubTick end.*/

            /*VirtueSky.Core.BaseMono.UnSubTick start.*/
            UnSubTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseMono#UnSubTick", this ); }

                VirtueSky.Core.App.UnSubTick$1(this);
                VirtueSky.Core.App.UnSubLateTick$1(this);
                VirtueSky.Core.App.UnSubFixedTick$1(this);
            },
            /*VirtueSky.Core.BaseMono.UnSubTick end.*/


        }
    });
    /*VirtueSky.Core.BaseMono end.*/

    /*VirtueSky.Core.BaseSO start.*/
    Bridge.define("VirtueSky.Core.BaseSO", {
        inherits: [UnityEngine.ScriptableObject,VirtueSky.Core.IEntity],
        fields: {
            description: null
        },
        alias: [
            "Initialize", "VirtueSky$Core$IEntity$Initialize",
            "Tick", "VirtueSky$Core$IEntity$Tick",
            "LateTick", "VirtueSky$Core$IEntity$LateTick",
            "FixedTick", "VirtueSky$Core$IEntity$FixedTick",
            "CleanUp", "VirtueSky$Core$IEntity$CleanUp"
        ],
        methods: {
            /*VirtueSky.Core.BaseSO.Enable start.*/
            Enable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#Enable", this ); }

                this.SubTick();
            },
            /*VirtueSky.Core.BaseSO.Enable end.*/

            /*VirtueSky.Core.BaseSO.Disable start.*/
            Disable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#Disable", this ); }

                this.UnSubTick();
            },
            /*VirtueSky.Core.BaseSO.Disable end.*/

            /*VirtueSky.Core.BaseSO.SubTick start.*/
            SubTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#SubTick", this ); }

                VirtueSky.Core.App.SubTick$1(this);
                VirtueSky.Core.App.SubLateTick$1(this);
                VirtueSky.Core.App.SubFixedTick$1(this);
            },
            /*VirtueSky.Core.BaseSO.SubTick end.*/

            /*VirtueSky.Core.BaseSO.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#Initialize", this ); }
 },
            /*VirtueSky.Core.BaseSO.Initialize end.*/

            /*VirtueSky.Core.BaseSO.Tick start.*/
            Tick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#Tick", this ); }
 },
            /*VirtueSky.Core.BaseSO.Tick end.*/

            /*VirtueSky.Core.BaseSO.LateTick start.*/
            LateTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#LateTick", this ); }
 },
            /*VirtueSky.Core.BaseSO.LateTick end.*/

            /*VirtueSky.Core.BaseSO.FixedTick start.*/
            FixedTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#FixedTick", this ); }
 },
            /*VirtueSky.Core.BaseSO.FixedTick end.*/

            /*VirtueSky.Core.BaseSO.CleanUp start.*/
            CleanUp: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#CleanUp", this ); }
 },
            /*VirtueSky.Core.BaseSO.CleanUp end.*/

            /*VirtueSky.Core.BaseSO.Destroy start.*/
            Destroy: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#Destroy", this ); }
 },
            /*VirtueSky.Core.BaseSO.Destroy end.*/

            /*VirtueSky.Core.BaseSO.UnSubTick start.*/
            UnSubTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.BaseSO#UnSubTick", this ); }

                VirtueSky.Core.App.UnSubTick$1(this);
                VirtueSky.Core.App.UnSubLateTick$1(this);
                VirtueSky.Core.App.UnSubFixedTick$1(this);
            },
            /*VirtueSky.Core.BaseSO.UnSubTick end.*/


        }
    });
    /*VirtueSky.Core.BaseSO end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    /**
     * Holds a reference to a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonDataAsset
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonDataAsset", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    Bridge.define("Spine.Unity.BlendModeMaterialsAsset", {
        inherits: [Spine.Unity.SkeletonDataModifierAsset],
        statics: {
            methods: {
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static start.*/
                ApplyMaterials: function (skeletonData, multiplyTemplate, screenTemplate, additiveTemplate, includeAdditiveSlots) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#ApplyMaterials", this ); }

                    var $t, $t1;
                    if (skeletonData == null) {
                        throw new System.ArgumentNullException.$ctor1("skeletonData");
                    }

                    var materialCache = new Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache();
                    try {
                        var entryBuffer = new (System.Collections.Generic.List$1(spine.SkinEntry)).ctor();
                        var slotsItems = skeletonData.Slots.Items;
                        for (var slotIndex = 0, slotCount = skeletonData.Slots.Count; slotIndex < slotCount; slotIndex = (slotIndex + 1) | 0) {
                            var slot = slotsItems[slotIndex];
                            if (slot.blendMode === spine.BlendMode.Normal) {
                                continue;
                            }
                            if (!includeAdditiveSlots && slot.blendMode === spine.BlendMode.Additive) {
                                continue;
                            }

                            entryBuffer.clear();
                            $t = Bridge.getEnumerator(skeletonData.Skins);
                            try {
                                while ($t.moveNext()) {
                                    var skin = $t.Current;
                                    ( entryBuffer._items.length = 0, skin.getAttachmentsForSlot( slotIndex, entryBuffer._items ), entryBuffer._size = entryBuffer._items.length );
                                }
                            } finally {
                                if (Bridge.is($t, System.IDisposable)) {
                                    $t.System$IDisposable$Dispose();
                                }
                            }

                            var templateMaterial = null;
                            switch (slot.blendMode) {
                                case spine.BlendMode.Multiply: 
                                    templateMaterial = multiplyTemplate;
                                    break;
                                case spine.BlendMode.Screen: 
                                    templateMaterial = screenTemplate;
                                    break;
                                case spine.BlendMode.Additive: 
                                    templateMaterial = additiveTemplate;
                                    break;
                            }
                            if (templateMaterial == null) {
                                continue;
                            }

                            $t1 = Bridge.getEnumerator(entryBuffer);
                            try {
                                while ($t1.moveNext()) {
                                    var entry = $t1.Current;
                                    var renderableAttachment = Bridge.as(entry.attachment, Spine.IHasTextureRegion);
                                    if (renderableAttachment != null) {
                                        renderableAttachment.Spine$IHasTextureRegion$Region = materialCache.CloneAtlasRegionWithMaterial(Bridge.cast(renderableAttachment.Spine$IHasTextureRegion$Region, Spine.AtlasRegion), templateMaterial);
                                    }
                                }
                            } finally {
                                if (Bridge.is($t1, System.IDisposable)) {
                                    $t1.System$IDisposable$Dispose();
                                }
                            }
                        }

                    }
                    finally {
                        if (Bridge.hasValue(materialCache)) {
                            materialCache.System$IDisposable$Dispose();
                        }
                    }
                    //attachmentBuffer.Clear();
                },
                /*Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials:static end.*/


            }
        },
        fields: {
            multiplyMaterialTemplate: null,
            screenMaterialTemplate: null,
            additiveMaterialTemplate: null,
            applyAdditiveMaterial: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#init", this ); }

                this.applyAdditiveMaterial = true;
            }
        },
        methods: {
            /*Spine.Unity.BlendModeMaterialsAsset.Apply start.*/
            Apply: function (skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.BlendModeMaterialsAsset#Apply", this ); }

                Spine.Unity.BlendModeMaterialsAsset.ApplyMaterials(skeletonData, this.multiplyMaterialTemplate, this.screenMaterialTemplate, this.additiveMaterialTemplate, this.applyAdditiveMaterial);
            },
            /*Spine.Unity.BlendModeMaterialsAsset.Apply end.*/


        }
    });
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    /**
     * A Spine-Unity Component that uses a Spine.AnimationState to animate its skeleton.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IAnimationStateComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IAnimationStateComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    /**
     * A Spine-Unity Component that holds a reference to an ISkeletonComponent.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    /**
     * A Spine-Unity Component that holds a reference to a SkeletonRenderer.
     *
     * @abstract
     * @public
     * @class Spine.Unity.IHasSkeletonRenderer
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.IHasSkeletonRenderer", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    /**
     * A Spine-Unity Component that animates a Skeleton but not necessarily with a Spine.AnimationState.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonAnimation
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonAnimation", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    /**
     * A Spine-Unity Component that manages a Spine.Skeleton instance, instantiated from a SkeletonDataAsset.
     *
     * @abstract
     * @public
     * @class Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.ISpineComponent
     */
    Bridge.define("Spine.Unity.ISkeletonComponent", {
        inherits: [Spine.Unity.ISpineComponent],
        $kind: 3
    });
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    /**
     * Add this component to a SkeletonMecanim GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonMecanimRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonMecanimRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultMecanimLayerFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                    this.DefaultMecanimLayerFlags = -1;
                }
            }
        },
        fields: {
            mecanimLayerFlags: 0,
            movementDelta: null,
            rotationDelta: 0,
            skeletonMecanim: null
        },
        props: {
            SkeletonMecanim: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#SkeletonMecanim#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonMecanim) ? this.skeletonMecanim : (this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim));
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#init", this ); }

                this.movementDelta = new UnityEngine.Vector2();
                this.mecanimLayerFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRemainingRootMotion", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var start = time;
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (layerIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#GetRootMotionInfo", this ); }

                var pair = this.skeletonMecanim.Translator.GetActiveAnimationAndTime(layerIndex);
                var animation = pair.key;
                var time = pair.value;
                if (animation == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }
                return this.GetAnimationRootMotionInfo(animation, time);
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.mecanimLayerFlags = Spine.Unity.SkeletonMecanimRootMotion.DefaultMecanimLayerFlags;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                this.skeletonMecanim = this.GetComponent(Spine.Unity.SkeletonMecanim);
                if (UnityEngine.Object.op_Implicit(this.skeletonMecanim)) {
                    this.skeletonMecanim.Translator.removeOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                    this.skeletonMecanim.Translator.addOnClipApplied(Bridge.fn.cacheBind(this, this.OnClipApplied));
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.Start end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied start.*/
            OnClipApplied: function (animation, layerIndex, weight, time, lastTime, playsBackward) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#OnClipApplied", this ); }


                if (((this.mecanimLayerFlags & 1 << layerIndex) === 0) || weight === 0) {
                    return;
                }

                if (!playsBackward) {
                    this.movementDelta = this.movementDelta.$clone().add( this.GetAnimationRootMotion$1(lastTime, time, animation).scale( weight ) );
                } else {
                    this.movementDelta = this.movementDelta.$clone().sub( this.GetAnimationRootMotion$1(time, lastTime, animation).scale( weight ) );
                }
                if (this.transformRotation) {
                    if (!playsBackward) {
                        this.rotationDelta += weight * this.GetAnimationRootMotionRotation$1(lastTime, time, animation);
                    } else {
                        this.rotationDelta -= weight * this.GetAnimationRootMotionRotation$1(time, lastTime, animation);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.OnClipApplied end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsMovementDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.movementDelta.$clone();
                this.movementDelta = pc.Vec2.ZERO.clone();
                return result.$clone();
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanimRootMotion#CalculateAnimationsRotationDelta", this ); }

                // Note: movement delta is not gathered after animation but
                // in OnClipApplied after every applied animation.
                var result = this.rotationDelta;
                this.rotationDelta = 0;
                return result;
            },
            /*Spine.Unity.SkeletonMecanimRootMotion.CalculateAnimationsRotationDelta end.*/


        }
    });
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    /**
     * Add this component to a SkeletonAnimation or SkeletonGraphic GameObject
     to turn motion of a selected root bone into Transform or RigidBody motion.
     Local bone translation movement is used as motion.
     All top-level bones of the skeleton are moved to compensate the root
     motion bone location, keeping the distance relationship between bones intact.
     *
     * @public
     * @class Spine.Unity.SkeletonRootMotion
     * @augments Spine.Unity.SkeletonRootMotionBase
     */
    Bridge.define("Spine.Unity.SkeletonRootMotion", {
        inherits: [Spine.Unity.SkeletonRootMotionBase],
        statics: {
            fields: {
                DefaultAnimationTrackFlags: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                    this.DefaultAnimationTrackFlags = -1;
                }
            }
        },
        fields: {
            animationTrackFlags: 0,
            animationState: null,
            skeletonGraphic: null
        },
        props: {
            AdditionalScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#AdditionalScale#get", this ); }

                    return UnityEngine.Object.op_Implicit(this.skeletonGraphic) ? this.skeletonGraphic.MeshScale : 1.0;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#init", this ); }

                this.animationTrackFlags = -1;
            }
        },
        methods: {
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion start.*/
            GetRemainingRootMotion: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRemainingRootMotion", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return pc.Vec2.ZERO.clone();
                }

                var animation = track.animation;
                var start = track.getAnimationTime();
                var end = animation.duration;
                return this.GetAnimationRootMotion$1(start, end, animation);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRemainingRootMotion end.*/

            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo start.*/
            GetRootMotionInfo: function (trackIndex) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetRootMotionInfo", this ); }

                var track = this.animationState.getCurrent(trackIndex);
                if (track == null) {
                    return new Spine.Unity.SkeletonRootMotionBase.RootMotionInfo();
                }

                var animation = track.animation;
                var time = track.getAnimationTime();
                return this.GetAnimationRootMotionInfo(track.animation, time);
            },
            /*Spine.Unity.SkeletonRootMotion.GetRootMotionInfo end.*/

            /*Spine.Unity.SkeletonRootMotion.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Reset", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Reset.call(this);
                this.animationTrackFlags = Spine.Unity.SkeletonRootMotion.DefaultAnimationTrackFlags;
            },
            /*Spine.Unity.SkeletonRootMotion.Reset end.*/

            /*Spine.Unity.SkeletonRootMotion.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#Start", this ); }

                Spine.Unity.SkeletonRootMotionBase.prototype.Start.call(this);
                var animstateComponent = Bridge.as(this.skeletonComponent, Spine.Unity.IAnimationStateComponent);
                this.animationState = (animstateComponent != null) ? animstateComponent.Spine$Unity$IAnimationStateComponent$AnimationState : null;

                this.skeletonGraphic = this.GetComponent(Spine.Unity.SkeletonGraphic);
            },
            /*Spine.Unity.SkeletonRootMotion.Start end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta start.*/
            CalculateAnimationsMovementDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsMovementDelta", this ); }

                var localDelta = pc.Vec2.ZERO.clone();
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotion$1(start, end, animation) };
                        if (!pc.Vec2.equals( currentDelta.v, pc.Vec2.ZERO.clone() )) {
                            this.ApplyMixAlphaToDelta$1(currentDelta, next, track);
                            localDelta = localDelta.$clone().add( currentDelta.v.$clone() );
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta.$clone();
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsMovementDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta start.*/
            CalculateAnimationsRotationDelta: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#CalculateAnimationsRotationDelta", this ); }

                var localDelta = 0;
                var trackCount = this.animationState.Tracks.Count;

                for (var trackIndex = 0; trackIndex < trackCount; trackIndex = (trackIndex + 1) | 0) {
                    // note: animationTrackFlags != -1 below covers trackIndex >= 32,
                    // with -1 corresponding to entry "everything" of the dropdown list.
                    if (this.animationTrackFlags !== -1 && (this.animationTrackFlags & 1 << trackIndex) === 0) {
                        continue;
                    }

                    var track = this.animationState.getCurrent(trackIndex);
                    var next = null;
                    while (track != null) {
                        var animation = track.animation;
                        var start = track.animationLast;
                        var end = track.getAnimationTime();
                        var currentDelta = { v : this.GetAnimationRootMotionRotation$1(start, end, animation) };
                        if (currentDelta.v !== 0) {
                            this.ApplyMixAlphaToDelta(currentDelta, next, track);
                            localDelta += currentDelta.v;
                        }

                        // Traverse mixingFrom chain.
                        next = track;
                        track = track.mixingFrom;
                    }
                }
                return localDelta;
            },
            /*Spine.Unity.SkeletonRootMotion.CalculateAnimationsRotationDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 start.*/
            ApplyMixAlphaToDelta$1: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta$1", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v = currentDelta.v.$clone().scale( mixAlpha.v );
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta$1 end.*/

            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta start.*/
            ApplyMixAlphaToDelta: function (currentDelta, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#ApplyMixAlphaToDelta", this ); }

                var mixAlpha = { v : 1 };
                this.GetMixAlpha(mixAlpha, next, track);
                currentDelta.v *= mixAlpha.v;
            },
            /*Spine.Unity.SkeletonRootMotion.ApplyMixAlphaToDelta end.*/

            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha start.*/
            GetMixAlpha: function (cumulatedMixAlpha, next, track) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRootMotion#GetMixAlpha", this ); }

                // code below based on AnimationState.cs
                var mix;
                if (next != null) {
                    if (next.mixDuration === 0) { // Single frame mix to undo mixingFrom changes.
                        mix = 1;
                    } else {
                        mix = next.mixTime / next.mixDuration;
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    var mixAndAlpha = track.alpha * next.interruptAlpha * (1 - mix);
                    cumulatedMixAlpha.v *= mixAndAlpha;
                } else {
                    if (track.mixDuration === 0) {
                        mix = 1;
                    } else {
                        mix = track.alpha * (track.mixTime / track.mixDuration);
                        if (mix > 1) {
                            mix = 1;
                        }
                    }
                    cumulatedMixAlpha.v *= mix;
                }
            },
            /*Spine.Unity.SkeletonRootMotion.GetMixAlpha end.*/


        },
        overloads: {
            "ApplyMixAlphaToDelta(Vector2, TrackEntry, TrackEntry)": "ApplyMixAlphaToDelta$1"
        }
    });
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SpineAnimation start.*/
    Bridge.define("Spine.Unity.SpineAnimation", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAnimation#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAnimation end.*/
    /**
     * @memberof System
     * @callback System.Func
     * @param   {Spine.Unity.SpineAtlasAsset}    arg
     * @return  {Spine.TextureLoader}
     */


    /*Spine.Unity.SpineAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}           atlasText                 
                 * @param   {Array.<UnityEngine.Material>}    materials                 
                 * @param   {boolean}                         initialize                
                 * @param   {System.Func}                     newCustomTextureLoader    When not null, a function instantiating
                 a custom <pre><code>TextureLoader</code></pre> with the newly created <pre><code>SpineAtlasAsset</code></pre> as argument
                 is used instead of instantiating the default <pre><code>MaterialsTextureLoader</code></pre>.
                 A valid parameter is e.g. <pre><code>(a) =&gt; new CustomTextureLoader(a)</code></pre>
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 */
                CreateRuntimeInstance: function (atlasText, materials, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.atlasFile = atlasText;
                    atlasAsset.materials = materials;
                    if (!Bridge.staticEquals(newCustomTextureLoader, null)) {
                        atlasAsset.customTextureLoader = newCustomTextureLoader(atlasAsset);
                    }

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static start.*/
                /**
                 * Creates a runtime AtlasAsset. Only providing the textures is slower
                 because it has to search for atlas page matches.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineAtlasAsset
                 * @memberof Spine.Unity.SpineAtlasAsset
                 * @param   {UnityEngine.TextAsset}            atlasText                 
                 * @param   {Array.<UnityEngine.Texture2D>}    textures                  An array of all textures referenced in the provided <pre><code>atlasText</code></pre>
                 atlas asset JSON file. When procedurally creating textures, each <pre><code>Texture.name</code></pre>
                 needs to be set to the atlas page texture filename without the .png extension,
                 e.g. 'my_skeleton' if the png filename listed in the atlas asset file is 'my_skeleton.png'.
                 * @param   {UnityEngine.Material}             materialPropertySource    
                 * @param   {boolean}                          initialize                
                 * @param   {System.Func}                      newCustomTextureLoader
                 * @return  {Spine.Unity.SpineAtlasAsset}
                 * @see {@link SpineAtlasAsset.CreateRuntimeInstance(TextAsset, Material[], bool, Func{SpineAtlasAsset, TextureLoader})}
                 */
                CreateRuntimeInstance$1: function (atlasText, textures, materialPropertySource, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$1", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    // Get atlas page names.
                    var atlasString = atlasText.text;
                    atlasString = System.String.replaceAll(atlasString, "\r", "");
                    var atlasLines = System.String.split(atlasString, [10].map(function (i) {{ return String.fromCharCode(i); }}));
                    var pages = new (System.Collections.Generic.List$1(System.String)).ctor();
                    for (var i = 0; i < ((atlasLines.length - 1) | 0); i = (i + 1) | 0) {
                        var line = atlasLines[i].trim();
                        if (System.String.endsWith(line, ".png")) {
                            pages.add(System.String.replaceAll(line, ".png", ""));
                        }
                    }

                    // Populate Materials[] by matching texture names with page names.
                    var materials = System.Array.init(pages.Count, null, UnityEngine.Material);
                    for (var i1 = 0, n = pages.Count; i1 < n; i1 = (i1 + 1) | 0) {
                        var mat = null;

                        // Search for a match.
                        var pageName = pages.getItem(i1);
                        for (var j = 0, m = textures.length; j < m; j = (j + 1) | 0) {
                            if (System.String.equals(pageName, textures[j].name, 5)) {
                                // Match found.
                                mat = new UnityEngine.Material.$ctor1(materialPropertySource);
                                mat.mainTexture = textures[j];
                                break;
                            }
                        }

                        if (mat != null) {
                            materials[i1] = mat;
                        } else {
                            throw new System.ArgumentException.$ctor1("Could not find matching atlas page in the texture array.");
                        }
                    }

                    // Create AtlasAsset normally
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance(atlasText, materials, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1:static end.*/

                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static start.*/
                
                CreateRuntimeInstance$2: function (atlasText, textures, shader, initialize, newCustomTextureLoader) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#CreateRuntimeInstance$2", this ); }

                    if (newCustomTextureLoader === void 0) { newCustomTextureLoader = null; }

                    if (shader == null) {
                        shader = UnityEngine.Shader.Find("Spine/Skeleton");
                    }

                    var materialProperySource = new UnityEngine.Material.$ctor2(shader);
                    return Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$1(atlasText, textures, materialProperySource, initialize, newCustomTextureLoader);
                },
                /*Spine.Unity.SpineAtlasAsset.CreateRuntimeInstance$2:static end.*/


            }
        },
        fields: {
            atlasFile: null,
            materials: null,
            customTextureLoader: null,
            atlas: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineAtlasAsset
             * @memberof Spine.Unity.SpineAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.atlasFile == null) {
                    UnityEngine.Debug.LogError$2("Atlas file not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for atlas asset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    var loader;
                    if (!onlyMetaData) {
                        loader = this.customTextureLoader == null ? new Spine.Unity.MaterialsTextureLoader(this) : this.customTextureLoader;
                    } else {
                        loader = new Spine.Unity.NoOpTextureLoader();
                    }
                    this.atlas = new Spine.Atlas.$ctor1(new System.IO.StringReader(this.atlasFile.text), "", loader);
                    this.atlas.FlipV();
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error reading atlas file for atlas asset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineAtlasAsset.GenerateMesh start.*/
            GenerateMesh: function (name, mesh, material, scale) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAtlasAsset#GenerateMesh", this ); }

                if (scale === void 0) { scale = 0.01; }
                var region = this.atlas.findRegion(name);
                material.v = null;
                if (region != null) {
                    if (mesh == null) {
                        mesh = new UnityEngine.Mesh.ctor();
                        mesh.name = name;
                    }

                    var verts = System.Array.init(4, function (){
                        return new UnityEngine.Vector3();
                    }, UnityEngine.Vector3);
                    var uvs = System.Array.init(4, function (){
                        return new UnityEngine.Vector2();
                    }, UnityEngine.Vector2);
                    var colors = System.Array.init([
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 ), 
                        new pc.Color( 1, 1, 1, 1 )
                    ], UnityEngine.Color);
                    var triangles = System.Array.init([
                        0, 
                        1, 
                        2, 
                        2, 
                        3, 
                        0
                    ], System.Int32);

                    var left, right, top, bottom;
                    left = region.width / -2.0;
                    right = left * -1.0;
                    top = region.height / 2.0;
                    bottom = top * -1;

                    verts[0] = new pc.Vec3( left, bottom, 0 ).clone().scale( scale );
                    verts[1] = new pc.Vec3( left, top, 0 ).clone().scale( scale );
                    verts[2] = new pc.Vec3( right, top, 0 ).clone().scale( scale );
                    verts[3] = new pc.Vec3( right, bottom, 0 ).clone().scale( scale );
                    var u, v, u2, v2;
                    u = region.u;
                    v = region.v;
                    u2 = region.u2;
                    v2 = region.v2;

                    if (region.degrees === 90) {
                        uvs[0] = new pc.Vec2( u2, v2 );
                        uvs[1] = new pc.Vec2( u, v2 );
                        uvs[2] = new pc.Vec2( u, v );
                        uvs[3] = new pc.Vec2( u2, v );
                    } else {
                        uvs[0] = new pc.Vec2( u, v2 );
                        uvs[1] = new pc.Vec2( u, v );
                        uvs[2] = new pc.Vec2( u2, v );
                        uvs[3] = new pc.Vec2( u2, v2 );
                    }

                    mesh.triangles = System.Array.init(0, 0, System.Int32);
                    mesh.vertices = verts;
                    mesh.uv = uvs;
                    mesh.colors = colors;
                    mesh.triangles = triangles;
                    mesh.RecalculateNormals();
                    mesh.RecalculateBounds();

                    material.v = Bridge.cast(region.page.rendererObject, UnityEngine.Material);
                } else {
                    mesh = null;
                }

                return mesh;
            },
            /*Spine.Unity.SpineAtlasAsset.GenerateMesh end.*/


        }
    });
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.SpineAttachment start.*/
    Bridge.define("Spine.Unity.SpineAttachment", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineAttachment.getHierarchy:static start.*/
                getHierarchy: function (fullPath) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getHierarchy", this ); }

                    return new Spine.Unity.SpineAttachment.Hierarchy.$ctor1(fullPath);
                },
                /*Spine.Unity.SpineAttachment.getHierarchy:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment:static start.*/
                getAttachment: function (attachmentPath, skeletonData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment", this ); }

                    var hierarchy = Spine.Unity.SpineAttachment.getHierarchy(attachmentPath);
                    if (System.String.isNullOrEmpty(hierarchy.name)) {
                        return null;
                    }

                    var slot = skeletonData.findSlot(hierarchy.slot);
                    if (slot == null) {
                        return null;
                    }
                    return skeletonData.findSkin(hierarchy.skin).getAttachment(slot.index, hierarchy.name);
                },
                /*Spine.Unity.SpineAttachment.getAttachment:static end.*/

                /*Spine.Unity.SpineAttachment.getAttachment$1:static start.*/
                getAttachment$1: function (attachmentPath, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#getAttachment$1", this ); }

                    return Spine.Unity.SpineAttachment.getAttachment(attachmentPath, skeletonDataAsset.GetSkeletonData(true));
                },
                /*Spine.Unity.SpineAttachment.getAttachment$1:static end.*/


            }
        },
        fields: {
            returnAttachmentPath: false,
            currentSkinOnly: false,
            placeholdersOnly: false,
            skinField: null,
            slotField: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#init", this ); }

                this.returnAttachmentPath = false;
                this.currentSkinOnly = false;
                this.placeholdersOnly = false;
                this.skinField = "";
                this.slotField = "";
            },
            
            ctor: function (currentSkinOnly, returnAttachmentPath, placeholdersOnly, slotField, dataField, skinField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineAttachment#ctor", this ); }

                if (currentSkinOnly === void 0) { currentSkinOnly = true; }
                if (returnAttachmentPath === void 0) { returnAttachmentPath = false; }
                if (placeholdersOnly === void 0) { placeholdersOnly = false; }
                if (slotField === void 0) { slotField = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (skinField === void 0) { skinField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.currentSkinOnly = currentSkinOnly;
                this.returnAttachmentPath = returnAttachmentPath;
                this.placeholdersOnly = placeholdersOnly;
                this.slotField = slotField;
                this.dataField = dataField;
                this.skinField = skinField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineBone start.*/
    Bridge.define("Spine.Unity.SpineBone", {
        inherits: [Spine.Unity.SpineAttributeBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineBone.getBone:static start.*/
                getBone: function (boneName, renderer) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBone", this ); }

                    return renderer.skeleton == null ? null : renderer.skeleton.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBone:static end.*/

                /*Spine.Unity.SpineBone.getBoneData:static start.*/
                getBoneData: function (boneName, skeletonDataAsset) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#getBoneData", this ); }

                    var data = skeletonDataAsset.GetSkeletonData(true);
                    return data.findBone(boneName);
                },
                /*Spine.Unity.SpineBone.getBoneData:static end.*/


            }
        },
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineBone#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineEvent start.*/
    Bridge.define("Spine.Unity.SpineEvent", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            /**
             * Smart popup menu for Spine Events (Spine.EventData)
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SpineEvent
             * @default false
             * @type boolean
             */
            audioOnly: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#init", this ); }

                this.audioOnly = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, audioOnly) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineEvent#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (audioOnly === void 0) { audioOnly = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.audioOnly = audioOnly;
            }
        }
    });
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    Bridge.define("Spine.Unity.SpineIkConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine IK Constraints (Spine.IkConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpineIkConstraint
             * @memberof Spine.Unity.SpineIkConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField    If true, and an animation list source can't be found, the field will fall back to a normal text field. If false, it will show an error.
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineIkConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    Bridge.define("Spine.Unity.SpinePathConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            /**
             * Smart popup menu for Spine Events (Spine.PathConstraint)
             *
             * @instance
             * @public
             * @this Spine.Unity.SpinePathConstraint
             * @memberof Spine.Unity.SpinePathConstraint
             * @param   {string}     startsWith             Filters popup results to elements that begin with supplied string.
             * @param   {string}     dataField              If specified, a locally scoped field with the name supplied by in dataField will be used to fill the popup results.
             Valid types are SkeletonDataAsset and SkeletonRenderer (and derivatives).
             If left empty and the script the attribute is applied to is derived from Component, GetComponent(SkeletonRenderer)() will be called as a fallback.
             * @param   {boolean}    includeNone            If true, the dropdown list will include a "none" option which stored as an empty string.
             * @param   {boolean}    fallbackToTextField
             * @return  {void}
             */
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpinePathConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    Bridge.define("Spine.Unity.SpineSkin", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            
            defaultAsEmptyString: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#init", this ); }

                this.defaultAsEmptyString = false;
            },
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField, defaultAsEmptyString) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSkin#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }
                if (defaultAsEmptyString === void 0) { defaultAsEmptyString = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
                this.defaultAsEmptyString = defaultAsEmptyString;
            }
        }
    });
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineSlot start.*/
    Bridge.define("Spine.Unity.SpineSlot", {
        inherits: [Spine.Unity.SpineAttributeBase],
        fields: {
            containsBoundingBoxes: false
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#init", this ); }

                this.containsBoundingBoxes = false;
            },
            
            ctor: function (startsWith, dataField, containsBoundingBoxes, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSlot#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (containsBoundingBoxes === void 0) { containsBoundingBoxes = false; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.containsBoundingBoxes = containsBoundingBoxes;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    /**
     * Loads and stores a Spine atlas and list of materials.
     *
     * @public
     * @class Spine.Unity.SpineSpriteAtlasAsset
     * @augments Spine.Unity.AtlasAssetBase
     */
    Bridge.define("Spine.Unity.SpineSpriteAtlasAsset", {
        inherits: [Spine.Unity.AtlasAssetBase],
        statics: {
            methods: {
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static start.*/
                /**
                 * Creates a runtime AtlasAsset
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SpineSpriteAtlasAsset
                 * @memberof Spine.Unity.SpineSpriteAtlasAsset
                 * @param   {UnityEngine.U2D.SpriteAtlas}          spriteAtlasFile    
                 * @param   {Array.<UnityEngine.Material>}         materials          
                 * @param   {boolean}                              initialize
                 * @return  {Spine.Unity.SpineSpriteAtlasAsset}
                 */
                CreateRuntimeInstance: function (spriteAtlasFile, materials, initialize) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#CreateRuntimeInstance", this ); }

                    var atlasAsset = UnityEngine.ScriptableObject.CreateInstance(Spine.Unity.SpineSpriteAtlasAsset);
                    atlasAsset.Reset();
                    atlasAsset.spriteAtlasFile = spriteAtlasFile;
                    atlasAsset.materials = materials;

                    if (initialize) {
                        atlasAsset.GetAtlas();
                    }

                    return atlasAsset;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.CreateRuntimeInstance:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static start.*/
                AccessPackedTexture: function (sprites) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedTexture", this ); }

                    return sprites[0].texture;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture:static end.*/

                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static start.*/
                AccessPackedSprites: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AccessPackedSprites", this ); }

                    var sprites = null;
                    if (sprites == null) {
                        sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                        spriteAtlas.GetSprites(sprites);
                        if (sprites.length === 0) {
                            return null;
                        }
                    }
                    return sprites;
                },
                /*Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites:static end.*/


            }
        },
        fields: {
            spriteAtlasFile: null,
            materials: null,
            atlas: null,
            updateRegionsInPlayMode: false,
            savedRegions: null
        },
        props: {
            IsLoaded: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#IsLoaded#get", this ); }

                    return this.atlas != null;
                }
            },
            Materials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Materials#get", this ); }

                    return this.materials;
                }
            },
            MaterialCount: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#MaterialCount#get", this ); }

                    return this.materials == null ? 0 : this.materials.length;
                }
            },
            PrimaryMaterial: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#PrimaryMaterial#get", this ); }

                    return this.materials[0];
                }
            }
        },
        methods: {
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Reset", this ); }

                this.Clear();
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Reset end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#Clear", this ); }

                this.atlas = null;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.Clear end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas start.*/
            /**
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SpineSpriteAtlasAsset
             * @memberof Spine.Unity.SpineSpriteAtlasAsset
             * @param   {boolean}        onlyMetaData
             * @return  {Spine.Atlas}                    The atlas or null if it could not be loaded.
             */
            GetAtlas: function (onlyMetaData) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#GetAtlas", this ); }

                if (onlyMetaData === void 0) { onlyMetaData = false; }
                if (this.spriteAtlasFile == null) {
                    UnityEngine.Debug.LogError$2("SpriteAtlas file not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (!onlyMetaData && (this.materials == null || this.materials.length === 0)) {
                    UnityEngine.Debug.LogError$2("Materials not set for SpineSpriteAtlasAsset: " + (this.name || ""), this);
                    this.Clear();
                    return null;
                }

                if (this.atlas != null) {
                    return this.atlas;
                }

                try {
                    this.atlas = this.LoadAtlas(this.spriteAtlasFile);
                    return this.atlas;
                } catch (ex) {
                    ex = System.Exception.create(ex);
                    UnityEngine.Debug.LogError$2("Error analyzing SpriteAtlas for SpineSpriteAtlasAsset: " + (this.name || "") + "\n" + (ex.Message || "") + "\n" + (ex.StackTrace || ""), this);
                    return null;
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.GetAtlas end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions start.*/
            AssignRegionsFromSavedRegions: function (sprites, usedAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#AssignRegionsFromSavedRegions", this ); }

                var $t;

                if (this.savedRegions == null || this.savedRegions.length !== sprites.length) {
                    return;
                }

                var i = 0;
                $t = Bridge.getEnumerator(usedAtlas);
                try {
                    while ($t.moveNext()) {
                        var region = $t.Current;
                        var savedRegion = this.savedRegions[i];
                        var page = region.page;

                        region.degrees = savedRegion.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                        var x = savedRegion.x;
                        var y = savedRegion.y;
                        var width = savedRegion.width;
                        var height = savedRegion.height;

                        region.u = x / page.width;
                        region.v = y / page.height;
                        if (region.degrees === 90) {
                            region.u2 = (x + height) / page.width;
                            region.v2 = (y + width) / page.height;
                        } else {
                            region.u2 = (x + width) / page.width;
                            region.v2 = (y + height) / page.height;
                        }
                        region.x = Bridge.Int.clip32(x);
                        region.y = Bridge.Int.clip32(y);
                        region.width = Math.abs(Bridge.Int.clip32(width));
                        region.height = Math.abs(Bridge.Int.clip32(height));

                        // flip upside down
                        var temp = region.v;
                        region.v = region.v2;
                        region.v2 = temp;

                        region.originalWidth = Bridge.Int.clip32(width);
                        region.originalHeight = Bridge.Int.clip32(height);

                        // note: currently sprite pivot offsets are ignored.
                        // Sprite sprite = sprites[i];
                        region.offsetX = 0; //sprite.pivot.x;
                        region.offsetY = 0; //sprite.pivot.y;

                        i = (i + 1) | 0;
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.AssignRegionsFromSavedRegions end.*/

            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas start.*/
            LoadAtlas: function (spriteAtlas) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineSpriteAtlasAsset#LoadAtlas", this ); }


                var pages = new (System.Collections.Generic.List$1(Spine.AtlasPage)).ctor();
                var regions = new (System.Collections.Generic.List$1(Spine.AtlasRegion)).ctor();

                var sprites = System.Array.init(spriteAtlas.spriteCount, null, UnityEngine.Sprite);
                spriteAtlas.GetSprites(sprites);
                if (sprites.length === 0) {
                    return new Spine.Atlas.ctor(pages, regions);
                }

                var texture = null;
                texture = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedTexture(sprites);

                var material = this.materials[0];
                material.mainTexture = texture;

                var page = new Spine.AtlasPage();
                page.name = spriteAtlas.name;
                page.width = texture.width;
                page.height = texture.height;
                page.format = Spine.Format.RGBA8888;

                page.minFilter = spine.TextureFilter.Linear;
                page.magFilter = spine.TextureFilter.Linear;
                page.uWrap = spine.TextureWrap.ClampToEdge;
                page.vWrap = spine.TextureWrap.ClampToEdge;
                page.rendererObject = material;
                pages.add(page);

                sprites = Spine.Unity.SpineSpriteAtlasAsset.AccessPackedSprites(spriteAtlas);

                var i = 0;
                for (; i < sprites.length; i = (i + 1) | 0) {
                    var sprite = sprites[i];
                    var region = new Spine.AtlasRegion();
                    region.name = System.String.replaceAll(sprite.name, "(Clone)", "");
                    region.page = page;
                    region.degrees = sprite.packingRotation === UnityEngine.SpritePackingRotation.None ? 0 : 90;

                    region.u2 = 1;
                    region.v2 = 1;
                    region.width = page.width;
                    region.height = page.height;
                    region.originalWidth = page.width;
                    region.originalHeight = page.height;

                    region.index = i;
                    regions.add(region);
                }

                var atlas = new Spine.Atlas.ctor(pages, regions);
                this.AssignRegionsFromSavedRegions(sprites, atlas);

                return atlas;
            },
            /*Spine.Unity.SpineSpriteAtlasAsset.LoadAtlas end.*/


        }
    });
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    Bridge.define("Spine.Unity.SpineTransformConstraint", {
        inherits: [Spine.Unity.SpineAttributeBase],
        ctors: {
            
            ctor: function (startsWith, dataField, includeNone, fallbackToTextField) {
if ( TRACE ) { TRACE( "Spine.Unity.SpineTransformConstraint#ctor", this ); }

                if (startsWith === void 0) { startsWith = ""; }
                if (dataField === void 0) { dataField = ""; }
                if (includeNone === void 0) { includeNone = true; }
                if (fallbackToTextField === void 0) { fallbackToTextField = false; }

                this.$initialize();
                Spine.Unity.SpineAttributeBase.ctor.call(this);
                this.startsWith = startsWith;
                this.dataField = dataField;
                this.includeNone = includeNone;
                this.fallbackToTextField = fallbackToTextField;
            }
        }
    });
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*TheBeginning.Services.PoolInitialization start.*/
    Bridge.define("TheBeginning.Services.PoolInitialization", {
        inherits: [TheBeginning.Services.ServiceInitialization],
        methods: {
            /*TheBeginning.Services.PoolInitialization.Initialization start.*/
            Initialization: function () {
if ( TRACE ) { TRACE( "TheBeginning.Services.PoolInitialization#Initialization", this ); }

                VirtueSky.ObjectPooling.Pool.InitPool();
            },
            /*TheBeginning.Services.PoolInitialization.Initialization end.*/


        }
    });
    /*TheBeginning.Services.PoolInitialization end.*/

    /*TheBeginning.Services.VibrationInitialization start.*/
    Bridge.define("TheBeginning.Services.VibrationInitialization", {
        inherits: [TheBeginning.Services.ServiceInitialization],
        methods: {
            /*TheBeginning.Services.VibrationInitialization.Initialization start.*/
            Initialization: function () {
if ( TRACE ) { TRACE( "TheBeginning.Services.VibrationInitialization#Initialization", this ); }

                VirtueSky.Vibration.Vibration.Init();
            },
            /*TheBeginning.Services.VibrationInitialization.Initialization end.*/


        }
    });
    /*TheBeginning.Services.VibrationInitialization end.*/

    /*VirtueSky.Events.BaseEventResponse start.*/
    Bridge.define("VirtueSky.Events.BaseEventResponse", {
        inherits: [UnityEngine.Events.UnityEvent,VirtueSky.Events.IEventResponse]
    });
    /*VirtueSky.Events.BaseEventResponse end.*/

    /*VirtueSky.Events.BaseEventResponse$1 start.*/
    Bridge.define("VirtueSky.Events.BaseEventResponse$1", function (TType) { return {
        inherits: [UnityEngine.Events.UnityEvent$1(TType),VirtueSky.Events.IEventResponse]
    }; });
    /*VirtueSky.Events.BaseEventResponse$1 end.*/

    /*VirtueSky.UIButton.ButtonText start.*/
    Bridge.define("VirtueSky.UIButton.ButtonText", {
        inherits: [VirtueSky.UIButton.ButtonCustom]
    });
    /*VirtueSky.UIButton.ButtonText end.*/

    /*VirtueSky.UIButton.ButtonTMP start.*/
    Bridge.define("VirtueSky.UIButton.ButtonTMP", {
        inherits: [VirtueSky.UIButton.ButtonCustom]
    });
    /*VirtueSky.UIButton.ButtonTMP end.*/

    /*VirtueSky.UIButton.ButtonUI start.*/
    Bridge.define("VirtueSky.UIButton.ButtonUI", {
        inherits: [VirtueSky.UIButton.ButtonCustom]
    });
    /*VirtueSky.UIButton.ButtonUI end.*/

    /*VirtueSky.UIButton.ButtonUI_Text start.*/
    Bridge.define("VirtueSky.UIButton.ButtonUI_Text", {
        inherits: [VirtueSky.UIButton.ButtonCustom]
    });
    /*VirtueSky.UIButton.ButtonUI_Text end.*/

    /*VirtueSky.UIButton.ButtonUI_TMP start.*/
    Bridge.define("VirtueSky.UIButton.ButtonUI_TMP", {
        inherits: [VirtueSky.UIButton.ButtonCustom]
    });
    /*VirtueSky.UIButton.ButtonUI_TMP end.*/

    /*VirtueSky.Variables.BaseReference start.*/
    Bridge.define("VirtueSky.Variables.BaseReference", {
        inherits: [VirtueSky.Variables.IReference]
    });
    /*VirtueSky.Variables.BaseReference end.*/

    /*VirtueSky.Variables.IReference$2 start.*/
    Bridge.definei("VirtueSky.Variables.IReference$2", function (TType, TVariable) { return {
        inherits: [VirtueSky.Variables.IReference],
        $kind: 3
    }; });
    /*VirtueSky.Variables.IReference$2 end.*/

    /*AnimatorComponent start.*/
    Bridge.define("AnimatorComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            _animator: null
        },
        methods: {
            /*AnimatorComponent.Play start.*/
            Play: function (animationName, layer, normalizedTime) {
if ( TRACE ) { TRACE( "AnimatorComponent#Play", this ); }

                if (layer === void 0) { layer = -1; }
                if (normalizedTime === void 0) { normalizedTime = 0.0; }
                this._animator.Play$4(animationName, layer, normalizedTime);
            },
            /*AnimatorComponent.Play end.*/

            /*AnimatorComponent.Stop start.*/
            Stop: function () {
if ( TRACE ) { TRACE( "AnimatorComponent#Stop", this ); }

                this._animator.StopPlayback();
            },
            /*AnimatorComponent.Stop end.*/

            /*AnimatorComponent.SetSpeed start.*/
            SetSpeed: function (speed) {
if ( TRACE ) { TRACE( "AnimatorComponent#SetSpeed", this ); }

                this._animator.speed = speed;
            },
            /*AnimatorComponent.SetSpeed end.*/


        }
    });
    /*AnimatorComponent end.*/

    /*CameraSystem start.*/
    Bridge.define("CameraSystem", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            screenSizeOrigin: null,
            cameraTarget: null,
            _fieldOfView: 0,
            _aspectOrigin: 0,
            _aspect: 0,
            _reNativeValue: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CameraSystem#init", this ); }

                this.screenSizeOrigin = new UnityEngine.Vector2();
                this.screenSizeOrigin = new pc.Vec2( 1080, 1920 );
            }
        },
        methods: {
            /*CameraSystem.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "CameraSystem#Awake", this ); }

                this._fieldOfView = this.cameraTarget.fieldOfView;
                this._aspectOrigin = this.screenSizeOrigin.x / this.screenSizeOrigin.y;
                this._aspect = this.cameraTarget.aspect;

                this.ReNative();
            },
            /*CameraSystem.Awake end.*/

            /*CameraSystem.ReNative start.*/
            ReNative: function () {
if ( TRACE ) { TRACE( "CameraSystem#ReNative", this ); }

                this._reNativeValue = this._aspectOrigin / this._aspect;
                this.cameraTarget.fieldOfView = this._fieldOfView * this._reNativeValue;
                this.CheckDeviceResolution();

            },
            /*CameraSystem.ReNative end.*/

            /*CameraSystem.CheckDeviceResolution start.*/
            CheckDeviceResolution: function () {
if ( TRACE ) { TRACE( "CameraSystem#CheckDeviceResolution", this ); }

                if (this._aspect > 1.5) {
                    this.cameraTarget.fieldOfView *= 1.65;
                } else if (this._aspect > 1.0) {
                    this.cameraTarget.fieldOfView *= 1.5;
                } else if (this._aspect > 0.6) {
                    this.cameraTarget.fieldOfView *= 1.4;
                } else if (this._aspect < 0.5) {
                    this.cameraTarget.fieldOfView *= 0.875;
                }
            },
            /*CameraSystem.CheckDeviceResolution end.*/


        }
    });
    /*CameraSystem end.*/

    /*ObjectBase start.*/
    Bridge.define("ObjectBase", {
        inherits: [VirtueSky.Core.BaseMono,IObject,IFreezer],
        fields: {
            objectName: null,
            girdSize: null,
            heightOrigin: 0,
            size: null,
            eRotationType: 0,
            materialCurrent: null,
            centerModel: null,
            isStarttingLevel: null,
            listColliders: null,
            eColorType: 0,
            colorConfig: null,
            path: null,
            colorMaterialName: null,
            pivotType: 0,
            model: null,
            yAxis: 0,
            isHaveStar: false,
            objectStarPrefab: null,
            objectStar: null,
            isFreeze: false,
            freezeCount: 0,
            textSize: 0,
            materialFreezeOverride: null,
            _isAlive: false,
            _renderer: null,
            _meshFilter: null,
            IsFrezering: false,
            FreezeCurrentCount: 0
        },
        props: {
            IsAlive: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#IsAlive#get", this ); }

                    return this._isAlive;
                }
            },
            IsCanMove: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#IsCanMove#get", this ); }

                    return this.IsAlive && !this.IsFrezering;
                }
            },
            IsHaveStar: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#IsHaveStar#get", this ); }

                    return this.isHaveStar;
                }
            },
            Size: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#Size#get", this ); }

                    return this.GetSize();
                }
            },
            ListColliders: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#ListColliders#get", this ); }

                    var $t;
                    if (this.listColliders.Count === 0) {
                        this.listColliders = ($t = UnityEngine.Collider, System.Linq.Enumerable.from(this.model.GetComponentsInChildren(UnityEngine.Collider), $t).toList($t));
                    }
                    return this.listColliders;
                }
            },
            YAxis: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#YAxis#get", this ); }

                    return this.yAxis;
                }
            },
            EColorType: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#EColorType#get", this ); }

                    return this.eColorType;
                }
            },
            Color: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#Color#get", this ); }

                    return this.colorConfig.GetColor(this.eColorType);
                }
            },
            Model: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#Model#get", this ); }

                    return this.model;
                }
            },
            Renderer: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#Renderer#get", this ); }

                    return UnityEngine.Component.op_Inequality(this._renderer, null) ? this._renderer : this.model.GetComponentInChildren(UnityEngine.Renderer);
                }
            },
            MeshFilter: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#MeshFilter#get", this ); }

                    return this._meshFilter || this.model.GetComponentInChildren(UnityEngine.MeshFilter);
                }
            },
            GameObject: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#GameObject#get", this ); }

                    return this.gameObject;
                }
            },
            FreezeCenterPosition: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#FreezeCenterPosition#get", this ); }

                    return this.GetCenterPosition();
                }
            },
            FreezeCount: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#FreezeCount#get", this ); }

                    return this.freezeCount;
                }
            },
            TextSize: {
                get: function () {
if ( TRACE ) { TRACE( "ObjectBase#TextSize#get", this ); }

                    return this.textSize;
                }
            }
        },
        alias: [
            "Size", "IObject$Size",
            "YAxis", "IObject$YAxis",
            "IsFrezering", "IFreezer$IsFrezering",
            "GameObject", "IFreezer$GameObject",
            "FreezeCenterPosition", "IFreezer$FreezeCenterPosition",
            "FreezeCount", "IFreezer$FreezeCount",
            "FreezeCurrentCount", "IFreezer$FreezeCurrentCount",
            "TextSize", "IFreezer$TextSize",
            "OnFreezerSetup", "IFreezer$OnFreezerSetup",
            "OnFreezerChanged", "IFreezer$OnFreezerChanged",
            "OnFreezerBreak", "IFreezer$OnFreezerBreak"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ObjectBase#init", this ); }

                this.size = new UnityEngine.Vector3();
                this.heightOrigin = 1.0;
                this.eRotationType = ERotationType.RIGHT;
                this.listColliders = new (System.Collections.Generic.List$1(UnityEngine.Collider)).ctor();
                this.path = "Assets/_Root/Game/Level/Elements/Renders";
                this.colorMaterialName = "_Color";
                this.yAxis = 0;
                this.freezeCount = 5;
                this.textSize = 10.0;
                this._isAlive = true;
            }
        },
        methods: {
            /*ObjectBase.GetCenterPosition start.*/
            GetCenterPosition: function () {
if ( TRACE ) { TRACE( "ObjectBase#GetCenterPosition", this ); }

                return UnityEngine.GameObject.op_Inequality(this.centerModel, null) ? this.centerModel.transform.position.$clone() : (UnityEngine.Object.op_Implicit(this.model) ? this.model.transform.position.$clone() : this.GetPostion());
            },
            /*ObjectBase.GetCenterPosition end.*/

            /*ObjectBase.GetSize start.*/
            GetSize: function () {
if ( TRACE ) { TRACE( "ObjectBase#GetSize", this ); }

                var result = new UnityEngine.Vector2();

                if (this.eRotationType === ERotationType.RIGHT || this.eRotationType === ERotationType.LEFT) {
                    result = new pc.Vec2( this.size.x, this.size.z );
                } else if (this.eRotationType === ERotationType.UP || this.eRotationType === ERotationType.DOWN) {
                    result = new pc.Vec2( this.size.z, this.size.x );
                } else {
                    result = new pc.Vec2( this.size.x, this.size.z );
                }

                return result.$clone();
            },
            /*ObjectBase.GetSize end.*/

            /*ObjectBase.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "ObjectBase#Awake", this ); }

                this.IsFrezering = this.isFreeze;
            },
            /*ObjectBase.Awake end.*/

            /*ObjectBase.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "ObjectBase#Start", this ); }

                this._isAlive = true;
            },
            /*ObjectBase.Start end.*/

            /*ObjectBase.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "ObjectBase#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.Initialize();
                if (UnityEngine.Object.op_Implicit(this.isStarttingLevel)) {
                    this.isStarttingLevel.addOnRaised(Bridge.fn.cacheBind(this, this.OnStarttingLevel));
                }
            },
            /*ObjectBase.OnEnable end.*/

            /*ObjectBase.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "ObjectBase#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.CleanUp();
                if (UnityEngine.Object.op_Implicit(this.isStarttingLevel)) {
                    this.isStarttingLevel.removeOnRaised(Bridge.fn.cacheBind(this, this.OnStarttingLevel));
                }
            },
            /*ObjectBase.OnDisable end.*/

            /*ObjectBase.OnStarttingLevel start.*/
            OnStarttingLevel: function (value) {
if ( TRACE ) { TRACE( "ObjectBase#OnStarttingLevel", this ); }
 },
            /*ObjectBase.OnStarttingLevel end.*/

            /*ObjectBase.Dead start.*/
            Dead: function () {
if ( TRACE ) { TRACE( "ObjectBase#Dead", this ); }

                this._isAlive = false;
            },
            /*ObjectBase.Dead end.*/

            /*ObjectBase.GetWidth start.*/
            GetWidth: function (eDirection, size) {
if ( TRACE ) { TRACE( "ObjectBase#GetWidth", this ); }

                var result;

                if (eDirection === EDirectionType.UP || eDirection === EDirectionType.DOWN) {
                    result = size.x;
                } else if (eDirection === EDirectionType.LEFT || eDirection === EDirectionType.RIGHT) {
                    result = size.y;
                } else {
                    result = 0;
                }

                return result;
            },
            /*ObjectBase.GetWidth end.*/

            /*ObjectBase.GetHeight start.*/
            GetHeight: function (eDirection, size) {
if ( TRACE ) { TRACE( "ObjectBase#GetHeight", this ); }

                var result;

                switch (eDirection) {
                    case EDirectionType.UP: 
                        result = size.y;
                        break;
                    case EDirectionType.DOWN: 
                        result = size.y;
                        break;
                    case EDirectionType.LEFT: 
                        result = size.x;
                        break;
                    case EDirectionType.RIGHT: 
                        result = size.x;
                        break;
                    default: 
                        result = 0;
                        break;
                }

                return result;
            },
            /*ObjectBase.GetHeight end.*/

            /*ObjectBase.ChangeColorType start.*/
            ChangeColorType: function (eColorTypeChange, materialChange) {
if ( TRACE ) { TRACE( "ObjectBase#ChangeColorType", this ); }

                this.eColorType = eColorTypeChange;
                this.materialCurrent = materialChange;
                this.Renderer.material = this.materialCurrent;
                //Renderer.material.color = colorConfig.GetColor(eColorTypeChange);
            },
            /*ObjectBase.ChangeColorType end.*/

            /*ObjectBase.ChangeMesh start.*/
            ChangeMesh: function (mesh) {
if ( TRACE ) { TRACE( "ObjectBase#ChangeMesh", this ); }

                if (UnityEngine.Object.op_Implicit(this.MeshFilter)) {
                    this.MeshFilter.mesh = mesh;
                }
            },
            /*ObjectBase.ChangeMesh end.*/

            /*ObjectBase.UpdateRotation start.*/
            UpdateRotation: function () {
if ( TRACE ) { TRACE( "ObjectBase#UpdateRotation", this ); }

                if (UnityEngine.Object.op_Implicit(this.model)) {
                    this.model.transform.localEulerAngles = new pc.Vec3( this.model.transform.localEulerAngles.x, this.GetYAngle(), this.model.transform.localEulerAngles.z );
                }
            },
            /*ObjectBase.UpdateRotation end.*/

            /*ObjectBase.GetYAngle start.*/
            GetYAngle: function () {
if ( TRACE ) { TRACE( "ObjectBase#GetYAngle", this ); }

                var result;

                if (this.eRotationType === ERotationType.RIGHT) {
                    result = 0;
                } else if (this.eRotationType === ERotationType.UP) {
                    result = 90;
                } else if (this.eRotationType === ERotationType.LEFT) {
                    result = 180;
                } else if (this.eRotationType === ERotationType.DOWN) {
                    result = 270;
                } else {
                    result = 0;
                }

                return result;
            },
            /*ObjectBase.GetYAngle end.*/

            /*ObjectBase.SetPosition start.*/
            SetPosition: function (position) {
if ( TRACE ) { TRACE( "ObjectBase#SetPosition", this ); }

                this.transform.position = new pc.Vec3( position.x, this.yAxis, position.z );
            },
            /*ObjectBase.SetPosition end.*/

            /*ObjectBase.GetPostion start.*/
            GetPostion: function () {
if ( TRACE ) { TRACE( "ObjectBase#GetPostion", this ); }

                return this.transform.position.$clone();
            },
            /*ObjectBase.GetPostion end.*/

            /*ObjectBase.OnFreezerSetup start.*/
            OnFreezerSetup: function (material) {
if ( TRACE ) { TRACE( "ObjectBase#OnFreezerSetup", this ); }

                var mat = this.materialFreezeOverride != null ? this.materialFreezeOverride : material;
                if (UnityEngine.Object.op_Implicit(this.Renderer)) {
                    this.Renderer.material = mat;
                }
            },
            /*ObjectBase.OnFreezerSetup end.*/

            /*ObjectBase.OnFreezerChanged start.*/
            OnFreezerChanged: function () {
if ( TRACE ) { TRACE( "ObjectBase#OnFreezerChanged", this ); }
 },
            /*ObjectBase.OnFreezerChanged end.*/

            /*ObjectBase.OnFreezerBreak start.*/
            OnFreezerBreak: function () {
if ( TRACE ) { TRACE( "ObjectBase#OnFreezerBreak", this ); }

                if (!this._isAlive) {
                    return;
                }
                if (UnityEngine.Object.op_Implicit(this.Renderer)) {
                    this.Renderer.material = this.materialCurrent;
                }
            },
            /*ObjectBase.OnFreezerBreak end.*/


        }
    });
    /*ObjectBase end.*/

    /*CoinGenerate start.*/
    Bridge.define("CoinGenerate", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            coinPrefab: null,
            holder: null,
            numberCoin: 0,
            delay: 0,
            durationNear: 0,
            durationTarget: 0,
            easeNear: 0,
            easeTarget: 0,
            scale: 0,
            offsetNear: 0,
            setFromCoinEvent: null,
            addTargetToCoinGenerateEvent: null,
            removeTargetToCoinGenerateEvent: null,
            moveOneCoinDone: null,
            moveAllCoinDone: null,
            decreaseCoinEvent: null,
            addCoinEvent: null,
            minusCoinEvent: null,
            playSoundFx: null,
            soundCoinMove: null,
            fx: null,
            isScaleIconTo: false,
            from: null,
            to: null,
            coinsActive: null,
            listTo: null,
            cacheCurrentCoin: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CoinGenerate#init", this ); }

                this.from = new UnityEngine.Vector3();
                this.scale = 1;
                this.offsetNear = 1;
                this.isScaleIconTo = false;
                this.coinsActive = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
                this.listTo = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
            }
        },
        methods: {
            /*CoinGenerate.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "CoinGenerate#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.addCoinEvent.AddListener(Bridge.fn.cacheBind(this, this.GenerateCoin));
                this.minusCoinEvent.AddListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.setFromCoinEvent.AddListener$1(Bridge.fn.cacheBind(this, this.SetFrom));
                this.addTargetToCoinGenerateEvent.AddListener$1(Bridge.fn.cacheBind(this, this.AddTo));
                this.removeTargetToCoinGenerateEvent.AddListener$1(Bridge.fn.cacheBind(this, this.RemoveTo));
                this.SetFrom(this.holder.position);
                this.SaveCache();
            },
            /*CoinGenerate.OnEnable end.*/

            /*CoinGenerate.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "CoinGenerate#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.addCoinEvent.RemoveListener(Bridge.fn.cacheBind(this, this.GenerateCoin));
                this.minusCoinEvent.RemoveListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.setFromCoinEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.SetFrom));
                this.addTargetToCoinGenerateEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.AddTo));
                this.removeTargetToCoinGenerateEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.RemoveTo));
            },
            /*CoinGenerate.OnDisable end.*/

            /*CoinGenerate.SaveCache start.*/
            SaveCache: function () {
if ( TRACE ) { TRACE( "CoinGenerate#SaveCache", this ); }

                this.cacheCurrentCoin = CoinSystem.GetCurrentCoin();
            },
            /*CoinGenerate.SaveCache end.*/

            /*CoinGenerate.DecreaseCoin start.*/
            DecreaseCoin: function () {
if ( TRACE ) { TRACE( "CoinGenerate#DecreaseCoin", this ); }

                this.decreaseCoinEvent.Raise();
                this.SaveCache();
            },
            /*CoinGenerate.DecreaseCoin end.*/

            /*CoinGenerate.SetFrom start.*/
            SetFrom: function (from) {
if ( TRACE ) { TRACE( "CoinGenerate#SetFrom", this ); }

                this.from = from.$clone();
            },
            /*CoinGenerate.SetFrom end.*/

            /*CoinGenerate.AddTo start.*/
            AddTo: function (obj) {
if ( TRACE ) { TRACE( "CoinGenerate#AddTo", this ); }

                this.listTo.add(obj);
                this.to = this.GetToNear();
            },
            /*CoinGenerate.AddTo end.*/

            /*CoinGenerate.RemoveTo start.*/
            RemoveTo: function (obj) {
if ( TRACE ) { TRACE( "CoinGenerate#RemoveTo", this ); }

                this.listTo.remove(obj);
                if (this.listTo.Count > 0) {
                    this.to = this.GetToNear();
                }
            },
            /*CoinGenerate.RemoveTo end.*/

            /*CoinGenerate.GetToNear start.*/
            GetToNear: function () {
if ( TRACE ) { TRACE( "CoinGenerate#GetToNear", this ); }

                var $t;
                var distances = new (System.Collections.Generic.List$1(System.Single)).ctor();
                $t = Bridge.getEnumerator(this.listTo);
                try {
                    while ($t.moveNext()) {
                        var t = $t.Current;
                        var distance = pc.Vec3.distance( this.from, t.transform.position );
                        distances.add(distance);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                var intdex = 0;
                var currentDistance = distances.getItem(0);
                for (var i = 0; i < distances.Count; i = (i + 1) | 0) {
                    if (distances.getItem(i) < currentDistance) {
                        currentDistance = distances.getItem(i);
                        intdex = i;
                    }
                }

                return this.listTo.getItem(intdex);
            },
            /*CoinGenerate.GetToNear end.*/

            /*CoinGenerate.GenerateCoin start.*/
            GenerateCoin: function () {
if ( TRACE ) { TRACE( "CoinGenerate#GenerateCoin", this ); }

                var $step = 0,
                    $task1, 
                    $jumpFromFinally, 
                    i, 
                    coin, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5], $step);
                            switch ($step) {
                                case 0: {
                                    this.isScaleIconTo = false;
                                    this.playSoundFx.Raise(this.soundCoinMove);
                                    this.to = this.GetToNear();
                                    i = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i < this.numberCoin ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    $task1 = System.Threading.Tasks.Task.delay(UnityEngine.Random.Range(0, this.delay));
                                    $step = 3;
                                    if ($task1.isCompleted()) {
                                        continue;
                                    }
                                    $task1.continue($asyncBody);
                                    return;
                                }
                                case 3: {
                                    $task1.getAwaitedResult();
                                    coin = { v : VirtueSky.ObjectPooling.Pool.Spawn$2(this.coinPrefab, this.holder) };
                                    coin.v.transform.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.scale );
                                    this.coinsActive.add(coin.v);
                                    coin.v.transform.position = this.from.$clone();
                                    this.MoveToTarget(coin.v, (function ($me, coin) {
                                        return Bridge.fn.bind($me, function () {
                                            this.coinsActive.remove(coin.v);
                                            VirtueSky.ObjectPooling.Pool.DeSpawn(coin.v);

                                            this.moveOneCoinDone.Raise();
                                            if (!this.isScaleIconTo) {
                                                this.isScaleIconTo = true;
                                                this.ScaleIconTo();
                                                if (UnityEngine.Object.op_Implicit(this.fx)) {
                                                    this.fx.transform.parent = this.to.transform;
                                                    this.fx.transform.localPosition = pc.Vec3.ZERO.clone();
                                                    this.fx.Stop();
                                                    this.fx.Play();
                                                }
                                            }

                                            if (this.coinsActive.Count === 0) {
                                                DG.Tweening.ShortcutExtensions.DOKill(this.to.transform.parent, true);
                                                this.moveAllCoinDone.Raise();
                                                this.SaveCache();
                                                this.SetFrom(this.holder.position);
                                            }
                                        });
                                    })(this, coin));
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                $asyncBody();
            },
            /*CoinGenerate.GenerateCoin end.*/

            /*CoinGenerate.MoveToTarget start.*/
            MoveToTarget: function (coin, completed) {
if ( TRACE ) { TRACE( "CoinGenerate#MoveToTarget", this ); }

                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(coin.transform, coin.transform.position.$clone().add( UnityEngine.Vector3.FromVector2(UnityEngine.Random.insideUnitCircle).clone().scale( this.offsetNear ) ), this.durationNear), this.easeNear), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(coin.transform, this.to.transform.position.$clone(), this.durationTarget), this.easeTarget), function () {
                        completed();
                    });
                }));
            },
            /*CoinGenerate.MoveToTarget end.*/

            /*CoinGenerate.SetNumberCoin start.*/
            SetNumberCoin: function (_numberCoin) {
if ( TRACE ) { TRACE( "CoinGenerate#SetNumberCoin", this ); }

                this.numberCoin = _numberCoin;
            },
            /*CoinGenerate.SetNumberCoin end.*/

            /*CoinGenerate.ScaleIconTo start.*/
            ScaleIconTo: function () {
if ( TRACE ) { TRACE( "CoinGenerate#ScaleIconTo", this ); }

                var currentScale = new pc.Vec3( 1, 1, 1 );
                var nextScale = currentScale.$clone().add( new pc.Vec3( 0.1, 0.1, 0.1 ) );
                var tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.to.transform.parent, nextScale.$clone(), 0.15), DG.Tweening.Ease.OutBack), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.to.transform.parent, currentScale.$clone(), 0.1), DG.Tweening.Ease.InBack);
                }));
                DG.Tweening.TweenSettingsExtensions.SetLoops(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), tween, -1);
            },
            /*CoinGenerate.ScaleIconTo end.*/


        }
    });
    /*CoinGenerate end.*/

    /*CollisionComponent start.*/
    Bridge.define("CollisionComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            ActionTriggerEnter: null,
            ActionTriggerStay: null,
            ActionTriggerExit: null
        },
        methods: {
            /*CollisionComponent.OnTriggerEnter start.*/
            OnTriggerEnter: function (other) {
if ( TRACE ) { TRACE( "CollisionComponent#OnTriggerEnter", this ); }

                !Bridge.staticEquals(this.ActionTriggerEnter, null) ? this.ActionTriggerEnter(other.gameObject) : null;
            },
            /*CollisionComponent.OnTriggerEnter end.*/

            /*CollisionComponent.OnTriggerStay start.*/
            OnTriggerStay: function (other) {
if ( TRACE ) { TRACE( "CollisionComponent#OnTriggerStay", this ); }

                !Bridge.staticEquals(this.ActionTriggerStay, null) ? this.ActionTriggerStay(other.gameObject) : null;
            },
            /*CollisionComponent.OnTriggerStay end.*/

            /*CollisionComponent.OnTriggerExit start.*/
            OnTriggerExit: function (other) {
if ( TRACE ) { TRACE( "CollisionComponent#OnTriggerExit", this ); }

                !Bridge.staticEquals(this.ActionTriggerExit, null) ? this.ActionTriggerExit(other.gameObject) : null;
            },
            /*CollisionComponent.OnTriggerExit end.*/


        }
    });
    /*CollisionComponent end.*/

    /*ConnectionPrefab start.*/
    Bridge.define("ConnectionPrefab", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            renderQueue: 0,
            render: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "ConnectionPrefab#init", this ); }

                this.renderQueue = 4050;
            }
        },
        methods: {
            /*ConnectionPrefab.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "ConnectionPrefab#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.render.material.renderQueue = this.renderQueue;
            },
            /*ConnectionPrefab.OnEnable end.*/

            /*ConnectionPrefab.SetMaterial start.*/
            SetMaterial: function (material) {
if ( TRACE ) { TRACE( "ConnectionPrefab#SetMaterial", this ); }

                this.render.material = material;
            },
            /*ConnectionPrefab.SetMaterial end.*/


        }
    });
    /*ConnectionPrefab end.*/

    /*VirtueSky.Events.EventNoParamResult$1 start.*/
    Bridge.define("VirtueSky.Events.EventNoParamResult$1", function (TResult) { return {
        inherits: [VirtueSky.Core.BaseSO,VirtueSky.Events.IEventNoParamResult$1(TResult)],
        fields: {
            onRaised: null
        },
        alias: [
            "Raise", "VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$Raise",
            "AddListener", "VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$AddListener",
            "RemoveListener", "VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$RemoveListener",
            "RemoveAll", "VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$RemoveAll"
        ],
        methods: {
            addOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventNoParamResult$1#addOnRaised", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, value);
            },
            removeOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventNoParamResult$1#removeOnRaised", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, value);
            },
            /*VirtueSky.Events.EventNoParamResult$1.Raise start.*/
            Raise: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventNoParamResult$1#Raise", this ); }

                var result = Bridge.getDefaultValue(TResult);
                if (!UnityEngine.Application.isPlaying) {
                    return Bridge.rValue(result);
                }

                if (!Bridge.staticEquals(this.onRaised, null)) {
                    result = Bridge.rValue(this.onRaised());
                }
                return Bridge.rValue(result);
            },
            /*VirtueSky.Events.EventNoParamResult$1.Raise end.*/

            /*VirtueSky.Events.EventNoParamResult$1.AddListener start.*/
            AddListener: function (func) {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventNoParamResult$1#AddListener", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, func);
            },
            /*VirtueSky.Events.EventNoParamResult$1.AddListener end.*/

            /*VirtueSky.Events.EventNoParamResult$1.RemoveListener start.*/
            RemoveListener: function (func) {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventNoParamResult$1#RemoveListener", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, func);
            },
            /*VirtueSky.Events.EventNoParamResult$1.RemoveListener end.*/

            /*VirtueSky.Events.EventNoParamResult$1.RemoveAll start.*/
            RemoveAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.EventNoParamResult$1#RemoveAll", this ); }

                this.onRaised = null;
            },
            /*VirtueSky.Events.EventNoParamResult$1.RemoveAll end.*/


        }
    }; });
    /*VirtueSky.Events.EventNoParamResult$1 end.*/

    /*GameState start.*/
    Bridge.define("GameState", {
        $kind: 6,
        statics: {
            fields: {
                PrepareGame: 0,
                PlayingGame: 1,
                WaitingResult: 2,
                LoseGame: 3,
                WinGame: 4,
                Lobby: 5
            }
        }
    });
    /*GameState end.*/

    /*FreezeSystem start.*/
    Bridge.define("FreezeSystem", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            listLinker: null,
            type: 0,
            configs: null,
            playSfxEvent: null,
            _soundCrack: null,
            _fxBreak: null,
            _dicData: null
        },
        props: {
            Material: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeSystem#Material#get", this ); }

                    return System.Linq.Enumerable.from(this.configs, FreezeConfig).firstOrDefault(Bridge.fn.bind(this, Bridge.fn.bind(this, function (x) {
                            return x.Type === this.type;
                        })), null).Material;
                }
            },
            freezePrefab: {
                get: function () {
if ( TRACE ) { TRACE( "FreezeSystem#freezePrefab#get", this ); }

                    return System.Linq.Enumerable.from(this.configs, FreezeConfig).firstOrDefault(Bridge.fn.bind(this, Bridge.fn.bind(this, function (x) {
                            return x.Type === this.type;
                        })), null).FreezePrefab;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "FreezeSystem#init", this ); }

                this.listLinker = new (System.Collections.Generic.List$1(FreezeLinker)).ctor();
                this._dicData = new (System.Collections.Generic.Dictionary$2(IFreezer,FreezePrefab)).ctor();
            }
        },
        methods: {
            /*FreezeSystem.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "FreezeSystem#Awake", this ); }

                var $t, $t1;
                this._dicData.clear();
                $t = Bridge.getEnumerator(this.listLinker);
                try {
                    while ($t.moveNext()) {
                        var item = $t.Current;
                        if (item != null) {
                            this._dicData.add(item.Freezer.GetComponent(IFreezer), item.Prefab);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                $t1 = Bridge.getEnumerator(this._dicData);
                try {
                    while ($t1.moveNext()) {
                        var data = $t1.Current;
                        var valueCurrent = data.key.IFreezer$FreezeCount;
                        data.key.IFreezer$FreezeCurrentCount = valueCurrent;
                        data.value.UpdateUI(valueCurrent);
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                var config = System.Linq.Enumerable.from(this.configs, FreezeConfig).firstOrDefault(Bridge.fn.bind(this, Bridge.fn.bind(this, function (x) {
                        return x.Type === this.type;
                    })), null);
                this._soundCrack = config.SoundCrack;
                this._fxBreak = config.FxBreak;
            },
            /*FreezeSystem.Awake end.*/

            /*FreezeSystem.Contains start.*/
            Contains: function (freezer) {
if ( TRACE ) { TRACE( "FreezeSystem#Contains", this ); }

                return this.GetFreezer(freezer) != null;
            },
            /*FreezeSystem.Contains end.*/

            /*FreezeSystem.GetPrefab start.*/
            GetPrefab: function (freezer) {
if ( TRACE ) { TRACE( "FreezeSystem#GetPrefab", this ); }

                return this.GetFreezer(freezer).Prefab;
            },
            /*FreezeSystem.GetPrefab end.*/

            /*FreezeSystem.GetFreezer start.*/
            GetFreezer: function (freezer) {
if ( TRACE ) { TRACE( "FreezeSystem#GetFreezer", this ); }

                return this.listLinker.Find(function (x) {
                    return UnityEngine.GameObject.op_Equality(x.Freezer, freezer);
                });
            },
            /*FreezeSystem.GetFreezer end.*/

            /*FreezeSystem.Add start.*/
            Add: function (freezer) {
if ( TRACE ) { TRACE( "FreezeSystem#Add", this ); }

                this.CheckNull();
                if (!this.Contains(freezer.IFreezer$GameObject)) {
                    var prefab = new FreezePrefab();
                    prefab = UnityEngine.Object.Instantiate(FreezePrefab, this.freezePrefab, this.transform);
                    //prefab.transform.SetParent(freezer.GameObject.transform);
                    prefab.SetUp(freezer.IFreezer$FreezeCenterPosition, freezer.IFreezer$FreezeCount, freezer.IFreezer$TextSize);
                    freezer.IFreezer$OnFreezerSetup(this.Material);
                    this.listLinker.add(new FreezeLinker(freezer.IFreezer$GameObject, prefab));
                }
            },
            /*FreezeSystem.Add end.*/

            /*FreezeSystem.Remove start.*/
            Remove: function (freezer) {
if ( TRACE ) { TRACE( "FreezeSystem#Remove", this ); }

                if (this.Contains(freezer.IFreezer$GameObject)) {
                    var freezerLiner = this.GetFreezer(freezer.IFreezer$GameObject);
                    this.OnFreezerBreak(freezer, freezerLiner.Prefab);
                    this.listLinker.remove(freezerLiner);
                }
            },
            /*FreezeSystem.Remove end.*/

            /*FreezeSystem.CheckNull start.*/
            CheckNull: function () {
if ( TRACE ) { TRACE( "FreezeSystem#CheckNull", this ); }

                var $t;
                if (this.listLinker.Count > 0) {
                    var listLinkerNull = new (System.Collections.Generic.List$1(FreezeLinker)).ctor();
                    for (var i = 0; i < this.listLinker.Count; i = (i + 1) | 0) {
                        if (UnityEngine.GameObject.op_Equality(this.listLinker.getItem(i).Freezer, null)) {
                            listLinkerNull.add(this.listLinker.getItem(i));
                        }
                    }

                    $t = Bridge.getEnumerator(listLinkerNull);
                    try {
                        while ($t.moveNext()) {
                            var linkerNull = $t.Current;
                            this.listLinker.remove(linkerNull);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*FreezeSystem.CheckNull end.*/

            /*FreezeSystem.OnFreezerBreak start.*/
            OnFreezerBreak: function (freezer, prefab) {
if ( TRACE ) { TRACE( "FreezeSystem#OnFreezerBreak", this ); }

                var position = prefab.transform.position.$clone();
                UnityEngine.MonoBehaviour.Destroy(prefab.gameObject);
                freezer.IFreezer$OnFreezerBreak();
                // create fx
                if (UnityEngine.Object.op_Implicit(this._fxBreak)) {
                    var fx = VirtueSky.ObjectPooling.Pool.Spawn(UnityEngine.ParticleSystem, this._fxBreak);
                    if (UnityEngine.Object.op_Implicit(fx)) {
                        fx.transform.position = position.$clone();
                        fx.Play();
                    }
                }

                if (UnityEngine.Object.op_Implicit(this._soundCrack)) {
                    this.playSfxEvent != null ? this.playSfxEvent.Raise(this._soundCrack) : null;
                }
            },
            /*FreezeSystem.OnFreezerBreak end.*/

            /*FreezeSystem.OnChange start.*/
            OnChange: function (value) {
if ( TRACE ) { TRACE( "FreezeSystem#OnChange", this ); }

                var $t;
                if (value === void 0) { value = 1; }
                $t = Bridge.getEnumerator(this._dicData);
                try {
                    while ($t.moveNext()) {
                        var data = $t.Current;
                        this.OnFreezerCrack(data.key, value);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*FreezeSystem.OnChange end.*/

            /*FreezeSystem.OnFreezerCrack start.*/
            OnFreezerCrack: function (iFreezer, value) {
if ( TRACE ) { TRACE( "FreezeSystem#OnFreezerCrack", this ); }

                if (value === void 0) { value = 1; }
                iFreezer.IFreezer$FreezeCurrentCount = (iFreezer.IFreezer$FreezeCurrentCount - value) | 0;
                if (iFreezer != null && iFreezer.IFreezer$IsFrezering) {
                    iFreezer.IFreezer$OnFreezerChanged();
                    var count = iFreezer.IFreezer$FreezeCurrentCount;
                    if (count <= 0) {
                        this.OnFreezerBreak(iFreezer, this._dicData.getItem(iFreezer));
                        iFreezer.IFreezer$IsFrezering = false;
                    } else {
                        this._dicData.getItem(iFreezer).UpdateUI(count);
                    }
                }
            },
            /*FreezeSystem.OnFreezerCrack end.*/


        }
    });
    /*FreezeSystem end.*/

    /*GateSwitcher start.*/
    Bridge.define("GateSwitcher", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            listRender: null,
            _materialDefault: null,
            _materialTarget: null,
            _rendererTarget: null,
            _isSwitched: false,
            _isCanSwitched: false,
            _onSwith: null
        },
        props: {
            MaterialDefault: {
                get: function () {
if ( TRACE ) { TRACE( "GateSwitcher#MaterialDefault#get", this ); }

                    return this._isSwitched ? this._materialTarget : this._materialDefault;
                }
            },
            MaterialTarget: {
                get: function () {
if ( TRACE ) { TRACE( "GateSwitcher#MaterialTarget#get", this ); }

                    return this._isSwitched ? this._materialDefault : this._materialTarget;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GateSwitcher#init", this ); }

                this.listRender = new (System.Collections.Generic.List$1(UnityEngine.Renderer)).ctor();
                this._isSwitched = false;
                this._isCanSwitched = true;
            }
        },
        methods: {
            /*GateSwitcher.SetUp start.*/
            SetUp: function (renderTarget, onSwith) {
if ( TRACE ) { TRACE( "GateSwitcher#SetUp", this ); }

                if (onSwith === void 0) { onSwith = null; }
                this._rendererTarget = renderTarget;
                this._onSwith = onSwith;
                this._materialDefault = this.listRender.getItem(0).material;
                this._materialTarget = renderTarget.material;
                this._isSwitched = false;
                this._isCanSwitched = true;
            },
            /*GateSwitcher.SetUp end.*/

            /*GateSwitcher.SetMaterial start.*/
            SetMaterial: function (material) {
if ( TRACE ) { TRACE( "GateSwitcher#SetMaterial", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.listRender);
                try {
                    while ($t.moveNext()) {
                        var render = $t.Current;
                        if (UnityEngine.Object.op_Implicit(render)) {
                            render.material = material;
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*GateSwitcher.SetMaterial end.*/

            /*GateSwitcher.Switch start.*/
            Switch: function (isCanSwitch) {
if ( TRACE ) { TRACE( "GateSwitcher#Switch", this ); }

                if (isCanSwitch === void 0) { isCanSwitch = true; }
                if (this._isCanSwitched) {
                    this._isSwitched = !this._isSwitched;
                    this._rendererTarget.material = this.MaterialTarget;
                    var material = isCanSwitch ? this.MaterialDefault : this.MaterialTarget;
                    this.SetMaterial(material);
                    !Bridge.staticEquals(this._onSwith, null) ? this._onSwith(this._isSwitched) : null;
                    if (!isCanSwitch && this._isCanSwitched) {
                        this._isCanSwitched = false;
                    }
                }
            },
            /*GateSwitcher.Switch end.*/

            /*GateSwitcher.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "GateSwitcher#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this._onSwith = null;
            },
            /*GateSwitcher.OnDisable end.*/


        }
    });
    /*GateSwitcher end.*/

    /*GridSystem start.*/
    Bridge.define("GridSystem", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            listCell: null
        },
        props: {
            CoordinateOrigin: {
                get: function () {
if ( TRACE ) { TRACE( "GridSystem#CoordinateOrigin#get", this ); }

                    return this.GetCell(UnityEngine.Vector2Int.zero).GetPostion();
                }
            },
            cells: {
                get: function () {
if ( TRACE ) { TRACE( "GridSystem#cells#get", this ); }

                    return this.listCell;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "GridSystem#init", this ); }

                this.listCell = new (System.Collections.Generic.List$1(CellGrid)).ctor();
            }
        },
        methods: {
            /*GridSystem.GetCell start.*/
            GetCell: function (coordinate) {
if ( TRACE ) { TRACE( "GridSystem#GetCell", this ); }

                return this.listCell.Find(function (item) {
                    return UnityEngine.Vector2Int.op_Equality(item.coordinate.$clone(), coordinate.$clone());
                });
            },
            /*GridSystem.GetCell end.*/

            /*GridSystem.SetCells start.*/
            SetCells: function (cells) {
if ( TRACE ) { TRACE( "GridSystem#SetCells", this ); }

                this.listCell = cells;
            },
            /*GridSystem.SetCells end.*/


        }
    });
    /*GridSystem end.*/

    /*HeartManager start.*/
    Bridge.define("HeartManager", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            isDontDestroyOnLoad: false,
            heartData: null,
            updatingTimeIncreaseHeart: null,
            _coroutineUpdateHeart: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "HeartManager#init", this ); }

                this.isDontDestroyOnLoad = true;
            }
        },
        methods: {
            /*HeartManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "HeartManager#Awake", this ); }

                if (this.isDontDestroyOnLoad) {
                    UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
                }
            },
            /*HeartManager.Awake end.*/

            /*HeartManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "HeartManager#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);

                this.heartData.Refesh();
                this._coroutineUpdateHeart = this.StartCoroutine$1(this.IUpdateTimeIncreaseHeart());
            },
            /*HeartManager.OnEnable end.*/

            /*HeartManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "HeartManager#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                if (this._coroutineUpdateHeart != null) {
                    this.StopCoroutine$2(this._coroutineUpdateHeart);
                }
            },
            /*HeartManager.OnDisable end.*/

            /*HeartManager.IUpdateTimeIncreaseHeart start.*/
            IUpdateTimeIncreaseHeart: function () {
if ( TRACE ) { TRACE( "HeartManager#IUpdateTimeIncreaseHeart", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    if ( true ) {
                                            $step = 1;
                                            continue;
                                        } 
                                        $step = 7;
                                        continue;
                                }
                                case 1: {
                                    if (!this.heartData.IsCanIncrease) {
                                            $step = 2;
                                            continue;
                                        } else  {
                                            $step = 4;
                                            continue;
                                        }
                                }
                                case 2: {
                                    this.updatingTimeIncreaseHeart != null ? this.updatingTimeIncreaseHeart.Raise(-1) : null;
                                        this.heartData.ResetTimeIncrease();
                                        $enumerator.current = null;
                                        $step = 3;
                                        return true;
                                }
                                case 3: {
                                    $step = 6;
                                    continue;
                                }
                                case 4: {
                                    if (this.heartData.TimeRemainingToIncrease <= 0) {
                                            this.heartData.Add(1);
                                            this.heartData.ResetTimeIncrease();
                                        }

                                        this.updatingTimeIncreaseHeart != null ? this.updatingTimeIncreaseHeart.Raise(this.heartData.TimeRemainingToIncrease) : null;
                                        $enumerator.current = new UnityEngine.WaitForSeconds(1);
                                        $step = 5;
                                        return true;
                                }
                                case 5: {
                                    $step = 6;
                                    continue;
                                }
                                case 6: {
                                    
                                        $step = 0;
                                        continue;
                                }
                                case 7: {

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*HeartManager.IUpdateTimeIncreaseHeart end.*/


        }
    });
    /*HeartManager end.*/

    /*HeartUI start.*/
    Bridge.define("HeartUI", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            updateHeartEvent: null,
            updatingTimeIncreaseHeartEvent: null,
            immortalData: null,
            heartData: null,
            plusIcon: null,
            iconHeart: null,
            iconHeartNormal: null,
            iconHeartImmortal: null,
            txtCount: null,
            txtFull: null,
            stringFormatCount: null,
            txtTime: null,
            stringFormatTime: null,
            stringFormatImmortalTimeWithDay: null,
            stringFormatImmortalTimeWithHour: null,
            stringFormatImmortalTimeWithMinute: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "HeartUI#init", this ); }

                this.stringFormatCount = "{0}";
                this.stringFormatTime = "{0}:{1}";
                this.stringFormatImmortalTimeWithDay = "{0}:{1}";
                this.stringFormatImmortalTimeWithHour = "{0}:{1}";
                this.stringFormatImmortalTimeWithMinute = "{0}:{1}";
            }
        },
        methods: {
            /*HeartUI.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "HeartUI#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.updateHeartEvent.addOnRaised(Bridge.fn.cacheBind(this, this.OnUpdateHeart));
                this.updatingTimeIncreaseHeartEvent.addOnRaised(Bridge.fn.cacheBind(this, this.OnUpdatingTimeIncreaseHeart));
                this.immortalData.OnUpdateTimeImmortalAction = Bridge.fn.combine(this.immortalData.OnUpdateTimeImmortalAction, Bridge.fn.cacheBind(this, this.OnUpdatingTimeImmortal));
                this.immortalData.OnInStatusImmortalAction = Bridge.fn.combine(this.immortalData.OnInStatusImmortalAction, Bridge.fn.cacheBind(this, this.OnInStatusImmortal));
                this.immortalData.OnEndStatusImmortalAction = Bridge.fn.combine(this.immortalData.OnEndStatusImmortalAction, Bridge.fn.cacheBind(this, this.OnEndStatusImmortal));
                this.OnUpdateHeart(this.heartData.Count);
                this.UpdateIcon();
            },
            /*HeartUI.OnEnable end.*/

            /*HeartUI.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "HeartUI#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.updateHeartEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.OnUpdateHeart));
                this.updatingTimeIncreaseHeartEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.OnUpdatingTimeIncreaseHeart));
                this.immortalData.OnUpdateTimeImmortalAction = Bridge.fn.remove(this.immortalData.OnUpdateTimeImmortalAction, Bridge.fn.cacheBind(this, this.OnUpdatingTimeImmortal));
                this.immortalData.OnInStatusImmortalAction = Bridge.fn.remove(this.immortalData.OnInStatusImmortalAction, Bridge.fn.cacheBind(this, this.OnInStatusImmortal));
                this.immortalData.OnEndStatusImmortalAction = Bridge.fn.remove(this.immortalData.OnEndStatusImmortalAction, Bridge.fn.cacheBind(this, this.OnEndStatusImmortal));
            },
            /*HeartUI.OnDisable end.*/

            /*HeartUI.UpdateIcon start.*/
            UpdateIcon: function () {
if ( TRACE ) { TRACE( "HeartUI#UpdateIcon", this ); }

                var sprite = this.immortalData.IsImmortalStatusVariable ? this.iconHeartImmortal : this.iconHeartNormal;
                this.iconHeart.sprite = sprite;
                this.iconHeart.SetNativeSize();
            },
            /*HeartUI.UpdateIcon end.*/

            /*HeartUI.OnUpdateHeart start.*/
            OnUpdateHeart: function (heart) {
if ( TRACE ) { TRACE( "HeartUI#OnUpdateHeart", this ); }

                if (!this.immortalData.IsImmortalStatusVariable) {
                    this.txtCount.gameObject.SetActive(true);
                    this.txtFull.SetActive(false);
                    if (UnityEngine.GameObject.op_Inequality(this.plusIcon, null)) {
                        this.plusIcon.SetActive(true);
                    }
                    this.txtCount.text = System.String.format(this.stringFormatCount, [Bridge.box(heart, System.Int32)]);
                } else {
                    this.OnInStatusImmortal();
                }
            },
            /*HeartUI.OnUpdateHeart end.*/

            /*HeartUI.OnUpdatingTimeIncreaseHeart start.*/
            OnUpdatingTimeIncreaseHeart: function (time) {
if ( TRACE ) { TRACE( "HeartUI#OnUpdatingTimeIncreaseHeart", this ); }

                if (!this.immortalData.IsImmortalStatusVariable) {
                    this.txtTime.gameObject.SetActive(time > 0);
                    this.txtFull.SetActive(time <= 0);
                    if (UnityEngine.GameObject.op_Inequality(this.plusIcon, null)) {
                        this.plusIcon.SetActive(time > 0);
                    }
                    if (time > 0) {
                        var timeSpan = this.ConvertSecondToTime(time);
                        this.txtTime.text = System.String.format(this.stringFormatTime, Bridge.box(timeSpan.getMinutes(), System.Int32), Bridge.box(timeSpan.getSeconds(), System.Int32));
                    }
                }
            },
            /*HeartUI.OnUpdatingTimeIncreaseHeart end.*/

            /*HeartUI.OnInStatusImmortal start.*/
            OnInStatusImmortal: function () {
if ( TRACE ) { TRACE( "HeartUI#OnInStatusImmortal", this ); }

                this.txtCount.gameObject.SetActive(false);
                this.iconHeart.sprite = this.iconHeartImmortal;
                this.iconHeart.SetNativeSize();
                this.txtFull.SetActive(false);
                if (UnityEngine.GameObject.op_Inequality(this.plusIcon, null)) {
                    this.plusIcon.SetActive(false);
                }
            },
            /*HeartUI.OnInStatusImmortal end.*/

            /*HeartUI.OnEndStatusImmortal start.*/
            OnEndStatusImmortal: function () {
if ( TRACE ) { TRACE( "HeartUI#OnEndStatusImmortal", this ); }

                this.iconHeart.sprite = this.iconHeartNormal;
                this.iconHeart.SetNativeSize();
                this.OnUpdateHeart(this.heartData.Count);
            },
            /*HeartUI.OnEndStatusImmortal end.*/

            /*HeartUI.OnUpdatingTimeImmortal start.*/
            OnUpdatingTimeImmortal: function (time) {
if ( TRACE ) { TRACE( "HeartUI#OnUpdatingTimeImmortal", this ); }

                this.txtTime.gameObject.SetActive(time > 0);
                if (time > 0) {
                    var timeSpan = this.ConvertSecondToTime(time);
                    if (timeSpan.getDays() > 0) {
                        this.txtTime.text = System.String.format(this.stringFormatImmortalTimeWithDay, Bridge.box(timeSpan.getDays(), System.Int32), Bridge.box(timeSpan.getHours(), System.Int32), Bridge.box(timeSpan.getMinutes(), System.Int32), Bridge.box(timeSpan.getSeconds(), System.Int32));
                    } else if (timeSpan.getHours() > 0) {
                        this.txtTime.text = System.String.format(this.stringFormatImmortalTimeWithHour, Bridge.box(timeSpan.getHours(), System.Int32), Bridge.box(timeSpan.getMinutes(), System.Int32), Bridge.box(timeSpan.getSeconds(), System.Int32));
                    } else {
                        this.txtTime.text = System.String.format(this.stringFormatImmortalTimeWithMinute, Bridge.box(timeSpan.getMinutes(), System.Int32), Bridge.box(timeSpan.getSeconds(), System.Int32));
                    }
                }
            },
            /*HeartUI.OnUpdatingTimeImmortal end.*/

            /*HeartUI.ConvertSecondToTime start.*/
            ConvertSecondToTime: function (second) {
if ( TRACE ) { TRACE( "HeartUI#ConvertSecondToTime", this ); }

                return System.TimeSpan.fromSeconds(second);
            },
            /*HeartUI.ConvertSecondToTime end.*/

            /*HeartUI.OnClickPlus start.*/
            OnClickPlus: function () {
if ( TRACE ) { TRACE( "HeartUI#OnClickPlus", this ); }
 },
            /*HeartUI.OnClickPlus end.*/


        }
    });
    /*HeartUI end.*/

    /*LevelConfig start.*/
    Bridge.define("LevelConfig", {
        inherits: [VirtueSky.Core.BaseMono]
    });
    /*LevelConfig end.*/

    /*MapSystem start.*/
    Bridge.define("MapSystem", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            sizeGrid: null,
            sizeActive: null,
            gridOffset: null,
            gridType: 0,
            axisType: 0,
            setting: null,
            gridSystem: null,
            plane: null,
            path: null
        },
        props: {
            GridSystem: {
                get: function () {
if ( TRACE ) { TRACE( "MapSystem#GridSystem#get", this ); }

                    return this.gridSystem;
                }
            },
            SizeActive: {
                get: function () {
if ( TRACE ) { TRACE( "MapSystem#SizeActive#get", this ); }

                    return this.sizeActive.$clone();
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "MapSystem#init", this ); }

                this.sizeGrid = new UnityEngine.Vector2Int();
                this.sizeActive = new UnityEngine.Vector2Int();
                this.gridOffset = new UnityEngine.Vector2();
                this.gridOffset = new pc.Vec2( 0.25, 0.25 );
                this.path = "Assets/_Root/Game/Level/Map/Creater/Meshs";
            }
        },
        methods: {
            /*MapSystem.GetDistance start.*/
            GetDistance: function (gridType, cellSetting) {
if ( TRACE ) { TRACE( "MapSystem#GetDistance", this ); }

                var result = new UnityEngine.Vector2();

                if (gridType === GridType.Rectangle) {
                    result = cellSetting.rectangle.Size.$clone();
                } else if (gridType === GridType.Hexagon) {
                    result = cellSetting.hexagon.Size.$clone();
                } else {
                    result = UnityEngine.Vector2Int.op_Implicit(UnityEngine.Vector2Int.zero.$clone());
                }

                return result.$clone();
            },
            /*MapSystem.GetDistance end.*/

            /*MapSystem.GetCell$1 start.*/
            GetCell$1: function (position) {
if ( TRACE ) { TRACE( "MapSystem#GetCell$1", this ); }

                if (UnityEngine.Object.op_Implicit(this.gridSystem)) {
                    var positionInCoordinate = position.$clone().sub( this.gridSystem.CoordinateOrigin );
                    var distane = this.GetDistance(this.gridType, this.setting);
                    var xAxis = Math.round(positionInCoordinate.x / distane.x);
                    var yAxis = 0;
                    switch (this.axisType) {
                        case AxisType.XY: 
                            yAxis = Math.round(positionInCoordinate.y / distane.y);
                            break;
                        case AxisType.XZ: 
                            yAxis = Math.round(positionInCoordinate.z / distane.y);
                            break;
                    }

                    var coordinate = new UnityEngine.Vector2Int.$ctor1(xAxis, yAxis);
                    return this.GetCell(coordinate);
                }
                return null;
            },
            /*MapSystem.GetCell$1 end.*/

            /*MapSystem.GetCell start.*/
            GetCell: function (coordinate) {
if ( TRACE ) { TRACE( "MapSystem#GetCell", this ); }

                return this.gridSystem.GetCell(coordinate);
            },
            /*MapSystem.GetCell end.*/


        },
        overloads: {
            "GetCell(Vector3)": "GetCell$1"
        }
    });
    /*MapSystem end.*/

    /*ObjectStar start.*/
    Bridge.define("ObjectStar", {
        inherits: [VirtueSky.Core.BaseMono]
    });
    /*ObjectStar end.*/

    /*Outline start.*/
    Bridge.define("Outline", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            material: null,
            colorProperty: null,
            widthProperty: null,
            _outlineMaterial: null,
            _materialAdd: null,
            _renderer: null,
            _renderQueueOrigin: 0,
            _color: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Outline#init", this ); }

                this._color = new UnityEngine.Color();
                this.colorProperty = "_OutlineColor";
                this.widthProperty = "_OutlineWidth";
                this._renderQueueOrigin = 2000;
            }
        },
        methods: {
            /*Outline.SetUp start.*/
            SetUp: function (renderer, color, width) {
if ( TRACE ) { TRACE( "Outline#SetUp", this ); }

                if (width === void 0) { width = 1.0; }
                if (this._outlineMaterial == null) {
                    this._outlineMaterial = new UnityEngine.Material.$ctor1(this.material);
                }

                this._renderer = renderer;
                this.SetColor(color);
                this.SetWidth(width);

                this._color = color.$clone();
                this._renderQueueOrigin = this._outlineMaterial.renderQueue;
            },
            /*Outline.SetUp end.*/

            /*Outline.SetColor start.*/
            SetColor: function (color) {
if ( TRACE ) { TRACE( "Outline#SetColor", this ); }

                if (UnityEngine.Object.op_Implicit(this._outlineMaterial)) {
                    this._outlineMaterial.SetColor$1(this.colorProperty, color);
                }
            },
            /*Outline.SetColor end.*/

            /*Outline.SetWidth start.*/
            SetWidth: function (size) {
if ( TRACE ) { TRACE( "Outline#SetWidth", this ); }

                if (UnityEngine.Object.op_Implicit(this._outlineMaterial)) {
                    this._outlineMaterial.SetFloat$1(this.widthProperty, size);
                }
            },
            /*Outline.SetWidth end.*/

            /*Outline.Active start.*/
            Active: function () {
if ( TRACE ) { TRACE( "Outline#Active", this ); }

                this.AddMaterial(this._outlineMaterial);
            },
            /*Outline.Active end.*/

            /*Outline.Deactive start.*/
            Deactive: function () {
if ( TRACE ) { TRACE( "Outline#Deactive", this ); }

                this.RemoveMaterial(this._materialAdd);
            },
            /*Outline.Deactive end.*/

            /*Outline.AddMaterial start.*/
            AddMaterial: function (material) {
if ( TRACE ) { TRACE( "Outline#AddMaterial", this ); }

                var $t;
                if (UnityEngine.Object.op_Implicit(this._renderer)) {
                    var materials = { v : this._renderer.materials };
                    System.Array.resize(materials, ((materials.v.length + 1) | 0), null, UnityEngine.Material);
                    materials.v[((materials.v.length - 1) | 0)] = material;
                    this._renderer.materials = materials.v;
                    this._materialAdd = ($t = this._renderer.materials)[((materials.v.length - 1) | 0)];
                }
            },
            /*Outline.AddMaterial end.*/

            /*Outline.RemoveMaterial start.*/
            RemoveMaterial: function (material) {
if ( TRACE ) { TRACE( "Outline#RemoveMaterial", this ); }

                var $t;
                var materials = ($t = UnityEngine.Material, System.Linq.Enumerable.from(this._renderer.materials, $t).toList($t));
                if (materials.contains(material)) {
                    materials.remove(material);
                    this._renderer.materials = materials.ToArray();
                }
            },
            /*Outline.RemoveMaterial end.*/

            /*Outline.SetActive start.*/
            SetActive: function (isActive) {
if ( TRACE ) { TRACE( "Outline#SetActive", this ); }

                if (isActive) {
                    this.Active();
                } else {
                    this.Deactive();
                }
            },
            /*Outline.SetActive end.*/

            /*Outline.SetRenderQueue start.*/
            SetRenderQueue: function (renderQueue) {
if ( TRACE ) { TRACE( "Outline#SetRenderQueue", this ); }

                this.material.renderQueue = renderQueue;
            },
            /*Outline.SetRenderQueue end.*/

            /*Outline.Reset start.*/
            Reset: function () {
if ( TRACE ) { TRACE( "Outline#Reset", this ); }

                this.material.renderQueue = this._renderQueueOrigin;
            },
            /*Outline.Reset end.*/

            /*Outline.ChangeShader start.*/
            ChangeShader: function (shader) {
if ( TRACE ) { TRACE( "Outline#ChangeShader", this ); }

                this._materialAdd.shader = shader;
                this.SetColor(this._color);
            },
            /*Outline.ChangeShader end.*/


        }
    });
    /*Outline end.*/

    /*PooledParticleCallback start.*/
    Bridge.define("PooledParticleCallback", {
        inherits: [VirtueSky.Core.BaseMono],
        methods: {
            /*PooledParticleCallback.OnParticleSystemStopped start.*/
            OnParticleSystemStopped: function () {
if ( TRACE ) { TRACE( "PooledParticleCallback#OnParticleSystemStopped", this ); }

                this.StartCoroutine$1(this.IEDespawn());
            },
            /*PooledParticleCallback.OnParticleSystemStopped end.*/

            /*PooledParticleCallback.IEDespawn start.*/
            IEDespawn: function () {
if ( TRACE ) { TRACE( "PooledParticleCallback#IEDespawn", this ); }

                var $step = 0,
                    $jumpFromFinally,
                    $returnValue,
                    $async_e;

                var $enumerator = new Bridge.GeneratorEnumerator(Bridge.fn.bind(this, function () {
                    try {
                        for (;;) {
                            switch ($step) {
                                case 0: {
                                    $enumerator.current = null;
                                        $step = 1;
                                        return true;
                                }
                                case 1: {
                                    VirtueSky.ObjectPooling.Pool.DeSpawn(this.gameObject);

                                }
                                default: {
                                    return false;
                                }
                            }
                        }
                    } catch($async_e1) {
                        $async_e = System.Exception.create($async_e1);
                        throw $async_e;
                    }
                }));
                return $enumerator;
            },
            /*PooledParticleCallback.IEDespawn end.*/


        }
    });
    /*PooledParticleCallback end.*/

    /*Shutter start.*/
    Bridge.define("Shutter", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            animator: null,
            openAnimName: null,
            closeAnimName: null,
            playSfxEvent: null,
            soundOpen: null,
            soundClose: null,
            _isOpen: false,
            _shutter: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Shutter#init", this ); }

                this.openAnimName = "Close";
                this.closeAnimName = "Open";
            }
        },
        methods: {
            /*Shutter.SetUp start.*/
            SetUp: function (shutter, isOpenDefault) {
if ( TRACE ) { TRACE( "Shutter#SetUp", this ); }

                if (isOpenDefault === void 0) { isOpenDefault = true; }
                this._isOpen = isOpenDefault;
                this._shutter = shutter;
                this._shutter.IShutter$IsOpen = this._isOpen;
            },
            /*Shutter.SetUp end.*/

            /*Shutter.Switch start.*/
            Switch: function () {
if ( TRACE ) { TRACE( "Shutter#Switch", this ); }

                this._isOpen = !this._isOpen;
                this._shutter.IShutter$IsOpen = this._isOpen;
                this.Refresh();
            },
            /*Shutter.Switch end.*/

            /*Shutter.Refresh start.*/
            Refresh: function () {
if ( TRACE ) { TRACE( "Shutter#Refresh", this ); }

                this.SetStatus(this._isOpen);
            },
            /*Shutter.Refresh end.*/

            /*Shutter.SetStatus start.*/
            SetStatus: function (isOpen) {
if ( TRACE ) { TRACE( "Shutter#SetStatus", this ); }

                var animName = isOpen ? this.openAnimName : this.closeAnimName;
                this.animator.Play(animName);

                var sound = isOpen ? this.soundOpen : this.soundClose;
                this.playSfxEvent != null ? this.playSfxEvent.Raise(sound) : null;
            },
            /*Shutter.SetStatus end.*/


        }
    });
    /*Shutter end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    Bridge.define("Spine.Unity.AnimationReferenceAsset", {
        inherits: [UnityEngine.ScriptableObject,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                QuietSkeletonData: false
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#init", this ); }

                    this.QuietSkeletonData = true;
                }
            },
            methods: {
                op_Implicit: function (asset) {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#op_Implicit", this ); }

                    return asset.Animation;
                }
            }
        },
        fields: {
            skeletonDataAsset: null,
            animationName: null,
            animation: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            Animation: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Animation#get", this ); }

                    if (this.animation == null) {
                        this.Initialize();
                    }
                    return this.animation;
                }
            }
        },
        alias: ["SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"],
        methods: {
            /*Spine.Unity.AnimationReferenceAsset.Clear start.*/
            /**
             * Clears the cached animation corresponding to a loaded SkeletonData object.
             Use this to force a reload for the next time Animation is called.
             *
             * @instance
             * @public
             * @this Spine.Unity.AnimationReferenceAsset
             * @memberof Spine.Unity.AnimationReferenceAsset
             * @return  {void}
             */
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Clear", this ); }

                this.animation = null;
            },
            /*Spine.Unity.AnimationReferenceAsset.Clear end.*/

            /*Spine.Unity.AnimationReferenceAsset.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.AnimationReferenceAsset#Initialize", this ); }

                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(Spine.Unity.AnimationReferenceAsset.QuietSkeletonData);
                this.animation = skeletonData != null ? skeletonData.findAnimation(this.animationName) : null;
                if (this.animation == null) {
                    UnityEngine.Debug.LogWarningFormat("Animation '{0}' not found in SkeletonData : {1}.", [this.animationName, this.skeletonDataAsset.name]);
                }
            },
            /*Spine.Unity.AnimationReferenceAsset.Initialize end.*/


        }
    });
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.PointFollower start.*/
    Bridge.define("Spine.Unity.PointFollower", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.IHasSkeletonRenderer,Spine.Unity.IHasSkeletonComponent],
        fields: {
            skeletonRenderer: null,
            slotName: null,
            pointAttachmentName: null,
            followRotation: false,
            followSkeletonFlip: false,
            followSkeletonZPosition: false,
            skeletonTransform: null,
            skeletonTransformIsParent: false,
            point: null,
            bone: null,
            valid: false
        },
        props: {
            SkeletonRenderer: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonRenderer#get", this ); }

                    return this.skeletonRenderer;
                }
            },
            SkeletonComponent: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#SkeletonComponent#get", this ); }

                    return Bridge.as(this.skeletonRenderer, Spine.Unity.ISkeletonComponent);
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#IsValid#get", this ); }

                    return this.valid;
                }
            }
        },
        alias: [
            "SkeletonRenderer", "Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer",
            "SkeletonComponent", "Spine$Unity$IHasSkeletonComponent$SkeletonComponent"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#init", this ); }

                this.followRotation = true;
                this.followSkeletonFlip = true;
                this.followSkeletonZPosition = false;
            }
        },
        methods: {
            /*Spine.Unity.PointFollower.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#Initialize", this ); }

                this.valid = UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null) && this.skeletonRenderer.valid;
                if (!this.valid) {
                    return;
                }

                this.UpdateReferences();

            },
            /*Spine.Unity.PointFollower.Initialize end.*/

            /*Spine.Unity.PointFollower.HandleRebuildRenderer start.*/
            HandleRebuildRenderer: function (skeletonRenderer) {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#HandleRebuildRenderer", this ); }

                this.Initialize();
            },
            /*Spine.Unity.PointFollower.HandleRebuildRenderer end.*/

            /*Spine.Unity.PointFollower.UpdateReferences start.*/
            UpdateReferences: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#UpdateReferences", this ); }

                this.skeletonTransform = this.skeletonRenderer.transform;
                this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonRenderer.addOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                this.skeletonTransformIsParent = Bridge.referenceEquals(this.skeletonTransform, this.transform.parent);

                this.bone = null;
                this.point = null;
                if (!System.String.isNullOrEmpty(this.pointAttachmentName)) {
                    var skeleton = this.skeletonRenderer.Skeleton;

                    var slot = skeleton.findSlot(this.slotName);
                    if (slot != null) {
                        var slotIndex = slot.data.index;
                        this.bone = slot.bone;
                        this.point = Bridge.as(skeleton.getAttachment(slotIndex, this.pointAttachmentName), Spine.PointAttachment);
                    }
                }
            },
            /*Spine.Unity.PointFollower.UpdateReferences end.*/

            /*Spine.Unity.PointFollower.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#OnDestroy", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.skeletonRenderer, null)) {
                    this.skeletonRenderer.removeOnRebuild(Bridge.fn.cacheBind(this, this.HandleRebuildRenderer));
                }
            },
            /*Spine.Unity.PointFollower.OnDestroy end.*/

            /*Spine.Unity.PointFollower.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.PointFollower#LateUpdate", this ); }

                var $t;

                if (this.point == null) {
                    if (System.String.isNullOrEmpty(this.pointAttachmentName)) {
                        return;
                    }
                    this.UpdateReferences();
                    if (this.point == null) {
                        return;
                    }
                }

                var worldPos = new UnityEngine.Vector2();
                this.point.ComputeWorldPosition(this.bone, Bridge.ref(worldPos, "x"), Bridge.ref(worldPos, "y"));
                var rotation = this.point.computeWorldRotation(this.bone);

                var thisTransform = this.transform;
                if (this.skeletonTransformIsParent) {
                    // Recommended setup: Use local transform properties if Spine GameObject is the immediate parent
                    thisTransform.localPosition = new pc.Vec3( worldPos.x, worldPos.y, this.followSkeletonZPosition ? 0.0 : thisTransform.localPosition.z );
                    if (this.followRotation) {
                        var halfRotation = rotation * 0.5 * UnityEngine.Mathf.Deg2Rad;

                        var q = Bridge.getDefaultValue(UnityEngine.Quaternion);
                        q.z = Math.sin(halfRotation);
                        q.w = Math.cos(halfRotation);
                        thisTransform.localRotation = q.$clone();
                    }
                } else {
                    // For special cases: Use transform world properties if transform relationship is complicated
                    var targetWorldPosition = this.skeletonTransform.TransformPoint$1(new pc.Vec3( worldPos.x, worldPos.y, 0.0 ));
                    if (!this.followSkeletonZPosition) {
                        targetWorldPosition.z = thisTransform.position.z;
                    }

                    var transformParent = thisTransform.parent;
                    if (UnityEngine.Component.op_Inequality(transformParent, null)) {
                        var m = transformParent.localToWorldMatrix.$clone();
                        if (m.e00 * m.e11 - m.e01 * m.e10 < 0) {
                            rotation = -rotation;
                        }
                    }

                    if (this.followRotation) {
                        var transformWorldRotation = this.skeletonTransform.rotation.getPositiveEulerAngles().$clone();
                        thisTransform.SetPositionAndRotation(targetWorldPosition, new pc.Quat().setFromEulerAngles_Unity( transformWorldRotation.x, transformWorldRotation.y, transformWorldRotation.z + rotation ));
                    } else {
                        thisTransform.position = targetWorldPosition.$clone();
                    }
                }

                if (this.followSkeletonFlip) {
                    var localScale = thisTransform.localScale.$clone();
                    localScale.y = Math.abs(localScale.y) * ($t = this.bone.skeleton.scaleX * this.bone.skeleton.scaleY, ($t === 0 ? 1 : Math.sign($t)));
                    thisTransform.localScale = localScale.$clone();
                }
            },
            /*Spine.Unity.PointFollower.LateUpdate end.*/


        }
    });
    /*Spine.Unity.PointFollower end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonRenderer.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.MeshGeneratorDelegate
     * @param   {Spine.Unity.MeshGeneratorBuffers}    buffers
     * @return  {void}
     */


    /*Spine.Unity.SkeletonRenderer start.*/
    /**
     * Base class of animated Spine skeleton components. This component manages and renders a skeleton.
     *
     * @public
     * @class Spine.Unity.SkeletonRenderer
     * @augments UnityEngine.MonoBehaviour
     * @implements  Spine.Unity.ISkeletonComponent
     * @implements  Spine.Unity.IHasSkeletonDataAsset
     */
    Bridge.define("Spine.Unity.SkeletonRenderer", {
        inherits: [UnityEngine.MonoBehaviour,Spine.Unity.ISkeletonComponent,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 8
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_NONE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 4
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE: 0,
                /**
                 * Shader property value used as Stencil comparison function for {@link }.
                 *
                 * @static
                 * @public
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @constant
                 * @default 5
                 * @type UnityEngine.Rendering.CompareFunction
                 */
                STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE: 0,
                /**
                 * Shader property ID used for the Stencil comparison function.
                 *
                 * @static
                 * @public
                 * @readonly
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @type number
                 */
                STENCIL_COMP_PARAM_ID: 0,
                SUBMESH_DUMMY_PARAM_ID: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                    this.STENCIL_COMP_MASKINTERACTION_NONE = UnityEngine.Rendering.CompareFunction.Always;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE = UnityEngine.Rendering.CompareFunction.LessEqual;
                    this.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE = UnityEngine.Rendering.CompareFunction.Greater;
                    this.STENCIL_COMP_PARAM_ID = UnityEngine.Shader.PropertyToID("_StencilComp");
                    this.SUBMESH_DUMMY_PARAM_ID = UnityEngine.Shader.PropertyToID("_Submesh");
                }
            },
            methods: {
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static start.*/
                NewSpineGameObject: function (T, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#NewSpineGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(T, new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonRenderer.NewSpineGameObject:static end.*/

                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static start.*/
                /**
                 * Add and prepare a Spine component that derives from SkeletonRenderer to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonRenderer
                 * @memberof Spine.Unity.SkeletonRenderer
                 * @param   {Function}                         T                    T should be SkeletonRenderer or any of its derived classes.
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {T}
                 */
                AddSpineComponent: function (T, gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AddSpineComponent", this ); }

                    if (quiet === void 0) { quiet = false; }
                    var c = Bridge.rValue(gameObject.AddComponent(T));
                    if (skeletonDataAsset != null) {
Bridge.rValue(                        c).skeletonDataAsset = skeletonDataAsset;
Bridge.rValue(                        c).Initialize(false, quiet);
                    }
                    return Bridge.rValue(c);
                },
                /*Spine.Unity.SkeletonRenderer.AddSpineComponent:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            /**
             * Skin name to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type string
             */
            initialSkinName: null,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipX: false,
            /**
             * Enable this parameter when overwriting the Skeleton's skin from an editor script.
             Otherwise any changes will be overwritten by the next inspector update.
             * Flip X and Y to use when the Skeleton is initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type boolean
             */
            initialFlipY: false,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            zSpacing: 0,
            /**
             * Use Spine's clipping feature. If false, ClippingAttachments will be ignored.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            useClipping: false,
            /**
             * If true, triangles will not be updated. Enable this as an optimization if the skeleton does not make use of attachment swapping or hiding, or draw order keys. Otherwise, setting this to false may cause errors in rendering.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            immutableTriangles: false,
            /**
             * Multiply vertex color RGB with vertex color alpha. Set this to true if the shader used for rendering is a premultiplied alpha shader. Setting this to false disables single-batch additive slots.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default true
             * @type boolean
             */
            pmaVertexColors: false,
            /**
             * Clears the state of the render and skeleton when this component or its GameObject is disabled. This prevents previous state from being retained when it is enabled again. When pooling your skeleton, setting this to true can be helpful.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            clearStateOnDisable: false,
            /**
             * If true, second colors on slots will be added to the output Mesh as UV2 and UV3. A special "tint black" shader that interprets UV2 and UV3 as black point colors is required to render this properly.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            tintBlack: false,
            /**
             * If true, the renderer assumes the skeleton only requires one Material and one submesh to render. This allows the MeshGenerator to skip checking for changes in Materials. Enable this as an optimization if the skeleton only uses one Material.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            singleSubmesh: false,
            /**
             * Applies only when 3+ submeshes are used (2+ materials with alternating order, e.g. "A B A").
             If true, GPU instancing is disabled at all materials and MaterialPropertyBlocks are assigned at each
             material to prevent aggressive batching of submeshes by e.g. the LWRP renderer, leading to incorrect
             draw order (e.g. "A1 B A2" changed to "A1A2 B").
             You can disable this parameter when everything is drawn correctly to save the additional performance cost.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            fixDrawOrder: false,
            /**
             * If true, the mesh generator adds normals to the output mesh. For better performance and reduced memory requirements, use a shader that assumes the desired normal.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            addNormals: false,
            /**
             * If true, tangents are calculated every frame and added to the Mesh. Enable this when using a shader that uses lighting that requires tangents.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @default false
             * @type boolean
             */
            calculateTangents: false,
            /**
             * This enum controls the mode under which the sprite will interact with the masking system.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type UnityEngine.SpriteMaskInteraction
             */
            maskInteraction: 0,
            /**
             * Material references for switching material sets at runtime when {@link } changes.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @type Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials
             */
            maskMaterials: null,
            disableRenderingOnOverride: false,
            customMaterialOverride: null,
            customSlotMaterials: null,
            currentInstructions: null,
            meshGenerator: null,
            rendererBuffers: null,
            meshRenderer: null,
            meshFilter: null,
            valid: false,
            skeleton: null,
            reusedPropertyBlock: null
        },
        events: {
            generateMeshOverride: null,
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data is populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is called at the end of LateUpdate after the Mesh and
             all materials have been updated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonRenderer.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null
        },
        props: {
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            /**
             * Use this Dictionary to override a Material with a different Material.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            /**
             * Use this Dictionary to use a different Material to render specific Slots.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonRenderer
             * @function CustomSlotMaterials
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomSlotMaterials: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#CustomSlotMaterials#get", this ); }

                    return this.customSlotMaterials;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                }
            },
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            }
        },
        alias: [
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#init", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.useClipping = true;
                this.immutableTriangles = false;
                this.pmaVertexColors = true;
                this.clearStateOnDisable = false;
                this.tintBlack = false;
                this.singleSubmesh = false;
                this.fixDrawOrder = false;
                this.addNormals = false;
                this.calculateTangents = false;
                this.maskInteraction = UnityEngine.SpriteMaskInteraction.None;
                this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                this.disableRenderingOnOverride = true;
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Material,UnityEngine.Material)).ctor();
                this.customSlotMaterials = new (System.Collections.Generic.Dictionary$2(Spine.Slot,UnityEngine.Material)).ctor();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.rendererBuffers = new Spine.Unity.MeshRendererBuffers();
            }
        },
        methods: {
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            addGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#addGenerateMeshOverride", this ); }

                this.addgenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && !Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = false;
                    }
                    this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                }
            },
            /**
             * Allows separate code to take over rendering for this SkeletonRenderer component. The subscriber is passed a SkeletonRendererInstruction argument to determine how to render a skeleton.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonRenderer
             * @event Spine.Unity.SkeletonRenderer#GenerateMeshOverride
             * @return  {Spine.Unity.SkeletonRenderer.InstructionDelegate}
             */
            removeGenerateMeshOverride: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#removeGenerateMeshOverride", this ); }

                this.removegenerateMeshOverride(value);
                if (this.disableRenderingOnOverride && Bridge.staticEquals(this.generateMeshOverride, null)) {
                    this.Initialize(false);
                    if (UnityEngine.Object.op_Implicit(this.meshRenderer)) {
                        this.meshRenderer.enabled = true;
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings start.*/
            /**
             * Applies MeshGenerator settings to the SkeletonRenderer and its internal MeshGenerator.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {Spine.Unity.MeshGenerator.Settings}    settings
             * @return  {void}
             */
            SetMeshSettings: function (settings) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMeshSettings", this ); }

                this.calculateTangents = settings.calculateTangents;
                this.immutableTriangles = settings.immutableTriangles;
                this.pmaVertexColors = settings.pmaVertexColors;
                this.tintBlack = settings.tintBlack;
                this.useClipping = settings.useClipping;
                this.zSpacing = settings.zSpacing;

                this.meshGenerator.settings = settings.$clone();
            },
            /*Spine.Unity.SkeletonRenderer.SetMeshSettings end.*/

            /*Spine.Unity.SkeletonRenderer.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Awake", this ); }

                this.Initialize(false);
                if (Bridge.staticEquals(this.generateMeshOverride, null) || !this.disableRenderingOnOverride) {
                    this.updateMode = this.updateWhenInvisible;
                }
            },
            /*Spine.Unity.SkeletonRenderer.Awake end.*/

            /*Spine.Unity.SkeletonRenderer.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDisable", this ); }

                if (this.clearStateOnDisable && this.valid) {
                    this.ClearState();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnDisable end.*/

            /*Spine.Unity.SkeletonRenderer.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnDestroy", this ); }

                this.rendererBuffers.Dispose();
                this.valid = false;
            },
            /*Spine.Unity.SkeletonRenderer.OnDestroy end.*/

            /*Spine.Unity.SkeletonRenderer.ClearState start.*/
            /**
             * Clears the previously generated mesh and resets the skeleton's pose.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ClearState", this ); }

                var meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Inequality(meshFilter, null)) {
                    meshFilter.sharedMesh = null;
                }
                this.currentInstructions.Clear();
                if (this.skeleton != null) {
                    this.skeleton.setToSetupPose();
                }
            },
            /*Spine.Unity.SkeletonRenderer.ClearState end.*/

            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity start.*/
            /**
             * Sets a minimum buffer size for the internal MeshGenerator to prevent excess allocations during animation.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {number}    minimumVertexCount
             * @return  {void}
             */
            EnsureMeshGeneratorCapacity: function (minimumVertexCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#EnsureMeshGeneratorCapacity", this ); }

                this.meshGenerator.EnsureVertexCapacity(minimumVertexCount);
            },
            /*Spine.Unity.SkeletonRenderer.EnsureMeshGeneratorCapacity end.*/

            /*Spine.Unity.SkeletonRenderer.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Skeleton object and buffers.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, it will overwrite internal objects if they were already generated. Otherwise, the initialized component will ignore subsequent calls to initialize.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#Initialize", this ); }

                var $t;
                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                // Clear
                {
                    // Note: do not reset meshFilter.sharedMesh or meshRenderer.sharedMaterial to null,
                    // otherwise constant reloading will be triggered at prefabs.
                    this.currentInstructions.Clear();
                    this.rendererBuffers.Clear();
                    this.meshGenerator.Begin();
                    this.skeleton = null;
                    this.valid = false;
                }

                if (this.skeletonDataAsset == null) {
                    return;
                }

                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }
                this.valid = true;

                this.meshFilter = this.GetComponent(UnityEngine.MeshFilter);
                if (UnityEngine.Component.op_Equality(this.meshFilter, null)) {
                    this.meshFilter = this.gameObject.AddComponent(UnityEngine.MeshFilter);
                }

                this.meshRenderer = this.GetComponent(UnityEngine.MeshRenderer);
                this.rendererBuffers.Initialize();

                this.skeleton = ($t = new Spine.Skeleton.$ctor1(skeletonData), $t.scaleX = this.initialFlipX ? -1 : 1, $t.scaleY = this.initialFlipY ? -1 : 1, $t);

                if (!System.String.isNullOrEmpty(this.initialSkinName) && !System.String.equals(this.initialSkinName, "default", 4)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                // Generate mesh once, required to update mesh bounds for visibility
                var updateModeSaved = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.skeleton.updateWorldTransform();
                this.LateUpdate();
                this.updateMode = updateModeSaved;

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

            },
            /*Spine.Unity.SkeletonRenderer.Initialize end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdate start.*/
            /**
             * Generates a new UnityEngine.Mesh from the internal Skeleton.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdate", this ); }

                if (!this.valid) {
                    return;
                }


                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                this.LateUpdateMesh();
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdate end.*/

            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh start.*/
            LateUpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#LateUpdateMesh", this ); }

                var $t, $t1;
                var doMeshOverride = !Bridge.staticEquals(this.generateMeshOverride, null);
                if ((!UnityEngine.Object.op_Implicit(this.meshRenderer) || !this.meshRenderer.enabled) && !doMeshOverride) {
                    return;
                }
                var currentInstructions = this.currentInstructions;
                var workingSubmeshInstructions = currentInstructions.submeshInstructions;
                var currentSmartMesh = this.rendererBuffers.GetNextMesh(); // Double-buffer for performance.

                var updateTriangles;

                if (this.singleSubmesh) {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(currentInstructions, this.skeleton, ($t = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.AddSubmesh(workingSubmeshInstructions.Items[0], updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }

                } else {
                    // STEP 1. Determine a SmartMesh.Instruction. Split up instructions into submeshes. =============================================
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(currentInstructions, this.skeleton, this.customSlotMaterials, this.separatorSlots, doMeshOverride, this.immutableTriangles);

                    // STEP 1.9. Post-process workingInstructions. ==================================================================================
                    if (this.customMaterialOverride.Count > 0) {
                        Spine.Unity.MeshGenerator.TryReplaceMaterials(workingSubmeshInstructions, this.customMaterialOverride);
                    }

                    if (doMeshOverride) {
                        this.generateMeshOverride(currentInstructions);
                        if (this.disableRenderingOnOverride) {
                            return;
                        }
                    }

                    updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, currentSmartMesh.instructionUsed);

                    // STEP 2. Update vertex buffer based on verts from the attachments. ===========================================================
                    this.meshGenerator.settings = ($t1 = new Spine.Unity.MeshGenerator.Settings(), $t1.pmaVertexColors = this.pmaVertexColors, $t1.zSpacing = this.zSpacing, $t1.useClipping = this.useClipping, $t1.tintBlack = this.tintBlack, $t1.calculateTangents = this.calculateTangents, $t1.addNormals = this.addNormals, $t1);
                    this.meshGenerator.Begin();
                    if (currentInstructions.hasActiveClipping) {
                        this.meshGenerator.BuildMesh(currentInstructions, updateTriangles);
                    } else {
                        this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                    }
                }

                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                // STEP 3. Move the mesh data into a UnityEngine.Mesh ===========================================================================
                var currentMesh = currentSmartMesh.mesh;
                this.meshGenerator.FillVertexData(currentMesh);

                this.rendererBuffers.UpdateSharedMaterials(workingSubmeshInstructions);

                var materialsChanged = this.rendererBuffers.MaterialsChangedInLastUpdate();
                if (updateTriangles) { // Check if the triangles should also be updated.
                    this.meshGenerator.FillTriangles(currentMesh);
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                } else if (materialsChanged) {
                    this.meshRenderer.sharedMaterials = this.rendererBuffers.GetUpdatedSharedMaterialsArray();
                }
                if (materialsChanged && (this.maskMaterials.AnyMaterialCreated)) {
                    this.maskMaterials = new Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials();
                }

                this.meshGenerator.FillLateVertexData(currentMesh);

                // STEP 4. The UnityEngine.Mesh is ready. Set it as the MeshFilter's mesh. Store the instructions used for that mesh. ===========
                if (UnityEngine.Object.op_Implicit(this.meshFilter)) {
                    this.meshFilter.sharedMesh = currentMesh;
                }
                currentSmartMesh.instructionUsed.Set(currentInstructions);

                if (UnityEngine.Component.op_Inequality(this.meshRenderer, null)) {
                    this.AssignSpriteMaskMaterials();
                }
                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }

                if (this.fixDrawOrder && this.meshRenderer.sharedMaterials.length > 2) {
                    this.SetMaterialSettingsToFixDrawOrder();
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonRenderer.LateUpdateMesh end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonRenderer.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 start.*/
            FindAndApplySeparatorSlots$1: function (startsWith, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots$1", this ); }

                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (System.String.isNullOrEmpty(startsWith)) {
                    return;
                }

                this.FindAndApplySeparatorSlots(function (slotName) {
                    return System.String.startsWith(slotName, startsWith);
                }, clearExistingSeparators, updateStringArray);
            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots$1 end.*/

            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots start.*/
            FindAndApplySeparatorSlots: function (slotNamePredicate, clearExistingSeparators, updateStringArray) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#FindAndApplySeparatorSlots", this ); }

                var $t, $t1, $t2;
                if (clearExistingSeparators === void 0) { clearExistingSeparators = true; }
                if (updateStringArray === void 0) { updateStringArray = false; }
                if (Bridge.staticEquals(slotNamePredicate, null)) {
                    return;
                }
                if (!this.valid) {
                    return;
                }

                if (clearExistingSeparators) {
                    this.separatorSlots.clear();
                }

                var slots = this.skeleton.Slots;
                $t = Bridge.getEnumerator(slots);
                try {
                    while ($t.moveNext()) {
                        var slot = $t.Current;
                        if (slotNamePredicate(slot.data.name)) {
                            this.separatorSlots.add(slot);
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                if (updateStringArray) {
                    var detectedSeparatorNames = new (System.Collections.Generic.List$1(System.String)).ctor();
                    $t1 = Bridge.getEnumerator(this.skeleton.Slots);
                    try {
                        while ($t1.moveNext()) {
                            var slot1 = $t1.Current;
                            var slotName = slot1.data.name;
                            if (slotNamePredicate(slotName)) {
                                detectedSeparatorNames.add(slotName);
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                    if (!clearExistingSeparators) {
                        var originalNames = this.separatorSlotNames;
                        $t2 = Bridge.getEnumerator(originalNames);
                        try {
                            while ($t2.moveNext()) {
                                var originalName = $t2.Current;
                                detectedSeparatorNames.add(originalName);
                            }
                        } finally {
                            if (Bridge.is($t2, System.IDisposable)) {
                                $t2.System$IDisposable$Dispose();
                            }
                        }
                    }

                    this.separatorSlotNames = detectedSeparatorNames.ToArray();
                }

            },
            /*Spine.Unity.SkeletonRenderer.FindAndApplySeparatorSlots end.*/

            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#ReapplySeparatorSlotNames", this ); }

                if (!this.valid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slot = this.skeleton.findSlot(this.separatorSlotNames[i]);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials start.*/
            AssignSpriteMaskMaterials: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#AssignSpriteMaskMaterials", this ); }

                var $t, $t1, $t2;

                if (UnityEngine.Application.isPlaying) {
                    if (this.maskInteraction !== UnityEngine.SpriteMaskInteraction.None && this.maskMaterials.materialsMaskDisabled.length === 0) {
                        this.maskMaterials.materialsMaskDisabled = this.meshRenderer.sharedMaterials;
                    }
                }

                if (this.maskMaterials.materialsMaskDisabled.length > 0 && ($t = this.maskMaterials.materialsMaskDisabled)[0] != null && this.maskInteraction === UnityEngine.SpriteMaskInteraction.None) {
                    this.meshRenderer.materials = this.maskMaterials.materialsMaskDisabled;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleInsideMask) {
                    if (this.maskMaterials.materialsInsideMask.length === 0 || ($t1 = this.maskMaterials.materialsInsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsInsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsInsideMask;
                } else if (this.maskInteraction === UnityEngine.SpriteMaskInteraction.VisibleOutsideMask) {
                    if (this.maskMaterials.materialsOutsideMask.length === 0 || ($t2 = this.maskMaterials.materialsOutsideMask)[0] == null) {
                        if (!this.InitSpriteMaskMaterialsOutsideMask()) {
                            return;
                        }
                    }
                    this.meshRenderer.materials = this.maskMaterials.materialsOutsideMask;
                }
            },
            /*Spine.Unity.SkeletonRenderer.AssignSpriteMaskMaterials end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask start.*/
            InitSpriteMaskMaterialsInsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsInsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE, Bridge.ref(this.maskMaterials, "materialsInsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsInsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask start.*/
            InitSpriteMaskMaterialsOutsideMask: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsOutsideMask", this ); }

                return this.InitSpriteMaskMaterialsForMaskType(Spine.Unity.SkeletonRenderer.STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE, Bridge.ref(this.maskMaterials, "materialsOutsideMask"));
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsOutsideMask end.*/

            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType start.*/
            InitSpriteMaskMaterialsForMaskType: function (maskFunction, materialsToFill) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#InitSpriteMaskMaterialsForMaskType", this ); }

                var originalMaterials = this.maskMaterials.materialsMaskDisabled;
                materialsToFill.v = System.Array.init(originalMaterials.length, null, UnityEngine.Material);
                for (var i = 0; i < originalMaterials.length; i = (i + 1) | 0) {
                    var originalMaterial = originalMaterials[i];
                    if (originalMaterial == null) {
                        materialsToFill.v[i] = null;
                        continue;
                    }
                    var newMaterial = new UnityEngine.Material.$ctor1(originalMaterial);
                    newMaterial.SetFloat(Spine.Unity.SkeletonRenderer.STENCIL_COMP_PARAM_ID, maskFunction);
                    materialsToFill.v[i] = newMaterial;
                }
                return true;
            },
            /*Spine.Unity.SkeletonRenderer.InitSpriteMaskMaterialsForMaskType end.*/

            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#HandleOnDemandLoading", this ); }

                var $t, $t1, $t2;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();
                            for (var i = 0, count = this.meshRenderer.sharedMaterials.length; i < count; i = (i + 1) | 0) {
                                var overrideMaterial = { v : null };
                                atlasAsset.RequireTexturesLoaded(($t1 = this.meshRenderer.sharedMaterials)[i], overrideMaterial);
                                if (overrideMaterial.v != null) {
                                    ($t2 = this.meshRenderer.sharedMaterials)[i] = overrideMaterial.v;
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonRenderer.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder start.*/
            /**
             * This method was introduced as a workaround for too aggressive submesh draw call batching,
             leading to incorrect draw order when 3+ materials are used at submeshes in alternating order.
             Otherwise, e.g. when using Lightweight Render Pipeline, deliberately separated draw calls
             "A1 B A2" are reordered to "A1A2 B", regardless of batching-related project settings.
             *
             * @instance
             * @private
             * @this Spine.Unity.SkeletonRenderer
             * @memberof Spine.Unity.SkeletonRenderer
             * @return  {void}
             */
            SetMaterialSettingsToFixDrawOrder: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonRenderer#SetMaterialSettingsToFixDrawOrder", this ); }

                var $t, $t1;
                if (this.reusedPropertyBlock == null) {
                    this.reusedPropertyBlock = new UnityEngine.MaterialPropertyBlock();
                }

                var hasPerRendererBlock = this.meshRenderer.HasPropertyBlock();
                if (hasPerRendererBlock) {
                    this.meshRenderer.GetPropertyBlock(this.reusedPropertyBlock);
                }

                for (var i = 0; i < this.meshRenderer.sharedMaterials.length; i = (i + 1) | 0) {
                    if (!UnityEngine.Object.op_Implicit(($t = this.meshRenderer.sharedMaterials)[i])) {
                        continue;
                    }

                    if (!hasPerRendererBlock) {
                        this.meshRenderer.GetPropertyBlock$1(this.reusedPropertyBlock, i);
                    }
                    // Note: this parameter shall not exist at any shader, then Unity will create separate
                    // material instances (not in terms of memory cost or leakage).
                    this.reusedPropertyBlock.SetFloat(Spine.Unity.SkeletonRenderer.SUBMESH_DUMMY_PARAM_ID, i);
                    this.meshRenderer.SetPropertyBlock$1(this.reusedPropertyBlock, i);

                    ($t1 = this.meshRenderer.sharedMaterials)[i].enableInstancing = false;
                }
            },
            /*Spine.Unity.SkeletonRenderer.SetMaterialSettingsToFixDrawOrder end.*/


        },
        overloads: {
            "FindAndApplySeparatorSlots(string, bool, bool)": "FindAndApplySeparatorSlots$1"
        }
    });
    /*Spine.Unity.SkeletonRenderer end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple
     * @param   {number}                          meshCount           
     * @param   {Array.<UnityEngine.Mesh>}        meshes              
     * @param   {Array.<UnityEngine.Material>}    graphicMaterials    
     * @param   {Array.<UnityEngine.Texture>}     textures
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle
     * @param   {UnityEngine.Mesh}        mesh               
     * @param   {UnityEngine.Material}    graphicMaterial    
     * @param   {UnityEngine.Texture}     texture
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.ISkeletonAnimationDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.InstructionDelegate
     * @param   {Spine.Unity.SkeletonRendererInstruction}    instruction
     * @return  {void}
     */

    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate
     * @param   {Spine.Unity.SkeletonGraphic}    skeletonGraphic
     * @return  {void}
     */


    /*Spine.Unity.SkeletonGraphic start.*/
    Bridge.define("Spine.Unity.SkeletonGraphic", {
        inherits: [UnityEngine.UI.MaskableGraphic,Spine.Unity.ISkeletonComponent,Spine.Unity.IAnimationStateComponent,Spine.Unity.ISkeletonAnimation,Spine.Unity.IHasSkeletonDataAsset],
        statics: {
            fields: {
                EditReferenceRect: false,
                SeparatorPartGameObjectName: null
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                    this.EditReferenceRect = false;
                    this.SeparatorPartGameObjectName = "Part";
                }
            },
            methods: {
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static start.*/
                /**
                 * Create a new GameObject with a SkeletonGraphic component.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Transform}            parent               
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                NewSkeletonGraphicGameObject: function (skeletonDataAsset, parent, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#NewSkeletonGraphicGameObject", this ); }

                    var sg = Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent(new UnityEngine.GameObject.$ctor2("New Spine GameObject"), skeletonDataAsset, material);
                    if (UnityEngine.Component.op_Inequality(parent, null)) {
                        sg.transform.SetParent(parent, false);
                    }
                    return sg;
                },
                /*Spine.Unity.SkeletonGraphic.NewSkeletonGraphicGameObject:static end.*/

                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static start.*/
                /**
                 * Add a SkeletonGraphic component to a GameObject.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonGraphic
                 * @memberof Spine.Unity.SkeletonGraphic
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {UnityEngine.Material}             material             Material for the canvas renderer to use. Usually, the default SkeletonGraphic material will work.
                 * @return  {Spine.Unity.SkeletonGraphic}
                 */
                AddSkeletonGraphicComponent: function (gameObject, skeletonDataAsset, material) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AddSkeletonGraphicComponent", this ); }

                    var skeletonGraphic = gameObject.AddComponent(Spine.Unity.SkeletonGraphic);
                    if (skeletonDataAsset != null) {
                        skeletonGraphic.material = material;
                        skeletonGraphic.skeletonDataAsset = skeletonDataAsset;
                        skeletonGraphic.Initialize(false);
                    }
                    var canvasRenderer = gameObject.GetComponent(UnityEngine.CanvasRenderer);
                    if (UnityEngine.Object.op_Implicit(canvasRenderer)) {
                        canvasRenderer.cullTransparentMesh = false;
                    }
                    return skeletonGraphic;
                },
                /*Spine.Unity.SkeletonGraphic.AddSkeletonGraphicComponent:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static start.*/
                SetRectTransformSize$1: function (target, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize$1", this ); }

                    Spine.Unity.SkeletonGraphic.SetRectTransformSize(target.rectTransform, size);
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize$1:static end.*/

                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static start.*/
                SetRectTransformSize: function (targetRectTransform, size) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformSize", this ); }

                    var $t;
                    var parentSize = pc.Vec2.ZERO.clone();
                    if (UnityEngine.Component.op_Inequality(targetRectTransform.parent, null)) {
                        var parentTransform = targetRectTransform.parent.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(parentTransform)) {
                            parentSize = parentTransform.rect.size.$clone();
                        }
                    }
                    var anchorAreaSize = ($t = targetRectTransform.anchorMax.$clone().sub( targetRectTransform.anchorMin ), new pc.Vec2( $t.x * parentSize.x, $t.y * parentSize.y ));
                    targetRectTransform.sizeDelta = size.$clone().sub( anchorAreaSize );
                },
                /*Spine.Unity.SkeletonGraphic.SetRectTransformSize:static end.*/


            }
        },
        fields: {
            skeletonDataAsset: null,
            additiveMaterial: null,
            multiplyMaterial: null,
            screenMaterial: null,
            initialSkinName: null,
            initialFlipX: false,
            initialFlipY: false,
            startingAnimation: null,
            startingLoop: false,
            timeScale: 0,
            freeze: false,
            meshScale: 0,
            layoutScaleMode: 0,
            referenceSize: null,
            referenceScale: 0,
            updateMode: 0,
            /**
             * Update mode used when the MeshRenderer becomes invisible
             (when <pre><code>OnBecameInvisible()</code></pre> is called). Update mode is automatically
             reset to <pre><code>UpdateMode.FullUpdate</code></pre> when the mesh becomes visible again.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Spine.Unity.UpdateMode
             */
            updateWhenInvisible: 0,
            allowMultipleCanvasRenderers: false,
            canvasRenderers: null,
            submeshGraphics: null,
            usedRenderersCount: 0,
            /**
             * Slot names used to populate separatorSlots list when the Skeleton is initialized. Changing this after initialization does nothing.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonGraphic
             * @type Array.<string>
             */
            separatorSlotNames: null,
            /**
             * Slots that determine where the render is split. This is used by components such as SkeletonRenderSeparator so that the skeleton can be rendered by two separate renderers on different GameObjects.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @type System.Collections.Generic.List$1
             */
            separatorSlots: null,
            enableSeparatorSlots: false,
            separatorParts: null,
            updateSeparatorPartLocation: false,
            updateSeparatorPartScale: false,
            wasUpdatedAfterInit: false,
            baseTexture: null,
            /**
             * When true, no meshes and materials are assigned at CanvasRenderers if the used override
             AssignMeshOverrideSingleRenderer or AssignMeshOverrideMultipleRenderers is non-null.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @default true
             * @type boolean
             */
            disableMeshAssignmentOnOverride: false,
            customTextureOverride: null,
            customMaterialOverride: null,
            overrideTexture: null,
            skeleton: null,
            state: null,
            meshGenerator: null,
            meshBuffers: null,
            currentInstructions: null,
            meshes: null,
            usedMaterials: null,
            usedTextures: null,
            updateTiming: 0,
            unscaledTime: false
        },
        events: {
            assignMeshOverrideSingle: null,
            assignMeshOverrideMultiple: null,
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnRebuild is raised after the Skeleton is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnRebuild
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnRebuild: null,
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            /**
             * OnInstructionsPrepared is raised at the end of <pre><code>LateUpdate</code></pre> after render instructions
             are done, target renderers are prepared, and the mesh is ready to be generated.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnInstructionsPrepared
             * @param   {Spine.Unity.SkeletonGraphic.InstructionDelegate}    value
             * @return  {void}
             */
            OnInstructionsPrepared: null,
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            /**
             * OnMeshAndMaterialsUpdated is raised at the end of <pre><code>Rebuild</code></pre> after the Mesh and
             all materials have been updated. Note that some Unity API calls are not permitted to be issued from
             <pre><code>Rebuild</code></pre>, so you may want to subscribe to {@link } instead
             from where you can issue such preparation calls.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnMeshAndMaterialsUpdated
             * @param   {Spine.Unity.SkeletonGraphic.SkeletonRendererDelegate}    value
             * @return  {void}
             */
            OnMeshAndMaterialsUpdated: null,
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnAnimationRebuild
             * @param   {Spine.Unity.ISkeletonAnimationDelegate}    value
             * @return  {void}
             */
            OnAnimationRebuild: null,
            BeforeApply: null,
            UpdateLocal: null,
            UpdateWorld: null,
            UpdateComplete: null,
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function addOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            /**
             * Occurs after the vertex data populated every frame, before the vertices are pushed into the mesh.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonGraphic
             * @memberof Spine.Unity.SkeletonGraphic
             * @function removeOnPostProcessVertices
             * @param   {Spine.Unity.MeshGeneratorDelegate}    value
             * @return  {void}
             */
            OnPostProcessVertices: null
        },
        props: {
            SkeletonDataAsset: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonDataAsset#get", this ); }

                    return this.skeletonDataAsset;
                }
            },
            MeshScale: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshScale#get", this ); }

                    return this.meshScale;
                }
            },
            /**
             * Update mode to optionally limit updates to e.g. only apply animations but not update the mesh.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @function UpdateMode
             * @type Spine.Unity.UpdateMode
             */
            UpdateMode: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#get", this ); }

                    return this.updateMode;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMode#set", this ); }

                    this.updateMode = value;
                }
            },
            SeparatorParts: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SeparatorParts#get", this ); }

                    return this.separatorParts;
                }
            },
            /**
             * Use this Dictionary to override a Texture with a different Texture.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomTextureOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomTextureOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomTextureOverride#get", this ); }

                    return this.customTextureOverride;
                }
            },
            /**
             * Use this Dictionary to override the Material where the Texture was used at the original atlas.
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonGraphic
             * @function CustomMaterialOverride
             * @type System.Collections.Generic.Dictionary$2
             */
            CustomMaterialOverride: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#CustomMaterialOverride#get", this ); }

                    return this.customMaterialOverride;
                }
            },
            OverrideTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#get", this ); }

                    return this.overrideTexture;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OverrideTexture#set", this ); }

                    this.overrideTexture = value;
                    this.canvasRenderer.SetTexture(this.mainTexture); // Refresh canvasRenderer's texture. Make sure it handles null.
                }
            },
            mainTexture: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#mainTexture#get", this ); }

                    if (this.overrideTexture != null) {
                        return this.overrideTexture;
                    }
                    return this.baseTexture;
                }
            },
            Skeleton: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#get", this ); }

                    this.Initialize(false);
                    return this.skeleton;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Skeleton#set", this ); }

                    this.skeleton = value;
                }
            },
            SkeletonData: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SkeletonData#get", this ); }

                    this.Initialize(false);
                    return this.skeleton == null ? null : this.skeleton.data;
                }
            },
            IsValid: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#IsValid#get", this ); }

                    return this.skeleton != null;
                }
            },
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            MeshGenerator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshGenerator#get", this ); }

                    return this.meshGenerator;
                }
            },
            MeshesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MeshesMultipleCanvasRenderers#get", this ); }

                    return this.meshes;
                }
            },
            MaterialsMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MaterialsMultipleCanvasRenderers#get", this ); }

                    return this.usedMaterials;
                }
            },
            TexturesMultipleCanvasRenderers: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TexturesMultipleCanvasRenderers#get", this ); }

                    return this.usedTextures;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            }
        },
        alias: [
            "SkeletonDataAsset", "Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset",
            "SkeletonDataAsset", "Spine$Unity$ISkeletonComponent$SkeletonDataAsset",
            "Rebuild", "UnityEngine$UI$ICanvasElement$Rebuild",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton",
            "Skeleton", "Spine$Unity$ISkeletonComponent$Skeleton",
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#init", this ); }

                this.referenceSize = new UnityEngine.Vector2();
                this.timeScale = 1.0;
                this.meshScale = 1.0;
                this.layoutScaleMode = Spine.Unity.SkeletonGraphic.LayoutMode.None;
                this.referenceSize = pc.Vec2.ONE.clone();
                this.referenceScale = 1.0;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
                this.updateWhenInvisible = Spine.Unity.UpdateMode.FullUpdate;
                this.allowMultipleCanvasRenderers = false;
                this.canvasRenderers = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                this.submeshGraphics = new (System.Collections.Generic.List$1(Spine.Unity.SkeletonSubmeshGraphic)).ctor();
                this.usedRenderersCount = 0;
                this.separatorSlotNames = System.Array.init(0, null, System.String);
                this.separatorSlots = new (System.Collections.Generic.List$1(Spine.Slot)).ctor();
                this.enableSeparatorSlots = false;
                this.separatorParts = new (System.Collections.Generic.List$1(UnityEngine.Transform)).ctor();
                this.updateSeparatorPartLocation = true;
                this.updateSeparatorPartScale = false;
                this.wasUpdatedAfterInit = true;
                this.disableMeshAssignmentOnOverride = true;
                this.customTextureOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Texture)).ctor();
                this.customMaterialOverride = new (System.Collections.Generic.Dictionary$2(UnityEngine.Texture,UnityEngine.Material)).ctor();
                this.meshGenerator = new Spine.Unity.MeshGenerator();
                this.currentInstructions = new Spine.Unity.SkeletonRendererInstruction();
                this.meshes = new (Spine.ExposedList$1(UnityEngine.Mesh)).ctor();
                this.usedMaterials = new (Spine.ExposedList$1(UnityEngine.Material)).ctor();
                this.usedTextures = new (Spine.ExposedList$1(UnityEngine.Texture)).ctor();
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            addAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideSingleRenderer", this ); }

                this.addassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is false.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideSingleRenderer
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateSingle}
             */
            removeAssignMeshOverrideSingleRenderer: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideSingleRenderer", this ); }

                this.removeassignMeshOverrideSingle(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            addAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#addAssignMeshOverrideMultipleRenderers", this ); }

                this.addassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && !Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /**
             * Allows separate code to take over mesh and material assignment for this SkeletonGraphic component.
             Used when <pre><code>allowMultipleCanvasRenderers</code></pre> is true.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonGraphic
             * @event Spine.Unity.SkeletonGraphic#AssignMeshOverrideMultipleRenderers
             * @return  {Spine.Unity.SkeletonGraphic.MeshAssignmentDelegateMultiple}
             */
            removeAssignMeshOverrideMultipleRenderers: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#removeAssignMeshOverrideMultipleRenderers", this ); }

                this.removeassignMeshOverrideMultiple(value);
                if (this.disableMeshAssignmentOnOverride && Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.Initialize(false);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Awake", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Awake.call(this);
                this.onCullStateChanged.AddListener(Bridge.fn.cacheBind(this, this.OnCullStateChanged));

                this.SyncSubmeshGraphicsWithCanvasRenderers();
                if (!this.IsValid) {
                    this.Initialize(false);
                    if (this.IsValid) {
                        this.Rebuild(UnityEngine.UI.CanvasUpdate.PreRender);
                    }
                }

            },
            /*Spine.Unity.SkeletonGraphic.Awake end.*/

            /*Spine.Unity.SkeletonGraphic.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDestroy", this ); }

                this.Clear();
                UnityEngine.UI.MaskableGraphic.prototype.OnDestroy.call(this);
            },
            /*Spine.Unity.SkeletonGraphic.OnDestroy end.*/

            /*Spine.Unity.SkeletonGraphic.Rebuild start.*/
            Rebuild: function (update) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Rebuild", this ); }

                UnityEngine.UI.MaskableGraphic.prototype.Rebuild.call(this, update);
                if (!this.IsValid) {
                    return;
                }
                if (this.canvasRenderer.cull) {
                    return;
                }
                if (update === UnityEngine.UI.CanvasUpdate.PreRender) {
                    this.PrepareInstructionsAndRenderers(true);
                    this.UpdateMeshToInstructions();
                }
                if (this.allowMultipleCanvasRenderers) {
                    this.canvasRenderer.Clear();
                }
            },
            /*Spine.Unity.SkeletonGraphic.Rebuild end.*/

            /*Spine.Unity.SkeletonGraphic.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnDisable", this ); }

                var $t;
                UnityEngine.UI.MaskableGraphic.prototype.OnDisable.call(this);
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        canvasRenderer.Clear();
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnDisable end.*/

            /*Spine.Unity.SkeletonGraphic.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.Update end.*/

            /*Spine.Unity.SkeletonGraphic.Update$1 start.*/
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Update$1", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonGraphic.Update$1 end.*/

            /*Spine.Unity.SkeletonGraphic.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#FixedUpdate", this ); }

                if (this.freeze || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.FixedUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers start.*/
            SyncSubmeshGraphicsWithCanvasRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SyncSubmeshGraphicsWithCanvasRenderers", this ); }

                var $t;
                this.submeshGraphics.clear();

                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        var submeshGraphic = canvasRenderer.GetComponent(Spine.Unity.SkeletonSubmeshGraphic);
                        if (UnityEngine.MonoBehaviour.op_Equality(submeshGraphic, null)) {
                            submeshGraphic = canvasRenderer.gameObject.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                            submeshGraphic.maskable = this.maskable;
                            submeshGraphic.raycastTarget = false;
                        }
                        this.submeshGraphics.add(submeshGraphic);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.SyncSubmeshGraphicsWithCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonGraphic.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonGraphic.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this.BeforeApply, null)) {
                    this.BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonGraphic.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this.UpdateLocal, null)) {
                    this.UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this.UpdateWorld, null)) {
                    this.UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this.UpdateComplete, null)) {
                    this.UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonGraphic.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#LateUpdate", this ); }

                if (!this.IsValid) {
                    return;
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                if (this.freeze) {
                    return;
                }
                if (this.updateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    return;
                }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate) {
                    this.Update$1(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                this.UpdateMesh();
            },
            /*Spine.Unity.SkeletonGraphic.LateUpdate end.*/

            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged start.*/
            OnCullStateChanged: function (culled) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnCullStateChanged", this ); }

                if (culled) {
                    this.OnBecameInvisible();
                } else {
                    this.OnBecameVisible();
                }
            },
            /*Spine.Unity.SkeletonGraphic.OnCullStateChanged end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameVisible", this ); }

                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameVisible end.*/

            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible start.*/
            OnBecameInvisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#OnBecameInvisible", this ); }

                this.updateMode = this.updateWhenInvisible;
            },
            /*Spine.Unity.SkeletonGraphic.OnBecameInvisible end.*/

            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames start.*/
            ReapplySeparatorSlotNames: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#ReapplySeparatorSlotNames", this ); }

                if (!this.IsValid) {
                    return;
                }

                this.separatorSlots.clear();
                for (var i = 0, n = this.separatorSlotNames.length; i < n; i = (i + 1) | 0) {
                    var slotName = this.separatorSlotNames[i];
                    if (Bridge.referenceEquals(slotName, "")) {
                        continue;
                    }
                    var slot = this.skeleton.findSlot(slotName);
                    if (slot != null) {
                        this.separatorSlots.add(slot);
                    }
                }
                this.UpdateSeparatorPartParents();
            },
            /*Spine.Unity.SkeletonGraphic.ReapplySeparatorSlotNames end.*/

            /*Spine.Unity.SkeletonGraphic.GetLastMesh start.*/
            GetLastMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLastMesh", this ); }

                return this.meshBuffers.GetCurrent().mesh;
            },
            /*Spine.Unity.SkeletonGraphic.GetLastMesh end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds start.*/
            MatchRectTransformWithBounds: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformWithBounds", this ); }

                if (!this.wasUpdatedAfterInit) {
                    this.Update$1(0);
                }
                this.UpdateMesh();

                if (!this.allowMultipleCanvasRenderers) {
                    return this.MatchRectTransformSingleRenderer();
                } else {
                    return this.MatchRectTransformMultipleRenderers();
                }
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformWithBounds end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer start.*/
            MatchRectTransformSingleRenderer: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformSingleRenderer", this ); }

                var mesh = this.GetLastMesh();
                if (mesh == null) {
                    return false;
                }
                if (mesh.vertexCount === 0 || pc.Vec3.equals( mesh.bounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }
                mesh.RecalculateBounds();
                this.SetRectTransformBounds(mesh.bounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformSingleRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers start.*/
            MatchRectTransformMultipleRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#MatchRectTransformMultipleRenderers", this ); }

                var $t;
                var anyBoundsAdded = false;
                var combinedBounds = new pc.BoundingBox.ctor();
                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (!canvasRenderer.gameObject.activeSelf) {
                        continue;
                    }

                    var mesh = ($t = this.meshes.Items)[i];
                    if (mesh == null || mesh.vertexCount === 0) {
                        continue;
                    }

                    mesh.RecalculateBounds();
                    var bounds = mesh.bounds;
                    if (anyBoundsAdded) {
                        combinedBounds.add( bounds );
                    } else {
                        anyBoundsAdded = true;
                        combinedBounds = bounds;
                    }
                }

                if (!anyBoundsAdded || pc.Vec3.equals( combinedBounds.halfExtents.$clone().scale( 2 ), pc.Vec3.ZERO.clone() )) {
                    this.rectTransform.sizeDelta = new pc.Vec2( 50.0, 50.0 );
                    this.rectTransform.pivot = new pc.Vec2( 0.5, 0.5 );
                    return false;
                }

                this.SetRectTransformBounds(combinedBounds);
                return true;
            },
            /*Spine.Unity.SkeletonGraphic.MatchRectTransformMultipleRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds start.*/
            SetRectTransformBounds: function (combinedBounds) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#SetRectTransformBounds", this ); }

                var $t, $t1;
                var size = combinedBounds.halfExtents.$clone().scale( 2 ).$clone();
                var center = combinedBounds.center.$clone();
                var p = new pc.Vec2( 0.5 - (center.x / size.x), 0.5 - (center.y / size.y) );

                Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(this, UnityEngine.Vector2.FromVector3(size));
                this.rectTransform.pivot = p.$clone();

                $t = Bridge.getEnumerator(this.separatorParts);
                try {
                    while ($t.moveNext()) {
                        var separatorPart = $t.Current;
                        var separatorTransform = separatorPart.GetComponent(UnityEngine.RectTransform);
                        if (UnityEngine.Object.op_Implicit(separatorTransform)) {
                            Spine.Unity.SkeletonGraphic.SetRectTransformSize(separatorTransform, UnityEngine.Vector2.FromVector3(size));
                            separatorTransform.pivot = p.$clone();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                $t1 = Bridge.getEnumerator(this.submeshGraphics);
                try {
                    while ($t1.moveNext()) {
                        var submeshGraphic = $t1.Current;
                        Spine.Unity.SkeletonGraphic.SetRectTransformSize$1(submeshGraphic, UnityEngine.Vector2.FromVector3(size));
                        submeshGraphic.rectTransform.pivot = p.$clone();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                this.referenceSize = UnityEngine.Vector2.FromVector3(size.$clone());
            },
            /*Spine.Unity.SkeletonGraphic.SetRectTransformBounds end.*/

            /*Spine.Unity.SkeletonGraphic.Clear start.*/
            Clear: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Clear", this ); }

                this.skeleton = null;
                this.canvasRenderer.Clear();

                for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                }
                this.DestroyMeshes();
                this.usedMaterials.Clear();
                this.usedTextures.Clear();
                this.DisposeMeshBuffers();
            },
            /*Spine.Unity.SkeletonGraphic.Clear end.*/

            /*Spine.Unity.SkeletonGraphic.TrimRenderers start.*/
            TrimRenderers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#TrimRenderers", this ); }

                var $t;
                var newList = new (System.Collections.Generic.List$1(UnityEngine.CanvasRenderer)).ctor();
                $t = Bridge.getEnumerator(this.canvasRenderers);
                try {
                    while ($t.moveNext()) {
                        var canvasRenderer = $t.Current;
                        if (canvasRenderer.gameObject.activeSelf) {
                            newList.add(canvasRenderer);
                        } else {
                            if (UnityEngine.Application.isEditor && !UnityEngine.Application.isPlaying) {
                                UnityEngine.Object.DestroyImmediate(canvasRenderer.gameObject);
                            } else {
                                UnityEngine.MonoBehaviour.Destroy(canvasRenderer.gameObject);
                            }
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.canvasRenderers = newList;
                this.SyncSubmeshGraphicsWithCanvasRenderers();
            },
            /*Spine.Unity.SkeletonGraphic.TrimRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.Initialize start.*/
            Initialize: function (overwrite) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#Initialize", this ); }

                var $t, $t1;
                if (this.IsValid && !overwrite) {
                    return;
                }
                if (this.skeletonDataAsset == null) {
                    return;
                }
                var skeletonData = this.skeletonDataAsset.GetSkeletonData(false);
                if (skeletonData == null) {
                    return;
                }

                if (this.skeletonDataAsset.atlasAssets.length <= 0 || ($t = this.skeletonDataAsset.atlasAssets)[0].MaterialCount <= 0) {
                    return;
                }

                this.skeleton = ($t1 = new Spine.Skeleton.$ctor1(skeletonData), $t1.scaleX = this.initialFlipX ? -1 : 1, $t1.scaleY = this.initialFlipY ? -1 : 1, $t1);

                this.InitMeshBuffers();
                this.baseTexture = ($t1 = this.skeletonDataAsset.atlasAssets)[0].PrimaryMaterial.mainTexture;
                this.canvasRenderer.SetTexture(this.mainTexture); // Needed for overwriting initializations.

                // Set the initial Skin and Animation
                if (!System.String.isNullOrEmpty(this.initialSkinName)) {
                    this.skeleton.setSkinByName(this.initialSkinName);
                }

                this.separatorSlots.clear();
                for (var i = 0; i < this.separatorSlotNames.length; i = (i + 1) | 0) {
                    this.separatorSlots.add(this.skeleton.findSlot(this.separatorSlotNames[i]));
                }

                if (!Bridge.staticEquals(this.OnRebuild, null)) {
                    this.OnRebuild(this);
                }

                this.wasUpdatedAfterInit = false;
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                if (this.state == null) {
                    this.Clear();
                    return;
                }

                if (!System.String.isNullOrEmpty(this.startingAnimation)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this.startingAnimation);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.startingLoop );
                    }
                }

                if (!Bridge.staticEquals(this.OnAnimationRebuild, null)) {
                    this.OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.Initialize end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers start.*/
            PrepareInstructionsAndRenderers: function (isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareInstructionsAndRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                if (!this.allowMultipleCanvasRenderers) {
                    Spine.Unity.MeshGenerator.GenerateSingleSubmeshInstruction(this.currentInstructions, this.skeleton, null);
                    if (this.canvasRenderers.Count > 0) {
                        this.DisableUnusedCanvasRenderers(0, isInRebuild);
                    }
                    this.usedRenderersCount = 0;
                } else {
                    Spine.Unity.MeshGenerator.GenerateSkeletonRendererInstruction(this.currentInstructions, this.skeleton, null, this.enableSeparatorSlots ? this.separatorSlots : null, this.enableSeparatorSlots ? this.separatorSlots.Count > 0 : false, false);

                    var submeshCount = this.currentInstructions.submeshInstructions.Count;
                    this.EnsureCanvasRendererCount(submeshCount);
                    this.EnsureMeshesCount(submeshCount);
                    this.EnsureUsedTexturesAndMaterialsCount(submeshCount);
                    this.EnsureSeparatorPartCount();
                    this.PrepareRendererGameObjects(this.currentInstructions, isInRebuild);
                }
                if (!Bridge.staticEquals(this.OnInstructionsPrepared, null)) {
                    this.OnInstructionsPrepared(this.currentInstructions);
                }
            },
            /*Spine.Unity.SkeletonGraphic.PrepareInstructionsAndRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMesh start.*/
            UpdateMesh: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMesh", this ); }

                this.PrepareInstructionsAndRenderers();
                this.UpdateMeshToInstructions();
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMesh end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions start.*/
            UpdateMeshToInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshToInstructions", this ); }

                if (!this.IsValid || this.currentInstructions.rawVertexCount < 0) {
                    return;
                }
                Spine.Unity.SkeletonExtensions.SetColor$4(this.skeleton, this.color.$clone());

                if (!this.allowMultipleCanvasRenderers) {
                    this.UpdateMeshSingleCanvasRenderer(this.currentInstructions);
                } else {
                    this.UpdateMaterialsMultipleCanvasRenderers(this.currentInstructions);
                    this.UpdateMeshMultipleCanvasRenderers(this.currentInstructions);
                }

                if (!Bridge.staticEquals(this.OnMeshAndMaterialsUpdated, null)) {
                    this.OnMeshAndMaterialsUpdated(this);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshToInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions start.*/
            HasMultipleSubmeshInstructions: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HasMultipleSubmeshInstructions", this ); }

                if (!this.IsValid) {
                    return false;
                }
                return Spine.Unity.MeshGenerator.RequiresMultipleSubmeshesByDrawOrder(this.skeleton);
            },
            /*Spine.Unity.SkeletonGraphic.HasMultipleSubmeshInstructions end.*/

            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers start.*/
            InitMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#InitMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Clear();
                    this.meshBuffers.GetNext().Clear();
                } else {
                    this.meshBuffers = new (Spine.Unity.DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh))();
                }
            },
            /*Spine.Unity.SkeletonGraphic.InitMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers start.*/
            DisposeMeshBuffers: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisposeMeshBuffers", this ); }

                if (this.meshBuffers != null) {
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers.GetNext().Dispose();
                    this.meshBuffers = null;
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisposeMeshBuffers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer start.*/
            UpdateMeshSingleCanvasRenderer: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshSingleCanvasRenderer", this ); }

                var $t, $t1;
                var smartMesh = this.meshBuffers.GetNext();
                var updateTriangles = Spine.Unity.SkeletonRendererInstruction.GeometryNotEqual(currentInstructions, smartMesh.instructionUsed);
                this.meshGenerator.Begin();

                var useAddSubmesh = currentInstructions.hasActiveClipping && currentInstructions.submeshInstructions.Count > 0;
                if (useAddSubmesh) {
                    this.meshGenerator.AddSubmesh(($t = currentInstructions.submeshInstructions.Items)[0], updateTriangles);
                } else {
                    this.meshGenerator.BuildMeshWithArrays(currentInstructions, updateTriangles);
                }

                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    if (true) {
                        this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                this.meshGenerator.ScaleVertexData(this.meshScale);
                if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                    this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                }

                var mesh = smartMesh.mesh;
                this.meshGenerator.FillVertexData(mesh);
                if (updateTriangles) {
                    this.meshGenerator.FillTriangles(mesh);
                }
                this.meshGenerator.FillLateVertexData(mesh);

                smartMesh.instructionUsed.Set(currentInstructions);
                if (!Bridge.staticEquals(this.assignMeshOverrideSingle, null)) {
                    this.assignMeshOverrideSingle(mesh, this.canvasRenderer.GetMaterial(), this.mainTexture);
                }

                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    this.canvasRenderer.SetMesh(mesh);
                } else {
                    this.canvasRenderer.SetMesh(null);
                }

                var assignTexture = false;
                if (currentInstructions.submeshInstructions.Count > 0) {
                    var material = ($t1 = currentInstructions.submeshInstructions.Items)[0].material;
                    if (material != null && !Bridge.referenceEquals(this.baseTexture, material.mainTexture)) {
                        this.baseTexture = material.mainTexture;
                        if (this.overrideTexture == null && assignAtCanvasRenderer) {
                            assignTexture = true;
                        }
                    }
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                if (assignTexture) {
                    this.canvasRenderer.SetTexture(this.mainTexture);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshSingleCanvasRenderer end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers start.*/
            UpdateMaterialsMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMaterialsMultipleCanvasRenderers", this ); }

                var $t;
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;

                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    var submeshMaterial = submeshInstructionItem.material;
                    if (useOriginalTextureAndMaterial) {
                        if (submeshMaterial == null) {
                            usedMaterialItems[i] = null;
                            usedTextureItems[i] = null;
                            continue;
                        }
                        usedTextureItems[i] = submeshMaterial.mainTexture;
                        if (!hasBlendModeMaterials) {
                            usedMaterialItems[i] = this.materialForRendering;
                        } else {
                            var blendMode = blendModeMaterials.BlendModeForMaterial(submeshMaterial);
                            var usedMaterial = this.materialForRendering;
                            if (blendMode === spine.BlendMode.Additive && !pmaVertexColors && UnityEngine.Object.op_Implicit(this.additiveMaterial)) {
                                usedMaterial = this.additiveMaterial;
                            } else if (blendMode === spine.BlendMode.Multiply && UnityEngine.Object.op_Implicit(this.multiplyMaterial)) {
                                usedMaterial = this.multiplyMaterial;
                            } else {
                                if (blendMode === spine.BlendMode.Screen && UnityEngine.Object.op_Implicit(this.screenMaterial)) {
                                    usedMaterial = this.screenMaterial;
                                }
                            }
                            usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial);
                        }
                    } else {
                        var originalTexture = submeshMaterial.mainTexture;
                        var usedMaterial1 = { };
                        var usedTexture = { };
                        if (!this.customMaterialOverride.tryGetValue(originalTexture, usedMaterial1)) {
                            usedMaterial1.v = this.material;
                        }
                        if (!this.customTextureOverride.tryGetValue(originalTexture, usedTexture)) {
                            usedTexture.v = originalTexture;
                        }

                        usedMaterialItems[i] = this.submeshGraphics.getItem(i).GetModifiedMaterial(usedMaterial1.v);
                        usedTextureItems[i] = usedTexture.v;
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMaterialsMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers start.*/
            UpdateMeshMultipleCanvasRenderers: function (currentInstructions) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateMeshMultipleCanvasRenderers", this ); }

                var $t;
                this.meshScale = (UnityEngine.Component.op_Equality(this.canvas, null)) ? 100 : this.canvas.referencePixelsPerUnit;
                if (this.layoutScaleMode !== Spine.Unity.SkeletonGraphic.LayoutMode.None) {
                    this.meshScale *= this.referenceScale;
                    if (true) {
                        this.meshScale *= this.GetLayoutScale(this.layoutScaleMode);
                    }
                }
                // Generate meshes.
                var submeshCount = currentInstructions.submeshInstructions.Count;
                var meshesItems = this.meshes.Items;
                var useOriginalTextureAndMaterial = (this.customMaterialOverride.Count === 0 && this.customTextureOverride.Count === 0);

                var blendModeMaterials = this.skeletonDataAsset.blendModeMaterials;
                var hasBlendModeMaterials = blendModeMaterials.RequiresBlendModeMaterials;
                var mainCullTransparentMesh = this.canvasRenderer.cullTransparentMesh;
                var pmaVertexColors = this.meshGenerator.settings.pmaVertexColors;
                var usedMaterialItems = this.usedMaterials.Items;
                var usedTextureItems = this.usedTextures.Items;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    this.meshGenerator.Begin();
                    this.meshGenerator.AddSubmesh(submeshInstructionItem);

                    var targetMesh = meshesItems[i];
                    this.meshGenerator.ScaleVertexData(this.meshScale);
                    if (!Bridge.staticEquals(this.OnPostProcessVertices, null)) {
                        this.OnPostProcessVertices(this.meshGenerator.Buffers.$clone());
                    }
                    this.meshGenerator.FillVertexData(targetMesh);
                    this.meshGenerator.FillTriangles(targetMesh);
                    this.meshGenerator.FillLateVertexData(targetMesh);

                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride) {
                        canvasRenderer.SetMesh(targetMesh);
                    } else {
                        canvasRenderer.SetMesh(null);
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (useOriginalTextureAndMaterial && hasBlendModeMaterials) {
                        var allowCullTransparentMesh = true;
                        var materialBlendMode = blendModeMaterials.BlendModeForMaterial(usedMaterialItems[i]);
                        if ((materialBlendMode === spine.BlendMode.Normal && submeshInstructionItem.hasPMAAdditiveSlot) || (materialBlendMode === spine.BlendMode.Additive && pmaVertexColors)) {
                            allowCullTransparentMesh = false;
                        }
                        canvasRenderer.cullTransparentMesh = allowCullTransparentMesh ? mainCullTransparentMesh : false;
                    }
                    canvasRenderer.materialCount = 1;
                }

                if (UnityEngine.Application.isPlaying) {
                    this.HandleOnDemandLoading();
                }
                var assignAtCanvasRenderer = (Bridge.staticEquals(this.assignMeshOverrideSingle, null) || !this.disableMeshAssignmentOnOverride);
                if (assignAtCanvasRenderer) {
                    for (var i1 = 0; i1 < submeshCount; i1 = (i1 + 1) | 0) {
                        var canvasRenderer1 = this.canvasRenderers.getItem(i1);
                        canvasRenderer1.SetMaterial$1(usedMaterialItems[i1], usedTextureItems[i1]);
                    }
                }

                if (!Bridge.staticEquals(this.assignMeshOverrideMultiple, null)) {
                    this.assignMeshOverrideMultiple(submeshCount, meshesItems, usedMaterialItems, usedTextureItems);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateMeshMultipleCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading start.*/
            HandleOnDemandLoading: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#HandleOnDemandLoading", this ); }

                var $t, $t1;
                $t = Bridge.getEnumerator(this.skeletonDataAsset.atlasAssets);
                try {
                    while ($t.moveNext()) {
                        var atlasAsset = $t.Current;
                        if (atlasAsset.TextureLoadingMode !== Spine.Unity.AtlasAssetBase.LoadingMode.Normal) {
                            atlasAsset.BeginCustomTextureLoading();

                            if (!this.allowMultipleCanvasRenderers) {
                                var loadedTexture = { v : null };
                                atlasAsset.RequireTextureLoaded(this.mainTexture, loadedTexture, null);
                                if (UnityEngine.Object.op_Implicit(loadedTexture.v)) {
                                    this.baseTexture = loadedTexture.v;
                                }
                            } else {
                                var textureItems = this.usedTextures.Items;
                                for (var i = 0, count = this.usedTextures.Count; i < count; i = (i + 1) | 0) {
                                    var loadedTexture1 = { v : null };
                                    atlasAsset.RequireTextureLoaded(textureItems[i], loadedTexture1, null);
                                    if (UnityEngine.Object.op_Implicit(loadedTexture1.v)) {
                                        ($t1 = this.usedTextures.Items)[i] = loadedTexture1.v;
                                    }
                                }
                            }
                            atlasAsset.EndCustomTextureLoading();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.HandleOnDemandLoading end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount start.*/
            EnsureCanvasRendererCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureCanvasRendererCount", this ); }

                var currentCount = this.canvasRenderers.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("Renderer{0}", [Bridge.box(i, System.Int32)]), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);
                    go.transform.localPosition = pc.Vec3.ZERO.clone();
                    var canvasRenderer = go.AddComponent(UnityEngine.CanvasRenderer);
                    this.canvasRenderers.add(canvasRenderer);
                    var submeshGraphic = go.AddComponent(Spine.Unity.SkeletonSubmeshGraphic);
                    submeshGraphic.maskable = this.maskable;
                    submeshGraphic.raycastTarget = false;
                    submeshGraphic.rectTransform.pivot = this.rectTransform.pivot.$clone();
                    submeshGraphic.rectTransform.anchorMin = pc.Vec2.ZERO.clone();
                    submeshGraphic.rectTransform.anchorMax = pc.Vec2.ONE.clone();
                    submeshGraphic.rectTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    this.submeshGraphics.add(submeshGraphic);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureCanvasRendererCount end.*/

            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects start.*/
            PrepareRendererGameObjects: function (currentInstructions, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#PrepareRendererGameObjects", this ); }

                var $t;
                if (isInRebuild === void 0) { isInRebuild = false; }

                var submeshCount = currentInstructions.submeshInstructions.Count;
                this.DisableUnusedCanvasRenderers(submeshCount, isInRebuild);

                var parent = this.separatorParts.Count === 0 ? this.transform : this.separatorParts.getItem(0);
                if (this.updateSeparatorPartLocation) {
                    for (var p = 0; p < this.separatorParts.Count; p = (p + 1) | 0) {
                        var separatorPart = this.separatorParts.getItem(p);
                        if (UnityEngine.Component.op_Equality(separatorPart, null)) {
                            continue;
                        }
                        separatorPart.position = this.transform.position.$clone();
                        separatorPart.rotation = this.transform.rotation.$clone();
                    }
                }
                if (this.updateSeparatorPartScale) {
                    var targetScale = this.transform.lossyScale.$clone();
                    for (var p1 = 0; p1 < this.separatorParts.Count; p1 = (p1 + 1) | 0) {
                        var separatorPart1 = this.separatorParts.getItem(p1);
                        if (UnityEngine.Component.op_Equality(separatorPart1, null)) {
                            continue;
                        }
                        var partParent = separatorPart1.parent;
                        var parentScale = UnityEngine.Component.op_Equality(partParent, null) ? new pc.Vec3( 1, 1, 1 ) : partParent.lossyScale.$clone();
                        separatorPart1.localScale = new pc.Vec3( parentScale.x === 0.0 ? 1.0 : targetScale.x / parentScale.x, parentScale.y === 0.0 ? 1.0 : targetScale.y / parentScale.y, parentScale.z === 0.0 ? 1.0 : targetScale.z / parentScale.z );
                    }
                }

                var separatorSlotGroupIndex = 0;
                var targetSiblingIndex = 0;
                for (var i = 0; i < submeshCount; i = (i + 1) | 0) {
                    var canvasRenderer = this.canvasRenderers.getItem(i);
                    if (UnityEngine.Component.op_Inequality(canvasRenderer, null)) {
                        if (i >= this.usedRenderersCount) {
                            canvasRenderer.gameObject.SetActive(true);
                        }

                        if (UnityEngine.Component.op_Inequality(canvasRenderer.transform.parent, parent.transform) && !isInRebuild) {
                            canvasRenderer.transform.SetParent(parent.transform, false);
                        }

                        canvasRenderer.transform.SetSiblingIndex(Bridge.identity(targetSiblingIndex, ((targetSiblingIndex = (targetSiblingIndex + 1) | 0))));
                    }

                    var submeshGraphic = this.submeshGraphics.getItem(i);
                    if (UnityEngine.MonoBehaviour.op_Inequality(submeshGraphic, null)) {
                        var dstTransform = submeshGraphic.rectTransform;
                        dstTransform.localPosition = pc.Vec3.ZERO.clone();
                        dstTransform.pivot = this.rectTransform.pivot.$clone();
                        dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                        dstTransform.anchorMax = pc.Vec2.ONE.clone();
                        dstTransform.sizeDelta = pc.Vec2.ZERO.clone();
                    }

                    var submeshInstructionItem = ($t = currentInstructions.submeshInstructions.Items)[i].$clone();
                    if (submeshInstructionItem.forceSeparate) {
                        targetSiblingIndex = 0;
                        parent = this.separatorParts.getItem(((separatorSlotGroupIndex = (separatorSlotGroupIndex + 1) | 0)));
                    }
                }
                this.usedRenderersCount = submeshCount;
            },
            /*Spine.Unity.SkeletonGraphic.PrepareRendererGameObjects end.*/

            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers start.*/
            DisableUnusedCanvasRenderers: function (usedCount, isInRebuild) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DisableUnusedCanvasRenderers", this ); }

                if (isInRebuild === void 0) { isInRebuild = false; }
                for (var i = usedCount; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                    this.canvasRenderers.getItem(i).Clear();
                    if (!isInRebuild) {
                        this.canvasRenderers.getItem(i).gameObject.SetActive(false);
                    }
                }
            },
            /*Spine.Unity.SkeletonGraphic.DisableUnusedCanvasRenderers end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount start.*/
            EnsureMeshesCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureMeshesCount", this ); }

                var oldCount = this.meshes.Count;
                this.meshes.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.meshes.Add(Spine.Unity.SpineMesh.NewSkeletonMesh());
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureMeshesCount end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount start.*/
            EnsureUsedTexturesAndMaterialsCount: function (targetCount) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureUsedTexturesAndMaterialsCount", this ); }

                var oldCount = this.usedMaterials.Count;
                this.usedMaterials.EnsureCapacity(targetCount);
                this.usedTextures.EnsureCapacity(targetCount);
                for (var i = oldCount; i < targetCount; i = (i + 1) | 0) {
                    this.usedMaterials.Add(null);
                    this.usedTextures.Add(null);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureUsedTexturesAndMaterialsCount end.*/

            /*Spine.Unity.SkeletonGraphic.DestroyMeshes start.*/
            DestroyMeshes: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#DestroyMeshes", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.meshes);
                try {
                    while ($t.moveNext()) {
                        var mesh = $t.Current;
                        UnityEngine.Object.Destroy(mesh);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this.meshes.Clear();
            },
            /*Spine.Unity.SkeletonGraphic.DestroyMeshes end.*/

            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount start.*/
            EnsureSeparatorPartCount: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#EnsureSeparatorPartCount", this ); }

                var targetCount = (this.separatorSlots.Count + 1) | 0;
                if (targetCount === 1) {
                    return;
                }

                var currentCount = this.separatorParts.Count;
                for (var i = currentCount; i < targetCount; i = (i + 1) | 0) {
                    var go = new UnityEngine.GameObject.$ctor3(System.String.format("{0}[{1}]", Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName, Bridge.box(i, System.Int32)), UnityEngine.RectTransform);
                    go.transform.SetParent(this.transform, false);

                    var dstTransform = go.transform.GetComponent(UnityEngine.RectTransform);
                    dstTransform.localPosition = pc.Vec3.ZERO.clone();
                    dstTransform.pivot = this.rectTransform.pivot.$clone();
                    dstTransform.anchorMin = pc.Vec2.ZERO.clone();
                    dstTransform.anchorMax = pc.Vec2.ONE.clone();
                    dstTransform.sizeDelta = pc.Vec2.ZERO.clone();

                    this.separatorParts.add(go.transform);
                }
            },
            /*Spine.Unity.SkeletonGraphic.EnsureSeparatorPartCount end.*/

            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents start.*/
            UpdateSeparatorPartParents: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#UpdateSeparatorPartParents", this ); }

                var usedCount = (this.separatorSlots.Count + 1) | 0;
                if (usedCount === 1) {
                    usedCount = 0; // placed directly at the SkeletonGraphic parent
                    for (var i = 0; i < this.canvasRenderers.Count; i = (i + 1) | 0) {
                        var canvasRenderer = this.canvasRenderers.getItem(i);
                        if (System.String.contains(canvasRenderer.transform.parent.name,Spine.Unity.SkeletonGraphic.SeparatorPartGameObjectName)) {
                            canvasRenderer.transform.SetParent(this.transform, false);
                            canvasRenderer.transform.localPosition = pc.Vec3.ZERO.clone();
                        }
                    }
                }
                for (var i1 = 0; i1 < this.separatorParts.Count; i1 = (i1 + 1) | 0) {
                    var isUsed = i1 < usedCount;
                    this.separatorParts.getItem(i1).gameObject.SetActive(isUsed);
                }
            },
            /*Spine.Unity.SkeletonGraphic.UpdateSeparatorPartParents end.*/

            /*Spine.Unity.SkeletonGraphic.GetLayoutScale start.*/
            GetLayoutScale: function (mode) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetLayoutScale", this ); }

                var currentSize = this.GetCurrentRectSize();
                var referenceAspect = this.referenceSize.x / this.referenceSize.y;
                var frameAspect = currentSize.x / currentSize.y;
                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.FitInParent) {
                    mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth : Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight;
                } else {
                    if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.EnvelopeParent) {
                        mode = frameAspect > referenceAspect ? Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight : Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth;
                    }
                }

                if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.WidthControlsHeight) {
                    return currentSize.x / this.referenceSize.x;
                } else if (mode === Spine.Unity.SkeletonGraphic.LayoutMode.HeightControlsWidth) {
                    return currentSize.y / this.referenceSize.y;
                }
                return 1.0;
            },
            /*Spine.Unity.SkeletonGraphic.GetLayoutScale end.*/

            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize start.*/
            GetCurrentRectSize: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonGraphic#GetCurrentRectSize", this ); }

                return this.rectTransform.rect.size.$clone();
            },
            /*Spine.Unity.SkeletonGraphic.GetCurrentRectSize end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonGraphic end.*/

    /*StarGenerate start.*/
    Bridge.define("StarGenerate", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            coinPrefab: null,
            holder: null,
            numberCoin: 0,
            delay: 0,
            durationNear: 0,
            durationTarget: 0,
            easeNear: 0,
            easeTarget: 0,
            scale: 0,
            scaleTo: 0,
            offsetNear: 0,
            setStarCountEvent: null,
            setFromCoinEvent: null,
            addTargetToCoinGenerateEvent: null,
            removeTargetToCoinGenerateEvent: null,
            moveOneCoinDone: null,
            moveAllCoinDone: null,
            decreaseCoinEvent: null,
            addCoinEvent: null,
            minusCoinEvent: null,
            playSoundFx: null,
            soundCoinMove: null,
            isScaleIconTo: false,
            from: null,
            to: null,
            coinsActive: null,
            listTo: null,
            cacheCurrentCoin: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "StarGenerate#init", this ); }

                this.from = new UnityEngine.Vector3();
                this.scale = 1;
                this.scaleTo = 1;
                this.offsetNear = 1;
                this.isScaleIconTo = false;
                this.coinsActive = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
                this.listTo = new (System.Collections.Generic.List$1(UnityEngine.GameObject)).ctor();
            }
        },
        methods: {
            /*StarGenerate.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "StarGenerate#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.addCoinEvent.AddListener(Bridge.fn.cacheBind(this, this.GenerateCoin));
                this.minusCoinEvent.AddListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.setStarCountEvent.AddListener$1(Bridge.fn.cacheBind(this, this.SetNumberCoin));
                this.setFromCoinEvent.AddListener$1(Bridge.fn.cacheBind(this, this.SetFrom));
                this.addTargetToCoinGenerateEvent.AddListener$1(Bridge.fn.cacheBind(this, this.AddTo));
                this.removeTargetToCoinGenerateEvent.AddListener$1(Bridge.fn.cacheBind(this, this.RemoveTo));
                this.SetFrom(this.holder.position);
                this.SaveCache();
            },
            /*StarGenerate.OnEnable end.*/

            /*StarGenerate.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "StarGenerate#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.addCoinEvent.RemoveListener(Bridge.fn.cacheBind(this, this.GenerateCoin));
                this.minusCoinEvent.RemoveListener(Bridge.fn.cacheBind(this, this.DecreaseCoin));
                this.setStarCountEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.SetNumberCoin));
                this.setFromCoinEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.SetFrom));
                this.addTargetToCoinGenerateEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.AddTo));
                this.removeTargetToCoinGenerateEvent.RemoveListener$1(Bridge.fn.cacheBind(this, this.RemoveTo));
            },
            /*StarGenerate.OnDisable end.*/

            /*StarGenerate.SaveCache start.*/
            SaveCache: function () {
if ( TRACE ) { TRACE( "StarGenerate#SaveCache", this ); }

                this.cacheCurrentCoin = CoinSystem.GetCurrentCoin();
            },
            /*StarGenerate.SaveCache end.*/

            /*StarGenerate.DecreaseCoin start.*/
            DecreaseCoin: function () {
if ( TRACE ) { TRACE( "StarGenerate#DecreaseCoin", this ); }

                this.decreaseCoinEvent.Raise();
                this.SaveCache();
            },
            /*StarGenerate.DecreaseCoin end.*/

            /*StarGenerate.SetFrom start.*/
            SetFrom: function (from) {
if ( TRACE ) { TRACE( "StarGenerate#SetFrom", this ); }

                this.from = from.$clone();
            },
            /*StarGenerate.SetFrom end.*/

            /*StarGenerate.AddTo start.*/
            AddTo: function (obj) {
if ( TRACE ) { TRACE( "StarGenerate#AddTo", this ); }

                this.listTo.add(obj);
                this.to = System.Linq.Enumerable.from(this.listTo, UnityEngine.GameObject).last();
            },
            /*StarGenerate.AddTo end.*/

            /*StarGenerate.RemoveTo start.*/
            RemoveTo: function (obj) {
if ( TRACE ) { TRACE( "StarGenerate#RemoveTo", this ); }

                this.listTo.remove(obj);
                if (this.listTo.Count > 0) {
                    this.to = System.Linq.Enumerable.from(this.listTo, UnityEngine.GameObject).last();
                }
            },
            /*StarGenerate.RemoveTo end.*/

            /*StarGenerate.GenerateCoin start.*/
            GenerateCoin: function () {
if ( TRACE ) { TRACE( "StarGenerate#GenerateCoin", this ); }

                var $step = 0,
                    $task1, 
                    $jumpFromFinally, 
                    i, 
                    coin, 
                    $asyncBody = Bridge.fn.bind(this, function () {
                        for (;;) {
                            $step = System.Array.min([0,1,2,3,4,5], $step);
                            switch ($step) {
                                case 0: {
                                    this.isScaleIconTo = false;
                                    i = 0;
                                    $step = 1;
                                    continue;
                                }
                                case 1: {
                                    if ( i < this.numberCoin ) {
                                        $step = 2;
                                        continue;
                                    }
                                    $step = 5;
                                    continue;
                                }
                                case 2: {
                                    $task1 = System.Threading.Tasks.Task.delay(UnityEngine.Random.Range(0, this.delay));
                                    $step = 3;
                                    if ($task1.isCompleted()) {
                                        continue;
                                    }
                                    $task1.continue($asyncBody);
                                    return;
                                }
                                case 3: {
                                    $task1.getAwaitedResult();
                                    coin = { v : VirtueSky.ObjectPooling.Pool.Spawn$2(this.coinPrefab, this.holder) };
                                    coin.v.transform.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.scale );
                                    this.coinsActive.add(coin.v);
                                    coin.v.transform.position = this.from.$clone();

                                    this.MoveToTarget(coin.v, (function ($me, coin) {
                                        return Bridge.fn.bind($me, function () {
                                            this.coinsActive.remove(coin.v);
                                            VirtueSky.ObjectPooling.Pool.DeSpawn(coin.v);
                                            if (!this.isScaleIconTo) {
                                                this.isScaleIconTo = true;
                                                this.playSoundFx.Raise(this.soundCoinMove);
                                                this.AddComplete();
                                            }

                                            this.moveOneCoinDone.Raise();
                                            if (this.coinsActive.Count === 0) {
                                                this.moveAllCoinDone.Raise();
                                                this.SaveCache();
                                                this.SetFrom(this.holder.position);
                                            }
                                        });
                                    })(this, coin));
                                    $step = 4;
                                    continue;
                                }
                                case 4: {
                                    i = (i + 1) | 0;
                                    $step = 1;
                                    continue;
                                }
                                case 5: {
                                    return;
                                }
                                default: {
                                    return;
                                }
                            }
                        }
                    }, arguments);

                $asyncBody();
            },
            /*StarGenerate.GenerateCoin end.*/

            /*StarGenerate.MoveToTarget start.*/
            MoveToTarget: function (coin, completed) {
if ( TRACE ) { TRACE( "StarGenerate#MoveToTarget", this ); }

                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(coin.transform, coin.transform.position.$clone().add( UnityEngine.Vector3.FromVector2(UnityEngine.Random.insideUnitCircle).clone().scale( this.offsetNear ) ), this.durationNear), this.easeNear), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Sequence, DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Sequence, DG.Tweening.ShortcutExtensions.DOJump(coin.transform, this.to.transform.position.$clone(), 0.15, 1, this.durationTarget), this.easeTarget), function () {
                        !Bridge.staticEquals(completed, null) ? completed() : null;
                    });
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale(coin.transform, this.scaleTo, this.durationTarget), this.easeTarget);
                }));
            },
            /*StarGenerate.MoveToTarget end.*/

            /*StarGenerate.SetNumberCoin start.*/
            SetNumberCoin: function (_numberCoin) {
if ( TRACE ) { TRACE( "StarGenerate#SetNumberCoin", this ); }

                this.numberCoin = _numberCoin;
            },
            /*StarGenerate.SetNumberCoin end.*/

            /*StarGenerate.AddComplete start.*/
            AddComplete: function () {
if ( TRACE ) { TRACE( "StarGenerate#AddComplete", this ); }

                var currentScale = new pc.Vec3( 1, 1, 1 );
                var nextScale = currentScale.$clone().add( new pc.Vec3( 0.15, 0.15, 0.15 ) );
                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.to.transform.parent, nextScale.$clone(), 0.15), DG.Tweening.Ease.OutBack), Bridge.fn.bind(this, function () {
                    DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.to.transform.parent.transform, currentScale.$clone(), 0.1), DG.Tweening.Ease.InBack);
                }));
            },
            /*StarGenerate.AddComplete end.*/


        }
    });
    /*StarGenerate end.*/

    /*TheBeginning.LevelSystem.Level start.*/
    Bridge.define("TheBeginning.LevelSystem.Level", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            indexLevelVariable: null,
            eventGetTransformCurrentLevel: null
        },
        methods: {
            /*TheBeginning.LevelSystem.Level.GetTransform start.*/
            GetTransform: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.Level#GetTransform", this ); }

                return this.transform;
            },
            /*TheBeginning.LevelSystem.Level.GetTransform end.*/

            /*TheBeginning.LevelSystem.Level.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.Level#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.eventGetTransformCurrentLevel.AddListener(Bridge.fn.cacheBind(this, this.GetTransform));
            },
            /*TheBeginning.LevelSystem.Level.OnEnable end.*/

            /*TheBeginning.LevelSystem.Level.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.Level#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.eventGetTransformCurrentLevel.RemoveListener(Bridge.fn.cacheBind(this, this.GetTransform));
            },
            /*TheBeginning.LevelSystem.Level.OnDisable end.*/


        }
    });
    /*TheBeginning.LevelSystem.Level end.*/

    /*TheBeginning.LevelSystem.LevelLoader start.*/
    Bridge.define("TheBeginning.LevelSystem.LevelLoader", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            currentLevel: null,
            previousLevel: null,
            levelSettings: null,
            currentIndexLevel: null,
            currentIndexLevelLoopBy: null,
            eventLoadLevel: null,
            eventGetCurrentLevel: null,
            eventGetPreviousLevel: null
        },
        methods: {
            /*TheBeginning.LevelSystem.LevelLoader.CurrentLevel start.*/
            CurrentLevel: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#CurrentLevel", this ); }

                return this.currentLevel;
            },
            /*TheBeginning.LevelSystem.LevelLoader.CurrentLevel end.*/

            /*TheBeginning.LevelSystem.LevelLoader.PreviousLevel start.*/
            PreviousLevel: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#PreviousLevel", this ); }

                return this.previousLevel;
            },
            /*TheBeginning.LevelSystem.LevelLoader.PreviousLevel end.*/

            /*TheBeginning.LevelSystem.LevelLoader.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.eventLoadLevel.AddListener(Bridge.fn.cacheBind(this, this.LoadLevel));
                this.eventGetCurrentLevel.AddListener(Bridge.fn.cacheBind(this, this.CurrentLevel));
                this.eventGetPreviousLevel.AddListener(Bridge.fn.cacheBind(this, this.PreviousLevel));
            },
            /*TheBeginning.LevelSystem.LevelLoader.OnEnable end.*/

            /*TheBeginning.LevelSystem.LevelLoader.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#Start", this ); }

                var instance = this.LoadLevel();
            },
            /*TheBeginning.LevelSystem.LevelLoader.Start end.*/

            /*TheBeginning.LevelSystem.LevelLoader.LoadLevel start.*/
            LoadLevel: function () {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#LoadLevel", this ); }

                var index = this.HandleIndexLevel(this.currentIndexLevel.Value);
                this.currentIndexLevelLoopBy.Value = index;
                var result = this.levelSettings.GePrefabLevel(index);
                if (UnityEngine.MonoBehaviour.op_Inequality(this.currentLevel, null)) {
                    this.previousLevel = this.currentLevel;
                } else {
                    var indexPrev = this.HandleIndexLevel(((this.currentIndexLevel.Value - 1) | 0));
                    var resultPre = this.levelSettings.GePrefabLevel(indexPrev);
                    if (UnityEngine.Object.op_Implicit(resultPre)) {
                        this.previousLevel = resultPre.GetComponent(TheBeginning.LevelSystem.Level);
                    }
                }

                this.currentLevel = result.GetComponent(TheBeginning.LevelSystem.Level);
                return this.currentLevel;
            },
            /*TheBeginning.LevelSystem.LevelLoader.LoadLevel end.*/

            /*TheBeginning.LevelSystem.LevelLoader.HandleIndexLevel start.*/
            HandleIndexLevel: function (indexLevel) {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#HandleIndexLevel", this ); }

                if (indexLevel > this.levelSettings.MaxLevel) {
                    return (((((indexLevel - this.levelSettings.StartLoopLevel) | 0)) % (((((this.levelSettings.MaxLevel - this.levelSettings.StartLoopLevel) | 0) + 1) | 0)) + this.levelSettings.StartLoopLevel) | 0);
                }

                if (indexLevel > 0 && indexLevel <= this.levelSettings.MaxLevel) {
                    //return (indexLevel - 1) % gameConfig.maxLevel + 1;
                    return indexLevel;
                }

                if (indexLevel === 0) {
                    return this.levelSettings.MaxLevel;
                }

                return 1;
            },
            /*TheBeginning.LevelSystem.LevelLoader.HandleIndexLevel end.*/

            /*TheBeginning.LevelSystem.LevelLoader.ActiveCurrentLevel start.*/
            ActiveCurrentLevel: function (active) {
if ( TRACE ) { TRACE( "TheBeginning.LevelSystem.LevelLoader#ActiveCurrentLevel", this ); }

                this.currentLevel.gameObject.SetActive(active);
            },
            /*TheBeginning.LevelSystem.LevelLoader.ActiveCurrentLevel end.*/


        }
    });
    /*TheBeginning.LevelSystem.LevelLoader end.*/

    /*TheBeginning.UI.UIPopup start.*/
    Bridge.define("TheBeginning.UI.UIPopup", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            canvasGroup: null,
            canvas: null,
            useAnimation: false,
            isAutoShow: false,
            isNotSortingLayer: false,
            background: null,
            container: null,
            useShowAnimation: false,
            showAnimationType: 0,
            durationShowPopup: 0,
            showMovePopup: 0,
            offsetShowMove: 0,
            scaleFromShow: null,
            eulerAngleShowFrom: null,
            pointShowPos: null,
            useHideAnimation: false,
            hideAnimationType: 0,
            durationHidePopup: 0,
            hideMovePopup: 0,
            offsetHideMove: 0,
            scaleFromHide: null,
            pointHidePos: null,
            playSfxEvent: null,
            soundOpen: null,
            soundClose: null,
            tween: null,
            ActionHide: null,
            isActive: false
        },
        props: {
            ConditionShowMove: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#ConditionShowMove#get", this ); }

                    return this.useAnimation && this.useShowAnimation && this.showAnimationType === TheBeginning.UI.ShowAnimationType.Move;
                }
            },
            ConditionHideMove: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#ConditionHideMove#get", this ); }

                    return this.useAnimation && this.useHideAnimation && this.hideAnimationType === TheBeginning.UI.HideAnimationType.Move;
                }
            },
            ConditionShowOutBack: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#ConditionShowOutBack#get", this ); }

                    return this.useAnimation && this.useShowAnimation && this.showAnimationType === TheBeginning.UI.ShowAnimationType.OutBack;
                }
            },
            ConditionHideInBack: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#ConditionHideInBack#get", this ); }

                    return this.useAnimation && this.useHideAnimation && this.hideAnimationType === TheBeginning.UI.HideAnimationType.InBack;
                }
            },
            ConditionShowFlip: {
                get: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#ConditionShowFlip#get", this ); }

                    return this.useAnimation && this.useShowAnimation && this.showAnimationType === TheBeginning.UI.ShowAnimationType.Flip;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#init", this ); }

                this.scaleFromShow = new UnityEngine.Vector3();
                this.eulerAngleShowFrom = new UnityEngine.Vector3();
                this.scaleFromHide = new UnityEngine.Vector3();
                this.durationShowPopup = 0.5;
                this.scaleFromShow = new pc.Vec3( 0.5, 0.5, 0.5 );
                this.eulerAngleShowFrom = new pc.Vec3( 0, 180, 0 );
                this.durationHidePopup = 0.5;
                this.scaleFromHide = new pc.Vec3( 0, 0, 0 );
                this.isActive = false;
            }
        },
        methods: {
            /*TheBeginning.UI.UIPopup.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.isActive = false;
                if (this.isAutoShow) {
                    this.Show();
                }
            },
            /*TheBeginning.UI.UIPopup.OnEnable end.*/

            /*TheBeginning.UI.UIPopup.Show start.*/
            Show: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#Show", this ); }

                if (UnityEngine.Object.op_Implicit(this.soundOpen)) {
                    this.playSfxEvent != null ? this.playSfxEvent.Raise(this.soundOpen) : null;
                }
                this.OnBeforeShow();
                if (this.useShowAnimation) {
                    var currentPos = this.container.transform.position.$clone();
                    var currentScale = this.container.transform.localScale.$clone();
                    var currentAngle = this.container.transform.localEulerAngles.$clone();
                    switch (this.showAnimationType) {
                        case TheBeginning.UI.ShowAnimationType.OutBack: 
                            this.container.transform.localScale = this.scaleFromShow.$clone();
                            this.gameObject.SetActive(true);
                            this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.container.transform, currentScale.$clone(), this.durationShowPopup), DG.Tweening.Ease.OutBack), Bridge.fn.cacheBind(this, this.OnAfterShow));
                            break;
                        case TheBeginning.UI.ShowAnimationType.Flip: 
                            this.container.transform.eulerAngles = this.eulerAngleShowFrom.$clone();
                            this.gameObject.SetActive(true);
                            this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions), DG.Tweening.ShortcutExtensions.DORotate(this.container.transform, currentAngle.$clone(), this.durationShowPopup), DG.Tweening.Ease.OutBack), Bridge.fn.cacheBind(this, this.OnAfterShow));
                            break;
                        case TheBeginning.UI.ShowAnimationType.Fade: 
                            this.canvasGroup.alpha = 0;
                            this.gameObject.SetActive(true);
                            this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.canvasGroup, 1, this.durationShowPopup), DG.Tweening.Ease.OutBack), Bridge.fn.bind(this, function () {
                                this.canvasGroup.alpha = 1;
                                this.OnAfterShow();
                            }));
                            break;
                        case TheBeginning.UI.ShowAnimationType.Move: 
                            switch (this.showMovePopup) {
                                case TheBeginning.UI.MovePopupType.Left: 
                                    this.container.transform.position = new pc.Vec3( this.container.transform.position.x - this.offsetShowMove, this.container.transform.position.y, this.container.transform.position.z );
                                    this.gameObject.SetActive(true);
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, currentPos.$clone(), this.durationShowPopup), DG.Tweening.Ease.Linear), Bridge.fn.cacheBind(this, this.OnAfterShow));
                                    break;
                                case TheBeginning.UI.MovePopupType.Right: 
                                    this.container.transform.position = new pc.Vec3( this.container.transform.position.x + this.offsetShowMove, this.container.transform.position.y, this.container.transform.position.z );
                                    this.gameObject.SetActive(true);
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, currentPos.$clone(), this.durationShowPopup), DG.Tweening.Ease.Linear), Bridge.fn.cacheBind(this, this.OnAfterShow));
                                    break;
                                case TheBeginning.UI.MovePopupType.Up: 
                                    this.container.transform.position = new pc.Vec3( this.container.transform.position.x, this.container.transform.position.y + this.offsetShowMove, this.container.transform.position.z );
                                    this.gameObject.SetActive(true);
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, currentPos.$clone(), this.durationShowPopup), DG.Tweening.Ease.Linear), Bridge.fn.cacheBind(this, this.OnAfterShow));
                                    break;
                                case TheBeginning.UI.MovePopupType.Down: 
                                    this.container.transform.position = new pc.Vec3( this.container.transform.position.x, this.container.transform.position.y - this.offsetShowMove, this.container.transform.position.z );
                                    this.gameObject.SetActive(true);
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, currentPos.$clone(), this.durationShowPopup), DG.Tweening.Ease.Linear), Bridge.fn.cacheBind(this, this.OnAfterShow));
                                    break;
                            }
                            break;
                        case TheBeginning.UI.ShowAnimationType.OutBackFromPoint: 
                            this.container.transform.position = this.pointShowPos.Value.$clone();
                            this.container.transform.localScale = pc.Vec3.ZERO.clone();
                            this.gameObject.SetActive(true);
                            DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, currentPos.$clone(), this.durationShowPopup), DG.Tweening.Ease.OutSine);
                            DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.container.transform, currentScale.$clone(), this.durationShowPopup), DG.Tweening.Ease.OutSine), Bridge.fn.cacheBind(this, this.OnAfterShow));
                            break;
                    }
                } else {
                    this.gameObject.SetActive(true);
                    this.OnAfterShow();
                }
            },
            /*TheBeginning.UI.UIPopup.Show end.*/

            /*TheBeginning.UI.UIPopup.Hide start.*/
            Hide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#Hide", this ); }

                this.isActive = false;
                if (UnityEngine.Object.op_Implicit(this.soundClose)) {
                    this.playSfxEvent != null ? this.playSfxEvent.Raise(this.soundClose) : null;
                }
                this.OnBeforeHide();
                if (this.useHideAnimation) {
                    var currentPos = this.container.transform.position.$clone();
                    var currentScale = this.container.transform.localScale.$clone();
                    switch (this.hideAnimationType) {
                        case TheBeginning.UI.HideAnimationType.Fade: 
                            this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleUI.DOFade(this.canvasGroup, 0, this.durationHidePopup), DG.Tweening.Ease.InBack), Bridge.fn.bind(this, function () {
                                this.gameObject.SetActive(false);
                                this.canvasGroup.alpha = 1;
                                this.OnAfterHide();
                            }));
                            break;
                        case TheBeginning.UI.HideAnimationType.InBack: 
                            this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.container.transform, this.scaleFromHide.$clone(), this.durationHidePopup), DG.Tweening.Ease.InBack), Bridge.fn.bind(this, function () {
                                this.gameObject.SetActive(false);
                                this.container.transform.localScale = currentScale.$clone();
                                this.OnAfterHide();
                            }));
                            break;
                        case TheBeginning.UI.HideAnimationType.Move: 
                            switch (this.hideMovePopup) {
                                case TheBeginning.UI.MovePopupType.Left: 
                                    var targetPosL = new pc.Vec3( this.container.transform.position.x - this.offsetHideMove, this.container.transform.position.y, this.container.transform.position.z );
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, targetPosL.$clone(), this.durationHidePopup), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                                        this.gameObject.SetActive(false);
                                        this.container.transform.position = currentPos.$clone();
                                        this.OnAfterHide();
                                    }));
                                    break;
                                case TheBeginning.UI.MovePopupType.Right: 
                                    var targetPosR = new pc.Vec3( this.container.transform.position.x + this.offsetHideMove, this.container.transform.position.y, this.container.transform.position.z );
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, targetPosR.$clone(), this.durationHidePopup), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                                        this.gameObject.SetActive(false);
                                        this.container.transform.position = currentPos.$clone();
                                        this.OnAfterHide();
                                    }));
                                    break;
                                case TheBeginning.UI.MovePopupType.Up: 
                                    var targetPosU = new pc.Vec3( this.container.transform.position.x, this.container.transform.position.y + this.offsetHideMove, this.container.transform.position.z );
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, targetPosU.$clone(), this.durationHidePopup), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                                        this.gameObject.SetActive(false);
                                        this.container.transform.position = currentPos.$clone();
                                        this.OnAfterHide();
                                    }));
                                    break;
                                case TheBeginning.UI.MovePopupType.Down: 
                                    var targetPosD = new pc.Vec3( this.container.transform.position.x, this.container.transform.position.y - this.offsetHideMove, this.container.transform.position.z );
                                    this.tween = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, targetPosD.$clone(), this.durationHidePopup), DG.Tweening.Ease.Linear), Bridge.fn.bind(this, function () {
                                        this.gameObject.SetActive(false);
                                        this.container.transform.position = currentPos.$clone();
                                        this.OnAfterHide();
                                    }));
                                    break;
                            }
                            break;
                        case TheBeginning.UI.HideAnimationType.InBackToPoint: 
                            DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.container.transform, this.pointHidePos.Value.$clone(), this.durationHidePopup), DG.Tweening.Ease.InSine);
                            DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.container.transform, pc.Vec3.ZERO.clone(), this.durationHidePopup), DG.Tweening.Ease.InSine), Bridge.fn.bind(this, function () {
                                this.gameObject.SetActive(false);
                                this.container.transform.position = currentPos.$clone();
                                this.container.transform.localScale = currentScale.$clone();
                                this.OnAfterHide();
                            }));
                            break;
                    }
                } else {
                    this.gameObject.SetActive(false);
                    this.OnAfterHide();
                }
            },
            /*TheBeginning.UI.UIPopup.Hide end.*/

            /*TheBeginning.UI.UIPopup.OnBeforeShow start.*/
            OnBeforeShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#OnBeforeShow", this ); }
 },
            /*TheBeginning.UI.UIPopup.OnBeforeShow end.*/

            /*TheBeginning.UI.UIPopup.OnAfterShow start.*/
            OnAfterShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#OnAfterShow", this ); }

                this.isActive = true;
                DG.Tweening.TweenExtensions.Kill(this.tween);
            },
            /*TheBeginning.UI.UIPopup.OnAfterShow end.*/

            /*TheBeginning.UI.UIPopup.OnBeforeHide start.*/
            OnBeforeHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#OnBeforeHide", this ); }
 },
            /*TheBeginning.UI.UIPopup.OnBeforeHide end.*/

            /*TheBeginning.UI.UIPopup.OnAfterHide start.*/
            OnAfterHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UIPopup#OnAfterHide", this ); }

                DG.Tweening.TweenExtensions.Kill(this.tween);
                !Bridge.staticEquals(this.ActionHide, null) ? this.ActionHide() : null;
                this.ActionHide = null;
            },
            /*TheBeginning.UI.UIPopup.OnAfterHide end.*/


        }
    });
    /*TheBeginning.UI.UIPopup end.*/

    /*TheBeginning.UI.PopupManager start.*/
    Bridge.define("TheBeginning.UI.PopupManager", {
        inherits: [VirtueSky.Core.BaseMono],
        statics: {
            fields: {
                _ins: null
            },
            methods: {
                /*TheBeginning.UI.PopupManager.Show:static start.*/
                Show: function (T, isHideAll, showPopupCompleted) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#Show", this ); }

                    if (isHideAll === void 0) { isHideAll = true; }
                    if (showPopupCompleted === void 0) { showPopupCompleted = null; }
                    TheBeginning.UI.PopupManager._ins.InternalShow(T, isHideAll, showPopupCompleted);
                },
                /*TheBeginning.UI.PopupManager.Show:static end.*/

                /*TheBeginning.UI.PopupManager.Hide:static start.*/
                Hide: function (T, hidePopupCompleted) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#Hide", this ); }

                    if (hidePopupCompleted === void 0) { hidePopupCompleted = null; }
                    TheBeginning.UI.PopupManager._ins.InternalHide(T, hidePopupCompleted);
                },
                /*TheBeginning.UI.PopupManager.Hide:static end.*/

                /*TheBeginning.UI.PopupManager.Get:static start.*/
                Get: function (T) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#Get", this ); }

                    return TheBeginning.UI.PopupManager._ins.InternalGet(T);
                },
                /*TheBeginning.UI.PopupManager.Get:static end.*/

                /*TheBeginning.UI.PopupManager.IsPopupReady:static start.*/
                IsPopupReady: function (T) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#IsPopupReady", this ); }

                    return TheBeginning.UI.PopupManager._ins.InternalIsPopupReady(T);
                },
                /*TheBeginning.UI.PopupManager.IsPopupReady:static end.*/

                /*TheBeginning.UI.PopupManager.HideAll:static start.*/
                HideAll: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#HideAll", this ); }

                    TheBeginning.UI.PopupManager._ins.InternalHideAll();
                },
                /*TheBeginning.UI.PopupManager.HideAll:static end.*/


            }
        },
        fields: {
            parentContainer: null,
            popupSettings: null,
            cameraUI: null,
            index: 0,
            container: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#init", this ); }

                this.index = 1;
                this.container = new (System.Collections.Generic.Dictionary$2(System.Type,TheBeginning.UI.UIPopup)).ctor();
            }
        },
        methods: {
            /*TheBeginning.UI.PopupManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#Awake", this ); }

                UnityEngine.Debug.Assert(UnityEngine.Component.op_Inequality(this.cameraUI, null), "CameraUI != null");
                if (UnityEngine.MonoBehaviour.op_Equality(TheBeginning.UI.PopupManager._ins, null)) {
                    TheBeginning.UI.PopupManager._ins = this;
                }

                Extension.Clear(this.parentContainer);
            },
            /*TheBeginning.UI.PopupManager.Awake end.*/

            /*TheBeginning.UI.PopupManager.InternalShow start.*/
            InternalShow: function (T, isHideAll, showPopupCompleted) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#InternalShow", this ); }

                if (isHideAll === void 0) { isHideAll = true; }
                if (showPopupCompleted === void 0) { showPopupCompleted = null; }
                var popup = { };
                this.container.tryGetValue(T, popup);
                if (UnityEngine.MonoBehaviour.op_Equality(popup.v, null)) {
                    var popupPrefab = this.popupSettings.GetPrefabPopup(Bridge.Reflection.getTypeName(T));
                    if (UnityEngine.MonoBehaviour.op_Inequality(popupPrefab, null)) {
                        var popupInstance = UnityEngine.Object.Instantiate(TheBeginning.UI.UIPopup, popupPrefab, this.parentContainer);
                        if (isHideAll) {
                            this.InternalHideAll();
                        }

                        if (!popupInstance.isNotSortingLayer) {
                            popupInstance.canvas.sortingOrder = Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)));
                        }

                        popupInstance.Show();
                        !Bridge.staticEquals(showPopupCompleted, null) ? showPopupCompleted() : null;
                        this.container.add(Bridge.getType(popupInstance), popupInstance);
                    } else {
                        UnityEngine.Debug.Log$1("Popup not found in the list to show");
                    }
                } else {
                    if (!popup.v.isActiveAndEnabled) {
                        if (isHideAll) {
                            this.InternalHideAll();
                        }

                        if (!popup.v.isNotSortingLayer) {
                            popup.v.canvas.sortingOrder = Bridge.identity(this.index, ((this.index = (this.index + 1) | 0)));
                        }

                        popup.v.Show();
                        !Bridge.staticEquals(showPopupCompleted, null) ? showPopupCompleted() : null;
                    }
                }
            },
            /*TheBeginning.UI.PopupManager.InternalShow end.*/

            /*TheBeginning.UI.PopupManager.InternalHide start.*/
            InternalHide: function (T, hidePopupCompleted) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#InternalHide", this ); }

                if (hidePopupCompleted === void 0) { hidePopupCompleted = null; }
                var popup = { };
                if (this.container.tryGetValue(T, popup)) {
                    if (popup.v.isActiveAndEnabled) {
                        popup.v.Hide();
                        !Bridge.staticEquals(hidePopupCompleted, null) ? hidePopupCompleted() : null;
                    }
                } else {
                    UnityEngine.Debug.Log$1("Popup not found to hide");
                }
            },
            /*TheBeginning.UI.PopupManager.InternalHide end.*/

            /*TheBeginning.UI.PopupManager.InternalGet start.*/
            InternalGet: function (T) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#InternalGet", this ); }

                return System.Collections.Generic.CollectionExtensions.GetValueOrDefault(System.Type, TheBeginning.UI.UIPopup, this.container, T);
            },
            /*TheBeginning.UI.PopupManager.InternalGet end.*/

            /*TheBeginning.UI.PopupManager.InternalIsPopupReady start.*/
            InternalIsPopupReady: function (T) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#InternalIsPopupReady", this ); }

                return this.container.containsKey(T);
            },
            /*TheBeginning.UI.PopupManager.InternalIsPopupReady end.*/

            /*TheBeginning.UI.PopupManager.InternalHideAll start.*/
            InternalHideAll: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#InternalHideAll", this ); }

                var $t;
                $t = Bridge.getEnumerator(this.container.Values);
                try {
                    while ($t.moveNext()) {
                        var popup = $t.Current;
                        if (popup.isActiveAndEnabled) {
                            popup.Hide();
                        }
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
            },
            /*TheBeginning.UI.PopupManager.InternalHideAll end.*/

            /*TheBeginning.UI.PopupManager.GetKeyPopup start.*/
            GetKeyPopup: function (fullName) {
if ( TRACE ) { TRACE( "TheBeginning.UI.PopupManager#GetKeyPopup", this ); }

                var index = fullName.lastIndexOf(String.fromCharCode(46));
                if (index !== -1) {
                    return fullName.substr(((index + 1) | 0)).trim();
                } else {
                    return fullName;
                }
            },
            /*TheBeginning.UI.PopupManager.GetKeyPopup end.*/


        }
    });
    /*TheBeginning.UI.PopupManager end.*/

    /*TimingController start.*/
    Bridge.define("TimingController", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            fadeWarnDuration: 0,
            pauseTimeLevelVariable: null,
            stringFormat: null,
            timeText: null,
            addTimePlayEvent: null,
            countDownTimeSetupEvent: null,
            startCountDownTimeEvent: null,
            onTimeUpEvent: null,
            playDuration: null,
            totalTimeAddWhenPlay: null,
            isUsingTimerBooster: null,
            onWarringTimeEvent: null,
            isPlayAgainMore: null,
            warningFrame: null,
            playSfxEvent: null,
            stopSfxEvent: null,
            soundWarring: null,
            _currentTime: 0,
            _isCanCountTime: false,
            _isWarned: false,
            _isShowWarnBoard: false,
            _isShowWaringSoundPlay: false,
            _soundWaringCache: null
        },
        methods: {
            /*TimingController.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TimingController#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.addTimePlayEvent.addOnRaised(Bridge.fn.cacheBind(this, this.AddTimePlayEvent));
                this.startCountDownTimeEvent.addOnRaised(Bridge.fn.cacheBind(this, this.OnStartCountDownTime));
                this.countDownTimeSetupEvent.addOnRaised(Bridge.fn.cacheBind(this, this.OnCountDownTimeSetup));
                this.isUsingTimerBooster.Value = false;
                this._isShowWarnBoard = false;
                VirtueSky.Misc.Common.SetAlpha(this.warningFrame, 0);
                this._isShowWaringSoundPlay = false;
            },
            /*TimingController.OnEnable end.*/

            /*TimingController.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TimingController#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.addTimePlayEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.AddTimePlayEvent));
                this.startCountDownTimeEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.OnStartCountDownTime));
                this.countDownTimeSetupEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.OnCountDownTimeSetup));
            },
            /*TimingController.OnDisable end.*/

            /*TimingController.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "TimingController#Update", this ); }

                if (this._isCanCountTime) {
                    if (this.pauseTimeLevelVariable.Value && this.warningFrame.color.a !== 0) {
                        VirtueSky.Misc.Common.SetAlpha(this.warningFrame, 0);
                    }

                    if (!this.pauseTimeLevelVariable.Value) {
                        this.playDuration.Value += UnityEngine.Time.deltaTime;
                        this._currentTime -= UnityEngine.Time.deltaTime;
                        if (this._currentTime <= 10.5 && !this._isShowWarnBoard) {
                            if (!this._isShowWaringSoundPlay) {
                                this._soundWaringCache = this.playSfxEvent != null ? this.playSfxEvent.Raise(this.soundWarring) : null;
                                this._isShowWaringSoundPlay = true;
                            }
                            this.onWarringTimeEvent != null ? this.onWarringTimeEvent.Raise() : null;
                            this._isShowWarnBoard = true;
                            DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$2(this.warningFrame, 1, this.fadeWarnDuration), Bridge.fn.bind(this, function () {
                                DG.Tweening.DOVirtual.DelayedCall(1 - this.fadeWarnDuration * 2, Bridge.fn.bind(this, function () {
                                    DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions), DG.Tweening.DOTweenModuleUI.DOFade$2(this.warningFrame, 0, this.fadeWarnDuration), Bridge.fn.bind(this, function () {
                                        this._isShowWarnBoard = false;
                                    }));
                                }));
                            }));
                        }

                        if (this._currentTime <= 10) {
                            if (!this._isWarned) {
                                this._isWarned = true;
                            }
                            this.onTimeUpEvent.Raise();
                            this._isCanCountTime = false;
                            this._currentTime = 0;
                        }
                        this.DisplayTime();
                    } else if (this.isUsingTimerBooster.Value) {
                        this.playDuration.Value += UnityEngine.Time.deltaTime;
                    }
                }
            },
            /*TimingController.Update end.*/

            /*TimingController.AddTimePlayEvent start.*/
            AddTimePlayEvent: function (value) {
if ( TRACE ) { TRACE( "TimingController#AddTimePlayEvent", this ); }

                this.totalTimeAddWhenPlay.Add(value);
                this._currentTime += value;
                if (this._isShowWaringSoundPlay) {
                    this._isShowWaringSoundPlay = false;
                }
                this.DisplayTime();
            },
            /*TimingController.AddTimePlayEvent end.*/

            /*TimingController.OnStartCountDownTime start.*/
            OnStartCountDownTime: function () {
if ( TRACE ) { TRACE( "TimingController#OnStartCountDownTime", this ); }

                this._isCanCountTime = true;
                this._isWarned = false;
                this._isShowWarnBoard = false;
                this._isShowWaringSoundPlay = false;
                VirtueSky.Misc.Common.SetAlpha(this.warningFrame, 0);
            },
            /*TimingController.OnStartCountDownTime end.*/

            /*TimingController.OnCountDownTimeSetup start.*/
            OnCountDownTimeSetup: function (time) {
if ( TRACE ) { TRACE( "TimingController#OnCountDownTimeSetup", this ); }

                if (this._soundWaringCache != null) {
                    this.stopSfxEvent != null ? this.stopSfxEvent.Raise(this._soundWaringCache) : null;
                    this._soundWaringCache = null;
                }
                this.SetTime(time);
                this.isPlayAgainMore.Value = false;
            },
            /*TimingController.OnCountDownTimeSetup end.*/

            /*TimingController.SetTime start.*/
            SetTime: function (time, onTimeUpEvent) {
if ( TRACE ) { TRACE( "TimingController#SetTime", this ); }

                if (onTimeUpEvent === void 0) { onTimeUpEvent = null; }
                this._isCanCountTime = false;
                this._currentTime = time;
                this.DisplayTime();
            },
            /*TimingController.SetTime end.*/

            /*TimingController.OnValidate start.*/
            OnValidate: function () {
if ( TRACE ) { TRACE( "TimingController#OnValidate", this ); }

                this.DisplayTime();
            },
            /*TimingController.OnValidate end.*/

            /*TimingController.DisplayTime start.*/
            DisplayTime: function () {
if ( TRACE ) { TRACE( "TimingController#DisplayTime", this ); }

                //var hours = (int)_currentTime / 3600;
                var minutes = (Bridge.Int.div(Bridge.Int.clip32(this._currentTime) % 3600, 60)) | 0;
                var seconds = Bridge.Int.clip32(this._currentTime) % 3600 % 60;
                this.timeText.text = System.String.format(this.stringFormat, Bridge.box(minutes, System.Int32), Bridge.box(seconds, System.Int32));
            },
            /*TimingController.DisplayTime end.*/


        }
    });
    /*TimingController end.*/

    /*TouchSystem start.*/
    Bridge.define("TouchSystem", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            sceneCamera: null,
            includeLayer: null,
            distance: 0,
            inputEventTouchBegin: null,
            inputEventTouchEnd: null,
            _lastPosition: null,
            ActionBegin: null,
            ActionEnd: null
        },
        props: {
            LastPosition: {
                get: function () {
if ( TRACE ) { TRACE( "TouchSystem#LastPosition#get", this ); }

                    return this._lastPosition.$clone();
                }
            }
        },
        alias: [
            "Initialize", "VirtueSky$Core$IEntity$Initialize",
            "CleanUp", "VirtueSky$Core$IEntity$CleanUp"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TouchSystem#init", this ); }

                this.includeLayer = new UnityEngine.LayerMask();
                this._lastPosition = new UnityEngine.Vector3();
                this._lastPosition = pc.Vec3.ZERO.clone();
            }
        },
        methods: {
            /*TouchSystem.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "TouchSystem#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.Initialize();
            },
            /*TouchSystem.OnEnable end.*/

            /*TouchSystem.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "TouchSystem#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.CleanUp();
            },
            /*TouchSystem.OnDisable end.*/

            /*TouchSystem.Initialize start.*/
            Initialize: function () {
if ( TRACE ) { TRACE( "TouchSystem#Initialize", this ); }

                VirtueSky.Core.BaseMono.prototype.Initialize.call(this);
                this.inputEventTouchBegin.addOnRaised(Bridge.fn.cacheBind(this, this.OnTouchBegin));
                this.inputEventTouchEnd.addOnRaised(Bridge.fn.cacheBind(this, this.OnTouchEnd));
            },
            /*TouchSystem.Initialize end.*/

            /*TouchSystem.OnTouchBegin start.*/
            OnTouchBegin: function (touchPosition) {
if ( TRACE ) { TRACE( "TouchSystem#OnTouchBegin", this ); }

                if (!this.IsPointerOverUI()) {
                    !Bridge.staticEquals(this.ActionBegin, null) ? this.ActionBegin(this.GetPointPosition()) : null;
                }
            },
            /*TouchSystem.OnTouchBegin end.*/

            /*TouchSystem.OnTouchEnd start.*/
            OnTouchEnd: function (touchPosition) {
if ( TRACE ) { TRACE( "TouchSystem#OnTouchEnd", this ); }

                !Bridge.staticEquals(this.ActionEnd, null) ? this.ActionEnd(this.GetPointPosition()) : null;
            },
            /*TouchSystem.OnTouchEnd end.*/

            /*TouchSystem.IsPointerOverUI start.*/
            IsPointerOverUI: function () {
if ( TRACE ) { TRACE( "TouchSystem#IsPointerOverUI", this ); }

                return UnityEngine.EventSystems.EventSystem.current.IsPointerOverGameObject();
            },
            /*TouchSystem.IsPointerOverUI end.*/

            /*TouchSystem.GetPointPosition start.*/
            GetPointPosition: function () {
if ( TRACE ) { TRACE( "TouchSystem#GetPointPosition", this ); }

                var mousePos = UnityEngine.Input.mousePosition.$clone();
                return this.sceneCamera.ScreenToWorldPoint(new pc.Vec3( mousePos.x, mousePos.y, Math.abs(this.sceneCamera.transform.position.y) ));
            },
            /*TouchSystem.GetPointPosition end.*/

            /*TouchSystem.GetToucher start.*/
            GetToucher: function () {
if ( TRACE ) { TRACE( "TouchSystem#GetToucher", this ); }

                var mousePos = UnityEngine.Input.mousePosition.$clone();
                mousePos.z = this.sceneCamera.nearClipPlane;
                var ray = this.sceneCamera.ScreenPointToRay(mousePos);
                var hit = { v : new UnityEngine.RaycastHit() };
                if (UnityEngine.Physics.Raycast$1(ray, hit, this.distance, UnityEngine.LayerMask.op_Implicit(this.includeLayer.$clone()))) {
                    return hit.v.collider.gameObject;
                }

                return null;
            },
            /*TouchSystem.GetToucher end.*/

            /*TouchSystem.CleanUp start.*/
            CleanUp: function () {
if ( TRACE ) { TRACE( "TouchSystem#CleanUp", this ); }

                VirtueSky.Core.BaseMono.prototype.CleanUp.call(this);
                this.inputEventTouchBegin.removeOnRaised(Bridge.fn.cacheBind(this, this.OnTouchBegin));
                this.inputEventTouchEnd.removeOnRaised(Bridge.fn.cacheBind(this, this.OnTouchEnd));
            },
            /*TouchSystem.CleanUp end.*/


        }
    });
    /*TouchSystem end.*/

    /*VirtueSky.Events.BaseEvent$1 start.*/
    Bridge.define("VirtueSky.Events.BaseEvent$1", function (TType) { return {
        inherits: [VirtueSky.Core.BaseSO,VirtueSky.Events.IEvent$1(TType)],
        fields: {
            listeners: null,
            onRaised: null
        },
        alias: [
            "Raise", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$Raise",
            "addOnRaised", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$addOnRaised",
            "removeOnRaised", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$removeOnRaised",
            "AddListener$1", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$AddListener",
            "RemoveListener$1", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$RemoveListener",
            "AddListener", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$AddListener$1",
            "RemoveListener", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$RemoveListener$1",
            "RemoveAll", "VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(TType) + "$RemoveAll"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#init", this ); }

                this.listeners = new (System.Collections.Generic.List$1(VirtueSky.Events.IEventListener$1(TType))).ctor();
            }
        },
        methods: {
            addOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#addOnRaised", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, value);
            },
            removeOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#removeOnRaised", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, value);
            },
            /*VirtueSky.Events.BaseEvent$1.Raise start.*/
            Raise: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#Raise", this ); }

                for (var i = (this.listeners.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    this.listeners.getItem(i)["VirtueSky$Events$IEventListener$1$" + Bridge.getTypeAlias(TType) + "$OnEventRaised"](this, Bridge.rValue(value));
                }

                !Bridge.staticEquals(this.onRaised, null) ? this.onRaised(Bridge.rValue(value)) : null;
            },
            /*VirtueSky.Events.BaseEvent$1.Raise end.*/

            /*VirtueSky.Events.BaseEvent$1.AddListener$1 start.*/
            AddListener$1: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#AddListener$1", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, action);
            },
            /*VirtueSky.Events.BaseEvent$1.AddListener$1 end.*/

            /*VirtueSky.Events.BaseEvent$1.AddListener start.*/
            AddListener: function (listener) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#AddListener", this ); }

                if (!this.listeners.contains(listener)) {
                    this.listeners.add(listener);
                }
            },
            /*VirtueSky.Events.BaseEvent$1.AddListener end.*/

            /*VirtueSky.Events.BaseEvent$1.RemoveListener$1 start.*/
            RemoveListener$1: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#RemoveListener$1", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, action);
            },
            /*VirtueSky.Events.BaseEvent$1.RemoveListener$1 end.*/

            /*VirtueSky.Events.BaseEvent$1.RemoveListener start.*/
            RemoveListener: function (listener) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#RemoveListener", this ); }

                if (this.listeners.contains(listener)) {
                    this.listeners.remove(listener);
                }
            },
            /*VirtueSky.Events.BaseEvent$1.RemoveListener end.*/

            /*VirtueSky.Events.BaseEvent$1.RemoveAll start.*/
            RemoveAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$1#RemoveAll", this ); }

                this.listeners.clear();
                this.onRaised = null;
            },
            /*VirtueSky.Events.BaseEvent$1.RemoveAll end.*/


        },
        overloads: {
            "AddListener(Action<TType>)": "AddListener$1",
            "RemoveListener(Action<TType>)": "RemoveListener$1"
        }
    }; });
    /*VirtueSky.Events.BaseEvent$1 end.*/

    /*VirtueSky.Audio.AudioManager start.*/
    Bridge.define("VirtueSky.Audio.AudioManager", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            isDontDestroyOnLoad: false,
            soundComponentPrefab: null,
            audioHolder: null,
            eventPlayMusic: null,
            eventStopMusic: null,
            eventPauseMusic: null,
            eventResumeMusic: null,
            eventPlaySfx: null,
            eventStopSfx: null,
            eventPauseSfx: null,
            eventResumeSfx: null,
            eventFinishSfx: null,
            eventStopAllSfx: null,
            musicVolume: null,
            sfxVolume: null,
            music: null,
            listCacheSfx: null,
            key: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#init", this ); }

                this.listCacheSfx = new (System.Collections.Generic.List$1(VirtueSky.Audio.SoundComponent)).ctor();
                this.key = 0;
            }
        },
        methods: {
            /*VirtueSky.Audio.AudioManager.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#Awake", this ); }

                if (this.isDontDestroyOnLoad) {
                    UnityEngine.Object.DontDestroyOnLoad(this.gameObject);
                }

                this.sfxVolume.AddListener$1(Bridge.fn.cacheBind(this, this.OnSfxVolumeChanged));
                this.musicVolume.AddListener$1(Bridge.fn.cacheBind(this, this.OnMusicVolumeChanged));
            },
            /*VirtueSky.Audio.AudioManager.Awake end.*/

            /*VirtueSky.Audio.AudioManager.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.eventPlaySfx.AddListener$1(Bridge.fn.cacheBind(this, this.PlaySfx));
                this.eventStopSfx.AddListener$1(Bridge.fn.cacheBind(this, this.StopSfx));
                this.eventFinishSfx.AddListener$1(Bridge.fn.cacheBind(this, this.FinishSfx));
                this.eventResumeSfx.AddListener$1(Bridge.fn.cacheBind(this, this.ResumeSfx));
                this.eventPauseSfx.AddListener$1(Bridge.fn.cacheBind(this, this.PauseSfx));
                this.eventStopAllSfx.AddListener(Bridge.fn.cacheBind(this, this.StopAllSfx));

                this.eventPlayMusic.AddListener$1(Bridge.fn.cacheBind(this, this.PlayMusic));
                this.eventPauseMusic.AddListener(Bridge.fn.cacheBind(this, this.PauseMusic));
                this.eventResumeMusic.AddListener(Bridge.fn.cacheBind(this, this.ResumeMusic));
                this.eventStopMusic.AddListener(Bridge.fn.cacheBind(this, this.StopMusic));
            },
            /*VirtueSky.Audio.AudioManager.OnEnable end.*/

            /*VirtueSky.Audio.AudioManager.OnDisable start.*/
            OnDisable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#OnDisable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnDisable.call(this);
                this.eventPlaySfx.RemoveListener$1(Bridge.fn.cacheBind(this, this.PlaySfx));
                this.eventStopSfx.RemoveListener$1(Bridge.fn.cacheBind(this, this.StopSfx));
                this.eventFinishSfx.RemoveListener$1(Bridge.fn.cacheBind(this, this.FinishSfx));
                this.eventResumeSfx.RemoveListener$1(Bridge.fn.cacheBind(this, this.ResumeSfx));
                this.eventPauseSfx.RemoveListener$1(Bridge.fn.cacheBind(this, this.PauseSfx));
                this.eventStopAllSfx.RemoveListener(Bridge.fn.cacheBind(this, this.StopAllSfx));

                this.eventPlayMusic.RemoveListener$1(Bridge.fn.cacheBind(this, this.PlayMusic));
                this.eventPauseMusic.RemoveListener(Bridge.fn.cacheBind(this, this.PauseMusic));
                this.eventResumeMusic.RemoveListener(Bridge.fn.cacheBind(this, this.ResumeMusic));
                this.eventStopMusic.RemoveListener(Bridge.fn.cacheBind(this, this.StopMusic));
            },
            /*VirtueSky.Audio.AudioManager.OnDisable end.*/

            /*VirtueSky.Audio.AudioManager.OnMusicVolumeChanged start.*/
            OnMusicVolumeChanged: function (volume) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#OnMusicVolumeChanged", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.music, null)) {
                    this.music.Volume = volume;
                }
            },
            /*VirtueSky.Audio.AudioManager.OnMusicVolumeChanged end.*/

            /*VirtueSky.Audio.AudioManager.OnSfxVolumeChanged start.*/
            OnSfxVolumeChanged: function (volume) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#OnSfxVolumeChanged", this ); }

                for (var i = 0; i < this.listCacheSfx.Count; i = (i + 1) | 0) {
                    this.listCacheSfx.getItem(i).Volume = volume;
                }
            },
            /*VirtueSky.Audio.AudioManager.OnSfxVolumeChanged end.*/

            /*VirtueSky.Audio.AudioManager.PlaySfx start.*/
            PlaySfx: function (soundData) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#PlaySfx", this ); }

                var sfxComponent = VirtueSky.ObjectPooling.Pool.Spawn(VirtueSky.Audio.SoundComponent, this.soundComponentPrefab, this.audioHolder);
                sfxComponent.PlayAudioClip(soundData.GetAudioClip(), soundData.loop, soundData.volume * this.sfxVolume.Value);
                if (!soundData.loop) {
                    sfxComponent.addOnCompleted(Bridge.fn.cacheBind(this, this.OnFinishPlayingAudio));
                }
                var soundCache = this.GetSoundCache(soundData);
                sfxComponent.Key = this.key;
                this.listCacheSfx.add(sfxComponent);
                return soundCache;
            },
            /*VirtueSky.Audio.AudioManager.PlaySfx end.*/

            /*VirtueSky.Audio.AudioManager.StopSfx start.*/
            StopSfx: function (soundCache) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#StopSfx", this ); }

                var soundComponent = this.GetSoundComponent(soundCache);
                if (UnityEngine.MonoBehaviour.op_Equality(soundComponent, null)) {
                    return;
                }
                this.StopAndCleanAudioComponent(soundComponent);
            },
            /*VirtueSky.Audio.AudioManager.StopSfx end.*/

            /*VirtueSky.Audio.AudioManager.PauseSfx start.*/
            PauseSfx: function (soundCache) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#PauseSfx", this ); }

                var soundComponent = this.GetSoundComponent(soundCache);
                if (UnityEngine.MonoBehaviour.op_Equality(soundComponent, null) || !soundComponent.IsPlaying) {
                    return;
                }
                soundComponent.Pause();
            },
            /*VirtueSky.Audio.AudioManager.PauseSfx end.*/

            /*VirtueSky.Audio.AudioManager.ResumeSfx start.*/
            ResumeSfx: function (soundCache) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#ResumeSfx", this ); }

                var soundComponent = this.GetSoundComponent(soundCache);
                if (UnityEngine.MonoBehaviour.op_Equality(soundComponent, null) || soundComponent.IsPlaying) {
                    return;
                }
                soundComponent.Resume();
            },
            /*VirtueSky.Audio.AudioManager.ResumeSfx end.*/

            /*VirtueSky.Audio.AudioManager.FinishSfx start.*/
            FinishSfx: function (soundCache) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#FinishSfx", this ); }

                var soundComponent = this.GetSoundComponent(soundCache);
                if (UnityEngine.MonoBehaviour.op_Equality(soundComponent, null) || !soundComponent.IsPlaying) {
                    return;
                }
                soundComponent.Finish();
                soundComponent.addOnCompleted(Bridge.fn.cacheBind(this, this.OnFinishPlayingAudio));
            },
            /*VirtueSky.Audio.AudioManager.FinishSfx end.*/

            /*VirtueSky.Audio.AudioManager.StopAllSfx start.*/
            StopAllSfx: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#StopAllSfx", this ); }

                var $t;
                var listTemp = ($t = VirtueSky.Audio.SoundComponent, System.Linq.Enumerable.from(this.listCacheSfx, $t).toList($t));
                for (var i = 0; i < listTemp.Count; i = (i + 1) | 0) {
                    this.StopAndCleanAudioComponent(listTemp.getItem(i));
                }

                this.listCacheSfx.clear();
                listTemp.clear();

                this.key = 0;
            },
            /*VirtueSky.Audio.AudioManager.StopAllSfx end.*/

            /*VirtueSky.Audio.AudioManager.PlayMusic start.*/
            PlayMusic: function (soundData) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#PlayMusic", this ); }

                if (UnityEngine.MonoBehaviour.op_Equality(this.music, null) || !this.music.IsPlaying) {
                    this.music = VirtueSky.ObjectPooling.Pool.Spawn(VirtueSky.Audio.SoundComponent, this.soundComponentPrefab, this.audioHolder);
                }

                this.music.FadePlayMusic(soundData.GetAudioClip(), soundData.loop, soundData.volume * this.musicVolume.Value, soundData.isMusicFadeVolume, soundData.fadeOutDuration, soundData.fadeInDuration);
                this.music.addOnCompleted(Bridge.fn.cacheBind(this, this.StopAudioMusic));
            },
            /*VirtueSky.Audio.AudioManager.PlayMusic end.*/

            /*VirtueSky.Audio.AudioManager.StopMusic start.*/
            StopMusic: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#StopMusic", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.music, null) && this.music.IsPlaying) {
                    this.music.Stop();
                    VirtueSky.ObjectPooling.Pool.DeSpawn(this.music.gameObject);
                }
            },
            /*VirtueSky.Audio.AudioManager.StopMusic end.*/

            /*VirtueSky.Audio.AudioManager.PauseMusic start.*/
            PauseMusic: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#PauseMusic", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.music, null) && this.music.IsPlaying) {
                    this.music.Pause();
                }
            },
            /*VirtueSky.Audio.AudioManager.PauseMusic end.*/

            /*VirtueSky.Audio.AudioManager.ResumeMusic start.*/
            ResumeMusic: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#ResumeMusic", this ); }

                if (UnityEngine.MonoBehaviour.op_Inequality(this.music, null) && !this.music.IsPlaying) {
                    this.music.Resume();
                }
            },
            /*VirtueSky.Audio.AudioManager.ResumeMusic end.*/

            /*VirtueSky.Audio.AudioManager.OnFinishPlayingAudio start.*/
            OnFinishPlayingAudio: function (soundComponent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#OnFinishPlayingAudio", this ); }

                this.StopAndCleanAudioComponent(soundComponent);
            },
            /*VirtueSky.Audio.AudioManager.OnFinishPlayingAudio end.*/

            /*VirtueSky.Audio.AudioManager.StopAndCleanAudioComponent start.*/
            StopAndCleanAudioComponent: function (soundComponent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#StopAndCleanAudioComponent", this ); }

                if (!soundComponent.IsLooping) {
                    soundComponent.removeOnCompleted(Bridge.fn.cacheBind(this, this.OnFinishPlayingAudio));
                }

                soundComponent.Stop();
                VirtueSky.ObjectPooling.Pool.DeSpawn(soundComponent.gameObject);
                if (this.listCacheSfx.contains(soundComponent)) {
                    this.listCacheSfx.remove(soundComponent);
                }
            },
            /*VirtueSky.Audio.AudioManager.StopAndCleanAudioComponent end.*/

            /*VirtueSky.Audio.AudioManager.StopAudioMusic start.*/
            StopAudioMusic: function (soundComponent) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#StopAudioMusic", this ); }

                soundComponent.removeOnCompleted(Bridge.fn.cacheBind(this, this.StopAudioMusic));
                VirtueSky.ObjectPooling.Pool.DeSpawn(soundComponent.gameObject);
            },
            /*VirtueSky.Audio.AudioManager.StopAudioMusic end.*/

            /*VirtueSky.Audio.AudioManager.GetSoundComponent start.*/
            GetSoundComponent: function (soundCache) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#GetSoundComponent", this ); }

                if (soundCache == null) {
                    return null;
                }
                for (var i = 0; i < this.listCacheSfx.Count; i = (i + 1) | 0) {
                    if (soundCache.key === this.listCacheSfx.getItem(i).Key) {
                        return this.listCacheSfx.getItem(i);
                    }
                }

                return null;
            },
            /*VirtueSky.Audio.AudioManager.GetSoundComponent end.*/

            /*VirtueSky.Audio.AudioManager.GetSoundCache start.*/
            GetSoundCache: function (soundData) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.AudioManager#GetSoundCache", this ); }

                this.key = (this.key + 1) | 0;
                return new VirtueSky.Audio.SoundCache(this.key, soundData);
            },
            /*VirtueSky.Audio.AudioManager.GetSoundCache end.*/


        }
    });
    /*VirtueSky.Audio.AudioManager end.*/

    /*VirtueSky.Audio.SoundCache start.*/
    Bridge.define("VirtueSky.Audio.SoundCache", {
        fields: {
            key: 0,
            soundData: null
        },
        ctors: {
            ctor: function (_key, _soundData) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundCache#ctor", this ); }

                this.$initialize();
                this.key = _key;
                this.soundData = _soundData;
            }
        }
    });
    /*VirtueSky.Audio.SoundCache end.*/

    /*VirtueSky.Events.BaseEvent start.*/
    Bridge.define("VirtueSky.Events.BaseEvent", {
        inherits: [VirtueSky.Core.BaseSO,VirtueSky.Events.IEvent],
        fields: {
            listeners: null,
            onRaised: null
        },
        alias: [
            "Raise", "VirtueSky$Events$IEvent$Raise",
            "addOnRaised", "VirtueSky$Events$IEvent$addOnRaised",
            "removeOnRaised", "VirtueSky$Events$IEvent$removeOnRaised",
            "AddListener", "VirtueSky$Events$IEvent$AddListener",
            "RemoveListener", "VirtueSky$Events$IEvent$RemoveListener",
            "AddListener$1", "VirtueSky$Events$IEvent$AddListener$1",
            "RemoveListener$1", "VirtueSky$Events$IEvent$RemoveListener$1",
            "RemoveAll", "VirtueSky$Events$IEvent$RemoveAll"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#init", this ); }

                this.listeners = new (System.Collections.Generic.List$1(VirtueSky.Events.IEventListener)).ctor();
            }
        },
        methods: {
            addOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#addOnRaised", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, value);
            },
            removeOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#removeOnRaised", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, value);
            },
            /*VirtueSky.Events.BaseEvent.Raise start.*/
            Raise: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#Raise", this ); }

                for (var i = (this.listeners.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    this.listeners.getItem(i).VirtueSky$Events$IEventListener$OnEventRaised(this);
                }

                !Bridge.staticEquals(this.onRaised, null) ? this.onRaised() : null;
            },
            /*VirtueSky.Events.BaseEvent.Raise end.*/

            /*VirtueSky.Events.BaseEvent.AddListener start.*/
            AddListener: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#AddListener", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, action);
            },
            /*VirtueSky.Events.BaseEvent.AddListener end.*/

            /*VirtueSky.Events.BaseEvent.AddListener$1 start.*/
            AddListener$1: function (listener) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#AddListener$1", this ); }

                if (!this.listeners.contains(listener)) {
                    this.listeners.add(listener);
                }
            },
            /*VirtueSky.Events.BaseEvent.AddListener$1 end.*/

            /*VirtueSky.Events.BaseEvent.RemoveListener start.*/
            RemoveListener: function (action) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#RemoveListener", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, action);
            },
            /*VirtueSky.Events.BaseEvent.RemoveListener end.*/

            /*VirtueSky.Events.BaseEvent.RemoveListener$1 start.*/
            RemoveListener$1: function (listener) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#RemoveListener$1", this ); }

                if (this.listeners.contains(listener)) {
                    this.listeners.remove(listener);
                }
            },
            /*VirtueSky.Events.BaseEvent.RemoveListener$1 end.*/

            /*VirtueSky.Events.BaseEvent.RemoveAll start.*/
            RemoveAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent#RemoveAll", this ); }

                this.listeners.clear();
                this.onRaised = null;
            },
            /*VirtueSky.Events.BaseEvent.RemoveAll end.*/


        },
        overloads: {
            "AddListener(IEventListener)": "AddListener$1",
            "RemoveListener(IEventListener)": "RemoveListener$1"
        }
    });
    /*VirtueSky.Events.BaseEvent end.*/

    /*VirtueSky.Audio.SoundData start.*/
    Bridge.define("VirtueSky.Audio.SoundData", {
        inherits: [VirtueSky.Core.BaseSO],
        fields: {
            loop: false,
            volume: 0,
            isMusicFadeVolume: false,
            fadeInDuration: 0,
            fadeOutDuration: 0,
            audioClips: null
        },
        props: {
            NumberOfAudioClips: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundData#NumberOfAudioClips#get", this ); }

                    return this.audioClips.Count;
                }
            }
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundData#init", this ); }

                this.loop = false;
                this.volume = 1;
                this.isMusicFadeVolume = false;
                this.fadeInDuration = 0.5;
                this.fadeOutDuration = 0.5;
            }
        },
        methods: {
            /*VirtueSky.Audio.SoundData.GetAudioClip start.*/
            GetAudioClip: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundData#GetAudioClip", this ); }

                if (this.audioClips.Count > 0) {
                    return this.audioClips.getItem(UnityEngine.Random.Range(0, this.audioClips.Count));
                }

                return null;
            },
            /*VirtueSky.Audio.SoundData.GetAudioClip end.*/


        }
    });
    /*VirtueSky.Audio.SoundData end.*/

    /*VirtueSky.Events.BaseEvent$2 start.*/
    Bridge.define("VirtueSky.Events.BaseEvent$2", function (TType, TResult) { return {
        inherits: [VirtueSky.Core.BaseSO,VirtueSky.Events.IEvent$2(TType,TResult)],
        fields: {
            listeners: null,
            onRaised: null
        },
        alias: [
            "Raise", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$Raise",
            "addOnRaised", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$addOnRaised",
            "removeOnRaised", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$removeOnRaised",
            "AddListener$1", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$AddListener",
            "RemoveListener$1", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$RemoveListener",
            "AddListener", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$AddListener$1",
            "RemoveListener", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$RemoveListener$1",
            "RemoveAll", "VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$RemoveAll"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#init", this ); }

                this.listeners = new (System.Collections.Generic.List$1(VirtueSky.Events.IEventListener$2(TType,TResult))).ctor();
            }
        },
        methods: {
            addOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#addOnRaised", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, value);
            },
            removeOnRaised: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#removeOnRaised", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, value);
            },
            /*VirtueSky.Events.BaseEvent$2.Raise start.*/
            Raise: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#Raise", this ); }

                var result = Bridge.getDefaultValue(TResult);
                if (!UnityEngine.Application.isPlaying) {
                    return Bridge.rValue(result);
                }
                for (var i = (this.listeners.Count - 1) | 0; i >= 0; i = (i - 1) | 0) {
                    this.listeners.getItem(i)["VirtueSky$Events$IEventListener$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$OnEventRaised"](this, Bridge.rValue(value));
                }

                if (!Bridge.staticEquals(this.onRaised, null)) {
                    result = Bridge.rValue(this.onRaised(Bridge.rValue(value)));
                }
                return Bridge.rValue(result);
            },
            /*VirtueSky.Events.BaseEvent$2.Raise end.*/

            /*VirtueSky.Events.BaseEvent$2.AddListener$1 start.*/
            AddListener$1: function (func) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#AddListener$1", this ); }

                this.onRaised = Bridge.fn.combine(this.onRaised, func);
            },
            /*VirtueSky.Events.BaseEvent$2.AddListener$1 end.*/

            /*VirtueSky.Events.BaseEvent$2.AddListener start.*/
            AddListener: function (listener) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#AddListener", this ); }

                if (!this.listeners.contains(listener)) {
                    this.listeners.add(listener);
                }
            },
            /*VirtueSky.Events.BaseEvent$2.AddListener end.*/

            /*VirtueSky.Events.BaseEvent$2.RemoveListener$1 start.*/
            RemoveListener$1: function (func) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#RemoveListener$1", this ); }

                this.onRaised = Bridge.fn.remove(this.onRaised, func);
            },
            /*VirtueSky.Events.BaseEvent$2.RemoveListener$1 end.*/

            /*VirtueSky.Events.BaseEvent$2.RemoveListener start.*/
            RemoveListener: function (listener) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#RemoveListener", this ); }

                if (this.listeners.contains(listener)) {
                    this.listeners.remove(listener);
                }
            },
            /*VirtueSky.Events.BaseEvent$2.RemoveListener end.*/

            /*VirtueSky.Events.BaseEvent$2.RemoveAll start.*/
            RemoveAll: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEvent$2#RemoveAll", this ); }

                this.listeners.clear();
                this.onRaised = null;
            },
            /*VirtueSky.Events.BaseEvent$2.RemoveAll end.*/


        },
        overloads: {
            "AddListener(Func<TType, TResult>)": "AddListener$1",
            "RemoveListener(Func<TType, TResult>)": "RemoveListener$1"
        }
    }; });
    /*VirtueSky.Events.BaseEvent$2 end.*/

    /*VirtueSky.Core.CacheComponent$1 start.*/
    Bridge.define("VirtueSky.Core.CacheComponent$1", function (T) { return {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            component: Bridge.getDefaultValue(T),
            CacheTransform: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.CacheComponent$1#init", this ); }

                this.component = Bridge.getDefaultValue(T);
            }
        },
        methods: {
            /*VirtueSky.Core.CacheComponent$1.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.CacheComponent$1#Awake", this ); }

                if (UnityEngine.Component.op_Equality(this.CacheTransform, null)) {
                    this.CacheTransform = this.transform;
                }
                this.GetCacheComponent();
            },
            /*VirtueSky.Core.CacheComponent$1.Awake end.*/

            /*VirtueSky.Core.CacheComponent$1.GetCacheComponent start.*/
            GetCacheComponent: function () {
if ( TRACE ) { TRACE( "VirtueSky.Core.CacheComponent$1#GetCacheComponent", this ); }

                if (Bridge.rValue(this.component) == null) {
                    this.component = Bridge.rValue(this.GetComponent(T));
                }
            },
            /*VirtueSky.Core.CacheComponent$1.GetCacheComponent end.*/


        }
    }; });
    /*VirtueSky.Core.CacheComponent$1 end.*/

    /*VirtueSky.Component.BounceComponent start.*/
    Bridge.define("VirtueSky.Component.BounceComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            isRotate: false,
            degreesPerSecond: 0,
            amplitude: 0,
            frequency: 0,
            _posOffset: null,
            _tempPos: null,
            isBounce: false
        },
        alias: ["FixedTick", "VirtueSky$Core$IEntity$FixedTick"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.BounceComponent#init", this ); }

                this._posOffset = new UnityEngine.Vector3();
                this._tempPos = new UnityEngine.Vector3();
                this.isRotate = false;
                this.degreesPerSecond = 15.0;
                this.amplitude = 5.0;
                this.frequency = 1.0;
                this.isBounce = true;
            }
        },
        methods: {
            /*VirtueSky.Component.BounceComponent.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.BounceComponent#OnEnable", this ); }

                VirtueSky.Core.BaseMono.prototype.OnEnable.call(this);
                this.isBounce = true;
                this._posOffset = this.transform.localPosition.$clone();
            },
            /*VirtueSky.Component.BounceComponent.OnEnable end.*/

            /*VirtueSky.Component.BounceComponent.Pause start.*/
            Pause: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.BounceComponent#Pause", this ); }

                this.isBounce = false;
            },
            /*VirtueSky.Component.BounceComponent.Pause end.*/

            /*VirtueSky.Component.BounceComponent.Resume start.*/
            Resume: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.BounceComponent#Resume", this ); }

                this.isBounce = true;
            },
            /*VirtueSky.Component.BounceComponent.Resume end.*/

            /*VirtueSky.Component.BounceComponent.FixedTick start.*/
            FixedTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.BounceComponent#FixedTick", this ); }

                VirtueSky.Core.BaseMono.prototype.FixedTick.call(this);
                if (this.isBounce) {
                    if (this.isRotate) {
                        this.transform.Rotate$2(new pc.Vec3( 0.0, UnityEngine.Time.deltaTime * this.degreesPerSecond, 0.0 ), UnityEngine.Space.World);
                    }

                    this._tempPos = this._posOffset.$clone();
                    this._tempPos.y += Math.sin(UnityEngine.Time.fixedTime * UnityEngine.Mathf.PI * this.frequency) * this.amplitude;

                    this.transform.localPosition = this._tempPos.$clone();
                }
            },
            /*VirtueSky.Component.BounceComponent.FixedTick end.*/


        }
    });
    /*VirtueSky.Component.BounceComponent end.*/

    /*VirtueSky.Component.FollowTargetComponent start.*/
    Bridge.define("VirtueSky.Component.FollowTargetComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            currentTrans: null,
            targetTrans: null,
            offsetTrans: null,
            directionFollowTarget: 0,
            typeFollowTarget: 0,
            interpolateValue: 0,
            currentVelocity: null,
            smoothTime: 0,
            maxSpeed: 0
        },
        props: {
            TargetTransform: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#TargetTransform#get", this ); }

                    return this.targetTrans;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#TargetTransform#set", this ); }

                    this.targetTrans = value;
                }
            },
            OffsetTrans: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#OffsetTrans#get", this ); }

                    return this.offsetTrans.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#OffsetTrans#set", this ); }

                    this.offsetTrans = value.$clone();
                }
            },
            DirectionFollowTarget: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#DirectionFollowTarget#get", this ); }

                    return this.directionFollowTarget;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#DirectionFollowTarget#set", this ); }

                    this.directionFollowTarget = value;
                }
            },
            TypeFollowTarget: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#TypeFollowTarget#get", this ); }

                    return this.typeFollowTarget;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#TypeFollowTarget#set", this ); }

                    this.typeFollowTarget = value;
                }
            },
            InterpolateValue: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#InterpolateValue#get", this ); }

                    return this.interpolateValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#InterpolateValue#set", this ); }

                    this.interpolateValue = value;
                }
            },
            CurrentVelocity: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#CurrentVelocity#get", this ); }

                    return this.currentVelocity.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#CurrentVelocity#set", this ); }

                    this.currentVelocity = value.$clone();
                }
            },
            SmoothTime: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#SmoothTime#get", this ); }

                    return this.smoothTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#SmoothTime#set", this ); }

                    this.smoothTime = value;
                }
            },
            MaxSpeed: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#MaxSpeed#get", this ); }

                    return this.maxSpeed;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#MaxSpeed#set", this ); }

                    this.maxSpeed = value;
                }
            }
        },
        alias: ["LateTick", "VirtueSky$Core$IEntity$LateTick"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#init", this ); }

                this.offsetTrans = new UnityEngine.Vector3();
                this.currentVelocity = new UnityEngine.Vector3();
                this.interpolateValue = 0.05;
                this.currentVelocity = pc.Vec3.ZERO.clone();
                this.smoothTime = 0.05;
                this.maxSpeed = window.Infinity;
            }
        },
        methods: {
            /*VirtueSky.Component.FollowTargetComponent.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#Awake", this ); }

                if (UnityEngine.Component.op_Equality(this.currentTrans, null)) {
                    this.currentTrans = this.gameObject.transform;
                }

                this.offsetTrans = this.currentTrans.position.$clone().sub( this.targetTrans.position );
            },
            /*VirtueSky.Component.FollowTargetComponent.Awake end.*/

            /*VirtueSky.Component.FollowTargetComponent.SetTarget start.*/
            SetTarget: function (t) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#SetTarget", this ); }

                this.targetTrans = t;
            },
            /*VirtueSky.Component.FollowTargetComponent.SetTarget end.*/

            /*VirtueSky.Component.FollowTargetComponent.SetDirectionFollowTarget start.*/
            SetDirectionFollowTarget: function (d) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#SetDirectionFollowTarget", this ); }

                this.directionFollowTarget = d;
            },
            /*VirtueSky.Component.FollowTargetComponent.SetDirectionFollowTarget end.*/

            /*VirtueSky.Component.FollowTargetComponent.SetTypeFollowTarget start.*/
            SetTypeFollowTarget: function (t) {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#SetTypeFollowTarget", this ); }

                this.typeFollowTarget = t;
            },
            /*VirtueSky.Component.FollowTargetComponent.SetTypeFollowTarget end.*/

            /*VirtueSky.Component.FollowTargetComponent.LateTick start.*/
            LateTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#LateTick", this ); }

                VirtueSky.Core.BaseMono.prototype.LateTick.call(this);
                switch (this.typeFollowTarget) {
                    case VirtueSky.Component.TypeFollowTarget.SetPosition: 
                        this.HandleSetPos();
                        break;
                    case VirtueSky.Component.TypeFollowTarget.Lerp: 
                        this.HandleLerp();
                        break;
                    case VirtueSky.Component.TypeFollowTarget.SmoothDamp: 
                        this.HandleSmoothDamp();
                        break;
                }
            },
            /*VirtueSky.Component.FollowTargetComponent.LateTick end.*/

            /*VirtueSky.Component.FollowTargetComponent.HandleSetPos start.*/
            HandleSetPos: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#HandleSetPos", this ); }

                var targetPos = this.targetTrans.position.$clone().add( this.offsetTrans );
                switch (this.directionFollowTarget) {
                    case VirtueSky.Component.DirectionFollowTarget.XYZ: 
                        VirtueSky.Misc.Common.SetPosition(this.currentTrans, targetPos.$clone());
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.XY: 
                        VirtueSky.Misc.Common.SetPositionXY$2(this.currentTrans, UnityEngine.Vector2.FromVector3(targetPos.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.XZ: 
                        VirtueSky.Misc.Common.SetPositionXZ$2(this.currentTrans, UnityEngine.Vector2.FromVector3(targetPos.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.YZ: 
                        VirtueSky.Misc.Common.SetPositionYZ$2(this.currentTrans, UnityEngine.Vector2.FromVector3(targetPos.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.X: 
                        VirtueSky.Misc.Common.SetPositionX(this.currentTrans, targetPos.x);
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.Y: 
                        VirtueSky.Misc.Common.SetPositionY(this.currentTrans, targetPos.y);
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.Z: 
                        VirtueSky.Misc.Common.SetPositionZ(this.currentTrans, targetPos.y);
                        break;
                }
            },
            /*VirtueSky.Component.FollowTargetComponent.HandleSetPos end.*/

            /*VirtueSky.Component.FollowTargetComponent.HandleLerp start.*/
            HandleLerp: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#HandleLerp", this ); }

                var interpolateVector3 = new pc.Vec3().lerp( this.currentTrans.position, this.targetTrans.position.$clone().add( this.offsetTrans ), this.interpolateValue );
                switch (this.directionFollowTarget) {
                    case VirtueSky.Component.DirectionFollowTarget.XYZ: 
                        VirtueSky.Misc.Common.SetPosition(this.currentTrans, interpolateVector3.$clone());
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.XY: 
                        VirtueSky.Misc.Common.SetPositionXY$2(this.currentTrans, UnityEngine.Vector2.FromVector3(interpolateVector3.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.XZ: 
                        VirtueSky.Misc.Common.SetPositionXZ$2(this.currentTrans, UnityEngine.Vector2.FromVector3(interpolateVector3.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.YZ: 
                        VirtueSky.Misc.Common.SetPositionYZ$2(this.currentTrans, UnityEngine.Vector2.FromVector3(interpolateVector3.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.X: 
                        VirtueSky.Misc.Common.SetPositionX(this.currentTrans, interpolateVector3.x);
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.Y: 
                        VirtueSky.Misc.Common.SetPositionY(this.currentTrans, interpolateVector3.y);
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.Z: 
                        VirtueSky.Misc.Common.SetPositionZ(this.currentTrans, interpolateVector3.z);
                        break;
                }
            },
            /*VirtueSky.Component.FollowTargetComponent.HandleLerp end.*/

            /*VirtueSky.Component.FollowTargetComponent.HandleSmoothDamp start.*/
            HandleSmoothDamp: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.FollowTargetComponent#HandleSmoothDamp", this ); }

                var smoothDampVector3 = pc.Vec3.smoothDamp( this.currentTrans.position.$clone(), this.targetTrans.position.$clone().add( this.offsetTrans ), Bridge.ref(this, "currentVelocity"), this.smoothTime, this.maxSpeed, UnityEngine.Time.deltaTime );
                switch (this.directionFollowTarget) {
                    case VirtueSky.Component.DirectionFollowTarget.XYZ: 
                        VirtueSky.Misc.Common.SetPosition(this.currentTrans, smoothDampVector3.$clone());
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.XY: 
                        VirtueSky.Misc.Common.SetPositionXY$2(this.currentTrans, UnityEngine.Vector2.FromVector3(smoothDampVector3.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.XZ: 
                        VirtueSky.Misc.Common.SetPositionXZ$2(this.currentTrans, UnityEngine.Vector2.FromVector3(smoothDampVector3.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.YZ: 
                        VirtueSky.Misc.Common.SetPositionYZ$2(this.currentTrans, UnityEngine.Vector2.FromVector3(smoothDampVector3.$clone()));
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.X: 
                        VirtueSky.Misc.Common.SetPositionX(this.currentTrans, smoothDampVector3.x);
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.Y: 
                        VirtueSky.Misc.Common.SetPositionY(this.currentTrans, smoothDampVector3.y);
                        break;
                    case VirtueSky.Component.DirectionFollowTarget.Z: 
                        VirtueSky.Misc.Common.SetPositionZ(this.currentTrans, smoothDampVector3.z);
                        break;
                }
            },
            /*VirtueSky.Component.FollowTargetComponent.HandleSmoothDamp end.*/


        }
    });
    /*VirtueSky.Component.FollowTargetComponent end.*/

    /*VirtueSky.Component.MoveComponent start.*/
    Bridge.define("VirtueSky.Component.MoveComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            movingObject: null,
            points: null,
            speed: 0,
            moveOnAwake: false,
            loop: false,
            _reverse: false,
            _currentPoint: 0,
            _isMoving: false
        },
        alias: ["Tick", "VirtueSky$Core$IEntity$Tick"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.MoveComponent#init", this ); }

                this.speed = 1.0;
                this.moveOnAwake = true;
                this.loop = true;
                this._isMoving = true;
            }
        },
        methods: {
            /*VirtueSky.Component.MoveComponent.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.MoveComponent#Start", this ); }

                this.movingObject.transform.position = this.points.getItem(0).position.$clone();
                if (!this.moveOnAwake) {
                    this._isMoving = false;
                }
            },
            /*VirtueSky.Component.MoveComponent.Start end.*/

            /*VirtueSky.Component.MoveComponent.Tick start.*/
            Tick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.MoveComponent#Tick", this ); }

                VirtueSky.Core.BaseMono.prototype.Tick.call(this);
                if (this._isMoving) {
                    if (this._currentPoint < this.points.Count) {
                        // Move the object towards the next point
                        this.movingObject.transform.position = pc.Vec3.moveTowards( this.movingObject.transform.position, this.points.getItem(this._currentPoint).position, this.speed * UnityEngine.Time.deltaTime );
                        if (pc.Vec3.equals( this.movingObject.transform.position, this.points.getItem(this._currentPoint).position )) {
                            // When the object reaches the point, move on to the next one
                            if (!this._reverse) {
                                this._currentPoint = (this._currentPoint + 1) | 0;
                            } else {
                                this._currentPoint = (this._currentPoint - 1) | 0;
                            }

                            if (this._currentPoint === this.points.Count && this.loop) {
                                this._currentPoint = 0;
                            }

                            if (this._currentPoint < 0 && this.loop) {
                                this._currentPoint = (this.points.Count - 1) | 0;
                            }
                        }
                    }
                }
            },
            /*VirtueSky.Component.MoveComponent.Tick end.*/

            /*VirtueSky.Component.MoveComponent.StopMoving start.*/
            StopMoving: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.MoveComponent#StopMoving", this ); }

                this._isMoving = false;
            },
            /*VirtueSky.Component.MoveComponent.StopMoving end.*/

            /*VirtueSky.Component.MoveComponent.ResumeMoving start.*/
            ResumeMoving: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.MoveComponent#ResumeMoving", this ); }

                this._isMoving = true;
            },
            /*VirtueSky.Component.MoveComponent.ResumeMoving end.*/


        }
    });
    /*VirtueSky.Component.MoveComponent end.*/

    /*VirtueSky.Component.RotateComponent start.*/
    Bridge.define("VirtueSky.Component.RotateComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            ignoreTimeScale: false,
            speed: 0,
            rotateX: false,
            rotateY: false,
            rotateZ: false,
            isReverse: false,
            isRotate: false
        },
        alias: ["FixedTick", "VirtueSky$Core$IEntity$FixedTick"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.RotateComponent#init", this ); }

                this.speed = 1.0;
                this.isRotate = true;
            }
        },
        methods: {
            /*VirtueSky.Component.RotateComponent.Resume start.*/
            Resume: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.RotateComponent#Resume", this ); }

                this.isRotate = true;
            },
            /*VirtueSky.Component.RotateComponent.Resume end.*/

            /*VirtueSky.Component.RotateComponent.Pause start.*/
            Pause: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.RotateComponent#Pause", this ); }

                this.isRotate = false;
            },
            /*VirtueSky.Component.RotateComponent.Pause end.*/

            /*VirtueSky.Component.RotateComponent.FixedTick start.*/
            FixedTick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.RotateComponent#FixedTick", this ); }

                VirtueSky.Core.BaseMono.prototype.FixedTick.call(this);
                if (this.isRotate) {
                    var transformTemp = this.transform;
                    if (this.rotateX) {
                        if (!this.isReverse) {
                            this.transform.RotateAround(this.transform.position.$clone(), this.transform.right.$clone(), UnityEngine.Time.deltaTime * 90.0 * this.speed);
                        } else {
                            this.transform.RotateAround(this.transform.position.$clone(), this.transform.right.$clone(), UnityEngine.Time.deltaTime * 90.0 * -this.speed);
                        }
                    }

                    if (this.rotateY) {
                        if (!this.isReverse) {
                            this.transform.RotateAround(this.transform.position.$clone(), this.transform.up.$clone(), UnityEngine.Time.deltaTime * 90.0 * this.speed);
                        } else {
                            this.transform.RotateAround(this.transform.position.$clone(), this.transform.up.$clone(), UnityEngine.Time.deltaTime * 90.0 * -this.speed);
                        }
                    }

                    if (this.rotateZ) {
                        if (!this.isReverse) {
                            this.transform.RotateAround(this.transform.position.$clone(), this.transform.forward.$clone(), UnityEngine.Time.deltaTime * 90.0 * this.speed * 1);
                        } else {
                            this.transform.RotateAround(this.transform.position.$clone(), this.transform.forward.$clone(), UnityEngine.Time.deltaTime * 90.0 * this.speed * -1);
                        }
                    }
                }
            },
            /*VirtueSky.Component.RotateComponent.FixedTick end.*/


        }
    });
    /*VirtueSky.Component.RotateComponent end.*/

    /*VirtueSky.Component.SafeAreaComponent start.*/
    
    Bridge.define("VirtueSky.Component.SafeAreaComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        statics: {
            fields: {
                /**
                 * Simulation mode for use in editor only. This can be edited at runtime to toggle between different safe areas.
                 *
                 * @static
                 * @public
                 * @memberof VirtueSky.Component.SafeAreaComponent
                 * @type number
                 */
                Sim: 0
            },
            ctors: {
                init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#init", this ); }

                    this.Sim = VirtueSky.Component.SafeAreaComponent.SimDevice.None;
                }
            }
        },
        fields: {
            /**
             * Normalised safe areas for iPhone X with Home indicator (ratios are identical to Xs, 11 Pro). Absolute values:
              PortraitU x=0, y=102, w=1125, h=2202 on full extents w=1125, h=2436;
              PortraitD x=0, y=102, w=1125, h=2202 on full extents w=1125, h=2436 (not supported, remains in Portrait Up);
              LandscapeL x=132, y=63, w=2172, h=1062 on full extents w=2436, h=1125;
              LandscapeR x=132, y=63, w=2172, h=1062 on full extents w=2436, h=1125.
              Aspect Ratio: ~19.5:9.
             *
             * @instance
             * @private
             * @memberof VirtueSky.Component.SafeAreaComponent
             * @type Array.<UnityEngine.Rect>
             */
            NSA_iPhoneX: null,
            /**
             * Normalised safe areas for iPhone Xs Max with Home indicator (ratios are identical to XR, 11, 11 Pro Max). Absolute values:
              PortraitU x=0, y=102, w=1242, h=2454 on full extents w=1242, h=2688;
              PortraitD x=0, y=102, w=1242, h=2454 on full extents w=1242, h=2688 (not supported, remains in Portrait Up);
              LandscapeL x=132, y=63, w=2424, h=1179 on full extents w=2688, h=1242;
              LandscapeR x=132, y=63, w=2424, h=1179 on full extents w=2688, h=1242.
              Aspect Ratio: ~19.5:9.
             *
             * @instance
             * @private
             * @memberof VirtueSky.Component.SafeAreaComponent
             * @type Array.<UnityEngine.Rect>
             */
            NSA_iPhoneXsMax: null,
            /**
             * Normalised safe areas for Pixel 3 XL using landscape left. Absolute values:
              PortraitU x=0, y=0, w=1440, h=2789 on full extents w=1440, h=2960;
              PortraitD x=0, y=0, w=1440, h=2789 on full extents w=1440, h=2960;
              LandscapeL x=171, y=0, w=2789, h=1440 on full extents w=2960, h=1440;
              LandscapeR x=0, y=0, w=2789, h=1440 on full extents w=2960, h=1440.
              Aspect Ratio: 18.5:9.
             *
             * @instance
             * @private
             * @memberof VirtueSky.Component.SafeAreaComponent
             * @type Array.<UnityEngine.Rect>
             */
            NSA_Pixel3XL_LSL: null,
            /**
             * Normalised safe areas for Pixel 3 XL using landscape right. Absolute values and aspect ratio same as above.
             *
             * @instance
             * @private
             * @memberof VirtueSky.Component.SafeAreaComponent
             * @type Array.<UnityEngine.Rect>
             */
            NSA_Pixel3XL_LSR: null,
            Panel: null,
            LastSafeArea: null,
            LastScreenSize: null,
            LastOrientation: 0,
            ConformX: false,
            ConformY: false,
            Logging: false
        },
        alias: ["Tick", "VirtueSky$Core$IEntity$Tick"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#init", this ); }

                this.LastSafeArea = new UnityEngine.Rect();
                this.LastScreenSize = new UnityEngine.Vector2Int();
                this.NSA_iPhoneX = System.Array.init([new UnityEngine.Rect.$ctor1(0.0, 0.04187192, 1.0, 0.9039409), new UnityEngine.Rect.$ctor1(0.0541871935, 0.056, 0.891625643, 0.944)], UnityEngine.Rect);
                this.NSA_iPhoneXsMax = System.Array.init([new UnityEngine.Rect.$ctor1(0.0, 0.03794643, 1.0, 0.9129464), new UnityEngine.Rect.$ctor1(0.04910714, 0.0507246368, 0.901785731, 0.9492754)], UnityEngine.Rect);
                this.NSA_Pixel3XL_LSL = System.Array.init([new UnityEngine.Rect.$ctor1(0.0, 0.0, 1.0, 0.942229748), new UnityEngine.Rect.$ctor1(0.0, 0.0, 0.942229748, 1.0)], UnityEngine.Rect);
                this.NSA_Pixel3XL_LSR = System.Array.init([new UnityEngine.Rect.$ctor1(0.0, 0.0, 1.0, 0.942229748), new UnityEngine.Rect.$ctor1(0.05777027, 0.0, 0.942229748, 1.0)], UnityEngine.Rect);
                this.LastSafeArea = new UnityEngine.Rect.$ctor1(0, 0, 0, 0);
                this.LastScreenSize = new UnityEngine.Vector2Int.$ctor1(0, 0);
                this.LastOrientation = UnityEngine.ScreenOrientation.AutoRotation;
                this.ConformX = true;
                this.ConformY = true;
                this.Logging = false;
            }
        },
        methods: {
            /*VirtueSky.Component.SafeAreaComponent.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#Awake", this ); }

                this.Panel = this.GetComponent(UnityEngine.RectTransform);

                if (UnityEngine.Component.op_Equality(this.Panel, null)) {
                    UnityEngine.Debug.LogError$2("Cannot apply safe area - no RectTransform found on " + (this.name || ""));
                    UnityEngine.MonoBehaviour.Destroy(this.gameObject);
                }

                this.Refresh();
            },
            /*VirtueSky.Component.SafeAreaComponent.Awake end.*/

            /*VirtueSky.Component.SafeAreaComponent.Tick start.*/
            Tick: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#Tick", this ); }

                VirtueSky.Core.BaseMono.prototype.Tick.call(this);
                this.Refresh();
            },
            /*VirtueSky.Component.SafeAreaComponent.Tick end.*/

            /*VirtueSky.Component.SafeAreaComponent.Refresh start.*/
            Refresh: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#Refresh", this ); }

                var safeArea = this.GetSafeArea();

                if (UnityEngine.Rect.op_Inequality(safeArea.$clone(), this.LastSafeArea.$clone()) || UnityEngine.Screen.width !== this.LastScreenSize.x || UnityEngine.Screen.height !== this.LastScreenSize.y || UnityEngine.Screen.orientation !== this.LastOrientation) {
                    // Fix for having auto-rotate off and manually forcing a screen orientation.
                    // See https://forum.unity.com/threads/569236/#post-4473253 and https://forum.unity.com/threads/569236/page-2#post-5166467
                    this.LastScreenSize.x = UnityEngine.Screen.width;
                    this.LastScreenSize.y = UnityEngine.Screen.height;
                    this.LastOrientation = UnityEngine.Screen.orientation;

                    this.ApplySafeArea(safeArea.$clone());
                }
            },
            /*VirtueSky.Component.SafeAreaComponent.Refresh end.*/

            /*VirtueSky.Component.SafeAreaComponent.GetSafeArea start.*/
            GetSafeArea: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#GetSafeArea", this ); }

                var safeArea = UnityEngine.Screen.safeArea.$clone();

                if (UnityEngine.Application.isEditor && VirtueSky.Component.SafeAreaComponent.Sim !== VirtueSky.Component.SafeAreaComponent.SimDevice.None) {
                    var nsa = new UnityEngine.Rect.$ctor1(0, 0, UnityEngine.Screen.width, UnityEngine.Screen.height);

                    switch (VirtueSky.Component.SafeAreaComponent.Sim) {
                        case VirtueSky.Component.SafeAreaComponent.SimDevice.iPhoneX: 
                            if (UnityEngine.Screen.height > UnityEngine.Screen.width) {
                                nsa = this.NSA_iPhoneX[0].$clone();
                            } else {
                                nsa = this.NSA_iPhoneX[1].$clone();
                            }
                            break;
                        case VirtueSky.Component.SafeAreaComponent.SimDevice.iPhoneXsMax: 
                            if (UnityEngine.Screen.height > UnityEngine.Screen.width) {
                                nsa = this.NSA_iPhoneXsMax[0].$clone();
                            } else {
                                nsa = this.NSA_iPhoneXsMax[1].$clone();
                            }
                            break;
                        case VirtueSky.Component.SafeAreaComponent.SimDevice.Pixel3XL_LSL: 
                            if (UnityEngine.Screen.height > UnityEngine.Screen.width) {
                                nsa = this.NSA_Pixel3XL_LSL[0].$clone();
                            } else {
                                nsa = this.NSA_Pixel3XL_LSL[1].$clone();
                            }
                            break;
                        case VirtueSky.Component.SafeAreaComponent.SimDevice.Pixel3XL_LSR: 
                            if (UnityEngine.Screen.height > UnityEngine.Screen.width) {
                                nsa = this.NSA_Pixel3XL_LSR[0].$clone();
                            } else {
                                nsa = this.NSA_Pixel3XL_LSR[1].$clone();
                            }
                            break;
                        default: 
                            break;
                    }

                    safeArea = new UnityEngine.Rect.$ctor1(UnityEngine.Screen.width * nsa.x, UnityEngine.Screen.height * nsa.y, UnityEngine.Screen.width * nsa.width, UnityEngine.Screen.height * nsa.height);
                }

                return safeArea.$clone();
            },
            /*VirtueSky.Component.SafeAreaComponent.GetSafeArea end.*/

            /*VirtueSky.Component.SafeAreaComponent.ApplySafeArea start.*/
            ApplySafeArea: function (r) {
if ( TRACE ) { TRACE( "VirtueSky.Component.SafeAreaComponent#ApplySafeArea", this ); }

                this.LastSafeArea = r.$clone();

                // Ignore x-axis?
                if (!this.ConformX) {
                    r.x = 0;
                    r.width = UnityEngine.Screen.width;
                }

                // Ignore y-axis?
                if (!this.ConformY) {
                    r.y = 0;
                    r.height = UnityEngine.Screen.height;
                }

                // Check for invalid screen startup state on some Samsung devices (see below)
                if (UnityEngine.Screen.width > 0 && UnityEngine.Screen.height > 0) {
                    // Convert safe area rectangle from absolute pixels to normalised anchor coordinates
                    var anchorMin = r.position.$clone();
                    var anchorMax = r.position.$clone().add( r.size );
                    anchorMin.x /= UnityEngine.Screen.width;
                    anchorMin.y /= UnityEngine.Screen.height;
                    anchorMax.x /= UnityEngine.Screen.width;
                    anchorMax.y /= UnityEngine.Screen.height;

                    // Fix for some Samsung devices (e.g. Note 10+, A71, S20) where Refresh gets called twice and the first time returns NaN anchor coordinates
                    // See https://forum.unity.com/threads/569236/page-2#post-6199352
                    if (anchorMin.x >= 0 && anchorMin.y >= 0 && anchorMax.x >= 0 && anchorMax.y >= 0) {
                        this.Panel.anchorMin = anchorMin.$clone();
                        this.Panel.anchorMax = anchorMax.$clone();
                    }
                }

                if (this.Logging) {
                    UnityEngine.Debug.LogFormat("New safe area applied to {0}: x={1}, y={2}, w={3}, h={4} on full extents w={5}, h={6}", [this.name, Bridge.box(r.x, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(r.y, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(r.width, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(r.height, System.Single, System.Single.format, System.Single.getHashCode), Bridge.box(UnityEngine.Screen.width, System.Int32), Bridge.box(UnityEngine.Screen.height, System.Int32)]);
                }
            },
            /*VirtueSky.Component.SafeAreaComponent.ApplySafeArea end.*/


        }
    });
    /*VirtueSky.Component.SafeAreaComponent end.*/

    /*VirtueSky.Component.TimeRemainingComponent start.*/
    Bridge.define("VirtueSky.Component.TimeRemainingComponent", {
        inherits: [VirtueSky.Core.BaseMono],
        fields: {
            targetYear: 0,
            targetMonth: 0,
            targetDay: 0,
            targetHour: 0,
            targetMinute: 0,
            targetSecond: 0,
            targetTime: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.TimeRemainingComponent#init", this ); }

                this.targetTime = System.DateTime.getDefaultValue();
            }
        },
        methods: {
            /*VirtueSky.Component.TimeRemainingComponent.InitTargetTime start.*/
            InitTargetTime: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.TimeRemainingComponent#InitTargetTime", this ); }

                this.targetTime = System.DateTime.create(this.targetYear, this.targetMonth, this.targetDay, this.targetHour, this.targetMinute, this.targetSecond);
            },
            /*VirtueSky.Component.TimeRemainingComponent.InitTargetTime end.*/

            /*VirtueSky.Component.TimeRemainingComponent.InitTargetTime$1 start.*/
            InitTargetTime$1: function (year, month, day, hour, minute, second) {
if ( TRACE ) { TRACE( "VirtueSky.Component.TimeRemainingComponent#InitTargetTime$1", this ); }

                this.targetTime = System.DateTime.create(year, month, day, hour, minute, second);
            },
            /*VirtueSky.Component.TimeRemainingComponent.InitTargetTime$1 end.*/

            /*VirtueSky.Component.TimeRemainingComponent.GetTimeRemaining start.*/
            GetTimeRemaining: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.TimeRemainingComponent#GetTimeRemaining", this ); }

                return (System.DateTime.subdd(this.targetTime, System.DateTime.getNow())).getTotalSeconds() > 0 ? (System.DateTime.subdd(this.targetTime, System.DateTime.getNow())) : System.TimeSpan.zero;
            },
            /*VirtueSky.Component.TimeRemainingComponent.GetTimeRemaining end.*/


        },
        overloads: {
            "InitTargetTime(int, int, int, int, int, int)": "InitTargetTime$1"
        }
    });
    /*VirtueSky.Component.TimeRemainingComponent end.*/

    /*CellGrid start.*/
    Bridge.define("CellGrid", {
        inherits: [ObjectBase],
        fields: {
            neighbours: null,
            coordinate: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "CellGrid#init", this ); }

                this.coordinate = new UnityEngine.Vector2Int();
            }
        },
        methods: {
            /*CellGrid.GetNeighbour start.*/
            GetNeighbour: function (direction) {
if ( TRACE ) { TRACE( "CellGrid#GetNeighbour", this ); }

                var data = this.neighbours.Find(function (x) {
                    return x.direction === direction;
                }).$clone();
                return data.cell;
            },
            /*CellGrid.GetNeighbour end.*/

            /*CellGrid.GetAllNeighbours start.*/
            GetAllNeighbours: function () {
if ( TRACE ) { TRACE( "CellGrid#GetAllNeighbours", this ); }

                var $t;
                var result = new (System.Collections.Generic.List$1(CellGrid)).ctor();
                $t = Bridge.getEnumerator(this.neighbours);
                try {
                    while ($t.moveNext()) {
                        var neighbour = $t.Current.$clone();
                        result.add(neighbour.cell);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }

                return result;
            },
            /*CellGrid.GetAllNeighbours end.*/

            /*CellGrid.PrepareNeighbour start.*/
            PrepareNeighbour: function (data) {
if ( TRACE ) { TRACE( "CellGrid#PrepareNeighbour", this ); }

                this.neighbours = new (System.Collections.Generic.List$1(CellData)).$ctor1(data);
            },
            /*CellGrid.PrepareNeighbour end.*/


        }
    });
    /*CellGrid end.*/

    /*EventGetGameState start.*/
    Bridge.define("EventGetGameState", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(GameState)]
    });
    /*EventGetGameState end.*/

    /*Plane start.*/
    Bridge.define("Plane", {
        inherits: [ObjectBase],
        methods: {
            /*Plane.SetSize start.*/
            SetSize: function (size) {
if ( TRACE ) { TRACE( "Plane#SetSize", this ); }

                this.transform.localScale = new pc.Vec3( size.x, 1, size.y );
            },
            /*Plane.SetSize end.*/


        }
    });
    /*Plane end.*/
    /**
     * @memberof Spine.Unity
     * @callback Spine.Unity.UpdateBonesDelegate
     * @param   {Spine.Unity.ISkeletonAnimation}    animated
     * @return  {void}
     */


    /*Spine.Unity.SkeletonAnimation start.*/
    Bridge.define("Spine.Unity.SkeletonAnimation", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation,Spine.Unity.IAnimationStateComponent],
        statics: {
            methods: {
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static start.*/
                /**
                 * Adds and prepares a SkeletonAnimation component to a GameObject at runtime.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {UnityEngine.GameObject}           gameObject           
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation
                 */
                AddToGameObject: function (gameObject, skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AddToGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.AddSpineComponent(Spine.Unity.SkeletonAnimation, gameObject, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.AddToGameObject:static end.*/

                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static start.*/
                /**
                 * Instantiates a new UnityEngine.GameObject and adds a prepared SkeletonAnimation component to it.
                 *
                 * @static
                 * @public
                 * @this Spine.Unity.SkeletonAnimation
                 * @memberof Spine.Unity.SkeletonAnimation
                 * @param   {Spine.Unity.SkeletonDataAsset}    skeletonDataAsset    
                 * @param   {boolean}                          quiet
                 * @return  {Spine.Unity.SkeletonAnimation}                         The newly instantiated SkeletonAnimation component.
                 */
                NewSkeletonAnimationGameObject: function (skeletonDataAsset, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#NewSkeletonAnimationGameObject", this ); }

                    if (quiet === void 0) { quiet = false; }
                    return Spine.Unity.SkeletonRenderer.NewSpineGameObject(Spine.Unity.SkeletonAnimation, skeletonDataAsset, quiet);
                },
                /*Spine.Unity.SkeletonAnimation.NewSkeletonAnimationGameObject:static end.*/


            }
        },
        fields: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type Spine.AnimationState
             */
            state: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0,
            /**
             * If enabled, AnimationState uses unscaled game time
             (<pre><code>Time.unscaledDeltaTime</code></pre> instead of normal game time(<pre><code>Time.deltaTime</code></pre>),
             running animations independent of e.g. game pause (<pre><code>Time.timeScale</code></pre>).
             Instance SkeletonAnimation.timeScale will still be applied.
             *
             * @instance
             * @protected
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            unscaledTime: false,
            _animationName: null,
            /**
             * Whether or not {@link } should loop. This only applies to the initial animation specified in the inspector, or any subsequent Animations played through .AnimationName. Animations set through state.SetAnimation are unaffected.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @type boolean
             */
            loop: false,
            /**
             * The rate at which animations progress over time. 1 means 100%. 0.5 means 50%.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @default 1
             * @type number
             */
            timeScale: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            /**
             * This is the Spine.AnimationState object of this SkeletonAnimation. You can control animations through it.
             Note that this object, like .skeleton, is not guaranteed to exist in Awake. Do all accesses and caching to it in Start
             *
             * @instance
             * @public
             * @readonly
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationState
             * @type Spine.AnimationState
             */
            AnimationState: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationState#get", this ); }

                    this.Initialize(false);
                    return this.state;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            },
            UnscaledTime: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#get", this ); }

                    return this.unscaledTime;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UnscaledTime#set", this ); }

                    this.unscaledTime = value;
                }
            },
            /**
             * Setting this property sets the animation of the skeleton. If invalid, it will store the animation name for the next time the skeleton is properly initialized.
             Getting this property gets the name of the currently playing animation. If invalid, it will return the last stored animation name set through this property.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @function AnimationName
             * @type string
             */
            AnimationName: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#get", this ); }

                    if (!this.valid) {
                        return this._animationName;
                    } else {
                        var entry = this.state.getCurrent(0);
                        return entry == null ? null : entry.animation.name;
                    }
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AnimationName#set", this ); }

                    this.Initialize(false);
                    if (Bridge.referenceEquals(this._animationName, value)) {
                        var entry = this.state.getCurrent(0);
                        if (entry != null && entry.loop === this.loop) {
                            return;
                        }
                    }
                    this._animationName = value;

                    if (System.String.isNullOrEmpty(value)) {
                        this.state.clearTrack(0);
                    } else {
                        var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(value);
                        if (animationObject != null) {
                            this.state.setAnimationWith( 0, animationObject, this.loop );
                        }
                    }
                }
            }
        },
        alias: [
            "AnimationState", "Spine$Unity$IAnimationStateComponent$AnimationState",
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "UnscaledTime", "Spine$Unity$IAnimationStateComponent$UnscaledTime",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
                this.timeScale = 1;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonAnimation
             * @event Spine.Unity.SkeletonAnimation#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonAnimation.ClearState start.*/
            /**
             * Clears the previously generated mesh, resets the skeleton's pose, and clears all previously active animations.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @return  {void}
             */
            ClearState: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ClearState", this ); }

                Spine.Unity.SkeletonRenderer.prototype.ClearState.call(this);
                if (this.state != null) {
                    this.state.clearTracks();
                }
            },
            /*Spine.Unity.SkeletonAnimation.ClearState end.*/

            /*Spine.Unity.SkeletonAnimation.Initialize start.*/
            /**
             * Initialize this component. Attempts to load the SkeletonData and creates the internal Spine objects and buffers.
             *
             * @instance
             * @public
             * @override
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {boolean}    overwrite    If set to <pre><code>true</code></pre>, force overwrite an already initialized object.
             * @param   {boolean}    quiet
             * @return  {void}
             */
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                this.state = null; // prevent applying leftover AnimationState
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }
                this.state = new Spine.AnimationState(this.skeletonDataAsset.GetAnimationStateData());
                this.wasUpdatedAfterInit = false;

                if (!System.String.isNullOrEmpty(this._animationName)) {
                    var animationObject = this.skeletonDataAsset.GetSkeletonData(false).findAnimation(this._animationName);
                    if (animationObject != null) {
                        this.state.setAnimationWith( 0, animationObject, this.loop );
                    }
                }

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.Initialize end.*/

            /*Spine.Unity.SkeletonAnimation.Update$1 start.*/
            Update$1: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update$1", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.Update$1 end.*/

            /*Spine.Unity.SkeletonAnimation.Update start.*/
            /**
             * Progresses the AnimationState according to the given deltaTime, and applies it to the Skeleton. Use Time.deltaTime to update manually. Use deltaTime 0 to update without progressing the time.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonAnimation
             * @memberof Spine.Unity.SkeletonAnimation
             * @param   {number}    deltaTime
             * @return  {void}
             */
            Update: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#Update", this ); }

                if (!this.valid || this.state == null) {
                    return;
                }

                this.wasUpdatedAfterInit = true;
                if (this.updateMode < Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }
                this.UpdateAnimationStatus(deltaTime);

                if (this.updateMode === Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, false);
                    return;
                }
                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonAnimation.Update end.*/

            /*Spine.Unity.SkeletonAnimation.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#FixedUpdate", this ); }

                if (this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.FixedUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus start.*/
            UpdateAnimationStatus: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#UpdateAnimationStatus", this ); }

                deltaTime *= this.timeScale;
                this.state.update(deltaTime);
            },
            /*Spine.Unity.SkeletonAnimation.UpdateAnimationStatus end.*/

            /*Spine.Unity.SkeletonAnimation.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                if (this.updateMode !== Spine.Unity.UpdateMode.OnlyEventTimelines) {
                    this.state.apply(this.skeleton);
                } else {
                    this.state.ApplyEventTimelinesOnly(this.skeleton, true);
                }

                this.AfterAnimationApplied();
            },
            /*Spine.Unity.SkeletonAnimation.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied start.*/
            AfterAnimationApplied: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#AfterAnimationApplied", this ); }

                if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                    this._UpdateLocal(this);
                }

                this.skeleton.updateWorldTransform();

                if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                    this._UpdateWorld(this);
                    this.skeleton.updateWorldTransform();
                }

                if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                    this._UpdateComplete(this);
                }
            },
            /*Spine.Unity.SkeletonAnimation.AfterAnimationApplied end.*/

            /*Spine.Unity.SkeletonAnimation.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid) {
                    this.Update(this.unscaledTime ? UnityEngine.Time.unscaledDeltaTime : UnityEngine.Time.deltaTime);
                }

                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update(0);
                }

                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonAnimation.LateUpdate end.*/

            /*Spine.Unity.SkeletonAnimation.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonAnimation#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update(0);
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonAnimation.OnBecameVisible end.*/


        },
        overloads: {
            "Update()": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    Bridge.define("Spine.Unity.SkeletonMecanim", {
        inherits: [Spine.Unity.SkeletonRenderer,Spine.Unity.ISkeletonAnimation],
        fields: {
            translator: null,
            wasUpdatedAfterInit: false,
            updateTiming: 0
        },
        events: {
            _OnAnimationRebuild: null,
            _BeforeApply: null,
            _UpdateLocal: null,
            _UpdateWorld: null,
            _UpdateComplete: null
        },
        props: {
            Translator: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Translator#get", this ); }

                    return this.translator;
                }
            },
            UpdateTiming: {
                get: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#get", this ); }

                    return this.updateTiming;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateTiming#set", this ); }

                    this.updateTiming = value;
                }
            }
        },
        alias: [
            "addOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild",
            "removeOnAnimationRebuild", "Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild",
            "addUpdateLocal", "Spine$Unity$ISkeletonAnimation$addUpdateLocal",
            "removeUpdateLocal", "Spine$Unity$ISkeletonAnimation$removeUpdateLocal",
            "addUpdateWorld", "Spine$Unity$ISkeletonAnimation$addUpdateWorld",
            "removeUpdateWorld", "Spine$Unity$ISkeletonAnimation$removeUpdateWorld",
            "addUpdateComplete", "Spine$Unity$ISkeletonAnimation$addUpdateComplete",
            "removeUpdateComplete", "Spine$Unity$ISkeletonAnimation$removeUpdateComplete",
            "UpdateTiming", "Spine$Unity$ISkeletonAnimation$UpdateTiming",
            "Skeleton", "Spine$Unity$ISkeletonAnimation$Skeleton"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#init", this ); }

                this.wasUpdatedAfterInit = true;
                this.updateTiming = Spine.Unity.UpdateTiming.InUpdate;
            }
        },
        methods: {
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            addOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addOnAnimationRebuild", this ); }

                this.add_OnAnimationRebuild(value);
            },
            /**
             * OnAnimationRebuild is raised after the SkeletonAnimation component is successfully initialized.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#OnAnimationRebuild
             * @return  {Spine.Unity.ISkeletonAnimationDelegate}
             */
            removeOnAnimationRebuild: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeOnAnimationRebuild", this ); }

                this.remove_OnAnimationRebuild(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addBeforeApply", this ); }

                this.add_BeforeApply(value);
            },
            /**
             * Occurs before the animations are applied.
             Use this callback when you want to change the skeleton state before animations are applied on top.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#BeforeApply
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeBeforeApply: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeBeforeApply", this ); }

                this.remove_BeforeApply(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateLocal", this ); }

                this.add_UpdateLocal(value);
            },
            /**
             * Occurs after the animations are applied and before world space values are resolved.
             Use this callback when you want to set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateLocal
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateLocal: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateLocal", this ); }

                this.remove_UpdateLocal(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateWorld", this ); }

                this.add_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Using this callback will cause the world space values to be solved an extra time.
             Use this callback if want to use bone world space values, and also set bone local values.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateWorld
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateWorld: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateWorld", this ); }

                this.remove_UpdateWorld(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            addUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#addUpdateComplete", this ); }

                this.add_UpdateComplete(value);
            },
            /**
             * Occurs after the Skeleton's bone world space values are resolved (including all constraints).
             Use this callback if you want to use bone world space values, but don't intend to modify bone local values.
             This callback can also be used when setting world position and the bone matrix.
             *
             * @instance
             * @public
             * @memberof Spine.Unity.SkeletonMecanim
             * @event Spine.Unity.SkeletonMecanim#UpdateComplete
             * @return  {Spine.Unity.UpdateBonesDelegate}
             */
            removeUpdateComplete: function (value) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#removeUpdateComplete", this ); }

                this.remove_UpdateComplete(value);
            },
            /*Spine.Unity.SkeletonMecanim.Initialize start.*/
            Initialize: function (overwrite, quiet) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Initialize", this ); }

                if (quiet === void 0) { quiet = false; }
                if (this.valid && !overwrite) {
                    return;
                }
                Spine.Unity.SkeletonRenderer.prototype.Initialize.call(this, overwrite, quiet);

                if (!this.valid) {
                    return;
                }

                if (this.translator == null) {
                    this.translator = new Spine.Unity.SkeletonMecanim.MecanimTranslator();
                }
                this.translator.Initialize(this.GetComponent(UnityEngine.Animator), this.skeletonDataAsset);
                this.wasUpdatedAfterInit = false;

                if (!Bridge.staticEquals(this._OnAnimationRebuild, null)) {
                    this._OnAnimationRebuild(this);
                }
            },
            /*Spine.Unity.SkeletonMecanim.Initialize end.*/

            /*Spine.Unity.SkeletonMecanim.Update start.*/
            Update: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update end.*/

            /*Spine.Unity.SkeletonMecanim.Update$1 start.*/
            /**
             * Manual animation update. Required when <pre><code>updateTiming</code></pre> is set to <pre><code>ManualUpdate</code></pre>.
             *
             * @instance
             * @public
             * @this Spine.Unity.SkeletonMecanim
             * @memberof Spine.Unity.SkeletonMecanim
             * @param   {number}    deltaTime    Ignored parameter.
             * @return  {void}
             */
            Update$1: function (deltaTime) {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#Update$1", this ); }

                if (!this.valid) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.Update$1 end.*/

            /*Spine.Unity.SkeletonMecanim.FixedUpdate start.*/
            FixedUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#FixedUpdate", this ); }

                if (!this.valid || this.updateTiming !== Spine.Unity.UpdateTiming.InFixedUpdate) {
                    return;
                }
                this.UpdateAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.FixedUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.UpdateAnimation start.*/
            UpdateAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#UpdateAnimation", this ); }

                this.wasUpdatedAfterInit = true;

                // animation status is kept by Mecanim Animator component
                if (this.updateMode <= Spine.Unity.UpdateMode.OnlyAnimationStatus) {
                    return;
                }

                this.ApplyAnimation();
            },
            /*Spine.Unity.SkeletonMecanim.UpdateAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.ApplyAnimation start.*/
            ApplyAnimation: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#ApplyAnimation", this ); }

                if (!Bridge.staticEquals(this._BeforeApply, null)) {
                    this._BeforeApply(this);
                }

                this.translator.Apply(this.skeleton);

                // UpdateWorldTransform and Bone Callbacks
                {
                    if (!Bridge.staticEquals(this._UpdateLocal, null)) {
                        this._UpdateLocal(this);
                    }

                    this.skeleton.updateWorldTransform();

                    if (!Bridge.staticEquals(this._UpdateWorld, null)) {
                        this._UpdateWorld(this);
                        this.skeleton.updateWorldTransform();
                    }

                    if (!Bridge.staticEquals(this._UpdateComplete, null)) {
                        this._UpdateComplete(this);
                    }
                }
            },
            /*Spine.Unity.SkeletonMecanim.ApplyAnimation end.*/

            /*Spine.Unity.SkeletonMecanim.LateUpdate start.*/
            LateUpdate: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#LateUpdate", this ); }

                if (this.updateTiming === Spine.Unity.UpdateTiming.InLateUpdate && this.valid && this.translator != null && UnityEngine.Component.op_Inequality(this.translator.Animator, null)) {
                    this.UpdateAnimation();
                }
                // instantiation can happen from Update() after this component, leading to a missing Update() call.
                if (!this.wasUpdatedAfterInit) {
                    this.Update();
                }
                Spine.Unity.SkeletonRenderer.prototype.LateUpdate.call(this);
            },
            /*Spine.Unity.SkeletonMecanim.LateUpdate end.*/

            /*Spine.Unity.SkeletonMecanim.OnBecameVisible start.*/
            OnBecameVisible: function () {
if ( TRACE ) { TRACE( "Spine.Unity.SkeletonMecanim#OnBecameVisible", this ); }

                var previousUpdateMode = this.updateMode;
                this.updateMode = Spine.Unity.UpdateMode.FullUpdate;

                // OnBecameVisible is called after LateUpdate()
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate && previousUpdateMode !== Spine.Unity.UpdateMode.EverythingExceptMesh) {
                    this.Update();
                }
                if (previousUpdateMode !== Spine.Unity.UpdateMode.FullUpdate) {
                    this.LateUpdate();
                }
            },
            /*Spine.Unity.SkeletonMecanim.OnBecameVisible end.*/


        },
        overloads: {
            "Update(float)": "Update$1"
        }
    });
    /*Spine.Unity.SkeletonMecanim end.*/

    /*TheBeginning.LevelSystem.EventGetCurrentLevel start.*/
    Bridge.define("TheBeginning.LevelSystem.EventGetCurrentLevel", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(TheBeginning.LevelSystem.Level)]
    });
    /*TheBeginning.LevelSystem.EventGetCurrentLevel end.*/

    /*TheBeginning.LevelSystem.EventGetPreviousLevel start.*/
    Bridge.define("TheBeginning.LevelSystem.EventGetPreviousLevel", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(TheBeginning.LevelSystem.Level)]
    });
    /*TheBeginning.LevelSystem.EventGetPreviousLevel end.*/

    /*TheBeginning.LevelSystem.EventGetTransformCurrentLevel start.*/
    Bridge.define("TheBeginning.LevelSystem.EventGetTransformCurrentLevel", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(UnityEngine.Transform)]
    });
    /*TheBeginning.LevelSystem.EventGetTransformCurrentLevel end.*/

    /*TheBeginning.LevelSystem.EventLoadLevel start.*/
    Bridge.define("TheBeginning.LevelSystem.EventLoadLevel", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(TheBeginning.LevelSystem.Level)]
    });
    /*TheBeginning.LevelSystem.EventLoadLevel end.*/

    /*TheBeginning.UI.GameplayPopup start.*/
    Bridge.define("TheBeginning.UI.GameplayPopup", {
        inherits: [TheBeginning.UI.UIPopup],
        fields: {
            levelText: null,
            levelTextNumber: null,
            stringFormatLevel: null,
            levelTypeText: null,
            boardLevel: null,
            boardLevelText: null,
            replayIcon: null,
            settingIcon: null,
            levelModeData: null,
            replayEvent: null,
            callReturnHomeEvent: null,
            callReplayLevelEvent: null,
            nextLevelEvent: null,
            backLevelEvent: null,
            winLevelEvent: null,
            loseLevelEvent: null,
            isStartingLevel: null,
            indexLevelVariable: null,
            unlockWinStreakLevel: null,
            isPlayingLevel: null,
            playMusicEvent: null,
            soundHardLevel: null,
            musicInGame: null,
            transHardLevel: null,
            transHardLevelAnim: null,
            isBackToBuildTutorialPlaying: null,
            btnBackHome: null,
            onShowBoosterGuild: null,
            groupUI: null,
            showCTAButtonEvent: null,
            ctaButton: null,
            levelAdditionalTime: null,
            addTimeIcon: null,
            addTimeModel: null,
            addTimeModelDefaultPos: null,
            addTimeModelToPos: null,
            addTimeText: null,
            stringFormatAddTimeText: null,
            timeDelayMove: 0,
            timeMove: 0,
            scaleDefault: 0,
            scaleToEnd: 0,
            easeMove: 0,
            preStartLevelEvent: null,
            addTimePlayEvent: null,
            _tweenAddTime: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#init", this ); }

                this.stringFormatLevel = "{0}";
                this.stringFormatAddTimeText = "{0}s";
                this.timeDelayMove = 0.5;
                this.timeMove = 1.0;
                this.scaleDefault = 1.0;
                this.scaleToEnd = 0.7;
                this._tweenAddTime = new (System.Collections.Generic.List$1(DG.Tweening.Tween)).ctor();
            }
        },
        methods: {
            /*TheBeginning.UI.GameplayPopup.OnBeforeShow start.*/
            OnBeforeShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnBeforeShow", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeShow.call(this);
                this.isPlayingLevel.Value = true;
                this.Setup(this.indexLevelVariable.Value);
                this.indexLevelVariable.AddListener$1(Bridge.fn.cacheBind(this, this.Setup));
                this.playMusicEvent.Raise(this.musicInGame);
                this.UpdateBoardLevelMode();

                this.callReplayLevelEvent.addOnRaised(Bridge.fn.cacheBind(this, this.Refresh));
                this.isBackToBuildTutorialPlaying.addOnRaised(Bridge.fn.cacheBind(this, this.OnBackToBuildTutorialPlaying));
                this.onShowBoosterGuild.addOnRaised(Bridge.fn.cacheBind(this, this.OnShowBoosterGuildEvent));
                this.preStartLevelEvent.addOnRaised(Bridge.fn.cacheBind(this, this.OnPreStartLevel));
                this.showCTAButtonEvent.addOnRaised(Bridge.fn.cacheBind(this, this.OnShowCTAButton));
                this.groupUI.SetActive(true);
            },
            /*TheBeginning.UI.GameplayPopup.OnBeforeShow end.*/

            /*TheBeginning.UI.GameplayPopup.UpdateBoardLevelMode start.*/
            UpdateBoardLevelMode: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#UpdateBoardLevelMode", this ); }

                this.transHardLevel.gameObject.SetActive(false);
                var data = this.levelModeData.GetLevelData();
                this.replayIcon.sprite = data.Item2.GetIconReplayLevelSprite();
                this.boardLevelText.sprite = data.Item2.GetIconBoardLevelSprite();
                this.boardLevel.sprite = data.Item2.iconBoardGameplay;
                this.settingIcon.sprite = data.Item2.GetIconSettingSprite();
                this.boardLevelText.SetNativeSize();
                this.levelText.fontMaterial = data.Item2.GetColorTextLevelModeGameplay();
                this.levelTextNumber.fontMaterial = data.Item2.GetColorTextLevelModeGameplay();
                this.boardLevel.SetNativeSize();
                this.replayIcon.SetNativeSize();
                this.settingIcon.SetNativeSize();

                this.Refresh();
            },
            /*TheBeginning.UI.GameplayPopup.UpdateBoardLevelMode end.*/

            /*TheBeginning.UI.GameplayPopup.Refresh start.*/
            Refresh: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#Refresh", this ); }

                if (this.levelModeData.GetLevelData().Item1.levelMode === ELevelMode.VeryHard) {
                    this.transHardLevel.gameObject.SetActive(true);
                    this.playSfxEvent.Raise(this.soundHardLevel);

                    VirtueSky.Core.App.Delay(1.0, Bridge.fn.bind(this, function () {
                        DG.Tweening.TweenSettingsExtensions.OnComplete(Spine.Unity.SkeletonGraphic, VirtueSky.Misc.SkeletonGraphicExtensions.PlayOnly(this.transHardLevel, this.transHardLevelAnim), Bridge.fn.bind(this, function () {
                            this.transHardLevel.gameObject.SetActive((false));
                        }));
                    }));
                }
            },
            /*TheBeginning.UI.GameplayPopup.Refresh end.*/

            /*TheBeginning.UI.GameplayPopup.OnBeforeHide start.*/
            OnBeforeHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnBeforeHide", this ); }

                var $t;
                TheBeginning.UI.UIPopup.prototype.OnBeforeHide.call(this);
                this.indexLevelVariable.RemoveListener$1(Bridge.fn.cacheBind(this, this.Setup));
                this.callReplayLevelEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.Refresh));
                this.isBackToBuildTutorialPlaying.removeOnRaised(Bridge.fn.cacheBind(this, this.OnBackToBuildTutorialPlaying));
                this.preStartLevelEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.OnPreStartLevel));
                this.onShowBoosterGuild.removeOnRaised(Bridge.fn.cacheBind(this, this.OnShowBoosterGuildEvent));
                this.showCTAButtonEvent.removeOnRaised(Bridge.fn.cacheBind(this, this.OnShowCTAButton));
                $t = Bridge.getEnumerator(this._tweenAddTime);
                try {
                    while ($t.moveNext()) {
                        var tween = $t.Current;
                        DG.Tweening.TweenExtensions.Kill(tween);
                    }
                } finally {
                    if (Bridge.is($t, System.IDisposable)) {
                        $t.System$IDisposable$Dispose();
                    }
                }
                this._tweenAddTime.clear();
            },
            /*TheBeginning.UI.GameplayPopup.OnBeforeHide end.*/

            /*TheBeginning.UI.GameplayPopup.OnBackToBuildTutorialPlaying start.*/
            OnBackToBuildTutorialPlaying: function (isPlaying) {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnBackToBuildTutorialPlaying", this ); }

                if (isPlaying) {
                    VirtueSky.Core.App.Delay(0.25, function () {

                    });
                }
            },
            /*TheBeginning.UI.GameplayPopup.OnBackToBuildTutorialPlaying end.*/

            /*TheBeginning.UI.GameplayPopup.Setup start.*/
            Setup: function (currentLevel) {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#Setup", this ); }

                this.levelTextNumber.text = System.String.format(this.stringFormatLevel, [Bridge.box(currentLevel, System.Int32)]);
                // LevelTypeText.text = $"Level ";
            },
            /*TheBeginning.UI.GameplayPopup.Setup end.*/

            /*TheBeginning.UI.GameplayPopup.OnShowBoosterGuildEvent start.*/
            OnShowBoosterGuildEvent: function (isShowing) {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnShowBoosterGuildEvent", this ); }

                this.groupUI.SetActive(!isShowing);
            },
            /*TheBeginning.UI.GameplayPopup.OnShowBoosterGuildEvent end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickHome start.*/
            OnClickHome: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickHome", this ); }
 },
            /*TheBeginning.UI.GameplayPopup.OnClickHome end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickReplay start.*/
            OnClickReplay: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickReplay", this ); }
 },
            /*TheBeginning.UI.GameplayPopup.OnClickReplay end.*/

            /*TheBeginning.UI.GameplayPopup.OnPreStartLevel start.*/
            OnPreStartLevel: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnPreStartLevel", this ); }

                var $t;
                if (UnityEngine.Object.op_Implicit(this.addTimeIcon)) {
                    this.addTimeIcon.SetActive(this.levelAdditionalTime.IsAvailable);
                }
                this.addTimeModel.gameObject.SetActive(this.levelAdditionalTime.IsAvailable);
                this.addTimeModel.localScale = new pc.Vec3( 1, 1, 1 ).clone().scale( this.scaleDefault );
                if (this.levelAdditionalTime.IsAvailable) {
                    $t = Bridge.getEnumerator(this._tweenAddTime);
                    try {
                        while ($t.moveNext()) {
                            var tween = $t.Current;
                            DG.Tweening.TweenExtensions.Kill(tween);
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                    this._tweenAddTime.clear();

                    this.addTimeText.text = System.String.format(this.stringFormatAddTimeText, [Bridge.box(this.levelAdditionalTime.Count, System.Int32)]);
                    var pos = UnityEngine.Component.op_Equality(this.addTimeModelDefaultPos, null) ? pc.Vec3.ZERO.clone() : this.addTimeModelDefaultPos.position.$clone();
                    this.addTimeModel.transform.position = pos.$clone();
                    var tweenDelay = DG.Tweening.DOVirtual.DelayedCall(this.timeDelayMove, Bridge.fn.bind(this, function () {
                        var tweenScale = DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.addTimeModel.transform, new pc.Vec3( 1, 1, 1 ).clone().scale( this.scaleToEnd ), this.timeMove), this.easeMove);
                        var tweenMove = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetEase$2(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOMove(this.addTimeModel.transform, this.addTimeModelToPos.position.$clone(), this.timeMove), this.easeMove), Bridge.fn.bind(this, function () {
                            this.addTimeModel.gameObject.SetActive(false);
                            this.addTimePlayEvent != null ? this.addTimePlayEvent.Raise(this.levelAdditionalTime.Count) : null;
                            this._tweenAddTime.clear();
                        }));

                        this._tweenAddTime.add(tweenScale);
                        this._tweenAddTime.add(tweenMove);
                    }));
                    this._tweenAddTime.add(tweenDelay);
                }
            },
            /*TheBeginning.UI.GameplayPopup.OnPreStartLevel end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickPrevious start.*/
            OnClickPrevious: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickPrevious", this ); }

                this.backLevelEvent.Raise();
            },
            /*TheBeginning.UI.GameplayPopup.OnClickPrevious end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickSkip start.*/
            OnClickSkip: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickSkip", this ); }

                this.nextLevelEvent.Raise();
            },
            /*TheBeginning.UI.GameplayPopup.OnClickSkip end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickLose start.*/
            OnClickLose: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickLose", this ); }

                this.loseLevelEvent.Raise(1);
            },
            /*TheBeginning.UI.GameplayPopup.OnClickLose end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickWin start.*/
            OnClickWin: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickWin", this ); }

                this.winLevelEvent.Raise(1);
            },
            /*TheBeginning.UI.GameplayPopup.OnClickWin end.*/

            /*TheBeginning.UI.GameplayPopup.OnClickSetting start.*/
            OnClickSetting: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnClickSetting", this ); }

                TheBeginning.UI.PopupManager.Show(TheBeginning.UI.SettingPopupInGame, false);
            },
            /*TheBeginning.UI.GameplayPopup.OnClickSetting end.*/

            /*TheBeginning.UI.GameplayPopup.OnShowCTAButton start.*/
            OnShowCTAButton: function (isShow) {
if ( TRACE ) { TRACE( "TheBeginning.UI.GameplayPopup#OnShowCTAButton", this ); }

                this.ctaButton.SetActive(isShow);
            },
            /*TheBeginning.UI.GameplayPopup.OnShowCTAButton end.*/


        }
    });
    /*TheBeginning.UI.GameplayPopup end.*/

    /*TheBeginning.UI.LosePopup start.*/
    Bridge.define("TheBeginning.UI.LosePopup", {
        inherits: [TheBeginning.UI.UIPopup],
        fields: {
            currentLevel: null,
            headerText: null,
            levelFormatText: null,
            heartData: null,
            iconTransform: null,
            replayGameEvent: null,
            returnHomeEvent: null
        },
        methods: {
            /*TheBeginning.UI.LosePopup.OnBeforeShow start.*/
            OnBeforeShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.LosePopup#OnBeforeShow", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeShow.call(this);

                Extension.Clear(this.iconTransform);

                this.headerText.SetNativeSize();

                this.heartData.Minus(1);
            },
            /*TheBeginning.UI.LosePopup.OnBeforeShow end.*/

            /*TheBeginning.UI.LosePopup.OnAfterShow start.*/
            OnAfterShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.LosePopup#OnAfterShow", this ); }

                TheBeginning.UI.UIPopup.prototype.OnAfterShow.call(this);
            },
            /*TheBeginning.UI.LosePopup.OnAfterShow end.*/

            /*TheBeginning.UI.LosePopup.OnBeforeHide start.*/
            OnBeforeHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.LosePopup#OnBeforeHide", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeHide.call(this);
            },
            /*TheBeginning.UI.LosePopup.OnBeforeHide end.*/

            /*TheBeginning.UI.LosePopup.OnAfterHide start.*/
            OnAfterHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.LosePopup#OnAfterHide", this ); }

                TheBeginning.UI.UIPopup.prototype.OnAfterHide.call(this);
            },
            /*TheBeginning.UI.LosePopup.OnAfterHide end.*/

            /*TheBeginning.UI.LosePopup.ClosePopup start.*/
            ClosePopup: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.LosePopup#ClosePopup", this ); }


            },
            /*TheBeginning.UI.LosePopup.ClosePopup end.*/

            /*TheBeginning.UI.LosePopup.OnClickReplay start.*/
            OnClickReplay: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.LosePopup#OnClickReplay", this ); }

                this.Hide();
            },
            /*TheBeginning.UI.LosePopup.OnClickReplay end.*/


        }
    });
    /*TheBeginning.UI.LosePopup end.*/

    /*TheBeginning.UI.SettingPopup start.*/
    Bridge.define("TheBeginning.UI.SettingPopup", {
        inherits: [TheBeginning.UI.UIPopup],
        fields: {
            unlockWinStreakLevel: null,
            indexLevelVariable: null,
            soundVolume: null,
            buttonSound: null,
            soundOn: null,
            soundOff: null,
            musicVolume: null,
            buttonMusic: null,
            musicOn: null,
            musicOff: null,
            buttonVibrate: null,
            vibrateOn: null,
            vibrateOff: null,
            buttonHome: null,
            btnRestorePurchase: null,
            isPlayingLevel: null,
            isPauseGame: null,
            isStartingLevel: null,
            pauseTimeLevelVariable: null,
            callReturnHome: null,
            isBackToBuildTutorialPlaying: null,
            isStartingGlamRush: null,
            isGlamRushFinished: null
        },
        methods: {
            /*TheBeginning.UI.SettingPopup.OnBeforeShow start.*/
            OnBeforeShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnBeforeShow", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeShow.call(this);
                this.pauseTimeLevelVariable.Value = true;
                this.btnRestorePurchase.onClick.AddListener(Bridge.fn.cacheBind(this, this.OnClickRestorePurchase));
                this.Init();
                // #if VIRTUESKY_ADMOB
                //             btnShowPrivacyConsent.gameObject.SetActive(ConsentInformation.PrivacyOptionsRequirementStatus ==
                //                                                        PrivacyOptionsRequirementStatus.Required);
                // #endif
                // InitBtnLanguage();
            },
            /*TheBeginning.UI.SettingPopup.OnBeforeShow end.*/

            /*TheBeginning.UI.SettingPopup.OnAfterShow start.*/
            OnAfterShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnAfterShow", this ); }

                TheBeginning.UI.UIPopup.prototype.OnAfterShow.call(this);
                if (this.isPlayingLevel.Value) {
                    this.isPauseGame.Value = true;
                }
            },
            /*TheBeginning.UI.SettingPopup.OnAfterShow end.*/

            /*TheBeginning.UI.SettingPopup.OnBeforeHide start.*/
            OnBeforeHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnBeforeHide", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeHide.call(this);
                this.pauseTimeLevelVariable.Value = false;
                this.btnRestorePurchase.onClick.RemoveListener(Bridge.fn.cacheBind(this, this.OnClickRestorePurchase));
                // btnShowPrivacyConsent.onClick.RemoveListener(OnClickShowPrivacyConsent);'

                if (this.isPlayingLevel.Value) {
                    this.isPauseGame.Value = false;
                }
            },
            /*TheBeginning.UI.SettingPopup.OnBeforeHide end.*/

            /*TheBeginning.UI.SettingPopup.InitBtnLanguage start.*/
            InitBtnLanguage: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#InitBtnLanguage", this ); }

                // btnLanguageEnglish.toneIntensity = 1;
                // btnLanguageVietNam.toneIntensity = 1;
                // if (Locale.CurrentLanguage == Language.English) btnLanguageEnglish.toneIntensity = 0;
                // if (Locale.CurrentLanguage == Language.Vietnamese) btnLanguageVietNam.toneIntensity = 0;
            },
            /*TheBeginning.UI.SettingPopup.InitBtnLanguage end.*/

            /*TheBeginning.UI.SettingPopup.Init start.*/
            Init: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#Init", this ); }

                this.btnRestorePurchase.gameObject.SetActive(false);
                this.UpdateStatus();
            },
            /*TheBeginning.UI.SettingPopup.Init end.*/

            /*TheBeginning.UI.SettingPopup.OnClickRestorePurchase start.*/
            OnClickRestorePurchase: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnClickRestorePurchase", this ); }
 },
            /*TheBeginning.UI.SettingPopup.OnClickRestorePurchase end.*/

            /*TheBeginning.UI.SettingPopup.OnClickSettingSound start.*/
            OnClickSettingSound: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnClickSettingSound", this ); }

                this.soundVolume.Value = this.soundVolume.Value === 0 ? 1 : 0;
                this.UpdateStatus();
            },
            /*TheBeginning.UI.SettingPopup.OnClickSettingSound end.*/

            /*TheBeginning.UI.SettingPopup.OnClickSettingMusic start.*/
            OnClickSettingMusic: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnClickSettingMusic", this ); }

                this.musicVolume.Value = this.musicVolume.Value === 0 ? 1 : 0;
                this.UpdateStatus();
            },
            /*TheBeginning.UI.SettingPopup.OnClickSettingMusic end.*/

            /*TheBeginning.UI.SettingPopup.OnClickSettingVibration start.*/
            OnClickSettingVibration: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnClickSettingVibration", this ); }

                VirtueSky.Vibration.Vibration.EnableVibration = !VirtueSky.Vibration.Vibration.EnableVibration;
                this.UpdateStatus();
            },
            /*TheBeginning.UI.SettingPopup.OnClickSettingVibration end.*/

            /*TheBeginning.UI.SettingPopup.UpdateStatus start.*/
            UpdateStatus: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#UpdateStatus", this ); }

                this.buttonSound.sprite = this.soundVolume.Value === 1 ? this.soundOn : this.soundOff;
                this.buttonMusic.sprite = this.musicVolume.Value === 1 ? this.musicOn : this.musicOff;
                this.buttonVibrate.sprite = VirtueSky.Vibration.Vibration.EnableVibration ? this.vibrateOn : this.vibrateOff;
            },
            /*TheBeginning.UI.SettingPopup.UpdateStatus end.*/

            /*TheBeginning.UI.SettingPopup.OnClickHome start.*/
            OnClickHome: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnClickHome", this ); }
 },
            /*TheBeginning.UI.SettingPopup.OnClickHome end.*/

            /*TheBeginning.UI.SettingPopup.OnClickShowPrivacyConsent start.*/
            OnClickShowPrivacyConsent: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.SettingPopup#OnClickShowPrivacyConsent", this ); }

                //callShowAgainGDPREvent.Raise();
            },
            /*TheBeginning.UI.SettingPopup.OnClickShowPrivacyConsent end.*/


        }
    });
    /*TheBeginning.UI.SettingPopup end.*/

    /*TheBeginning.UI.UpdatePopup start.*/
    Bridge.define("TheBeginning.UI.UpdatePopup", {
        inherits: [TheBeginning.UI.UIPopup],
        fields: {
            textContent: null,
            textVersion: null,
            contentUpdateVariable: null,
            versionUpdateVariable: null,
            dontShowAgainPopupUpdate: null,
            toggleShowAgain: null
        },
        methods: {
            /*TheBeginning.UI.UpdatePopup.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UpdatePopup#Start", this ); }

                this.toggleShowAgain.isOn = false;
            },
            /*TheBeginning.UI.UpdatePopup.Start end.*/

            /*TheBeginning.UI.UpdatePopup.OnBeforeShow start.*/
            OnBeforeShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UpdatePopup#OnBeforeShow", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeShow.call(this);
                this.Setup();
            },
            /*TheBeginning.UI.UpdatePopup.OnBeforeShow end.*/

            /*TheBeginning.UI.UpdatePopup.Setup start.*/
            Setup: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UpdatePopup#Setup", this ); }

                this.textContent.text = this.contentUpdateVariable.Value;
                this.textVersion.text = this.versionUpdateVariable.Value;
            },
            /*TheBeginning.UI.UpdatePopup.Setup end.*/

            /*TheBeginning.UI.UpdatePopup.OnChangeValueShowAgain start.*/
            OnChangeValueShowAgain: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.UpdatePopup#OnChangeValueShowAgain", this ); }

                this.dontShowAgainPopupUpdate.Value = this.toggleShowAgain.isOn;
            },
            /*TheBeginning.UI.UpdatePopup.OnChangeValueShowAgain end.*/


        }
    });
    /*TheBeginning.UI.UpdatePopup end.*/

    /*TheBeginning.UI.WinPopup start.*/
    Bridge.define("TheBeginning.UI.WinPopup", {
        inherits: [TheBeginning.UI.UIPopup],
        fields: {
            gameSettings: null,
            moneyWin: 0,
            ratioScaleContinueButton: 0,
            currentLevel: null,
            btnTapToContinue: null,
            textValueFormat: null,
            textButtonComplete: null,
            timeDelayShowContinue: 0,
            timeScaleContinue: 0,
            soundFx: null,
            timeDelayPlayFx: 0,
            starPosition: null,
            playCurrentLevelEvent: null,
            moveAllCoinDone: null,
            timeShowAnimation: 0,
            listAnimatorUI: null,
            group: null,
            percent: 0,
            waitMoveAllCoinDone: false,
            _isCanClickContinue: false,
            _delayShowBtnContinue: null,
            _tweenScaleBtnContinue: null,
            _moneyWin: 0
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#init", this ); }

                this.moneyWin = 50;
                this.timeDelayPlayFx = 0.5;
                this.timeShowAnimation = 3.0;
                this.listAnimatorUI = new (System.Collections.Generic.List$1(AnimatorUIControl)).ctor();
                this.percent = 0;
                this._moneyWin = 0;
            }
        },
        methods: {
            /*TheBeginning.UI.WinPopup.OnBeforeShow start.*/
            OnBeforeShow: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#OnBeforeShow", this ); }

                var $t, $t1;
                TheBeginning.UI.UIPopup.prototype.OnBeforeShow.call(this);

                ($t = this.currentLevel).Value = ($t.Value + 1) | 0;
                this.waitMoveAllCoinDone = false;
                this._moneyWin = this.moneyWin;
                this.moveAllCoinDone.AddListener(Bridge.fn.cacheBind(this, this.OnMoveAllCoinDone));
                this.Setup();

                $t1 = Bridge.getEnumerator(this.listAnimatorUI);
                try {
                    while ($t1.moveNext()) {
                        var animator = $t1.Current;
                        animator.Play();
                    }
                } finally {
                    if (Bridge.is($t1, System.IDisposable)) {
                        $t1.System$IDisposable$Dispose();
                    }
                }

                VirtueSky.Core.App.Delay(this.timeDelayPlayFx, Bridge.fn.bind(this, function () {
                    this.playSfxEvent != null ? this.playSfxEvent.Raise(this.soundFx) : null;
                }));
                this.group.SetActive(false);

                VirtueSky.Core.App.Delay(this.timeShowAnimation, Bridge.fn.bind(this, function () {
                    this.group.SetActive(true);
                    this.btnTapToContinue.gameObject.SetActive(false);
                    this._isCanClickContinue = false;
                    this._delayShowBtnContinue = VirtueSky.Core.App.Delay$1(this, this.timeDelayShowContinue, Bridge.fn.bind(this, function () {
                        this.btnTapToContinue.gameObject.SetActive(true);
                        this.btnTapToContinue.interactable = false;
                        this.btnTapToContinue.transform.localScale = pc.Vec3.ZERO.clone();
                        this._tweenScaleBtnContinue = DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.TweenSettingsExtensions.SetUpdate(DG.Tweening.Core.TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions), DG.Tweening.ShortcutExtensions.DOScale$1(this.btnTapToContinue.transform, new pc.Vec3( 1, 1, 1 ), this.timeScaleContinue), true), Bridge.fn.bind(this, function () {
                            this._isCanClickContinue = true;
                            this.btnTapToContinue.interactable = true;
                        }));
                    }));
                }));
            },
            /*TheBeginning.UI.WinPopup.OnBeforeShow end.*/

            /*TheBeginning.UI.WinPopup.OnBeforeHide start.*/
            OnBeforeHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#OnBeforeHide", this ); }

                TheBeginning.UI.UIPopup.prototype.OnBeforeHide.call(this);
                this.moveAllCoinDone.RemoveListener(Bridge.fn.cacheBind(this, this.OnMoveAllCoinDone));
            },
            /*TheBeginning.UI.WinPopup.OnBeforeHide end.*/

            /*TheBeginning.UI.WinPopup.Setup start.*/
            Setup: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#Setup", this ); }

                this.textButtonComplete.text = System.String.format(this.textValueFormat, [Bridge.box(this._moneyWin, System.Int32)]);
            },
            /*TheBeginning.UI.WinPopup.Setup end.*/

            /*TheBeginning.UI.WinPopup.OnClickContinue start.*/
            OnClickContinue: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#OnClickContinue", this ); }

                if (!this._isCanClickContinue && this.isActive) {
                    return;
                }
                this.OnClaimCoinWin(false);
            },
            /*TheBeginning.UI.WinPopup.OnClickContinue end.*/

            /*TheBeginning.UI.WinPopup.OnClaimCoinWin start.*/
            OnClaimCoinWin: function (isWatchAds) {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#OnClaimCoinWin", this ); }

                this.btnTapToContinue.gameObject.SetActive(false);
                this._delayShowBtnContinue != null ? this._delayShowBtnContinue.Cancel() : null;
                DG.Tweening.TweenExtensions.Kill(this._tweenScaleBtnContinue);

                var reason = isWatchAds ? TrackingEnum.EResourceReason.watch_ads : TrackingEnum.EResourceReason.reward;
                StarSystem.AddStar(1, this.starPosition.transform.position.$clone(), TrackingEnum.EResourceType.currency, reason, TrackingEnum.EPlacement.win_popup);
                CoinSystem.AddCoin(this._moneyWin, this.btnTapToContinue.transform.position.$clone(), TrackingEnum.EResourceType.currency, reason, TrackingEnum.EPlacement.win_popup);
                VirtueSky.Core.App.Delay(1.25, Bridge.fn.bind(this, function () {
                    this.Hide();
                }));
            },
            /*TheBeginning.UI.WinPopup.OnClaimCoinWin end.*/

            /*TheBeginning.UI.WinPopup.OnAfterHide start.*/
            OnAfterHide: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#OnAfterHide", this ); }

                TheBeginning.UI.UIPopup.prototype.OnAfterHide.call(this);
            },
            /*TheBeginning.UI.WinPopup.OnAfterHide end.*/

            /*TheBeginning.UI.WinPopup.OnMoveAllCoinDone start.*/
            OnMoveAllCoinDone: function () {
if ( TRACE ) { TRACE( "TheBeginning.UI.WinPopup#OnMoveAllCoinDone", this ); }

                this.waitMoveAllCoinDone = true;
            },
            /*TheBeginning.UI.WinPopup.OnMoveAllCoinDone end.*/


        }
    });
    /*TheBeginning.UI.WinPopup end.*/

    /*TrackingEvent start.*/
    Bridge.define("TrackingEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(System.ValueTuple$2(System.String,System.Array.type(TrackingParameter)))]
    });
    /*TrackingEvent end.*/

    /*VirtueSky.Audio.FinishSfxEvent start.*/
    Bridge.define("VirtueSky.Audio.FinishSfxEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(VirtueSky.Audio.SoundCache)]
    });
    /*VirtueSky.Audio.FinishSfxEvent end.*/

    /*VirtueSky.Variables.BaseVariable$1 start.*/
    Bridge.define("VirtueSky.Variables.BaseVariable$1", function (TType) { return {
        inherits: [VirtueSky.Events.BaseEvent$1(TType),VirtueSky.Variables.IVariable$1(TType),UnityEngine.ISerializationCallbackReceiver,VirtueSky.Variables.IGuidVariable],
        fields: {
            typeId: 0,
            guid: null,
            customId: null,
            initializeValue: Bridge.getDefaultValue(TType),
            isSetData: false,
            isSaveData: false,
            isRaiseEvent: false,
            runtimeValue: Bridge.getDefaultValue(TType)
        },
        props: {
            InitializeValue: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#InitializeValue#get", this ); }

                    return Bridge.rValue(this.initializeValue);
                }
            },
            Guid: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#Guid#get", this ); }

                    return this.guid;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#Guid#set", this ); }

                    this.guid = value;
                }
            },
            CustomId: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#CustomId#get", this ); }

                    return this.customId;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#CustomId#set", this ); }

                    this.customId = value;
                }
            },
            Id: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#Id#get", this ); }

                    if (this.typeId === VirtueSky.Variables.TypeId.Guid) {
                        return this.guid;
                    }
                    return this.customId;
                }
            },
            Value: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#Value#get", this ); }

                    return this.isSetData ? VirtueSky.DataStorage.GameData.Get(TType, this.Id, Bridge.rValue(this.initializeValue)) : Bridge.rValue(this.runtimeValue);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#Value#set", this ); }

                    if (this.isSetData) {
                        VirtueSky.DataStorage.GameData.Set(TType, this.Id, Bridge.rValue(value));
                        if (this.isSaveData) {
                            VirtueSky.DataStorage.GameData.Save();
                        }
                    } else {
                        this.runtimeValue = Bridge.rValue(value);
                    }

                    if (this.isRaiseEvent) {
                        this.Raise(Bridge.rValue(value));
                    }
                }
            },
            IsShowGuid: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#IsShowGuid#get", this ); }

                    return this.isSetData && this.typeId === VirtueSky.Variables.TypeId.Guid;
                }
            },
            IsShowCustomId: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#IsShowCustomId#get", this ); }

                    return this.isSetData && this.typeId === VirtueSky.Variables.TypeId.CustomId;
                }
            }
        },
        alias: [
            "Guid", "VirtueSky$Variables$IGuidVariable$Guid",
            "Value", "VirtueSky$Variables$IVariable$1$" + Bridge.getTypeAlias(TType) + "$Value",
            "OnBeforeSerialize", "UnityEngine$ISerializationCallbackReceiver$OnBeforeSerialize",
            "OnAfterDeserialize", "UnityEngine$ISerializationCallbackReceiver$OnAfterDeserialize"
        ],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#init", this ); }

                this.initializeValue = Bridge.getDefaultValue(TType);
                this.runtimeValue = Bridge.getDefaultValue(TType);
            }
        },
        methods: {
            /*VirtueSky.Variables.BaseVariable$1.OnEnable start.*/
            OnEnable: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#OnEnable", this ); }
 },
            /*VirtueSky.Variables.BaseVariable$1.OnEnable end.*/

            /*VirtueSky.Variables.BaseVariable$1.OnBeforeSerialize start.*/
            OnBeforeSerialize: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#OnBeforeSerialize", this ); }
 },
            /*VirtueSky.Variables.BaseVariable$1.OnBeforeSerialize end.*/

            /*VirtueSky.Variables.BaseVariable$1.OnAfterDeserialize start.*/
            OnAfterDeserialize: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#OnAfterDeserialize", this ); }

                this.runtimeValue = Bridge.rValue(this.initializeValue);
            },
            /*VirtueSky.Variables.BaseVariable$1.OnAfterDeserialize end.*/

            /*VirtueSky.Variables.BaseVariable$1.ResetValue start.*/
            ResetValue: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#ResetValue", this ); }

                this.Value = Bridge.rValue(this.initializeValue);
            },
            /*VirtueSky.Variables.BaseVariable$1.ResetValue end.*/

            /*VirtueSky.Variables.BaseVariable$1.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariable$1#toString", this ); }

                return Bridge.toString(Bridge.rValue(this.Value));
            },
            /*VirtueSky.Variables.BaseVariable$1.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    }; });
    /*VirtueSky.Variables.BaseVariable$1 end.*/

    /*VirtueSky.Audio.PauseSfxEvent start.*/
    Bridge.define("VirtueSky.Audio.PauseSfxEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(VirtueSky.Audio.SoundCache)]
    });
    /*VirtueSky.Audio.PauseSfxEvent end.*/

    /*VirtueSky.Audio.PlayMusicEvent start.*/
    Bridge.define("VirtueSky.Audio.PlayMusicEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(VirtueSky.Audio.SoundData)]
    });
    /*VirtueSky.Audio.PlayMusicEvent end.*/

    /*VirtueSky.Audio.PlaySfxEvent start.*/
    Bridge.define("VirtueSky.Audio.PlaySfxEvent", {
        inherits: [VirtueSky.Events.BaseEvent$2(VirtueSky.Audio.SoundData,VirtueSky.Audio.SoundCache)]
    });
    /*VirtueSky.Audio.PlaySfxEvent end.*/

    /*VirtueSky.Audio.ResumeSfxEvent start.*/
    Bridge.define("VirtueSky.Audio.ResumeSfxEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(VirtueSky.Audio.SoundCache)]
    });
    /*VirtueSky.Audio.ResumeSfxEvent end.*/

    /*VirtueSky.Audio.SoundComponent start.*/
    Bridge.define("VirtueSky.Audio.SoundComponent", {
        inherits: [VirtueSky.Core.CacheComponent$1(UnityEngine.AudioSource)],
        fields: {
            key: 0
        },
        events: {
            OnCompleted: null,
            OnPaused: null,
            OnResumed: null,
            OnStopped: null
        },
        props: {
            GetClip: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#GetClip#get", this ); }

                    return this.component.clip;
                }
            },
            IsPlaying: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#IsPlaying#get", this ); }

                    return this.component.isPlaying;
                }
            },
            IsLooping: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#IsLooping#get", this ); }

                    return this.component.loop;
                }
            },
            Volume: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Volume#get", this ); }

                    return this.component.volume;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Volume#set", this ); }

                    this.component.volume = value;
                }
            },
            Key: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Key#get", this ); }

                    return this.key;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Key#set", this ); }

                    this.key = value;
                }
            }
        },
        methods: {
            /*VirtueSky.Audio.SoundComponent.Awake$1 start.*/
            Awake$1: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Awake$1", this ); }

                this.component.playOnAwake = false;
            },
            /*VirtueSky.Audio.SoundComponent.Awake$1 end.*/

            /*VirtueSky.Audio.SoundComponent.PlayAudioClip start.*/
            PlayAudioClip: function (audioClip, isLooping, volume) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#PlayAudioClip", this ); }

                if (audioClip == null) {
                    UnityEngine.Debug.LogError$2(System.String.format("AudioClip is null", null));
                    return;
                }

                this.component.clip = audioClip;
                this.component.loop = isLooping;
                this.component.volume = volume;
                this.component.time = 0;
                this.component.Play();
                if (!isLooping) {
                    VirtueSky.Core.App.Delay$1(this, audioClip.length, Bridge.fn.cacheBind(this, this.OnCompletedInvoke));
                }
            },
            /*VirtueSky.Audio.SoundComponent.PlayAudioClip end.*/

            /*VirtueSky.Audio.SoundComponent.FadeInVolumeMusic start.*/
            FadeInVolumeMusic: function (audioClip, isLooping, endValue, duration) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#FadeInVolumeMusic", this ); }

                this.PlayAudioClip(audioClip, isLooping, 0);
                DG.Tweening.DOTweenModuleAudio.DOFade(this.component, endValue, duration);
            },
            /*VirtueSky.Audio.SoundComponent.FadeInVolumeMusic end.*/

            /*VirtueSky.Audio.SoundComponent.FadeOutVolumeMusic start.*/
            FadeOutVolumeMusic: function (duration, fadeCompleted) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#FadeOutVolumeMusic", this ); }

                DG.Tweening.TweenSettingsExtensions.OnComplete(DG.Tweening.Core.TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions), DG.Tweening.DOTweenModuleAudio.DOFade(this.component, 0, duration), function () {
                    !Bridge.staticEquals(fadeCompleted, null) ? fadeCompleted() : null;
                });
            },
            /*VirtueSky.Audio.SoundComponent.FadeOutVolumeMusic end.*/

            /*VirtueSky.Audio.SoundComponent.Resume start.*/
            Resume: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Resume", this ); }

                !Bridge.staticEquals(this.OnResumed, null) ? this.OnResumed(this) : null;
                this.component.UnPause();
            },
            /*VirtueSky.Audio.SoundComponent.Resume end.*/

            /*VirtueSky.Audio.SoundComponent.Pause start.*/
            Pause: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Pause", this ); }

                !Bridge.staticEquals(this.OnPaused, null) ? this.OnPaused(this) : null;
                this.component.Pause();
            },
            /*VirtueSky.Audio.SoundComponent.Pause end.*/

            /*VirtueSky.Audio.SoundComponent.Stop start.*/
            Stop: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Stop", this ); }

                !Bridge.staticEquals(this.OnStopped, null) ? this.OnStopped(this) : null;
                this.component.Stop();
            },
            /*VirtueSky.Audio.SoundComponent.Stop end.*/

            /*VirtueSky.Audio.SoundComponent.Finish start.*/
            Finish: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#Finish", this ); }

                if (!this.component.loop) {
                    return;
                }
                this.component.loop = false;
                var remainingTime = this.component.clip.length - this.component.time;
                VirtueSky.Core.App.Delay$1(this, remainingTime, Bridge.fn.cacheBind(this, this.OnCompletedInvoke));
            },
            /*VirtueSky.Audio.SoundComponent.Finish end.*/

            /*VirtueSky.Audio.SoundComponent.FadePlayMusic start.*/
            FadePlayMusic: function (audioClip, isLooping, volume, isMusicFadeVolume, durationOut, durationIn) {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#FadePlayMusic", this ); }

                if (isMusicFadeVolume && volume !== 0) {
                    if (this.component.isPlaying) {
                        this.FadeOutVolumeMusic(durationOut, Bridge.fn.bind(this, function () {
                            this.FadeInVolumeMusic(audioClip, isLooping, volume, durationIn);
                        }));
                    } else {
                        this.FadeInVolumeMusic(audioClip, isLooping, volume, durationIn);
                    }
                } else {
                    this.PlayAudioClip(audioClip, isLooping, volume);
                }
            },
            /*VirtueSky.Audio.SoundComponent.FadePlayMusic end.*/

            /*VirtueSky.Audio.SoundComponent.OnCompletedInvoke start.*/
            OnCompletedInvoke: function () {
if ( TRACE ) { TRACE( "VirtueSky.Audio.SoundComponent#OnCompletedInvoke", this ); }

                !Bridge.staticEquals(this.OnCompleted, null) ? this.OnCompleted(this) : null;
            },
            /*VirtueSky.Audio.SoundComponent.OnCompletedInvoke end.*/


        },
        overloads: {
            "Awake()": "Awake$1"
        }
    });
    /*VirtueSky.Audio.SoundComponent end.*/

    /*VirtueSky.Audio.StopSfxEvent start.*/
    Bridge.define("VirtueSky.Audio.StopSfxEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(VirtueSky.Audio.SoundCache)]
    });
    /*VirtueSky.Audio.StopSfxEvent end.*/

    /*VirtueSky.Component.ResizeCameraOrthographicComponent start.*/
    Bridge.define("VirtueSky.Component.ResizeCameraOrthographicComponent", {
        inherits: [VirtueSky.Core.CacheComponent$1(UnityEngine.Camera)],
        fields: {
            ratio: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.ResizeCameraOrthographicComponent#init", this ); }

                this.ratio = new UnityEngine.Vector2();
                this.ratio = new pc.Vec2( 9, 16 );
            }
        },
        methods: {
            /*VirtueSky.Component.ResizeCameraOrthographicComponent.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.ResizeCameraOrthographicComponent#Awake", this ); }

                VirtueSky.Core.CacheComponent$1(UnityEngine.Camera).prototype.Awake.call(this);
                var sizeStart = this.component.orthographicSize;
                var size = this.component.orthographicSize * this.ratio.x / (this.ratio.y * this.component.aspect);
                if (size > sizeStart) {
                    this.component.orthographicSize = size;
                }
            },
            /*VirtueSky.Component.ResizeCameraOrthographicComponent.Awake end.*/


        }
    });
    /*VirtueSky.Component.ResizeCameraOrthographicComponent end.*/

    /*VirtueSky.Component.ResizeMatchCanvasScalerComponent start.*/
    Bridge.define("VirtueSky.Component.ResizeMatchCanvasScalerComponent", {
        inherits: [VirtueSky.Core.CacheComponent$1(UnityEngine.UI.CanvasScaler)],
        fields: {
            aspectRatio: 0,
            canvas: null,
            camera: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.ResizeMatchCanvasScalerComponent#init", this ); }

                this.aspectRatio = 0.6;
            }
        },
        methods: {
            /*VirtueSky.Component.ResizeMatchCanvasScalerComponent.Awake start.*/
            Awake: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.ResizeMatchCanvasScalerComponent#Awake", this ); }

                VirtueSky.Core.CacheComponent$1(UnityEngine.UI.CanvasScaler).prototype.Awake.call(this);
                this.GetCanvas();
                if (UnityEngine.Component.op_Inequality(this.camera, null)) {
                    this.component.matchWidthOrHeight = this.camera.aspect > this.aspectRatio ? 1 : 0;
                }
            },
            /*VirtueSky.Component.ResizeMatchCanvasScalerComponent.Awake end.*/

            /*VirtueSky.Component.ResizeMatchCanvasScalerComponent.GetCanvas start.*/
            GetCanvas: function () {
if ( TRACE ) { TRACE( "VirtueSky.Component.ResizeMatchCanvasScalerComponent#GetCanvas", this ); }

                if (UnityEngine.Component.op_Equality(this.canvas, null)) {
                    this.canvas = this.GetComponent(UnityEngine.Canvas);
                    if (UnityEngine.Object.op_Implicit(this.canvas.worldCamera)) {
                        this.camera = this.canvas.worldCamera;
                    }
                }
            },
            /*VirtueSky.Component.ResizeMatchCanvasScalerComponent.GetCanvas end.*/


        }
    });
    /*VirtueSky.Component.ResizeMatchCanvasScalerComponent end.*/

    /*VirtueSky.Events.BaseEventListener$2 start.*/
    Bridge.define("VirtueSky.Events.BaseEventListener$2", function (TEvent, TResponse) { return {
        inherits: [VirtueSky.Events.EventListenerMono,VirtueSky.Events.IEventListener],
        fields: {
            listEventResponseDatas: null,
            _dictionary: null
        },
        alias: ["OnEventRaised", "VirtueSky$Events$IEventListener$OnEventRaised"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$2#init", this ); }

                this._dictionary = new (System.Collections.Generic.Dictionary$2(VirtueSky.Events.BaseEvent,UnityEngine.Events.UnityEvent)).ctor();
            }
        },
        methods: {
            /*VirtueSky.Events.BaseEventListener$2.ToggleListenerEvent start.*/
            ToggleListenerEvent: function (isListenerEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$2#ToggleListenerEvent", this ); }

                var $t, $t1;
                if (isListenerEvent) {
                    $t = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
Bridge.rValue(                            t.event).AddListener$1(this);
                            System.Collections.Generic.CollectionExtensions.TryAdd(VirtueSky.Events.BaseEvent, UnityEngine.Events.UnityEvent, this._dictionary, Bridge.rValue(t.event), Bridge.rValue(t.response));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                } else {
                    $t1 = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t1.moveNext()) {
                            var t1 = $t1.Current;
Bridge.rValue(                            t1.event).RemoveListener$1(this);
                            if (this._dictionary.containsKey(Bridge.rValue(t1.event))) {
                                this._dictionary.remove(Bridge.rValue(t1.event));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*VirtueSky.Events.BaseEventListener$2.ToggleListenerEvent end.*/

            /*VirtueSky.Events.BaseEventListener$2.OnEventRaised start.*/
            OnEventRaised: function (eventRaise) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$2#OnEventRaised", this ); }

                var $t;
                ($t = this._dictionary.getItem(eventRaise)) != null ? $t.Invoke() : null;
            },
            /*VirtueSky.Events.BaseEventListener$2.OnEventRaised end.*/


        }
    }; });
    /*VirtueSky.Events.BaseEventListener$2 end.*/

    /*VirtueSky.Events.BaseEventListener$2+EventResponseData start.*/
    Bridge.define("VirtueSky.Events.BaseEventListener$2.EventResponseData", function (TEvent, TResponse) { return {
        $kind: 1002,
        fields: {
            event: Bridge.getDefaultValue(TEvent),
            response: Bridge.getDefaultValue(TResponse)
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$2.EventResponseData#init", this ); }

                this.event = Bridge.getDefaultValue(TEvent);
                this.response = Bridge.getDefaultValue(TResponse);
            }
        }
    }; });
    /*VirtueSky.Events.BaseEventListener$2+EventResponseData end.*/

    /*VirtueSky.Events.BaseEventListener$3 start.*/
    Bridge.define("VirtueSky.Events.BaseEventListener$3", function (TType, TEvent, TResponse) { return {
        inherits: [VirtueSky.Events.EventListenerMono,VirtueSky.Events.IEventListener$1(TType)],
        fields: {
            listEventResponseDatas: null,
            _dictionary: null
        },
        alias: ["OnEventRaised", "VirtueSky$Events$IEventListener$1$" + Bridge.getTypeAlias(TType) + "$OnEventRaised"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$3#init", this ); }

                this._dictionary = new (System.Collections.Generic.Dictionary$2(VirtueSky.Events.BaseEvent$1(TType),UnityEngine.Events.UnityEvent$1(TType))).ctor();
            }
        },
        methods: {
            /*VirtueSky.Events.BaseEventListener$3.ToggleListenerEvent start.*/
            ToggleListenerEvent: function (isListenerEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$3#ToggleListenerEvent", this ); }

                var $t, $t1;
                if (isListenerEvent) {
                    $t = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
Bridge.rValue(                            t.event).AddListener(this);
                            System.Collections.Generic.CollectionExtensions.TryAdd(VirtueSky.Events.BaseEvent$1(TType), UnityEngine.Events.UnityEvent$1(TType), this._dictionary, Bridge.rValue(t.event), Bridge.rValue(t.response));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                } else {
                    $t1 = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t1.moveNext()) {
                            var t1 = $t1.Current;
Bridge.rValue(                            t1.event).RemoveListener(this);
                            if (this._dictionary.containsKey(Bridge.rValue(t1.event))) {
                                this._dictionary.remove(Bridge.rValue(t1.event));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*VirtueSky.Events.BaseEventListener$3.ToggleListenerEvent end.*/

            /*VirtueSky.Events.BaseEventListener$3.OnEventRaised start.*/
            OnEventRaised: function (eventRaise, value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$3#OnEventRaised", this ); }

                var $t;
                ($t = this._dictionary.getItem(eventRaise)) != null ? $t.Invoke(Bridge.rValue(value)) : null;
            },
            /*VirtueSky.Events.BaseEventListener$3.OnEventRaised end.*/


        }
    }; });
    /*VirtueSky.Events.BaseEventListener$3 end.*/

    /*VirtueSky.Events.BaseEventListener$3+EventResponseData start.*/
    Bridge.define("VirtueSky.Events.BaseEventListener$3.EventResponseData", function (TType, TEvent, TResponse) { return {
        $kind: 1002,
        fields: {
            event: Bridge.getDefaultValue(TEvent),
            response: Bridge.getDefaultValue(TResponse)
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$3.EventResponseData#init", this ); }

                this.event = Bridge.getDefaultValue(TEvent);
                this.response = Bridge.getDefaultValue(TResponse);
            }
        }
    }; });
    /*VirtueSky.Events.BaseEventListener$3+EventResponseData end.*/

    /*VirtueSky.Events.BaseEventListener$4 start.*/
    Bridge.define("VirtueSky.Events.BaseEventListener$4", function (TType, TResult, TEvent, TResponse) { return {
        inherits: [VirtueSky.Events.EventListenerMono,VirtueSky.Events.IEventListener$2(TType,TResult)],
        fields: {
            listEventResponseDatas: null,
            _dictionary: null
        },
        alias: ["OnEventRaised", "VirtueSky$Events$IEventListener$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$OnEventRaised"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$4#init", this ); }

                this._dictionary = new (System.Collections.Generic.Dictionary$2(VirtueSky.Events.BaseEvent$2(TType,TResult),UnityEngine.Events.UnityEvent$1(TType))).ctor();
            }
        },
        methods: {
            /*VirtueSky.Events.BaseEventListener$4.OnEventRaised start.*/
            OnEventRaised: function (eventRaise, value) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$4#OnEventRaised", this ); }

                var $t;
                ($t = this._dictionary.getItem(eventRaise)) != null ? $t.Invoke(Bridge.rValue(value)) : null;
            },
            /*VirtueSky.Events.BaseEventListener$4.OnEventRaised end.*/

            /*VirtueSky.Events.BaseEventListener$4.ToggleListenerEvent start.*/
            ToggleListenerEvent: function (isListenerEvent) {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$4#ToggleListenerEvent", this ); }

                var $t, $t1;
                if (isListenerEvent) {
                    $t = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
Bridge.rValue(                            t.event).AddListener(this);
                            System.Collections.Generic.CollectionExtensions.TryAdd(VirtueSky.Events.BaseEvent$2(TType,TResult), UnityEngine.Events.UnityEvent$1(TType), this._dictionary, Bridge.rValue(t.event), Bridge.rValue(t.response));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                } else {
                    $t1 = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t1.moveNext()) {
                            var t1 = $t1.Current;
Bridge.rValue(                            t1.event).RemoveListener(this);
                            if (this._dictionary.containsKey(Bridge.rValue(t1.event))) {
                                this._dictionary.remove(Bridge.rValue(t1.event));
                            }
                        }
                    } finally {
                        if (Bridge.is($t1, System.IDisposable)) {
                            $t1.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*VirtueSky.Events.BaseEventListener$4.ToggleListenerEvent end.*/


        }
    }; });
    /*VirtueSky.Events.BaseEventListener$4 end.*/

    /*VirtueSky.Events.BaseEventListener$4+EventResponseData start.*/
    Bridge.define("VirtueSky.Events.BaseEventListener$4.EventResponseData", function (TType, TResult, TEvent, TResponse) { return {
        $kind: 1002,
        fields: {
            event: Bridge.getDefaultValue(TEvent),
            response: Bridge.getDefaultValue(TResponse)
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Events.BaseEventListener$4.EventResponseData#init", this ); }

                this.event = Bridge.getDefaultValue(TEvent);
                this.response = Bridge.getDefaultValue(TResponse);
            }
        }
    }; });
    /*VirtueSky.Events.BaseEventListener$4+EventResponseData end.*/

    /*VirtueSky.Events.BooleanEvent start.*/
    Bridge.define("VirtueSky.Events.BooleanEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(System.Boolean)]
    });
    /*VirtueSky.Events.BooleanEvent end.*/

    /*VirtueSky.Events.BoolEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,System.Boolean)]
    });
    /*VirtueSky.Events.BoolEventBoolResult end.*/

    /*VirtueSky.Events.BoolEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,System.Single)]
    });
    /*VirtueSky.Events.BoolEventFloatResult end.*/

    /*VirtueSky.Events.BoolEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.BoolEventGameObjectResult end.*/

    /*VirtueSky.Events.BoolEventIntResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,System.Int32)]
    });
    /*VirtueSky.Events.BoolEventIntResult end.*/

    /*VirtueSky.Events.BoolEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,System.Object)]
    });
    /*VirtueSky.Events.BoolEventObjectResult end.*/

    /*VirtueSky.Events.BoolEventStringResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,System.String)]
    });
    /*VirtueSky.Events.BoolEventStringResult end.*/

    /*VirtueSky.Events.BoolEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.BoolEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.BoolEventTransformResult end.*/

    /*VirtueSky.Events.BoolEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.BoolEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Boolean,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.BoolEventVector3Result end.*/

    /*VirtueSky.Events.DictionaryEvent start.*/
    Bridge.define("VirtueSky.Events.DictionaryEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(System.Collections.Generic.Dictionary$2(System.String,System.Object))]
    });
    /*VirtueSky.Events.DictionaryEvent end.*/

    /*VirtueSky.Events.EventNoParamBoolResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamBoolResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(System.Boolean)]
    });
    /*VirtueSky.Events.EventNoParamBoolResult end.*/

    /*VirtueSky.Events.EventNoParamFloatResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamFloatResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(System.Single)]
    });
    /*VirtueSky.Events.EventNoParamFloatResult end.*/

    /*VirtueSky.Events.EventNoParamGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamGameObjectResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.EventNoParamGameObjectResult end.*/

    /*VirtueSky.Events.EventNoParamIntResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamIntResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(System.Int32)]
    });
    /*VirtueSky.Events.EventNoParamIntResult end.*/

    /*VirtueSky.Events.EventNoParamObjectResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamObjectResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(System.Object)]
    });
    /*VirtueSky.Events.EventNoParamObjectResult end.*/

    /*VirtueSky.Events.EventNoParamStringResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamStringResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(System.String)]
    });
    /*VirtueSky.Events.EventNoParamStringResult end.*/

    /*VirtueSky.Events.EventNoParamTransformResult start.*/
    Bridge.define("VirtueSky.Events.EventNoParamTransformResult", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(UnityEngine.Transform)]
    });
    /*VirtueSky.Events.EventNoParamTransformResult end.*/

    /*VirtueSky.Events.EventNoParamVector3Result start.*/
    Bridge.define("VirtueSky.Events.EventNoParamVector3Result", {
        inherits: [VirtueSky.Events.EventNoParamResult$1(UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.EventNoParamVector3Result end.*/

    /*VirtueSky.Events.FloatEvent start.*/
    Bridge.define("VirtueSky.Events.FloatEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(System.Single)]
    });
    /*VirtueSky.Events.FloatEvent end.*/

    /*VirtueSky.Events.FloatEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,System.Boolean)]
    });
    /*VirtueSky.Events.FloatEventBoolResult end.*/

    /*VirtueSky.Events.FloatEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,System.Single)]
    });
    /*VirtueSky.Events.FloatEventFloatResult end.*/

    /*VirtueSky.Events.FloatEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.FloatEventGameObjectResult end.*/

    /*VirtueSky.Events.FloatEventIntResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,System.Int32)]
    });
    /*VirtueSky.Events.FloatEventIntResult end.*/

    /*VirtueSky.Events.FloatEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,System.Object)]
    });
    /*VirtueSky.Events.FloatEventObjectResult end.*/

    /*VirtueSky.Events.FloatEventStringResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,System.String)]
    });
    /*VirtueSky.Events.FloatEventStringResult end.*/

    /*VirtueSky.Events.FloatEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.FloatEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.FloatEventTransformResult end.*/

    /*VirtueSky.Events.FloatEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.FloatEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Single,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.FloatEventVector3Result end.*/

    /*VirtueSky.Events.GameObjectEvent start.*/
    Bridge.define("VirtueSky.Events.GameObjectEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.GameObjectEvent end.*/

    /*VirtueSky.Events.GameObjectEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,System.Boolean)]
    });
    /*VirtueSky.Events.GameObjectEventBoolResult end.*/

    /*VirtueSky.Events.GameObjectEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,System.Single)]
    });
    /*VirtueSky.Events.GameObjectEventFloatResult end.*/

    /*VirtueSky.Events.GameObjectEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.GameObjectEventGameObjectResult end.*/

    /*VirtueSky.Events.GameObjectEventIntResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,System.Int32)]
    });
    /*VirtueSky.Events.GameObjectEventIntResult end.*/

    /*VirtueSky.Events.GameObjectEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,System.Object)]
    });
    /*VirtueSky.Events.GameObjectEventObjectResult end.*/

    /*VirtueSky.Events.GameObjectEventStringResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,System.String)]
    });
    /*VirtueSky.Events.GameObjectEventStringResult end.*/

    /*VirtueSky.Events.GameObjectEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.GameObjectEventTransformResult end.*/

    /*VirtueSky.Events.GameObjectEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.GameObject,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.GameObjectEventVector3Result end.*/

    /*VirtueSky.Events.IntegerEvent start.*/
    Bridge.define("VirtueSky.Events.IntegerEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(System.Int32)]
    });
    /*VirtueSky.Events.IntegerEvent end.*/

    /*VirtueSky.Events.IntEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.IntEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,System.Boolean)]
    });
    /*VirtueSky.Events.IntEventBoolResult end.*/

    /*VirtueSky.Events.IntEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.IntEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,System.Single)]
    });
    /*VirtueSky.Events.IntEventFloatResult end.*/

    /*VirtueSky.Events.IntEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.IntEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.IntEventGameObjectResult end.*/

    /*VirtueSky.Events.IntEventIntResult start.*/
    Bridge.define("VirtueSky.Events.IntEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,System.Int32)]
    });
    /*VirtueSky.Events.IntEventIntResult end.*/

    /*VirtueSky.Events.IntEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.IntEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,System.Object)]
    });
    /*VirtueSky.Events.IntEventObjectResult end.*/

    /*VirtueSky.Events.IntEventStringResult start.*/
    Bridge.define("VirtueSky.Events.IntEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,System.String)]
    });
    /*VirtueSky.Events.IntEventStringResult end.*/

    /*VirtueSky.Events.IntEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.IntEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.IntEventTransformResult end.*/

    /*VirtueSky.Events.IntEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.IntEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Int32,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.IntEventVector3Result end.*/

    /*VirtueSky.Events.ObjectEvent start.*/
    Bridge.define("VirtueSky.Events.ObjectEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(UnityEngine.Object)]
    });
    /*VirtueSky.Events.ObjectEvent end.*/

    /*VirtueSky.Events.ObjectEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,System.Boolean)]
    });
    /*VirtueSky.Events.ObjectEventBoolResult end.*/

    /*VirtueSky.Events.ObjectEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,System.Single)]
    });
    /*VirtueSky.Events.ObjectEventFloatResult end.*/

    /*VirtueSky.Events.ObjectEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.ObjectEventGameObjectResult end.*/

    /*VirtueSky.Events.ObjectEventIntResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,System.Int32)]
    });
    /*VirtueSky.Events.ObjectEventIntResult end.*/

    /*VirtueSky.Events.ObjectEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,System.Object)]
    });
    /*VirtueSky.Events.ObjectEventObjectResult end.*/

    /*VirtueSky.Events.ObjectEventStringResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,System.String)]
    });
    /*VirtueSky.Events.ObjectEventStringResult end.*/

    /*VirtueSky.Events.ObjectEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.ObjectEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.ObjectEventTransformResult end.*/

    /*VirtueSky.Events.ObjectEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.ObjectEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.Object,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.ObjectEventVector3Result end.*/

    /*VirtueSky.Events.ShortDoubleEvent start.*/
    Bridge.define("VirtueSky.Events.ShortDoubleEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(VirtueSky.DataType.ShortDouble)]
    });
    /*VirtueSky.Events.ShortDoubleEvent end.*/

    /*VirtueSky.Events.StringEvent start.*/
    Bridge.define("VirtueSky.Events.StringEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(System.String)]
    });
    /*VirtueSky.Events.StringEvent end.*/

    /*VirtueSky.Events.StringEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.StringEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,System.Boolean)]
    });
    /*VirtueSky.Events.StringEventBoolResult end.*/

    /*VirtueSky.Events.StringEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.StringEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,System.Single)]
    });
    /*VirtueSky.Events.StringEventFloatResult end.*/

    /*VirtueSky.Events.StringEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.StringEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.StringEventGameObjectResult end.*/

    /*VirtueSky.Events.StringEventIntResult start.*/
    Bridge.define("VirtueSky.Events.StringEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,System.Int32)]
    });
    /*VirtueSky.Events.StringEventIntResult end.*/

    /*VirtueSky.Events.StringEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.StringEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,System.Object)]
    });
    /*VirtueSky.Events.StringEventObjectResult end.*/

    /*VirtueSky.Events.StringEventStringResult start.*/
    Bridge.define("VirtueSky.Events.StringEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,System.String)]
    });
    /*VirtueSky.Events.StringEventStringResult end.*/

    /*VirtueSky.Events.StringEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.StringEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.StringEventTransformResult end.*/

    /*VirtueSky.Events.StringEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.StringEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(System.String,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.StringEventVector3Result end.*/

    /*VirtueSky.Events.TransformEvent start.*/
    Bridge.define("VirtueSky.Events.TransformEvent", {
        inherits: [VirtueSky.Events.BaseEvent$1(UnityEngine.Transform)]
    });
    /*VirtueSky.Events.TransformEvent end.*/

    /*VirtueSky.Events.TransformEventBoolResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,System.Boolean)]
    });
    /*VirtueSky.Events.TransformEventBoolResult end.*/

    /*VirtueSky.Events.TransformEventFloatResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,System.Single)]
    });
    /*VirtueSky.Events.TransformEventFloatResult end.*/

    /*VirtueSky.Events.TransformEventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.TransformEventGameObjectResult end.*/

    /*VirtueSky.Events.TransformEventIntResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,System.Int32)]
    });
    /*VirtueSky.Events.TransformEventIntResult end.*/

    /*VirtueSky.Events.TransformEventObjectResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,System.Object)]
    });
    /*VirtueSky.Events.TransformEventObjectResult end.*/

    /*VirtueSky.Events.TransformEventStringResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,System.String)]
    });
    /*VirtueSky.Events.TransformEventStringResult end.*/

    /*VirtueSky.Events.TransformEventTransformResult start.*/
    Bridge.define("VirtueSky.Events.TransformEventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.TransformEventTransformResult end.*/

    /*VirtueSky.Events.TransformEventVector3Result start.*/
    Bridge.define("VirtueSky.Events.TransformEventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Transform,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.TransformEventVector3Result end.*/

    /*VirtueSky.Events.Vector3Event start.*/
    Bridge.define("VirtueSky.Events.Vector3Event", {
        inherits: [VirtueSky.Events.BaseEvent$1(UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.Vector3Event end.*/

    /*VirtueSky.Events.Vector3EventBoolResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventBoolResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,System.Boolean)]
    });
    /*VirtueSky.Events.Vector3EventBoolResult end.*/

    /*VirtueSky.Events.Vector3EventFloatResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventFloatResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,System.Single)]
    });
    /*VirtueSky.Events.Vector3EventFloatResult end.*/

    /*VirtueSky.Events.Vector3EventGameObjectResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventGameObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.Vector3EventGameObjectResult end.*/

    /*VirtueSky.Events.Vector3EventIntResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventIntResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,System.Int32)]
    });
    /*VirtueSky.Events.Vector3EventIntResult end.*/

    /*VirtueSky.Events.Vector3EventObjectResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventObjectResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,System.Object)]
    });
    /*VirtueSky.Events.Vector3EventObjectResult end.*/

    /*VirtueSky.Events.Vector3EventStringResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventStringResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,System.String)]
    });
    /*VirtueSky.Events.Vector3EventStringResult end.*/

    /*VirtueSky.Events.Vector3EventTransformResult start.*/
    Bridge.define("VirtueSky.Events.Vector3EventTransformResult", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,UnityEngine.Transform)]
    });
    /*VirtueSky.Events.Vector3EventTransformResult end.*/

    /*VirtueSky.Events.Vector3EventVector3Result start.*/
    Bridge.define("VirtueSky.Events.Vector3EventVector3Result", {
        inherits: [VirtueSky.Events.BaseEvent$2(UnityEngine.Vector3,UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.Vector3EventVector3Result end.*/

    /*Wall start.*/
    Bridge.define("Wall", {
        inherits: [ObjectBase],
        fields: {
            isAutoSize: false,
            sizeOrigin: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "Wall#init", this ); }

                this.sizeOrigin = new UnityEngine.Vector3();
                this.sizeOrigin = new pc.Vec3( 1, 1, 1 );
            }
        },
        methods: {
            /*Wall.AutoSize start.*/
            AutoSize: function () {
if ( TRACE ) { TRACE( "Wall#AutoSize", this ); }

                if (this.isAutoSize) {
                    var height = this.size.z;
                    var render = UnityEngine.Component.op_Equality(this.Renderer, null) ? this.model.GetComponentInChildren(UnityEngine.Renderer) : this.Renderer;
                    switch (render.transform.localEulerAngles.y) {
                        case 90: 
                            height = this.size.x;
                            break;
                        case 270: 
                            height = this.size.x;
                            break;
                        default: 
                            height = this.size.z;
                            break;
                    }
                    render.transform.localScale = new pc.Vec3( render.transform.localScale.x, render.transform.localScale.y, height / this.sizeOrigin.z );
                }
            },
            /*Wall.AutoSize end.*/


        }
    });
    /*Wall end.*/

    /*TheBeginning.UI.SettingPopupInGame start.*/
    Bridge.define("TheBeginning.UI.SettingPopupInGame", {
        inherits: [TheBeginning.UI.SettingPopup]
    });
    /*TheBeginning.UI.SettingPopupInGame end.*/

    /*VirtueSky.Variables.FloatVariable start.*/
    Bridge.define("VirtueSky.Variables.FloatVariable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(System.Single)],
        fields: {
            isClamped: false,
            minMax: null
        },
        props: {
            IsClamped: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#IsClamped#get", this ); }

                    return this.isClamped;
                }
            },
            MinMax: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#MinMax#get", this ); }

                    return this.minMax.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#MinMax#set", this ); }

                    this.minMax = value.$clone();
                }
            },
            Min: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Min#get", this ); }

                    return this.minMax.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Min#set", this ); }

                    this.minMax.x = value;
                }
            },
            Max: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Max#get", this ); }

                    return this.minMax.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Max#set", this ); }

                    this.minMax.y = value;
                }
            },
            Value: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Value#get", this ); }

                    return this.isSetData ? VirtueSky.DataStorage.GameData.Get(System.Single, this.Id, this.initializeValue) : this.runtimeValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Value#set", this ); }

                    var clampedValue = this.IsClamped ? Math.max(this.minMax.x, Math.min(value, this.minMax.y)) : value;
                    if (this.isSetData) {
                        VirtueSky.DataStorage.GameData.Set(System.Single, this.Id, clampedValue);
                        if (this.isSaveData) {
                            VirtueSky.DataStorage.GameData.Save();
                        }
                    } else {
                        this.runtimeValue = clampedValue;
                    }

                    if (this.isRaiseEvent) {
                        this.Raise(clampedValue);
                    }
                }
            }
        },
        alias: ["Value", "VirtueSky$Variables$IVariable$1$System$Single$Value"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#init", this ); }

                this.minMax = new UnityEngine.Vector2();
                this.minMax = new pc.Vec2( 0, 100 );
            }
        },
        methods: {
            /*VirtueSky.Variables.FloatVariable.Add start.*/
            Add: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.FloatVariable#Add", this ); }

                this.Value += value;
            },
            /*VirtueSky.Variables.FloatVariable.Add end.*/


        }
    });
    /*VirtueSky.Variables.FloatVariable end.*/

    /*VirtueSky.Events.EventNoParam start.*/
    Bridge.define("VirtueSky.Events.EventNoParam", {
        inherits: [VirtueSky.Events.BaseEvent]
    });
    /*VirtueSky.Events.EventNoParam end.*/

    /*VirtueSky.Events.BooleanEventResponse start.*/
    Bridge.define("VirtueSky.Events.BooleanEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(System.Boolean)]
    });
    /*VirtueSky.Events.BooleanEventResponse end.*/

    /*VirtueSky.Events.DictionaryEventResponse start.*/
    Bridge.define("VirtueSky.Events.DictionaryEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(System.Collections.Generic.Dictionary$2(System.String,System.Object))]
    });
    /*VirtueSky.Events.DictionaryEventResponse end.*/

    /*VirtueSky.Events.FloatEventResponse start.*/
    Bridge.define("VirtueSky.Events.FloatEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(System.Single)]
    });
    /*VirtueSky.Events.FloatEventResponse end.*/

    /*VirtueSky.Events.GameObjectEventResponse start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(UnityEngine.GameObject)]
    });
    /*VirtueSky.Events.GameObjectEventResponse end.*/

    /*VirtueSky.Events.IntegerEventResponse start.*/
    Bridge.define("VirtueSky.Events.IntegerEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(System.Int32)]
    });
    /*VirtueSky.Events.IntegerEventResponse end.*/

    /*VirtueSky.Events.ObjectEventResponse start.*/
    Bridge.define("VirtueSky.Events.ObjectEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(UnityEngine.Object)]
    });
    /*VirtueSky.Events.ObjectEventResponse end.*/

    /*VirtueSky.Events.ShortDoubleEventResponse start.*/
    Bridge.define("VirtueSky.Events.ShortDoubleEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(VirtueSky.DataType.ShortDouble)]
    });
    /*VirtueSky.Events.ShortDoubleEventResponse end.*/

    /*VirtueSky.Events.StringEventResponse start.*/
    Bridge.define("VirtueSky.Events.StringEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(System.String)]
    });
    /*VirtueSky.Events.StringEventResponse end.*/

    /*VirtueSky.Events.TransformEventResponse start.*/
    Bridge.define("VirtueSky.Events.TransformEventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(UnityEngine.Transform)]
    });
    /*VirtueSky.Events.TransformEventResponse end.*/

    /*VirtueSky.Events.Vector3EventResponse start.*/
    Bridge.define("VirtueSky.Events.Vector3EventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse$1(UnityEngine.Vector3)]
    });
    /*VirtueSky.Events.Vector3EventResponse end.*/

    /*VirtueSky.TouchInput.InputEventTouchBegin start.*/
    Bridge.define("VirtueSky.TouchInput.InputEventTouchBegin", {
        inherits: [VirtueSky.Events.Vector3Event]
    });
    /*VirtueSky.TouchInput.InputEventTouchBegin end.*/

    /*VirtueSky.TouchInput.InputEventTouchCancel start.*/
    Bridge.define("VirtueSky.TouchInput.InputEventTouchCancel", {
        inherits: [VirtueSky.Events.Vector3Event]
    });
    /*VirtueSky.TouchInput.InputEventTouchCancel end.*/

    /*VirtueSky.TouchInput.InputEventTouchEnd start.*/
    Bridge.define("VirtueSky.TouchInput.InputEventTouchEnd", {
        inherits: [VirtueSky.Events.Vector3Event]
    });
    /*VirtueSky.TouchInput.InputEventTouchEnd end.*/

    /*VirtueSky.TouchInput.InputEventTouchMove start.*/
    Bridge.define("VirtueSky.TouchInput.InputEventTouchMove", {
        inherits: [VirtueSky.Events.Vector3Event]
    });
    /*VirtueSky.TouchInput.InputEventTouchMove end.*/

    /*VirtueSky.TouchInput.InputEventTouchStationary start.*/
    Bridge.define("VirtueSky.TouchInput.InputEventTouchStationary", {
        inherits: [VirtueSky.Events.Vector3Event]
    });
    /*VirtueSky.TouchInput.InputEventTouchStationary end.*/

    /*VirtueSky.Variables.BooleanVariable start.*/
    Bridge.define("VirtueSky.Variables.BooleanVariable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(System.Boolean)],
        methods: {
            /*VirtueSky.Variables.BooleanVariable.Toggle start.*/
            Toggle: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BooleanVariable#Toggle", this ); }

                this.Value = !this.Value;
            },
            /*VirtueSky.Variables.BooleanVariable.Toggle end.*/


        }
    });
    /*VirtueSky.Variables.BooleanVariable end.*/

    /*VirtueSky.Variables.BaseReference$2 start.*/
    Bridge.define("VirtueSky.Variables.BaseReference$2", function (TType, TVariable) { return {
        inherits: [VirtueSky.Variables.BaseReference,VirtueSky.Variables.IReference$2(TType,TVariable)],
        fields: {
            useVariable: false,
            constantValue: Bridge.getDefaultValue(TType),
            variable: Bridge.getDefaultValue(TVariable)
        },
        props: {
            Value: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseReference$2#Value#get", this ); }

                    return this.useVariable ? Bridge.rValue(Bridge.rValue(this.variable).Value) : Bridge.rValue(this.constantValue);
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseReference$2#Value#set", this ); }

                    if (this.useVariable) {
Bridge.rValue(                        this.variable).Value = Bridge.rValue(value);
                    } else {
                        this.constantValue = Bridge.rValue(value);
                    }
                }
            }
        },
        alias: ["Value", "VirtueSky$Variables$IReference$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TVariable) + "$Value"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseReference$2#init", this ); }

                this.constantValue = Bridge.getDefaultValue(TType);
                this.variable = Bridge.getDefaultValue(TVariable);
            }
        },
        methods: {
            /*VirtueSky.Variables.BaseReference$2.toString start.*/
            toString: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseReference$2#toString", this ); }

                return Bridge.toString(Bridge.rValue(this.Value));
            },
            /*VirtueSky.Variables.BaseReference$2.toString end.*/


        },
        overloads: {
            "ToString()": "toString"
        }
    }; });
    /*VirtueSky.Variables.BaseReference$2 end.*/

    /*VirtueSky.Variables.BaseVariableListener$3 start.*/
    Bridge.define("VirtueSky.Variables.BaseVariableListener$3", function (TType, TEvent, TResponse) { return {
        inherits: [VirtueSky.Events.BaseEventListener$3(TType,TEvent,TResponse)],
        fields: {
            isRaisedOnStart: false,
            isRaisedOnEnable: false
        },
        methods: {
            /*VirtueSky.Variables.BaseVariableListener$3.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariableListener$3#Start", this ); }

                var $t;
                if (this.isRaisedOnStart) {
                    $t = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            this.OnEventRaised(Bridge.rValue(t.event), Bridge.rValue(Bridge.rValue(t.event).Value));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*VirtueSky.Variables.BaseVariableListener$3.Start end.*/

            /*VirtueSky.Variables.BaseVariableListener$3.OnEnable$1 start.*/
            OnEnable$1: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.BaseVariableListener$3#OnEnable$1", this ); }

                var $t;
                if (this.isRaisedOnEnable) {
                    $t = Bridge.getEnumerator(this.listEventResponseDatas);
                    try {
                        while ($t.moveNext()) {
                            var t = $t.Current;
                            this.OnEventRaised(Bridge.rValue(t.event), Bridge.rValue(Bridge.rValue(t.event).Value));
                        }
                    } finally {
                        if (Bridge.is($t, System.IDisposable)) {
                            $t.System$IDisposable$Dispose();
                        }
                    }
                }
            },
            /*VirtueSky.Variables.BaseVariableListener$3.OnEnable$1 end.*/


        },
        overloads: {
            "OnEnable()": "OnEnable$1"
        }
    }; });
    /*VirtueSky.Variables.BaseVariableListener$3 end.*/

    /*VirtueSky.Variables.IntegerVariable start.*/
    Bridge.define("VirtueSky.Variables.IntegerVariable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(System.Int32)],
        fields: {
            isClamped: false,
            minMax: null
        },
        props: {
            IsClamped: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#IsClamped#get", this ); }

                    return this.isClamped;
                }
            },
            MinMax: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#MinMax#get", this ); }

                    return this.minMax.$clone();
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#MinMax#set", this ); }

                    this.minMax = value.$clone();
                }
            },
            Min: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Min#get", this ); }

                    return this.minMax.x;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Min#set", this ); }

                    this.minMax.x = value;
                }
            },
            Max: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Max#get", this ); }

                    return this.minMax.y;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Max#set", this ); }

                    this.minMax.y = value;
                }
            },
            Value: {
                get: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Value#get", this ); }

                    return this.isSetData ? VirtueSky.DataStorage.GameData.Get(System.Int32, this.Id, this.initializeValue) : this.runtimeValue;
                },
                set: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Value#set", this ); }

                    var clampedValue = this.IsClamped ? Math.max(this.minMax.x, Math.min(value, this.minMax.y)) : value;
                    if (this.isSetData) {
                        VirtueSky.DataStorage.GameData.Set(System.Int32, this.Id, clampedValue);
                        if (this.isSaveData) {
                            VirtueSky.DataStorage.GameData.Save();
                        }
                    } else {
                        this.runtimeValue = clampedValue;
                    }

                    if (this.isRaiseEvent) {
                        this.Raise(clampedValue);
                    }
                }
            }
        },
        alias: ["Value", "VirtueSky$Variables$IVariable$1$System$Int32$Value"],
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#init", this ); }

                this.minMax = new UnityEngine.Vector2Int();
                this.minMax = new UnityEngine.Vector2Int.$ctor1(0, 100);
            }
        },
        methods: {
            /*VirtueSky.Variables.IntegerVariable.Add start.*/
            Add: function (value) {
if ( TRACE ) { TRACE( "VirtueSky.Variables.IntegerVariable#Add", this ); }

                this.Value = (this.Value + value) | 0;
            },
            /*VirtueSky.Variables.IntegerVariable.Add end.*/


        }
    });
    /*VirtueSky.Variables.IntegerVariable end.*/

    /*VirtueSky.Variables.ObjectVariable start.*/
    Bridge.define("VirtueSky.Variables.ObjectVariable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(UnityEngine.Object)]
    });
    /*VirtueSky.Variables.ObjectVariable end.*/

    /*VirtueSky.Variables.ShortDoubleVariable start.*/
    Bridge.define("VirtueSky.Variables.ShortDoubleVariable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(VirtueSky.DataType.ShortDouble)]
    });
    /*VirtueSky.Variables.ShortDoubleVariable end.*/

    /*VirtueSky.Variables.StringVariable start.*/
    Bridge.define("VirtueSky.Variables.StringVariable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(System.String)]
    });
    /*VirtueSky.Variables.StringVariable end.*/

    /*VirtueSky.Variables.Vector3Variable start.*/
    Bridge.define("VirtueSky.Variables.Vector3Variable", {
        inherits: [VirtueSky.Variables.BaseVariable$1(UnityEngine.Vector3)]
    });
    /*VirtueSky.Variables.Vector3Variable end.*/

    /*WallPath start.*/
    Bridge.define("WallPath", {
        inherits: [Wall],
        fields: {
            timeMove: 0,
            distanceMove: 0,
            _yAxisModelDefault: 0,
            _tweenMove: null
        },
        ctors: {
            init: function () {
if ( TRACE ) { TRACE( "WallPath#init", this ); }

                this.timeMove = 0.5;
                this.distanceMove = -0.5;
                this._yAxisModelDefault = 0.0;
            }
        },
        methods: {
            /*WallPath.Start start.*/
            Start: function () {
if ( TRACE ) { TRACE( "WallPath#Start", this ); }

                Wall.prototype.Start.call(this);
                this._yAxisModelDefault = this.model.transform.localPosition.y;
                this.OnSelectBlock(false);

            },
            /*WallPath.Start end.*/

            /*WallPath.OnSelectBlock start.*/
            OnSelectBlock: function (isSelect) {
if ( TRACE ) { TRACE( "WallPath#OnSelectBlock", this ); }

                var posY = isSelect ? this._yAxisModelDefault + this.distanceMove : this._yAxisModelDefault;
                this.MoveY(posY);
            },
            /*WallPath.OnSelectBlock end.*/

            /*WallPath.MoveY start.*/
            MoveY: function (y) {
if ( TRACE ) { TRACE( "WallPath#MoveY", this ); }

                DG.Tweening.TweenExtensions.Kill(this._tweenMove);
                this._tweenMove = DG.Tweening.ShortcutExtensions.DOLocalMoveY(this.model.transform, y, this.timeMove);
            },
            /*WallPath.MoveY end.*/

            /*WallPath.OnDestroy start.*/
            OnDestroy: function () {
if ( TRACE ) { TRACE( "WallPath#OnDestroy", this ); }


            },
            /*WallPath.OnDestroy end.*/


        }
    });
    /*WallPath end.*/

    /*VirtueSky.Audio.MusicVolumeChange start.*/
    Bridge.define("VirtueSky.Audio.MusicVolumeChange", {
        inherits: [VirtueSky.Variables.FloatVariable]
    });
    /*VirtueSky.Audio.MusicVolumeChange end.*/

    /*VirtueSky.Audio.PauseMusicEvent start.*/
    Bridge.define("VirtueSky.Audio.PauseMusicEvent", {
        inherits: [VirtueSky.Events.EventNoParam]
    });
    /*VirtueSky.Audio.PauseMusicEvent end.*/

    /*VirtueSky.Audio.ResumeMusicEvent start.*/
    Bridge.define("VirtueSky.Audio.ResumeMusicEvent", {
        inherits: [VirtueSky.Events.EventNoParam]
    });
    /*VirtueSky.Audio.ResumeMusicEvent end.*/

    /*VirtueSky.Audio.SfxVolumeChange start.*/
    Bridge.define("VirtueSky.Audio.SfxVolumeChange", {
        inherits: [VirtueSky.Variables.FloatVariable]
    });
    /*VirtueSky.Audio.SfxVolumeChange end.*/

    /*VirtueSky.Audio.StopAllSfxEvent start.*/
    Bridge.define("VirtueSky.Audio.StopAllSfxEvent", {
        inherits: [VirtueSky.Events.EventNoParam]
    });
    /*VirtueSky.Audio.StopAllSfxEvent end.*/

    /*VirtueSky.Audio.StopMusicEvent start.*/
    Bridge.define("VirtueSky.Audio.StopMusicEvent", {
        inherits: [VirtueSky.Events.EventNoParam]
    });
    /*VirtueSky.Audio.StopMusicEvent end.*/

    /*VirtueSky.Events.BooleanEventListener start.*/
    Bridge.define("VirtueSky.Events.BooleanEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(System.Boolean,VirtueSky.Events.BooleanEvent,VirtueSky.Events.BooleanEventResponse)]
    });
    /*VirtueSky.Events.BooleanEventListener end.*/

    /*VirtueSky.Events.ClickButtonEvent start.*/
    Bridge.define("VirtueSky.Events.ClickButtonEvent", {
        inherits: [VirtueSky.Events.EventNoParam]
    });
    /*VirtueSky.Events.ClickButtonEvent end.*/

    /*VirtueSky.Events.DictionaryEventListener start.*/
    Bridge.define("VirtueSky.Events.DictionaryEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(System.Collections.Generic.Dictionary$2(System.String,System.Object),VirtueSky.Events.DictionaryEvent,VirtueSky.Events.DictionaryEventResponse)]
    });
    /*VirtueSky.Events.DictionaryEventListener end.*/

    /*VirtueSky.Events.EventResponse start.*/
    Bridge.define("VirtueSky.Events.EventResponse", {
        inherits: [VirtueSky.Events.BaseEventResponse]
    });
    /*VirtueSky.Events.EventResponse end.*/

    /*VirtueSky.Events.FloatEventListener start.*/
    Bridge.define("VirtueSky.Events.FloatEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(System.Single,VirtueSky.Events.FloatEvent,VirtueSky.Events.FloatEventResponse)]
    });
    /*VirtueSky.Events.FloatEventListener end.*/

    /*VirtueSky.Events.GameObjectEventListener start.*/
    Bridge.define("VirtueSky.Events.GameObjectEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(UnityEngine.GameObject,VirtueSky.Events.GameObjectEvent,VirtueSky.Events.GameObjectEventResponse)]
    });
    /*VirtueSky.Events.GameObjectEventListener end.*/

    /*VirtueSky.Events.IntegerEventListener start.*/
    Bridge.define("VirtueSky.Events.IntegerEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(System.Int32,VirtueSky.Events.IntegerEvent,VirtueSky.Events.IntegerEventResponse)]
    });
    /*VirtueSky.Events.IntegerEventListener end.*/

    /*VirtueSky.Events.ObjectEventListener start.*/
    Bridge.define("VirtueSky.Events.ObjectEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(UnityEngine.Object,VirtueSky.Events.ObjectEvent,VirtueSky.Events.ObjectEventResponse)]
    });
    /*VirtueSky.Events.ObjectEventListener end.*/

    /*VirtueSky.Events.ShortDoubleEventListener start.*/
    Bridge.define("VirtueSky.Events.ShortDoubleEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(VirtueSky.DataType.ShortDouble,VirtueSky.Events.ShortDoubleEvent,VirtueSky.Events.ShortDoubleEventResponse)]
    });
    /*VirtueSky.Events.ShortDoubleEventListener end.*/

    /*VirtueSky.Events.StringEventListener start.*/
    Bridge.define("VirtueSky.Events.StringEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(System.String,VirtueSky.Events.StringEvent,VirtueSky.Events.StringEventResponse)]
    });
    /*VirtueSky.Events.StringEventListener end.*/

    /*VirtueSky.Events.TransformEventListener start.*/
    Bridge.define("VirtueSky.Events.TransformEventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(UnityEngine.Transform,VirtueSky.Events.TransformEvent,VirtueSky.Events.TransformEventResponse)]
    });
    /*VirtueSky.Events.TransformEventListener end.*/

    /*VirtueSky.Events.Vector3EventListener start.*/
    Bridge.define("VirtueSky.Events.Vector3EventListener", {
        inherits: [VirtueSky.Events.BaseEventListener$3(UnityEngine.Vector3,VirtueSky.Events.Vector3Event,VirtueSky.Events.Vector3EventResponse)]
    });
    /*VirtueSky.Events.Vector3EventListener end.*/

    /*VirtueSky.TouchInput.InputPreventTouchVariable start.*/
    Bridge.define("VirtueSky.TouchInput.InputPreventTouchVariable", {
        inherits: [VirtueSky.Variables.BooleanVariable]
    });
    /*VirtueSky.TouchInput.InputPreventTouchVariable end.*/

    /*VirtueSky.Variables.BooleanReference start.*/
    Bridge.define("VirtueSky.Variables.BooleanReference", {
        inherits: [VirtueSky.Variables.BaseReference$2(System.Boolean,VirtueSky.Variables.BooleanVariable)]
    });
    /*VirtueSky.Variables.BooleanReference end.*/

    /*VirtueSky.Variables.BooleanVariableListener start.*/
    Bridge.define("VirtueSky.Variables.BooleanVariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(System.Boolean,VirtueSky.Variables.BooleanVariable,VirtueSky.Events.BooleanEventResponse)]
    });
    /*VirtueSky.Variables.BooleanVariableListener end.*/

    /*VirtueSky.Variables.FloatReference start.*/
    Bridge.define("VirtueSky.Variables.FloatReference", {
        inherits: [VirtueSky.Variables.BaseReference$2(System.Single,VirtueSky.Variables.FloatVariable)]
    });
    /*VirtueSky.Variables.FloatReference end.*/

    /*VirtueSky.Variables.FloatVariableListener start.*/
    Bridge.define("VirtueSky.Variables.FloatVariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(System.Single,VirtueSky.Variables.FloatVariable,VirtueSky.Events.FloatEventResponse)]
    });
    /*VirtueSky.Variables.FloatVariableListener end.*/

    /*VirtueSky.Variables.IntegerReference start.*/
    Bridge.define("VirtueSky.Variables.IntegerReference", {
        inherits: [VirtueSky.Variables.BaseReference$2(System.Int32,VirtueSky.Variables.IntegerVariable)]
    });
    /*VirtueSky.Variables.IntegerReference end.*/

    /*VirtueSky.Variables.IntegerVariableListener start.*/
    Bridge.define("VirtueSky.Variables.IntegerVariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(System.Int32,VirtueSky.Variables.IntegerVariable,VirtueSky.Events.IntegerEventResponse)]
    });
    /*VirtueSky.Variables.IntegerVariableListener end.*/

    /*VirtueSky.Variables.ObjectReference start.*/
    Bridge.define("VirtueSky.Variables.ObjectReference", {
        inherits: [VirtueSky.Variables.BaseReference$2(UnityEngine.Object,VirtueSky.Variables.ObjectVariable)]
    });
    /*VirtueSky.Variables.ObjectReference end.*/

    /*VirtueSky.Variables.ObjectVariableListener start.*/
    Bridge.define("VirtueSky.Variables.ObjectVariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(UnityEngine.Object,VirtueSky.Variables.ObjectVariable,VirtueSky.Events.ObjectEventResponse)]
    });
    /*VirtueSky.Variables.ObjectVariableListener end.*/

    /*VirtueSky.Variables.ShortDoubleReference start.*/
    Bridge.define("VirtueSky.Variables.ShortDoubleReference", {
        inherits: [VirtueSky.Variables.BaseReference$2(VirtueSky.DataType.ShortDouble,VirtueSky.Variables.ShortDoubleVariable)]
    });
    /*VirtueSky.Variables.ShortDoubleReference end.*/

    /*VirtueSky.Variables.ShortDoubleVariableListener start.*/
    Bridge.define("VirtueSky.Variables.ShortDoubleVariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(VirtueSky.DataType.ShortDouble,VirtueSky.Variables.ShortDoubleVariable,VirtueSky.Events.ShortDoubleEventResponse)]
    });
    /*VirtueSky.Variables.ShortDoubleVariableListener end.*/

    /*VirtueSky.Variables.StringVariableListener start.*/
    Bridge.define("VirtueSky.Variables.StringVariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(System.String,VirtueSky.Variables.StringVariable,VirtueSky.Events.StringEventResponse)]
    });
    /*VirtueSky.Variables.StringVariableListener end.*/

    /*VirtueSky.Variables.Vector3Reference start.*/
    Bridge.define("VirtueSky.Variables.Vector3Reference", {
        inherits: [VirtueSky.Variables.BaseReference$2(UnityEngine.Vector3,VirtueSky.Variables.Vector3Variable)]
    });
    /*VirtueSky.Variables.Vector3Reference end.*/

    /*VirtueSky.Variables.Vector3VariableListener start.*/
    Bridge.define("VirtueSky.Variables.Vector3VariableListener", {
        inherits: [VirtueSky.Variables.BaseVariableListener$3(UnityEngine.Vector3,VirtueSky.Variables.Vector3Variable,VirtueSky.Events.Vector3EventResponse)]
    });
    /*VirtueSky.Variables.Vector3VariableListener end.*/

    /*VirtueSky.Events.EventListenerNoParam start.*/
    Bridge.define("VirtueSky.Events.EventListenerNoParam", {
        inherits: [VirtueSky.Events.BaseEventListener$2(VirtueSky.Events.EventNoParam,VirtueSky.Events.EventResponse)]
    });
    /*VirtueSky.Events.EventListenerNoParam end.*/

    if ( MODULE_reflection ) {
    var $m = Bridge.setMetadata,
        $n = ["System","UnityEngine","VirtueSky.Events","System.Collections.Generic","DG.Tweening","VirtueSky.Audio","VirtueSky.Variables","TMPro","UnityEngine.UI","System.Collections","TheBeginning.LevelSystem","VirtueSky.TouchInput","Spine.Unity","UnityEngine.Audio","DG.Tweening.Core","DG.Tweening.Plugins.Core.PathCore","System.Globalization","DG.Tweening.Plugins.Options","Spine","UnityEngine.U2D","UnityEngine.Rendering","Spine.Unity.AttachmentTools","VirtueSky.Vibration","VirtueSky.ObjectPooling","VirtueSky.Core","VirtueSky.DataType","VirtueSky.Component","UnityEngine.EventSystems","VirtueSky.Vfx","TheBeginning.UI","VirtueSky.UIButton"];

    /*GameSettings start.*/
    $m("GameSettings", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnableDebugView","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_EnableDebugView","t":8,"rt":$n[0].Boolean,"fg":"EnableDebugView","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"EnableDebugView"},{"a":2,"n":"EnableNotificationInGame","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_EnableNotificationInGame","t":8,"rt":$n[0].Boolean,"fg":"EnableNotificationInGame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"EnableNotificationInGame"},{"a":2,"n":"EnableRequireInternet","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_EnableRequireInternet","t":8,"rt":$n[0].Boolean,"fg":"EnableRequireInternet","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"EnableRequireInternet"},{"a":2,"n":"EnableShowPopupUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_EnableShowPopupUpdate","t":8,"rt":$n[0].Boolean,"fg":"EnableShowPopupUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"EnableShowPopupUpdate"},{"a":2,"n":"HammerBoosterAmount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_HammerBoosterAmount","t":8,"rt":$n[0].Int32,"fg":"HammerBoosterAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"HammerBoosterAmount"},{"a":2,"n":"MultiTouchEnabled","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_MultiTouchEnabled","t":8,"rt":$n[0].Boolean,"fg":"MultiTouchEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"MultiTouchEnabled"},{"a":2,"n":"PauseTimeBoosterAmount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PauseTimeBoosterAmount","t":8,"rt":$n[0].Int32,"fg":"PauseTimeBoosterAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PauseTimeBoosterAmount"},{"a":2,"n":"PercentWinGiftPerLevel","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PercentWinGiftPerLevel","t":8,"rt":$n[0].Int32,"fg":"PercentWinGiftPerLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"PercentWinGiftPerLevel"},{"a":2,"n":"SuckBoosterAmount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SuckBoosterAmount","t":8,"rt":$n[0].Int32,"fg":"SuckBoosterAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SuckBoosterAmount"},{"a":2,"n":"TargetFrameRate","t":16,"rt":TargetFrameRate,"g":{"a":2,"n":"get_TargetFrameRate","t":8,"rt":TargetFrameRate,"fg":"TargetFrameRate","box":function ($v) { return Bridge.box($v, TargetFrameRate, System.Enum.toStringFn(TargetFrameRate));}},"fn":"TargetFrameRate"},{"a":2,"n":"TimeDelayCheckInternet","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeDelayCheckInternet","t":8,"rt":$n[0].Single,"fg":"TimeDelayCheckInternet","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TimeDelayCheckInternet"},{"a":2,"n":"TimeDelayHideNotificationInGame","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeDelayHideNotificationInGame","t":8,"rt":$n[0].Single,"fg":"TimeDelayHideNotificationInGame","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TimeDelayHideNotificationInGame"},{"a":2,"n":"TimeLoopCheckInternet","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeLoopCheckInternet","t":8,"rt":$n[0].Single,"fg":"TimeLoopCheckInternet","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TimeLoopCheckInternet"},{"a":2,"n":"WinLevelMoney","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_WinLevelMoney","t":8,"rt":$n[0].Int32,"fg":"WinLevelMoney","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"WinLevelMoney"},{"at":[new UnityEngine.HeaderAttribute("Gameplay config"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"enableDebugView","t":4,"rt":$n[0].Boolean,"sn":"enableDebugView","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Notification In Game"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"enableNotificationInGame","t":4,"rt":$n[0].Boolean,"sn":"enableNotificationInGame","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Require Internet"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"enableRequireInternet","t":4,"rt":$n[0].Boolean,"sn":"enableRequireInternet","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Show Popup Update"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"enableShowPopupUpdate","t":4,"rt":$n[0].Boolean,"sn":"enableShowPopupUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"hammerBoosterAmount","t":4,"rt":$n[0].Int32,"sn":"hammerBoosterAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"multiTouchEnabled","t":4,"rt":$n[0].Boolean,"sn":"multiTouchEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pauseTimeBoosterAmount","t":4,"rt":$n[0].Int32,"sn":"pauseTimeBoosterAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"percentWinGiftPerLevel","t":4,"rt":$n[0].Int32,"sn":"percentWinGiftPerLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"suckBoosterAmount","t":4,"rt":$n[0].Int32,"sn":"suckBoosterAmount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetFrameRate","t":4,"rt":TargetFrameRate,"sn":"targetFrameRate","box":function ($v) { return Bridge.box($v, TargetFrameRate, System.Enum.toStringFn(TargetFrameRate));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayCheckInternet","t":4,"rt":$n[0].Single,"sn":"timeDelayCheckInternet","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayHideNotificationInGame","t":4,"rt":$n[0].Single,"sn":"timeDelayHideNotificationInGame","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeLoopCheckInternet","t":4,"rt":$n[0].Single,"sn":"timeLoopCheckInternet","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"winLevelMoney","t":4,"rt":$n[0].Int32,"sn":"winLevelMoney","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*GameSettings end.*/

    /*TargetFrameRate start.*/
    $m("TargetFrameRate", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ByDevice","is":true,"t":4,"rt":TargetFrameRate,"sn":"ByDevice","box":function ($v) { return Bridge.box($v, TargetFrameRate, System.Enum.toStringFn(TargetFrameRate));}},{"a":2,"n":"Frame120","is":true,"t":4,"rt":TargetFrameRate,"sn":"Frame120","box":function ($v) { return Bridge.box($v, TargetFrameRate, System.Enum.toStringFn(TargetFrameRate));}},{"a":2,"n":"Frame240","is":true,"t":4,"rt":TargetFrameRate,"sn":"Frame240","box":function ($v) { return Bridge.box($v, TargetFrameRate, System.Enum.toStringFn(TargetFrameRate));}},{"a":2,"n":"Frame60","is":true,"t":4,"rt":TargetFrameRate,"sn":"Frame60","box":function ($v) { return Bridge.box($v, TargetFrameRate, System.Enum.toStringFn(TargetFrameRate));}}]}; }, $n);
    /*TargetFrameRate end.*/

    /*CoinGenerate start.*/
    $m("CoinGenerate", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddTo","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"AddTo","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"DecreaseCoin","t":8,"sn":"DecreaseCoin","rt":$n[0].Void},{"a":2,"n":"GenerateCoin","t":8,"sn":"GenerateCoin","rt":$n[0].Void},{"a":1,"n":"GetToNear","t":8,"sn":"GetToNear","rt":$n[1].GameObject},{"a":1,"n":"MoveToTarget","t":8,"pi":[{"n":"coin","pt":$n[1].GameObject,"ps":0},{"n":"completed","pt":Function,"ps":1}],"sn":"MoveToTarget","rt":$n[0].Void,"p":[$n[1].GameObject,Function]},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RemoveTo","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"RemoveTo","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"SaveCache","t":8,"sn":"SaveCache","rt":$n[0].Void},{"a":1,"n":"ScaleIconTo","t":8,"sn":"ScaleIconTo","rt":$n[0].Void},{"a":2,"n":"SetFrom","t":8,"pi":[{"n":"from","pt":$n[1].Vector3,"ps":0}],"sn":"SetFrom","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":2,"n":"SetNumberCoin","t":8,"pi":[{"n":"_numberCoin","pt":$n[0].Int32,"ps":0}],"sn":"SetNumberCoin","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"addCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTargetToCoinGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"addTargetToCoinGenerateEvent"},{"a":1,"n":"cacheCurrentCoin","t":4,"rt":$n[0].Int32,"sn":"cacheCurrentCoin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"coinPrefab","t":4,"rt":$n[1].GameObject,"sn":"coinPrefab"},{"a":1,"n":"coinsActive","t":4,"rt":$n[3].List$1(UnityEngine.GameObject),"sn":"coinsActive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"decreaseCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"decreaseCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"delay","t":4,"rt":$n[0].Int32,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"durationNear","t":4,"rt":$n[0].Single,"sn":"durationNear","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"durationTarget","t":4,"rt":$n[0].Single,"sn":"durationTarget","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"easeNear","t":4,"rt":$n[4].Ease,"sn":"easeNear","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"easeTarget","t":4,"rt":$n[4].Ease,"sn":"easeTarget","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"a":1,"n":"from","t":4,"rt":$n[1].Vector3,"sn":"from"},{"at":[new UnityEngine.HeaderAttribute("Fx"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fx","t":4,"rt":$n[1].ParticleSystem,"sn":"fx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"holder","t":4,"rt":$n[1].Transform,"sn":"holder"},{"a":1,"n":"isScaleIconTo","t":4,"rt":$n[0].Boolean,"sn":"isScaleIconTo","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"listTo","t":4,"rt":$n[3].List$1(UnityEngine.GameObject),"sn":"listTo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minusCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"minusCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveAllCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveAllCoinDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveOneCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveOneCoinDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"numberCoin","t":4,"rt":$n[0].Int32,"sn":"numberCoin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offsetNear","t":4,"rt":$n[0].Single,"sn":"offsetNear","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Sound"),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"playSoundFx","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSoundFx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"removeTargetToCoinGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"removeTargetToCoinGenerateEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"setFromCoinEvent","t":4,"rt":$n[2].Vector3Event,"sn":"setFromCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundCoinMove","t":4,"rt":$n[5].SoundData,"sn":"soundCoinMove"},{"a":1,"n":"to","t":4,"rt":$n[1].GameObject,"sn":"to"}]}; }, $n);
    /*CoinGenerate end.*/

    /*CoinSystem start.*/
    $m("CoinSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddCoin","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":3},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":4},{"n":"isGenerate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddCoin","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceReason,TrackingEnum.EPlacement,$n[0].Boolean]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"GetCurrentCoin","is":true,"t":8,"sn":"GetCurrentCoin","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"InternalAddCoin","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceName","pt":TrackingEnum.EResourceName,"ps":3},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":4},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":5},{"n":"isGenerate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"InternalAddCoin","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EPlacement,$n[0].Boolean]},{"a":1,"n":"InternalMinusCoin","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":1},{"n":"resourceName","pt":TrackingEnum.EResourceName,"ps":2},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":3},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":4}],"sn":"InternalMinusCoin","rt":$n[0].Void,"p":[$n[0].Int32,TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":1,"n":"InternalSetCoin","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceName","pt":TrackingEnum.EResourceName,"ps":3},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":4},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":5}],"sn":"InternalSetCoin","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":2,"n":"MinusCoin","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":1},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":2},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":3}],"sn":"MinusCoin","rt":$n[0].Void,"p":[$n[0].Int32,TrackingEnum.EResourceType,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":1,"n":"OnChangeValue","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"OnChangeValue","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetCoin","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":3},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":4}],"sn":"SetCoin","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":1,"n":"CurrentCoin","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":1,"n":"get_CurrentCoin","t":8,"rt":$n[0].Int32,"fg":"CurrentCoin","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_CurrentCoin","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"CurrentCoin","is":true},"fn":"CurrentCoin"},{"a":1,"n":"CURRENT_COIN","is":true,"t":4,"rt":$n[0].String,"sn":"CURRENT_COIN"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"addCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"balanceAmount","t":4,"rt":$n[6].IntegerVariable,"sn":"balanceAmount"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"generateCoinEvent","t":4,"rt":$n[2].Vector3Event,"sn":"generateCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minusCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"minusCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updateCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"updateCoinEvent"},{"a":1,"n":"OnAddCoinEvent","is":true,"t":2,"ad":{"a":1,"n":"add_OnAddCoinEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAddCoinEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_OnAddCoinEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAddCoinEvent","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"OnMinusCoinEvent","is":true,"t":2,"ad":{"a":1,"n":"add_OnMinusCoinEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMinusCoinEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_OnMinusCoinEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMinusCoinEvent","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"OnSetCoinEvent","is":true,"t":2,"ad":{"a":1,"n":"add_OnSetCoinEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnSetCoinEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_OnSetCoinEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnSetCoinEvent","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*CoinSystem end.*/

    /*CoinUpdater start.*/
    $m("CoinUpdater", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DecreaseCoin","t":8,"sn":"DecreaseCoin","rt":$n[0].Void},{"a":1,"n":"MoveAllCoinDone","t":8,"sn":"MoveAllCoinDone","rt":$n[0].Void},{"a":1,"n":"MoveOneCoinDone","t":8,"sn":"MoveOneCoinDone","rt":$n[0].Void},{"a":1,"n":"OnBuildingProcessing","t":8,"pi":[{"n":"isProcessing","pt":$n[0].Boolean,"ps":0}],"sn":"OnBuildingProcessing","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"OnClickPlus","t":8,"sn":"OnClickPlus","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"UpdateDisplayValue","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"UpdateDisplayValue","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"UpdateTextCoin","t":8,"sn":"UpdateTextCoin","rt":$n[0].Void},{"a":2,"n":"CurrencyAmountText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"CurrencyAmountText"},{"a":1,"n":"_isProcessingBuilding","t":4,"rt":$n[0].Boolean,"sn":"_isProcessingBuilding","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTargetToCoinGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"addTargetToCoinGenerateEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"decreaseCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"decreaseCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconCoin","t":4,"rt":$n[1].GameObject,"sn":"iconCoin"},{"a":1,"n":"isFirsCoinMoveDone","t":4,"rt":$n[0].Boolean,"sn":"isFirsCoinMoveDone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveAllCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveAllCoinDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveOneCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveOneCoinDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"removeTargetToCoinGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"removeTargetToCoinGenerateEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updateCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"updateCoinEvent"}]}; }, $n);
    /*CoinUpdater end.*/

    /*Constant start.*/
    $m("Constant", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CURRENT_MONTH_BATTLE_PASS","is":true,"t":4,"rt":$n[0].String,"sn":"CURRENT_MONTH_BATTLE_PASS"},{"a":2,"n":"DAILY_REWARD_DAY_INDEX","is":true,"t":4,"rt":$n[0].String,"sn":"DAILY_REWARD_DAY_INDEX"},{"a":2,"n":"DATE_TIME_START","is":true,"t":4,"rt":$n[0].String,"sn":"DATE_TIME_START"},{"a":2,"n":"EMPTY_SCENE","is":true,"t":4,"rt":$n[0].String,"sn":"EMPTY_SCENE"},{"a":2,"n":"EQUIP_ITEM","is":true,"t":4,"rt":$n[0].String,"sn":"EQUIP_ITEM"},{"a":2,"n":"Environment","is":true,"t":4,"rt":$n[0].String,"sn":"Environment"},{"a":2,"n":"GAMEOBJECT_SHOW","is":true,"t":4,"rt":$n[0].String,"sn":"GAMEOBJECT_SHOW"},{"a":2,"n":"GAME_SCENE","is":true,"t":4,"rt":$n[0].String,"sn":"GAME_SCENE"},{"a":2,"n":"INDEX_LEVEL_CURRENT","is":true,"t":4,"rt":$n[0].String,"sn":"INDEX_LEVEL_CURRENT"},{"a":2,"n":"IS_FIRST_OPEN_GAME","is":true,"t":4,"rt":$n[0].String,"sn":"IS_FIRST_OPEN_GAME"},{"a":2,"n":"IS_OFF_INTER_ADS","is":true,"t":4,"rt":$n[0].String,"sn":"IS_OFF_INTER_ADS"},{"a":2,"n":"IS_START_LOOPING_DAILY_REWARD","is":true,"t":4,"rt":$n[0].String,"sn":"IS_START_LOOPING_DAILY_REWARD"},{"a":2,"n":"IS_TESTING","is":true,"t":4,"rt":$n[0].String,"sn":"IS_TESTING"},{"a":2,"n":"LAST_DAILY_GIFT","is":true,"t":4,"rt":$n[0].String,"sn":"LAST_DAILY_GIFT"},{"a":2,"n":"LAST_DAILY_GIFT_CLAIM","is":true,"t":4,"rt":$n[0].String,"sn":"LAST_DAILY_GIFT_CLAIM"},{"a":2,"n":"LAST_DAILY_INFINITY","is":true,"t":4,"rt":$n[0].String,"sn":"LAST_DAILY_INFINITY"},{"a":2,"n":"LAST_DAILY_REWARD_CLAIM","is":true,"t":4,"rt":$n[0].String,"sn":"LAST_DAILY_REWARD_CLAIM"},{"a":2,"n":"LAST_SESSION_TIME","is":true,"t":4,"rt":$n[0].String,"sn":"LAST_SESSION_TIME"},{"a":2,"n":"LAST_WIN_STREAK_START","is":true,"t":4,"rt":$n[0].String,"sn":"LAST_WIN_STREAK_START"},{"a":2,"n":"Normal_Attribute","is":true,"t":4,"rt":$n[0].String,"sn":"Normal_Attribute"},{"a":2,"n":"PERCENT_WIN_GIFT","is":true,"t":4,"rt":$n[0].String,"sn":"PERCENT_WIN_GIFT"},{"a":2,"n":"PROGRESS_AMOUNT","is":true,"t":4,"rt":$n[0].String,"sn":"PROGRESS_AMOUNT"},{"a":2,"n":"SERVICE_SCENE","is":true,"t":4,"rt":$n[0].String,"sn":"SERVICE_SCENE"},{"a":2,"n":"SO_Event","is":true,"t":4,"rt":$n[0].String,"sn":"SO_Event"},{"a":2,"n":"SO_Variable","is":true,"t":4,"rt":$n[0].String,"sn":"SO_Variable"},{"a":2,"n":"TOTAL_CLAIM_DAILY_REWARD","is":true,"t":4,"rt":$n[0].String,"sn":"TOTAL_CLAIM_DAILY_REWARD"},{"a":2,"n":"UI_Motion","is":true,"t":4,"rt":$n[0].String,"sn":"UI_Motion"},{"a":2,"n":"UNLOCK_ITEM","is":true,"t":4,"rt":$n[0].String,"sn":"UNLOCK_ITEM"}]}; }, $n);
    /*Constant end.*/

    /*EventGetGameState start.*/
    $m("EventGetGameState", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Event Custom/Event Get GameState", fileName: "event_get_game_state"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*EventGetGameState end.*/

    /*StarGenerate start.*/
    $m("StarGenerate", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddComplete","t":8,"sn":"AddComplete","rt":$n[0].Void},{"a":2,"n":"AddTo","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"AddTo","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"DecreaseCoin","t":8,"sn":"DecreaseCoin","rt":$n[0].Void},{"a":2,"n":"GenerateCoin","t":8,"sn":"GenerateCoin","rt":$n[0].Void},{"a":1,"n":"MoveToTarget","t":8,"pi":[{"n":"coin","pt":$n[1].GameObject,"ps":0},{"n":"completed","pt":Function,"ps":1}],"sn":"MoveToTarget","rt":$n[0].Void,"p":[$n[1].GameObject,Function]},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RemoveTo","t":8,"pi":[{"n":"obj","pt":$n[1].GameObject,"ps":0}],"sn":"RemoveTo","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"SaveCache","t":8,"sn":"SaveCache","rt":$n[0].Void},{"a":2,"n":"SetFrom","t":8,"pi":[{"n":"from","pt":$n[1].Vector3,"ps":0}],"sn":"SetFrom","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":2,"n":"SetNumberCoin","t":8,"pi":[{"n":"_numberCoin","pt":$n[0].Int32,"ps":0}],"sn":"SetNumberCoin","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"addCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTargetToCoinGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"addTargetToCoinGenerateEvent"},{"a":1,"n":"cacheCurrentCoin","t":4,"rt":$n[0].Int32,"sn":"cacheCurrentCoin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"coinPrefab","t":4,"rt":$n[1].GameObject,"sn":"coinPrefab"},{"a":1,"n":"coinsActive","t":4,"rt":$n[3].List$1(UnityEngine.GameObject),"sn":"coinsActive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"decreaseCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"decreaseCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"delay","t":4,"rt":$n[0].Int32,"sn":"delay","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"durationNear","t":4,"rt":$n[0].Single,"sn":"durationNear","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"durationTarget","t":4,"rt":$n[0].Single,"sn":"durationTarget","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"easeNear","t":4,"rt":$n[4].Ease,"sn":"easeNear","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"easeTarget","t":4,"rt":$n[4].Ease,"sn":"easeTarget","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"a":1,"n":"from","t":4,"rt":$n[1].Vector3,"sn":"from"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"holder","t":4,"rt":$n[1].Transform,"sn":"holder"},{"a":1,"n":"isScaleIconTo","t":4,"rt":$n[0].Boolean,"sn":"isScaleIconTo","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"listTo","t":4,"rt":$n[3].List$1(UnityEngine.GameObject),"sn":"listTo"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minusCoinEvent","t":4,"rt":$n[2].EventNoParam,"sn":"minusCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveAllCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveAllCoinDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveOneCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveOneCoinDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"numberCoin","t":4,"rt":$n[0].Int32,"sn":"numberCoin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offsetNear","t":4,"rt":$n[0].Single,"sn":"offsetNear","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Sound"),new UnityEngine.SerializeFieldAttribute()],"a":2,"n":"playSoundFx","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSoundFx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"removeTargetToCoinGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"removeTargetToCoinGenerateEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleTo","t":4,"rt":$n[0].Single,"sn":"scaleTo","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"setFromCoinEvent","t":4,"rt":$n[2].Vector3Event,"sn":"setFromCoinEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"setStarCountEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"setStarCountEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundCoinMove","t":4,"rt":$n[5].SoundData,"sn":"soundCoinMove"},{"a":1,"n":"to","t":4,"rt":$n[1].GameObject,"sn":"to"}]}; }, $n);
    /*StarGenerate end.*/

    /*StarSystem start.*/
    $m("StarSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddStar","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":3},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":4},{"n":"isGenerate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddStar","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceReason,TrackingEnum.EPlacement,$n[0].Boolean]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"GetCurrentStar","is":true,"t":8,"sn":"GetCurrentStar","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"InternalAddStar","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceName","pt":TrackingEnum.EResourceName,"ps":3},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":4},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":5},{"n":"isGenerate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"InternalAddStar","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EPlacement,$n[0].Boolean]},{"a":1,"n":"InternalMinusStar","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":1},{"n":"resourceName","pt":TrackingEnum.EResourceName,"ps":2},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":3},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":4}],"sn":"InternalMinusStar","rt":$n[0].Void,"p":[$n[0].Int32,TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":1,"n":"InternalSetStar","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceName","pt":TrackingEnum.EResourceName,"ps":3},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":4},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":5}],"sn":"InternalSetStar","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":2,"n":"MinusStar","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":1},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":2},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":3}],"sn":"MinusStar","rt":$n[0].Void,"p":[$n[0].Int32,TrackingEnum.EResourceType,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":1,"n":"OnChangeValue","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"OnChangeValue","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetStar","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0},{"n":"posGenerateCoin","pt":$n[1].Vector3,"ps":1},{"n":"resourceType","pt":TrackingEnum.EResourceType,"ps":2},{"n":"resourceReason","pt":TrackingEnum.EResourceReason,"ps":3},{"n":"placement","pt":TrackingEnum.EPlacement,"ps":4}],"sn":"SetStar","rt":$n[0].Void,"p":[$n[0].Int32,$n[1].Vector3,TrackingEnum.EResourceType,TrackingEnum.EResourceReason,TrackingEnum.EPlacement]},{"a":1,"n":"CurrentStar","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":1,"n":"get_CurrentStar","t":8,"rt":$n[0].Int32,"fg":"CurrentStar","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":1,"n":"set_CurrentStar","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"CurrentStar","is":true},"fn":"CurrentStar"},{"a":1,"n":"CURRENT_STAR","is":true,"t":4,"rt":$n[0].String,"sn":"CURRENT_STAR"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addStarCompleteEvent","t":4,"rt":$n[2].EventNoParam,"sn":"addStarCompleteEvent"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("addCoinEvent"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addStarEvent","t":4,"rt":$n[2].EventNoParam,"sn":"addStarEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"balanceAmount","t":4,"rt":$n[6].IntegerVariable,"sn":"balanceAmount"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("generateCoinEvent"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"generateStarEvent","t":4,"rt":$n[2].Vector3Event,"sn":"generateStarEvent"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("minusCoinEvent"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minusStarEvent","t":4,"rt":$n[2].EventNoParam,"sn":"minusStarEvent"},{"a":2,"n":"ActionChangeValue","is":true,"t":2,"ad":{"a":2,"n":"add_ActionChangeValue","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addActionChangeValue","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ActionChangeValue","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeActionChangeValue","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"OnAddStarEvent","is":true,"t":2,"ad":{"a":1,"n":"add_OnAddStarEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAddStarEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_OnAddStarEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAddStarEvent","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"OnMinusStarEvent","is":true,"t":2,"ad":{"a":1,"n":"add_OnMinusStarEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMinusStarEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_OnMinusStarEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMinusStarEvent","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"OnSetStarEvent","is":true,"t":2,"ad":{"a":1,"n":"add_OnSetStarEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnSetStarEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_OnSetStarEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnSetStarEvent","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*StarSystem end.*/

    /*StarUpdater start.*/
    $m("StarUpdater", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DecreaseCoin","t":8,"sn":"DecreaseCoin","rt":$n[0].Void},{"a":1,"n":"MoveAllCoinDone","t":8,"sn":"MoveAllCoinDone","rt":$n[0].Void},{"a":1,"n":"MoveOneCoinDone","t":8,"sn":"MoveOneCoinDone","rt":$n[0].Void},{"a":1,"n":"OnBuildingProcessing","t":8,"pi":[{"n":"isProcessing","pt":$n[0].Boolean,"ps":0}],"sn":"OnBuildingProcessing","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"OnClickPlus","t":8,"sn":"OnClickPlus","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"UpdateTextCoin","t":8,"sn":"UpdateTextCoin","rt":$n[0].Void},{"a":2,"n":"CurrencyAmountText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"CurrencyAmountText"},{"a":1,"n":"_isFirstCoinMoveDone","t":4,"rt":$n[0].Boolean,"sn":"_isFirstCoinMoveDone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isProcessingBuilding","t":4,"rt":$n[0].Boolean,"sn":"_isProcessingBuilding","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTargetToStarGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"addTargetToStarGenerateEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"decreaseStarEvent","t":4,"rt":$n[2].EventNoParam,"sn":"decreaseStarEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconStar","t":4,"rt":$n[1].GameObject,"sn":"iconStar"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveAllStarDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveAllStarDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveOneStarDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveOneStarDone"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"removeTargetToStarGenerateEvent","t":4,"rt":$n[2].GameObjectEvent,"sn":"removeTargetToStarGenerateEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updateStartTextEvent","t":4,"rt":$n[2].EventNoParam,"sn":"updateStartTextEvent"}]}; }, $n);
    /*StarUpdater end.*/

    /*TimingController start.*/
    $m("TimingController", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddTimePlayEvent","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"AddTimePlayEvent","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"DisplayTime","t":8,"sn":"DisplayTime","rt":$n[0].Void},{"a":1,"n":"OnCountDownTimeSetup","t":8,"pi":[{"n":"time","pt":$n[0].Int32,"ps":0}],"sn":"OnCountDownTimeSetup","rt":$n[0].Void,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"OnStartCountDownTime","t":8,"sn":"OnStartCountDownTime","rt":$n[0].Void},{"a":1,"n":"OnValidate","t":8,"sn":"OnValidate","rt":$n[0].Void},{"a":2,"n":"SetTime","t":8,"pi":[{"n":"time","pt":$n[0].Int32,"ps":0},{"n":"onTimeUpEvent","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"SetTime","rt":$n[0].Void,"p":[$n[0].Int32,Function]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"_currentTime","t":4,"rt":$n[0].Single,"sn":"_currentTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_isCanCountTime","t":4,"rt":$n[0].Boolean,"sn":"_isCanCountTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"_isShowWaringSoundPlay","t":4,"rt":$n[0].Boolean,"sn":"_isShowWaringSoundPlay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"_isShowWarnBoard","t":4,"rt":$n[0].Boolean,"sn":"_isShowWarnBoard","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isWarned","t":4,"rt":$n[0].Boolean,"sn":"_isWarned","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_soundWaringCache","t":4,"rt":$n[5].SoundCache,"sn":"_soundWaringCache"},{"at":[new UnityEngine.HeaderAttribute("Event"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimePlayEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"addTimePlayEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"countDownTimeSetupEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"countDownTimeSetupEvent"},{"at":[new UnityEngine.HeaderAttribute("Properties"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fadeWarnDuration","t":4,"rt":$n[0].Single,"sn":"fadeWarnDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPlayAgainMore","t":4,"rt":$n[6].BooleanVariable,"sn":"isPlayAgainMore"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isUsingTimerBooster","t":4,"rt":$n[6].BooleanVariable,"sn":"isUsingTimerBooster"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"onTimeUpEvent","t":4,"rt":$n[2].EventNoParam,"sn":"onTimeUpEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"onWarringTimeEvent","t":4,"rt":$n[2].EventNoParam,"sn":"onWarringTimeEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pauseTimeLevelVariable","t":4,"rt":$n[6].BooleanVariable,"sn":"pauseTimeLevelVariable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playDuration","t":4,"rt":$n[6].FloatVariable,"sn":"playDuration"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundWarring","t":4,"rt":$n[5].SoundData,"sn":"soundWarring"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"startCountDownTimeEvent","t":4,"rt":$n[2].EventNoParam,"sn":"startCountDownTimeEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stopSfxEvent","t":4,"rt":$n[5].StopSfxEvent,"sn":"stopSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormat","t":4,"rt":$n[0].String,"sn":"stringFormat"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"timeText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"totalTimeAddWhenPlay","t":4,"rt":$n[6].IntegerVariable,"sn":"totalTimeAddWhenPlay"},{"at":[new UnityEngine.HeaderAttribute("Warring"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"warningFrame","t":4,"rt":$n[8].Image,"sn":"warningFrame"}]}; }, $n);
    /*TimingController end.*/

    /*Switcher start.*/
    $m("Switcher", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Setup","t":8,"sn":"Setup","rt":$n[0].Void},{"a":1,"n":"SetupData","t":8,"sn":"SetupData","rt":$n[0].Void},{"a":1,"n":"SetupUI","t":8,"sn":"SetupUI","rt":$n[0].Void},{"a":2,"n":"Switching","t":8,"sn":"Switching","rt":$n[0].Void},{"a":1,"n":"MusicChanged","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_MusicChanged","t":8,"rt":$n[0].Boolean,"fg":"MusicChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_MusicChanged","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"MusicChanged"},"fn":"MusicChanged"},{"a":1,"n":"SoundFxChanged","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_SoundFxChanged","t":8,"rt":$n[0].Boolean,"fg":"SoundFxChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_SoundFxChanged","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"SoundFxChanged"},"fn":"SoundFxChanged"},{"a":1,"n":"VibrateChanged","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_VibrateChanged","t":8,"rt":$n[0].Boolean,"fg":"VibrateChanged","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_VibrateChanged","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"VibrateChanged"},"fn":"VibrateChanged"},{"a":2,"n":"IsOn","t":4,"rt":$n[0].Boolean,"sn":"IsOn","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Off","t":4,"rt":$n[1].Sprite,"sn":"Off"},{"a":2,"n":"OffPos","t":4,"rt":$n[1].Transform,"sn":"OffPos"},{"a":2,"n":"On","t":4,"rt":$n[1].Sprite,"sn":"On"},{"a":2,"n":"OnPos","t":4,"rt":$n[1].Transform,"sn":"OnPos"},{"at":[new UnityEngine.HeaderAttribute("Components")],"a":2,"n":"SettingType","t":4,"rt":SettingType,"sn":"SettingType","box":function ($v) { return Bridge.box($v, SettingType, System.Enum.toStringFn(SettingType));}},{"a":2,"n":"Switch","t":4,"rt":$n[8].Image,"sn":"Switch"},{"at":[new UnityEngine.HeaderAttribute("Datas")],"a":2,"n":"SwitchState","t":4,"rt":SwitchState,"sn":"SwitchState","box":function ($v) { return Bridge.box($v, SwitchState, System.Enum.toStringFn(SwitchState));}},{"a":2,"n":"SwitchText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"SwitchText"},{"at":[new UnityEngine.HeaderAttribute("Config attribute"),new UnityEngine.RangeAttribute(0.1, 3.0)],"a":2,"n":"TimeSwitching","t":4,"rt":$n[0].Single,"sn":"TimeSwitching","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicChangedVariable","t":4,"rt":$n[6].FloatVariable,"sn":"musicChangedVariable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundFxChangeVariable","t":4,"rt":$n[6].FloatVariable,"sn":"soundFxChangeVariable"}]}; }, $n);
    /*Switcher end.*/

    /*SettingType start.*/
    $m("SettingType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BackgroundMusic","is":true,"t":4,"rt":SettingType,"sn":"BackgroundMusic","box":function ($v) { return Bridge.box($v, SettingType, System.Enum.toStringFn(SettingType));}},{"a":2,"n":"SoundFx","is":true,"t":4,"rt":SettingType,"sn":"SoundFx","box":function ($v) { return Bridge.box($v, SettingType, System.Enum.toStringFn(SettingType));}},{"a":2,"n":"Vibration","is":true,"t":4,"rt":SettingType,"sn":"Vibration","box":function ($v) { return Bridge.box($v, SettingType, System.Enum.toStringFn(SettingType));}}]}; }, $n);
    /*SettingType end.*/

    /*SwitchState start.*/
    $m("SwitchState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Idle","is":true,"t":4,"rt":SwitchState,"sn":"Idle","box":function ($v) { return Bridge.box($v, SwitchState, System.Enum.toStringFn(SwitchState));}},{"a":2,"n":"Moving","is":true,"t":4,"rt":SwitchState,"sn":"Moving","box":function ($v) { return Bridge.box($v, SwitchState, System.Enum.toStringFn(SwitchState));}}]}; }, $n);
    /*SwitchState end.*/

    /*PooledParticleCallback start.*/
    $m("PooledParticleCallback", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"IEDespawn","t":8,"sn":"IEDespawn","rt":$n[9].IEnumerator},{"a":1,"n":"OnParticleSystemStopped","t":8,"sn":"OnParticleSystemStopped","rt":$n[0].Void}]}; }, $n);
    /*PooledParticleCallback end.*/

    /*LevelAdditionalTime start.*/
    $m("LevelAdditionalTime", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Game/Level/Additional Time", fileName: "level_additional_time", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0},{"n":"time","pt":$n[0].Int32,"ps":1}],"sn":"Add","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32]},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Count","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Count"},"fn":"Count"},{"a":2,"n":"IsAvailable","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsAvailable","t":8,"rt":$n[0].Boolean,"fg":"IsAvailable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsAvailable"},{"a":2,"n":"TimeCurrent","t":16,"rt":$n[0].DateTime,"g":{"a":2,"n":"get_TimeCurrent","t":8,"rt":$n[0].DateTime,"fg":"TimeCurrent","box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},"fn":"TimeCurrent"},{"a":2,"n":"TimeEnd","t":16,"rt":$n[0].DateTime,"g":{"a":2,"n":"get_TimeEnd","t":8,"rt":$n[0].DateTime,"fg":"TimeEnd","box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},"s":{"a":2,"n":"set_TimeEnd","t":8,"p":[$n[0].DateTime],"rt":$n[0].Void,"fs":"TimeEnd"},"fn":"TimeEnd"},{"a":1,"n":"id","t":4,"rt":$n[0].String,"sn":"id"}]}; }, $n);
    /*LevelAdditionalTime end.*/

    /*CameraSystem start.*/
    $m("CameraSystem", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Camera)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"CheckDeviceResolution","t":8,"sn":"CheckDeviceResolution","rt":$n[0].Void},{"a":1,"n":"ReNative","t":8,"sn":"ReNative","rt":$n[0].Void},{"a":1,"n":"_aspect","t":4,"rt":$n[0].Single,"sn":"_aspect","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_aspectOrigin","t":4,"rt":$n[0].Single,"sn":"_aspectOrigin","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_fieldOfView","t":4,"rt":$n[0].Single,"sn":"_fieldOfView","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_reNativeValue","t":4,"rt":$n[0].Single,"sn":"_reNativeValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cameraTarget","t":4,"rt":$n[1].Camera,"sn":"cameraTarget"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"screenSizeOrigin","t":4,"rt":$n[1].Vector2,"sn":"screenSizeOrigin"}]}; }, $n);
    /*CameraSystem end.*/

    /*Extension start.*/
    $m("Extension", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ArcMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Transform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"height","pt":$n[0].Single,"ps":3},{"n":"numSteps","dv":20,"o":true,"pt":$n[0].Int32,"ps":4}],"sn":"ArcMove","rt":$n[4].Sequence,"p":[$n[1].Transform,$n[1].Vector3,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"CanvasToWorldPosition","is":true,"t":8,"pi":[{"n":"camera","pt":$n[1].Camera,"ps":0},{"n":"canvas","pt":$n[1].Canvas,"ps":1},{"n":"rectTransform","pt":$n[1].RectTransform,"ps":2}],"sn":"CanvasToWorldPosition","rt":$n[1].Vector3,"p":[$n[1].Camera,$n[1].Canvas,$n[1].RectTransform]},{"a":2,"n":"Clear","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":2,"n":"FlyToTarget","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"durationFlightUp","pt":$n[0].Single,"ps":2},{"n":"durationFlightDown","pt":$n[0].Single,"ps":3},{"n":"height","pt":$n[0].Single,"ps":4},{"n":"widthRange","pt":$n[0].Single,"ps":5},{"n":"complete","pt":Function,"ps":6},{"n":"scaleEnd","dv":null,"o":true,"pt":$n[1].Vector3,"ps":7}],"sn":"FlyToTarget","rt":$n[4].Sequence,"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,Function,$n[1].Vector3]},{"a":2,"n":"GetCoordinate","is":true,"t":8,"pi":[{"n":"coordinate","pt":$n[1].Vector2Int,"ps":0},{"n":"direction","pt":Direction,"ps":1}],"sn":"GetCoordinate","rt":$n[1].Vector2Int,"p":[$n[1].Vector2Int,Direction]},{"a":2,"n":"GetNumberFromText","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0}],"sn":"GetNumberFromText","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetTextValueFromNumber","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"GetTextValueFromNumber","rt":$n[0].String,"p":[$n[0].Int32]},{"a":2,"n":"Jump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Transform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"height","pt":$n[0].Single,"ps":3},{"n":"numJumps","dv":1,"o":true,"pt":$n[0].Int32,"ps":4}],"sn":"Jump","rt":$n[4].Sequence,"p":[$n[1].Transform,$n[1].Vector3,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"WorldToCanvasPosition","is":true,"t":8,"pi":[{"n":"camera","pt":$n[1].Camera,"ps":0},{"n":"canvas","pt":$n[1].Canvas,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2}],"sn":"WorldToCanvasPosition","rt":$n[1].Vector3,"p":[$n[1].Camera,$n[1].Canvas,$n[1].Vector3]}]}; }, $n);
    /*Extension end.*/

    /*AnimatorComponent start.*/
    $m("AnimatorComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Play","t":8,"pi":[{"n":"animationName","pt":$n[0].String,"ps":0},{"n":"layer","dv":-1,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"normalizedTime","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"Play","rt":$n[0].Void,"p":[$n[0].String,$n[0].Int32,$n[0].Single]},{"a":2,"n":"SetSpeed","t":8,"pi":[{"n":"speed","pt":$n[0].Single,"ps":0}],"sn":"SetSpeed","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"Stop","t":8,"sn":"Stop","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"_animator","t":4,"rt":$n[1].Animator,"sn":"_animator"}]}; }, $n);
    /*AnimatorComponent end.*/

    /*CollisionComponent start.*/
    $m("CollisionComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnTriggerEnter","t":8,"pi":[{"n":"other","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerEnter","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":1,"n":"OnTriggerExit","t":8,"pi":[{"n":"other","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerExit","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":1,"n":"OnTriggerStay","t":8,"pi":[{"n":"other","pt":$n[1].Collider,"ps":0}],"sn":"OnTriggerStay","rt":$n[0].Void,"p":[$n[1].Collider]},{"a":2,"n":"ActionTriggerEnter","t":4,"rt":Function,"sn":"ActionTriggerEnter"},{"a":2,"n":"ActionTriggerExit","t":4,"rt":Function,"sn":"ActionTriggerExit"},{"a":2,"n":"ActionTriggerStay","t":4,"rt":Function,"sn":"ActionTriggerStay"}]}; }, $n);
    /*CollisionComponent end.*/

    /*ColorConfig start.*/
    $m("ColorConfig", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Game/Level/Config/Color", fileName: "Color Config", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetColor","t":8,"pi":[{"n":"type","pt":EColorType,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[EColorType]},{"a":2,"n":"GetData","t":8,"pi":[{"n":"type","pt":EColorType,"ps":0}],"sn":"GetData","rt":ColorData,"p":[EColorType]},{"a":2,"n":"Colors","t":16,"rt":$n[3].List$1(ColorData),"g":{"a":2,"n":"get_Colors","t":8,"rt":$n[3].List$1(ColorData),"fg":"Colors"},"fn":"Colors"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"colors","t":4,"rt":$n[3].List$1(ColorData),"sn":"colors"}]}; }, $n);
    /*ColorConfig end.*/

    /*ColorData start.*/
    $m("ColorData", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Color","t":16,"rt":$n[1].Color,"g":{"a":2,"n":"get_Color","t":8,"rt":$n[1].Color,"fg":"Color"},"fn":"Color"},{"a":2,"n":"Type","t":16,"rt":EColorType,"g":{"a":2,"n":"get_Type","t":8,"rt":EColorType,"fg":"Type","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},"fn":"Type"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"color","t":4,"rt":$n[1].Color,"sn":"color"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"type","t":4,"rt":EColorType,"sn":"type","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}}]}; }, $n);
    /*ColorData end.*/

    /*EColorType start.*/
    $m("EColorType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"BLUE","is":true,"t":4,"rt":EColorType,"sn":"BLUE","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"CYAN","is":true,"t":4,"rt":EColorType,"sn":"CYAN","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"DARK_GREEN","is":true,"t":4,"rt":EColorType,"sn":"DARK_GREEN","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"GREEN","is":true,"t":4,"rt":EColorType,"sn":"GREEN","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"NONE","is":true,"t":4,"rt":EColorType,"sn":"NONE","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"ORANGE","is":true,"t":4,"rt":EColorType,"sn":"ORANGE","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"PINK","is":true,"t":4,"rt":EColorType,"sn":"PINK","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"RED","is":true,"t":4,"rt":EColorType,"sn":"RED","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"TIFFANY_BLUE","is":true,"t":4,"rt":EColorType,"sn":"TIFFANY_BLUE","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"VIOLET","is":true,"t":4,"rt":EColorType,"sn":"VIOLET","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"a":2,"n":"YELLOW","is":true,"t":4,"rt":EColorType,"sn":"YELLOW","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}}]}; }, $n);
    /*EColorType end.*/

    /*DirectionConfig start.*/
    $m("DirectionConfig", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Game/Level/Config/Direction", fileName: "Direction Config", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetData","t":8,"pi":[{"n":"type","pt":EDirectionType,"ps":0}],"sn":"GetData","rt":DirectionData,"p":[EDirectionType]},{"a":2,"n":"GetDirection","t":8,"pi":[{"n":"type","pt":EDirectionType,"ps":0}],"sn":"GetDirection","rt":$n[1].Vector2,"p":[EDirectionType]},{"a":2,"n":"Datas","t":16,"rt":$n[3].List$1(DirectionData),"g":{"a":2,"n":"get_Datas","t":8,"rt":$n[3].List$1(DirectionData),"fg":"Datas"},"fn":"Datas"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"datas","t":4,"rt":$n[3].List$1(DirectionData),"sn":"datas"}]}; }, $n);
    /*DirectionConfig end.*/

    /*DirectionData start.*/
    $m("DirectionData", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Direction","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_Direction","t":8,"rt":$n[1].Vector2,"fg":"Direction"},"fn":"Direction"},{"a":2,"n":"EDirectionType","t":16,"rt":EDirectionType,"g":{"a":2,"n":"get_EDirectionType","t":8,"rt":EDirectionType,"fg":"EDirectionType","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}},"fn":"EDirectionType"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"direction","t":4,"rt":$n[1].Vector2,"sn":"direction"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eDirectionType","t":4,"rt":EDirectionType,"sn":"eDirectionType","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}}]}; }, $n);
    /*DirectionData end.*/

    /*EDirectionType start.*/
    $m("EDirectionType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DOWN","is":true,"t":4,"rt":EDirectionType,"sn":"DOWN","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}},{"a":2,"n":"LEFT","is":true,"t":4,"rt":EDirectionType,"sn":"LEFT","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}},{"a":2,"n":"NONE","is":true,"t":4,"rt":EDirectionType,"sn":"NONE","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}},{"a":2,"n":"RIGHT","is":true,"t":4,"rt":EDirectionType,"sn":"RIGHT","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}},{"a":2,"n":"UP","is":true,"t":4,"rt":EDirectionType,"sn":"UP","box":function ($v) { return Bridge.box($v, EDirectionType, System.Enum.toStringFn(EDirectionType));}}]}; }, $n);
    /*EDirectionType end.*/

    /*LevelConfig start.*/
    $m("LevelConfig", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*LevelConfig end.*/

    /*LevelModeData start.*/
    $m("LevelModeData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Data/LevelModeData", fileName: "level_mode_data"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetLevelData","t":8,"sn":"GetLevelData","rt":$n[0].ValueTuple$2(LevelModeInfor,LevelTypeInfor)},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentLevel","t":4,"rt":$n[6].IntegerVariable,"sn":"currentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelModeInfors","t":4,"rt":$n[3].List$1(LevelModeInfor),"sn":"levelModeInfors"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelSettings","t":4,"rt":$n[10].LevelSettings,"sn":"levelSettings"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelTypeData","t":4,"rt":LevelTypeData,"sn":"levelTypeData"}]}; }, $n);
    /*LevelModeData end.*/

    /*LevelModeInfor start.*/
    $m("LevelModeInfor", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"levelIndex","t":4,"rt":$n[0].Int32,"sn":"levelIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"levelMode","t":4,"rt":ELevelMode,"sn":"levelMode","box":function ($v) { return Bridge.box($v, ELevelMode, System.Enum.toStringFn(ELevelMode));}},{"a":2,"n":"star","t":4,"rt":$n[0].Int32,"sn":"star","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*LevelModeInfor end.*/

    /*ELevelMode start.*/
    $m("ELevelMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Hard","is":true,"t":4,"rt":ELevelMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, ELevelMode, System.Enum.toStringFn(ELevelMode));}},{"a":2,"n":"Normal","is":true,"t":4,"rt":ELevelMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, ELevelMode, System.Enum.toStringFn(ELevelMode));}},{"a":2,"n":"VeryHard","is":true,"t":4,"rt":ELevelMode,"sn":"VeryHard","box":function ($v) { return Bridge.box($v, ELevelMode, System.Enum.toStringFn(ELevelMode));}}]}; }, $n);
    /*ELevelMode end.*/

    /*LevelTypeData start.*/
    $m("LevelTypeData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Data/LevelTypeData", fileName: "level_type_data"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetLevelTypeInfor","t":8,"pi":[{"n":"getLevelMode","pt":ELevelMode,"ps":0}],"sn":"GetLevelTypeInfor","rt":LevelTypeInfor,"p":[ELevelMode]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelTypeInfors","t":4,"rt":$n[3].List$1(LevelTypeInfor),"sn":"levelTypeInfors"}]}; }, $n);
    /*LevelTypeData end.*/

    /*LevelTypeInfor start.*/
    $m("LevelTypeInfor", function () { return {"nested":[LevelTypeInfor.BoosterIconData],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetBoosterSprite","t":8,"pi":[{"n":"getElementType","pt":EElementType,"ps":0}],"sn":"GetBoosterSprite","rt":$n[1].Sprite,"p":[EElementType]},{"a":2,"n":"GetBoosterSpriteLock","t":8,"pi":[{"n":"getElementType","pt":EElementType,"ps":0}],"sn":"GetBoosterSpriteLock","rt":$n[1].Sprite,"p":[EElementType]},{"a":2,"n":"GetColorTextLevelModeGameplay","t":8,"sn":"GetColorTextLevelModeGameplay","rt":$n[1].Material},{"a":2,"n":"GetColorTextLevelModeHome","t":8,"sn":"GetColorTextLevelModeHome","rt":$n[1].Material},{"a":2,"n":"GetIconBoardLevelSprite","t":8,"sn":"GetIconBoardLevelSprite","rt":$n[1].Sprite},{"a":2,"n":"GetIconReplayLevelSprite","t":8,"sn":"GetIconReplayLevelSprite","rt":$n[1].Sprite},{"a":2,"n":"GetIconSettingSprite","t":8,"sn":"GetIconSettingSprite","rt":$n[1].Sprite},{"a":2,"n":"LevelMode","t":4,"rt":ELevelMode,"sn":"LevelMode","box":function ($v) { return Bridge.box($v, ELevelMode, System.Enum.toStringFn(ELevelMode));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boosterIconDatas","t":4,"rt":$n[3].List$1(LevelTypeInfor.BoosterIconData),"sn":"boosterIconDatas"},{"a":2,"n":"coinBonus","t":4,"rt":$n[0].Int32,"sn":"coinBonus","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"colorTextGameplay","t":4,"rt":$n[1].Material,"sn":"colorTextGameplay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"colorTextHome","t":4,"rt":$n[1].Material,"sn":"colorTextHome"},{"a":2,"n":"description","t":4,"rt":$n[0].String,"sn":"description"},{"a":2,"n":"icon","t":4,"rt":$n[1].Sprite,"sn":"icon"},{"a":2,"n":"iconBoardGameplay","t":4,"rt":$n[1].Sprite,"sn":"iconBoardGameplay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconBoardLevel","t":4,"rt":$n[1].Sprite,"sn":"iconBoardLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconReplay","t":4,"rt":$n[1].Sprite,"sn":"iconReplay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconSetting","t":4,"rt":$n[1].Sprite,"sn":"iconSetting"},{"a":2,"n":"soundStartGame","t":4,"rt":$n[5].SoundData,"sn":"soundStartGame"}]}; }, $n);
    /*LevelTypeInfor end.*/

    /*LevelTypeInfor+BoosterIconData start.*/
    $m("LevelTypeInfor.BoosterIconData", function () { return {"td":LevelTypeInfor,"att":1057035,"a":1,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"elementType","t":4,"rt":EElementType,"sn":"elementType","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"icon","t":4,"rt":$n[1].Sprite,"sn":"icon"},{"a":2,"n":"iconLock","t":4,"rt":$n[1].Sprite,"sn":"iconLock"}]}; }, $n);
    /*LevelTypeInfor+BoosterIconData end.*/

    /*EElementType start.*/
    $m("EElementType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Air","is":true,"t":4,"rt":EElementType,"sn":"Air","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"Dark","is":true,"t":4,"rt":EElementType,"sn":"Dark","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"Earth","is":true,"t":4,"rt":EElementType,"sn":"Earth","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"Fire","is":true,"t":4,"rt":EElementType,"sn":"Fire","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"Light","is":true,"t":4,"rt":EElementType,"sn":"Light","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"None","is":true,"t":4,"rt":EElementType,"sn":"None","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}},{"a":2,"n":"Water","is":true,"t":4,"rt":EElementType,"sn":"Water","box":function ($v) { return Bridge.box($v, EElementType, System.Enum.toStringFn(EElementType));}}]}; }, $n);
    /*EElementType end.*/

    /*FreezeSystem start.*/
    $m("FreezeSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","t":8,"pi":[{"n":"freezer","pt":IFreezer,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[IFreezer]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"CheckNull","t":8,"sn":"CheckNull","rt":$n[0].Void},{"a":1,"n":"Contains","t":8,"pi":[{"n":"freezer","pt":$n[1].GameObject,"ps":0}],"sn":"Contains","rt":$n[0].Boolean,"p":[$n[1].GameObject],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"GetFreezer","t":8,"pi":[{"n":"freezer","pt":$n[1].GameObject,"ps":0}],"sn":"GetFreezer","rt":FreezeLinker,"p":[$n[1].GameObject]},{"a":1,"n":"GetPrefab","t":8,"pi":[{"n":"freezer","pt":$n[1].GameObject,"ps":0}],"sn":"GetPrefab","rt":FreezePrefab,"p":[$n[1].GameObject]},{"a":2,"n":"OnChange","t":8,"pi":[{"n":"value","dv":1,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"OnChange","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"OnFreezerBreak","t":8,"pi":[{"n":"freezer","pt":IFreezer,"ps":0},{"n":"prefab","pt":FreezePrefab,"ps":1}],"sn":"OnFreezerBreak","rt":$n[0].Void,"p":[IFreezer,FreezePrefab]},{"a":2,"n":"OnFreezerCrack","t":8,"pi":[{"n":"iFreezer","pt":IFreezer,"ps":0},{"n":"value","dv":1,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"OnFreezerCrack","rt":$n[0].Void,"p":[IFreezer,$n[0].Int32]},{"a":2,"n":"Remove","t":8,"pi":[{"n":"freezer","pt":IFreezer,"ps":0}],"sn":"Remove","rt":$n[0].Void,"p":[IFreezer]},{"a":2,"n":"Material","t":16,"rt":$n[1].Material,"g":{"a":2,"n":"get_Material","t":8,"rt":$n[1].Material,"fg":"Material"},"fn":"Material"},{"a":2,"n":"freezePrefab","t":16,"rt":FreezePrefab,"g":{"a":2,"n":"get_freezePrefab","t":8,"rt":FreezePrefab,"fg":"freezePrefab"},"fn":"freezePrefab"},{"a":1,"n":"_dicData","t":4,"rt":$n[3].Dictionary$2(IFreezer,FreezePrefab),"sn":"_dicData"},{"a":1,"n":"_fxBreak","t":4,"rt":$n[1].ParticleSystem,"sn":"_fxBreak"},{"a":1,"n":"_soundCrack","t":4,"rt":$n[5].SoundData,"sn":"_soundCrack"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"configs","t":4,"rt":$n[3].List$1(FreezeConfig),"sn":"configs"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listLinker","t":4,"rt":$n[3].List$1(FreezeLinker),"sn":"listLinker"},{"at":[new UnityEngine.HeaderAttribute("Audio"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"type","t":4,"rt":EFreezeType,"sn":"type","box":function ($v) { return Bridge.box($v, EFreezeType, System.Enum.toStringFn(EFreezeType));}}]}; }, $n);
    /*FreezeSystem end.*/

    /*FreezeLinker start.*/
    $m("FreezeLinker", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"p":[$n[1].GameObject,FreezePrefab],"pi":[{"n":"freezer","pt":$n[1].GameObject,"ps":0},{"n":"prefab","pt":FreezePrefab,"ps":1}],"sn":"ctor"},{"a":2,"n":"Freezer","t":16,"rt":$n[1].GameObject,"g":{"a":2,"n":"get_Freezer","t":8,"rt":$n[1].GameObject,"fg":"Freezer"},"fn":"Freezer"},{"a":2,"n":"Prefab","t":16,"rt":FreezePrefab,"g":{"a":2,"n":"get_Prefab","t":8,"rt":FreezePrefab,"fg":"Prefab"},"fn":"Prefab"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"freezer","t":4,"rt":$n[1].GameObject,"sn":"freezer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"prefab","t":4,"rt":FreezePrefab,"sn":"prefab"}]}; }, $n);
    /*FreezeLinker end.*/

    /*FreezeConfig start.*/
    $m("FreezeConfig", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"FreezePrefab","t":16,"rt":FreezePrefab,"g":{"a":2,"n":"get_FreezePrefab","t":8,"rt":FreezePrefab,"fg":"FreezePrefab"},"fn":"FreezePrefab"},{"a":2,"n":"FxBreak","t":16,"rt":$n[1].ParticleSystem,"g":{"a":2,"n":"get_FxBreak","t":8,"rt":$n[1].ParticleSystem,"fg":"FxBreak"},"fn":"FxBreak"},{"a":2,"n":"Material","t":16,"rt":$n[1].Material,"g":{"a":2,"n":"get_Material","t":8,"rt":$n[1].Material,"fg":"Material"},"fn":"Material"},{"a":2,"n":"SoundCrack","t":16,"rt":$n[5].SoundData,"g":{"a":2,"n":"get_SoundCrack","t":8,"rt":$n[5].SoundData,"fg":"SoundCrack"},"fn":"SoundCrack"},{"a":2,"n":"Type","t":16,"rt":EFreezeType,"g":{"a":2,"n":"get_Type","t":8,"rt":EFreezeType,"fg":"Type","box":function ($v) { return Bridge.box($v, EFreezeType, System.Enum.toStringFn(EFreezeType));}},"fn":"Type"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"freezePrefab","t":4,"rt":FreezePrefab,"sn":"freezePrefab"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"fxBreak","t":4,"rt":$n[1].ParticleSystem,"sn":"fxBreak"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundCrack","t":4,"rt":$n[5].SoundData,"sn":"soundCrack"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"type","t":4,"rt":EFreezeType,"sn":"type","box":function ($v) { return Bridge.box($v, EFreezeType, System.Enum.toStringFn(EFreezeType));}}]}; }, $n);
    /*FreezeConfig end.*/

    /*EFreezeType start.*/
    $m("EFreezeType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":EFreezeType,"sn":"Normal","box":function ($v) { return Bridge.box($v, EFreezeType, System.Enum.toStringFn(EFreezeType));}},{"a":2,"n":"Wood","is":true,"t":4,"rt":EFreezeType,"sn":"Wood","box":function ($v) { return Bridge.box($v, EFreezeType, System.Enum.toStringFn(EFreezeType));}}]}; }, $n);
    /*EFreezeType end.*/

    /*IFreezer start.*/
    $m("IFreezer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"OnFreezerBreak","t":8,"sn":"IFreezer$OnFreezerBreak","rt":$n[0].Void},{"ab":true,"a":2,"n":"OnFreezerChanged","t":8,"sn":"IFreezer$OnFreezerChanged","rt":$n[0].Void},{"ab":true,"a":2,"n":"OnFreezerSetup","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"IFreezer$OnFreezerSetup","rt":$n[0].Void,"p":[$n[1].Material]},{"ab":true,"a":2,"n":"FreezeCenterPosition","t":16,"rt":$n[1].Vector3,"g":{"ab":true,"a":2,"n":"get_FreezeCenterPosition","t":8,"rt":$n[1].Vector3,"fg":"IFreezer$FreezeCenterPosition"},"fn":"IFreezer$FreezeCenterPosition"},{"ab":true,"a":2,"n":"FreezeCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_FreezeCount","t":8,"rt":$n[0].Int32,"fg":"IFreezer$FreezeCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"IFreezer$FreezeCount"},{"ab":true,"a":2,"n":"FreezeCurrentCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_FreezeCurrentCount","t":8,"rt":$n[0].Int32,"fg":"IFreezer$FreezeCurrentCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"ab":true,"a":2,"n":"set_FreezeCurrentCount","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"IFreezer$FreezeCurrentCount"},"fn":"IFreezer$FreezeCurrentCount"},{"ab":true,"a":2,"n":"GameObject","t":16,"rt":$n[1].GameObject,"g":{"ab":true,"a":2,"n":"get_GameObject","t":8,"rt":$n[1].GameObject,"fg":"IFreezer$GameObject"},"fn":"IFreezer$GameObject"},{"ab":true,"a":2,"n":"IsFrezering","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsFrezering","t":8,"rt":$n[0].Boolean,"fg":"IFreezer$IsFrezering","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_IsFrezering","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IFreezer$IsFrezering"},"fn":"IFreezer$IsFrezering"},{"ab":true,"a":2,"n":"TextSize","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_TextSize","t":8,"rt":$n[0].Single,"fg":"IFreezer$TextSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"IFreezer$TextSize"},{"a":1,"backing":true,"n":"<FreezeCenterPosition>k__BackingField","t":4,"rt":$n[1].Vector3,"sn":"IFreezer$FreezeCenterPosition"},{"a":1,"backing":true,"n":"<FreezeCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"IFreezer$FreezeCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<FreezeCurrentCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"IFreezer$FreezeCurrentCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<GameObject>k__BackingField","t":4,"rt":$n[1].GameObject,"sn":"IFreezer$GameObject"},{"a":1,"backing":true,"n":"<IsFrezering>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IFreezer$IsFrezering","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<TextSize>k__BackingField","t":4,"rt":$n[0].Single,"sn":"IFreezer$TextSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*IFreezer end.*/

    /*FreezePrefab start.*/
    $m("FreezePrefab", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"SetUp","t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"textSize","pt":$n[0].Single,"ps":2}],"sn":"SetUp","rt":$n[0].Void,"p":[$n[1].Vector3,$n[0].Int32,$n[0].Single]},{"a":2,"n":"UpdateUI","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"UpdateUI","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"txtCount","t":4,"rt":$n[7].TextMeshPro,"sn":"txtCount"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"yAxis","t":4,"rt":$n[0].Single,"sn":"yAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*FreezePrefab end.*/

    /*IObject start.*/
    $m("IObject", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Size","t":16,"rt":$n[1].Vector2,"g":{"ab":true,"a":2,"n":"get_Size","t":8,"rt":$n[1].Vector2,"fg":"IObject$Size"},"fn":"IObject$Size"},{"ab":true,"a":2,"n":"YAxis","t":16,"rt":$n[0].Single,"g":{"ab":true,"a":2,"n":"get_YAxis","t":8,"rt":$n[0].Single,"fg":"IObject$YAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"IObject$YAxis"},{"a":1,"backing":true,"n":"<Size>k__BackingField","t":4,"rt":$n[1].Vector2,"sn":"IObject$Size"},{"a":1,"backing":true,"n":"<YAxis>k__BackingField","t":4,"rt":$n[0].Single,"sn":"IObject$YAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*IObject end.*/

    /*ObjectBase start.*/
    $m("ObjectBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"ChangeColorType","t":8,"pi":[{"n":"eColorTypeChange","pt":EColorType,"ps":0},{"n":"materialChange","pt":$n[1].Material,"ps":1}],"sn":"ChangeColorType","rt":$n[0].Void,"p":[EColorType,$n[1].Material]},{"a":2,"n":"ChangeMesh","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"ChangeMesh","rt":$n[0].Void,"p":[$n[1].Mesh]},{"v":true,"a":2,"n":"Dead","t":8,"sn":"Dead","rt":$n[0].Void},{"a":2,"n":"GetCenterPosition","t":8,"sn":"GetCenterPosition","rt":$n[1].Vector3},{"a":2,"n":"GetHeight","t":8,"pi":[{"n":"eDirection","pt":EDirectionType,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"GetHeight","rt":$n[0].Single,"p":[EDirectionType,$n[1].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetPostion","t":8,"sn":"GetPostion","rt":$n[1].Vector3},{"a":3,"n":"GetSize","t":8,"sn":"GetSize","rt":$n[1].Vector2},{"a":2,"n":"GetWidth","t":8,"pi":[{"n":"eDirection","pt":EDirectionType,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"GetWidth","rt":$n[0].Single,"p":[EDirectionType,$n[1].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetYAngle","t":8,"sn":"GetYAngle","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"v":true,"a":2,"n":"OnFreezerBreak","t":8,"sn":"OnFreezerBreak","rt":$n[0].Void},{"a":2,"n":"OnFreezerChanged","t":8,"sn":"OnFreezerChanged","rt":$n[0].Void},{"v":true,"a":2,"n":"OnFreezerSetup","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"OnFreezerSetup","rt":$n[0].Void,"p":[$n[1].Material]},{"v":true,"a":3,"n":"OnStarttingLevel","t":8,"pi":[{"n":"value","pt":$n[0].Boolean,"ps":0}],"sn":"OnStarttingLevel","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetPosition","t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0}],"sn":"SetPosition","rt":$n[0].Void,"p":[$n[1].Vector3]},{"v":true,"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":3,"n":"UpdateRotation","t":8,"sn":"UpdateRotation","rt":$n[0].Void},{"a":2,"n":"Color","t":16,"rt":$n[1].Color,"g":{"a":2,"n":"get_Color","t":8,"rt":$n[1].Color,"fg":"Color"},"fn":"Color"},{"a":2,"n":"EColorType","t":16,"rt":EColorType,"g":{"a":2,"n":"get_EColorType","t":8,"rt":EColorType,"fg":"EColorType","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},"fn":"EColorType"},{"a":2,"n":"FreezeCenterPosition","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_FreezeCenterPosition","t":8,"rt":$n[1].Vector3,"fg":"FreezeCenterPosition"},"fn":"FreezeCenterPosition"},{"a":2,"n":"FreezeCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FreezeCount","t":8,"rt":$n[0].Int32,"fg":"FreezeCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"FreezeCount"},{"a":2,"n":"FreezeCurrentCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_FreezeCurrentCount","t":8,"rt":$n[0].Int32,"fg":"FreezeCurrentCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_FreezeCurrentCount","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"FreezeCurrentCount"},"fn":"FreezeCurrentCount"},{"a":2,"n":"GameObject","t":16,"rt":$n[1].GameObject,"g":{"a":2,"n":"get_GameObject","t":8,"rt":$n[1].GameObject,"fg":"GameObject"},"fn":"GameObject"},{"a":2,"n":"IsAlive","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsAlive","t":8,"rt":$n[0].Boolean,"fg":"IsAlive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsAlive"},{"v":true,"a":2,"n":"IsCanMove","t":16,"rt":$n[0].Boolean,"g":{"v":true,"a":2,"n":"get_IsCanMove","t":8,"rt":$n[0].Boolean,"fg":"IsCanMove","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsCanMove"},{"a":2,"n":"IsFrezering","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsFrezering","t":8,"rt":$n[0].Boolean,"fg":"IsFrezering","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsFrezering","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsFrezering"},"fn":"IsFrezering"},{"a":2,"n":"IsHaveStar","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsHaveStar","t":8,"rt":$n[0].Boolean,"fg":"IsHaveStar","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsHaveStar"},{"a":2,"n":"ListColliders","t":16,"rt":$n[3].List$1(UnityEngine.Collider),"g":{"a":2,"n":"get_ListColliders","t":8,"rt":$n[3].List$1(UnityEngine.Collider),"fg":"ListColliders"},"fn":"ListColliders"},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"Model","t":16,"rt":$n[1].GameObject,"g":{"a":2,"n":"get_Model","t":8,"rt":$n[1].GameObject,"fg":"Model"},"fn":"Model"},{"a":2,"n":"Renderer","t":16,"rt":$n[1].Renderer,"g":{"a":2,"n":"get_Renderer","t":8,"rt":$n[1].Renderer,"fg":"Renderer"},"fn":"Renderer"},{"a":2,"n":"Size","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_Size","t":8,"rt":$n[1].Vector2,"fg":"Size"},"fn":"Size"},{"a":2,"n":"TextSize","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TextSize","t":8,"rt":$n[0].Single,"fg":"TextSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TextSize"},{"a":2,"n":"YAxis","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_YAxis","t":8,"rt":$n[0].Single,"fg":"YAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"YAxis"},{"a":3,"n":"_isAlive","t":4,"rt":$n[0].Boolean,"sn":"_isAlive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"_meshFilter"},{"a":1,"n":"_renderer","t":4,"rt":$n[1].Renderer,"sn":"_renderer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"centerModel","t":4,"rt":$n[1].GameObject,"sn":"centerModel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"colorConfig","t":4,"rt":ColorConfig,"sn":"colorConfig"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"colorMaterialName","t":4,"rt":$n[0].String,"sn":"colorMaterialName"},{"at":[new UnityEngine.HeaderAttribute("Color"),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"eColorType","t":4,"rt":EColorType,"sn":"eColorType","box":function ($v) { return Bridge.box($v, EColorType, System.Enum.toStringFn(EColorType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"eRotationType","t":4,"rt":ERotationType,"sn":"eRotationType","box":function ($v) { return Bridge.box($v, ERotationType, System.Enum.toStringFn(ERotationType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"freezeCount","t":4,"rt":$n[0].Int32,"sn":"freezeCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"girdSize","t":4,"rt":$n[6].Vector3Variable,"sn":"girdSize"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"heightOrigin","t":4,"rt":$n[0].Single,"sn":"heightOrigin","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Freeze"),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"isFreeze","t":4,"rt":$n[0].Boolean,"sn":"isFreeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Texture"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isHaveStar","t":4,"rt":$n[0].Boolean,"sn":"isHaveStar","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isStarttingLevel","t":4,"rt":$n[6].BooleanVariable,"sn":"isStarttingLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listColliders","t":4,"rt":$n[3].List$1(UnityEngine.Collider),"sn":"listColliders"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"materialCurrent","t":4,"rt":$n[1].Material,"sn":"materialCurrent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"materialFreezeOverride","t":4,"rt":$n[1].Material,"sn":"materialFreezeOverride"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"model","t":4,"rt":$n[1].GameObject,"sn":"model"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"objectName","t":4,"rt":$n[0].String,"sn":"objectName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"objectStar","t":4,"rt":ObjectStar,"sn":"objectStar"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"objectStarPrefab","t":4,"rt":ObjectStar,"sn":"objectStarPrefab"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"path","t":4,"rt":$n[0].String,"sn":"path"},{"at":[new UnityEngine.HeaderAttribute("Pivot"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pivotType","t":4,"rt":EPivotType,"sn":"pivotType","box":function ($v) { return Bridge.box($v, EPivotType, System.Enum.toStringFn(EPivotType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"size","t":4,"rt":$n[1].Vector3,"sn":"size"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"textSize","t":4,"rt":$n[0].Single,"sn":"textSize","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"yAxis","t":4,"rt":$n[0].Single,"sn":"yAxis","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<FreezeCurrentCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"FreezeCurrentCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<IsFrezering>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsFrezering","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*ObjectBase end.*/

    /*EPivotType start.*/
    $m("EPivotType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"LEFT_BOTTOM","is":true,"t":4,"rt":EPivotType,"sn":"LEFT_BOTTOM","box":function ($v) { return Bridge.box($v, EPivotType, System.Enum.toStringFn(EPivotType));}},{"a":2,"n":"LEFT_TOP","is":true,"t":4,"rt":EPivotType,"sn":"LEFT_TOP","box":function ($v) { return Bridge.box($v, EPivotType, System.Enum.toStringFn(EPivotType));}},{"a":2,"n":"NONE","is":true,"t":4,"rt":EPivotType,"sn":"NONE","box":function ($v) { return Bridge.box($v, EPivotType, System.Enum.toStringFn(EPivotType));}},{"a":2,"n":"RIGHT_BOTTOM","is":true,"t":4,"rt":EPivotType,"sn":"RIGHT_BOTTOM","box":function ($v) { return Bridge.box($v, EPivotType, System.Enum.toStringFn(EPivotType));}},{"a":2,"n":"RIGHT_TOP","is":true,"t":4,"rt":EPivotType,"sn":"RIGHT_TOP","box":function ($v) { return Bridge.box($v, EPivotType, System.Enum.toStringFn(EPivotType));}}]}; }, $n);
    /*EPivotType end.*/

    /*ERotationType start.*/
    $m("ERotationType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DOWN","is":true,"t":4,"rt":ERotationType,"sn":"DOWN","box":function ($v) { return Bridge.box($v, ERotationType, System.Enum.toStringFn(ERotationType));}},{"a":2,"n":"LEFT","is":true,"t":4,"rt":ERotationType,"sn":"LEFT","box":function ($v) { return Bridge.box($v, ERotationType, System.Enum.toStringFn(ERotationType));}},{"a":2,"n":"RIGHT","is":true,"t":4,"rt":ERotationType,"sn":"RIGHT","box":function ($v) { return Bridge.box($v, ERotationType, System.Enum.toStringFn(ERotationType));}},{"a":2,"n":"UP","is":true,"t":4,"rt":ERotationType,"sn":"UP","box":function ($v) { return Bridge.box($v, ERotationType, System.Enum.toStringFn(ERotationType));}}]}; }, $n);
    /*ERotationType end.*/

    /*Plane start.*/
    $m("Plane", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"SetSize","t":8,"pi":[{"n":"size","pt":$n[1].Vector3,"ps":0}],"sn":"SetSize","rt":$n[0].Void,"p":[$n[1].Vector3]}]}; }, $n);
    /*Plane end.*/

    /*IShutter start.*/
    $m("IShutter", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"IsOpen","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsOpen","t":8,"rt":$n[0].Boolean,"fg":"IShutter$IsOpen","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_IsOpen","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IShutter$IsOpen"},"fn":"IShutter$IsOpen"},{"a":1,"backing":true,"n":"<IsOpen>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IShutter$IsOpen","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*IShutter end.*/

    /*Shutter start.*/
    $m("Shutter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Refresh","t":8,"sn":"Refresh","rt":$n[0].Void},{"a":2,"n":"SetStatus","t":8,"pi":[{"n":"isOpen","pt":$n[0].Boolean,"ps":0}],"sn":"SetStatus","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetUp","t":8,"pi":[{"n":"shutter","pt":IShutter,"ps":0},{"n":"isOpenDefault","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"SetUp","rt":$n[0].Void,"p":[IShutter,$n[0].Boolean]},{"a":2,"n":"Switch","t":8,"sn":"Switch","rt":$n[0].Void},{"a":1,"n":"_isOpen","t":4,"rt":$n[0].Boolean,"sn":"_isOpen","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_shutter","t":4,"rt":IShutter,"sn":"_shutter"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"animator","t":4,"rt":AnimatorComponent,"sn":"animator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"closeAnimName","t":4,"rt":$n[0].String,"sn":"closeAnimName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"openAnimName","t":4,"rt":$n[0].String,"sn":"openAnimName"},{"at":[new UnityEngine.HeaderAttribute("Audio"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundClose","t":4,"rt":$n[5].SoundData,"sn":"soundClose"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundOpen","t":4,"rt":$n[5].SoundData,"sn":"soundOpen"}]}; }, $n);
    /*Shutter end.*/

    /*ObjectStar start.*/
    $m("ObjectStar", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*ObjectStar end.*/

    /*ConnectionPrefab start.*/
    $m("ConnectionPrefab", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SetMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"SetMaterial","rt":$n[0].Void,"p":[$n[1].Material]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"render","t":4,"rt":$n[1].Renderer,"sn":"render"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"renderQueue","t":4,"rt":$n[0].Int32,"sn":"renderQueue","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*ConnectionPrefab end.*/

    /*GateSwitcher start.*/
    $m("GateSwitcher", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"SetMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"SetMaterial","rt":$n[0].Void,"p":[$n[1].Material]},{"a":2,"n":"SetUp","t":8,"pi":[{"n":"renderTarget","pt":$n[1].Renderer,"ps":0},{"n":"onSwith","dv":null,"o":true,"pt":Function,"ps":1}],"sn":"SetUp","rt":$n[0].Void,"p":[$n[1].Renderer,Function]},{"a":2,"n":"Switch","t":8,"pi":[{"n":"isCanSwitch","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Switch","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"MaterialDefault","t":16,"rt":$n[1].Material,"g":{"a":2,"n":"get_MaterialDefault","t":8,"rt":$n[1].Material,"fg":"MaterialDefault"},"fn":"MaterialDefault"},{"a":2,"n":"MaterialTarget","t":16,"rt":$n[1].Material,"g":{"a":2,"n":"get_MaterialTarget","t":8,"rt":$n[1].Material,"fg":"MaterialTarget"},"fn":"MaterialTarget"},{"a":1,"n":"_isCanSwitched","t":4,"rt":$n[0].Boolean,"sn":"_isCanSwitched","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_isSwitched","t":4,"rt":$n[0].Boolean,"sn":"_isSwitched","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_materialDefault","t":4,"rt":$n[1].Material,"sn":"_materialDefault"},{"a":1,"n":"_materialTarget","t":4,"rt":$n[1].Material,"sn":"_materialTarget"},{"a":1,"n":"_onSwith","t":4,"rt":Function,"sn":"_onSwith"},{"a":1,"n":"_rendererTarget","t":4,"rt":$n[1].Renderer,"sn":"_rendererTarget"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listRender","t":4,"rt":$n[3].List$1(UnityEngine.Renderer),"sn":"listRender"}]}; }, $n);
    /*GateSwitcher end.*/

    /*Wall start.*/
    $m("Wall", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"AutoSize","t":8,"sn":"AutoSize","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isAutoSize","t":4,"rt":$n[0].Boolean,"sn":"isAutoSize","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sizeOrigin","t":4,"rt":$n[1].Vector3,"sn":"sizeOrigin"}]}; }, $n);
    /*Wall end.*/

    /*WallPath start.*/
    $m("WallPath", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"MoveY","t":8,"pi":[{"n":"y","pt":$n[0].Single,"ps":0}],"sn":"MoveY","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnSelectBlock","t":8,"pi":[{"n":"isSelect","pt":$n[0].Boolean,"ps":0}],"sn":"OnSelectBlock","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"_tweenMove","t":4,"rt":$n[4].Tween,"sn":"_tweenMove"},{"a":1,"n":"_yAxisModelDefault","t":4,"rt":$n[0].Single,"sn":"_yAxisModelDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"distanceMove","t":4,"rt":$n[0].Single,"sn":"distanceMove","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeMove","t":4,"rt":$n[0].Single,"sn":"timeMove","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*WallPath end.*/

    /*HeartData start.*/
    $m("HeartData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Game/Level/Heart", fileName: "Heart", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new UnityEngine.ContextMenu.ctor("AddDebug")],"a":1,"n":"AddDebug","t":8,"sn":"AddDebug","rt":$n[0].Void},{"a":2,"n":"Minus","t":8,"pi":[{"n":"count","pt":$n[0].Int32,"ps":0}],"sn":"Minus","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new UnityEngine.ContextMenu.ctor("MinusDebug")],"a":1,"n":"MinusDebug","t":8,"sn":"MinusDebug","rt":$n[0].Void},{"a":1,"n":"OnUpate","t":8,"sn":"OnUpate","rt":$n[0].Void},{"a":2,"n":"Refesh","t":8,"sn":"Refesh","rt":$n[0].Void},{"at":[new UnityEngine.ContextMenu.ctor("ResetID")],"a":1,"n":"ResetID","t":8,"sn":"ResetID","rt":$n[0].Void},{"a":2,"n":"ResetTimeIncrease","t":8,"sn":"ResetTimeIncrease","rt":$n[0].Void},{"a":2,"n":"Count","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Count","t":8,"rt":$n[0].Int32,"fg":"Count","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Count","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Count"},"fn":"Count"},{"a":2,"n":"IsCanIncrease","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsCanIncrease","t":8,"rt":$n[0].Boolean,"fg":"IsCanIncrease","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsCanIncrease"},{"a":2,"n":"IsInitialized","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsInitialized","t":8,"rt":$n[0].Boolean,"fg":"IsInitialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsInitialized","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsInitialized"},"fn":"IsInitialized"},{"a":2,"n":"IsRunOutOfHeart","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsRunOutOfHeart","t":8,"rt":$n[0].Boolean,"fg":"IsRunOutOfHeart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsRunOutOfHeart"},{"a":2,"n":"Max","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Max","t":8,"rt":$n[0].Int32,"fg":"Max","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Max","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Max"},"fn":"Max"},{"a":2,"n":"StartTimeIncrease","t":16,"rt":$n[0].DateTime,"g":{"a":2,"n":"get_StartTimeIncrease","t":8,"rt":$n[0].DateTime,"fg":"StartTimeIncrease","box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},"s":{"a":2,"n":"set_StartTimeIncrease","t":8,"p":[$n[0].DateTime],"rt":$n[0].Void,"fs":"StartTimeIncrease"},"fn":"StartTimeIncrease"},{"a":2,"n":"TimeCurrent","t":16,"rt":$n[0].DateTime,"g":{"a":2,"n":"get_TimeCurrent","t":8,"rt":$n[0].DateTime,"fg":"TimeCurrent","box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},"fn":"TimeCurrent"},{"a":2,"n":"TimeRemainingToIncrease","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TimeRemainingToIncrease","t":8,"rt":$n[0].Int32,"fg":"TimeRemainingToIncrease","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TimeRemainingToIncrease"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"balanceAmount","t":4,"rt":$n[6].IntegerVariable,"sn":"balanceAmount"},{"at":[new UnityEngine.HeaderAttribute("Config"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"countIncrease","t":4,"rt":$n[0].Int32,"sn":"countIncrease","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"id","t":4,"rt":$n[0].String,"sn":"id"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"immortalData","t":4,"rt":ImmortalData,"sn":"immortalData"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"max","t":4,"rt":$n[0].Int32,"sn":"max","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeIncrease","t":4,"rt":$n[0].Int32,"sn":"timeIncrease","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updateHeartEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"updateHeartEvent"}]}; }, $n);
    /*HeartData end.*/

    /*HeartManager start.*/
    $m("HeartManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"IUpdateTimeIncreaseHeart","t":8,"sn":"IUpdateTimeIncreaseHeart","rt":$n[9].IEnumerator},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"_coroutineUpdateHeart","t":4,"rt":$n[1].Coroutine,"sn":"_coroutineUpdateHeart"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"heartData","t":4,"rt":HeartData,"sn":"heartData"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isDontDestroyOnLoad","t":4,"rt":$n[0].Boolean,"sn":"isDontDestroyOnLoad","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updatingTimeIncreaseHeart","t":4,"rt":$n[2].IntegerEvent,"sn":"updatingTimeIncreaseHeart"}]}; }, $n);
    /*HeartManager end.*/

    /*HeartUI start.*/
    $m("HeartUI", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ConvertSecondToTime","t":8,"pi":[{"n":"second","pt":$n[0].Int32,"ps":0}],"sn":"ConvertSecondToTime","rt":$n[0].TimeSpan,"p":[$n[0].Int32]},{"a":2,"n":"OnClickPlus","t":8,"sn":"OnClickPlus","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnEndStatusImmortal","t":8,"sn":"OnEndStatusImmortal","rt":$n[0].Void},{"a":1,"n":"OnInStatusImmortal","t":8,"sn":"OnInStatusImmortal","rt":$n[0].Void},{"a":1,"n":"OnUpdateHeart","t":8,"pi":[{"n":"heart","pt":$n[0].Int32,"ps":0}],"sn":"OnUpdateHeart","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"OnUpdatingTimeImmortal","t":8,"pi":[{"n":"time","pt":$n[0].Int32,"ps":0}],"sn":"OnUpdatingTimeImmortal","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"OnUpdatingTimeIncreaseHeart","t":8,"pi":[{"n":"time","pt":$n[0].Int32,"ps":0}],"sn":"OnUpdatingTimeIncreaseHeart","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"UpdateIcon","t":8,"sn":"UpdateIcon","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"heartData","t":4,"rt":HeartData,"sn":"heartData"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconHeart","t":4,"rt":$n[8].Image,"sn":"iconHeart"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconHeartImmortal","t":4,"rt":$n[1].Sprite,"sn":"iconHeartImmortal"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconHeartNormal","t":4,"rt":$n[1].Sprite,"sn":"iconHeartNormal"},{"at":[new UnityEngine.HeaderAttribute("Data"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"immortalData","t":4,"rt":ImmortalData,"sn":"immortalData"},{"at":[new UnityEngine.HeaderAttribute("Properties"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"plusIcon","t":4,"rt":$n[1].GameObject,"sn":"plusIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormatCount","t":4,"rt":$n[0].String,"sn":"stringFormatCount"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormatImmortalTimeWithDay","t":4,"rt":$n[0].String,"sn":"stringFormatImmortalTimeWithDay"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormatImmortalTimeWithHour","t":4,"rt":$n[0].String,"sn":"stringFormatImmortalTimeWithHour"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormatImmortalTimeWithMinute","t":4,"rt":$n[0].String,"sn":"stringFormatImmortalTimeWithMinute"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormatTime","t":4,"rt":$n[0].String,"sn":"stringFormatTime"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"txtCount","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"txtCount"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"txtFull","t":4,"rt":$n[1].GameObject,"sn":"txtFull"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"txtTime","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"txtTime"},{"at":[new UnityEngine.HeaderAttribute("Event"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updateHeartEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"updateHeartEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"updatingTimeIncreaseHeartEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"updatingTimeIncreaseHeartEvent"}]}; }, $n);
    /*HeartUI end.*/

    /*CellData start.*/
    $m("CellData", function () { return {"att":1057033,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"cell","t":4,"rt":CellGrid,"sn":"cell"},{"a":2,"n":"direction","t":4,"rt":Direction,"sn":"direction","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}}]}; }, $n);
    /*CellData end.*/

    /*CellGrid start.*/
    $m("CellGrid", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetAllNeighbours","t":8,"sn":"GetAllNeighbours","rt":$n[3].List$1(CellGrid)},{"a":2,"n":"GetNeighbour","t":8,"pi":[{"n":"direction","pt":Direction,"ps":0}],"sn":"GetNeighbour","rt":CellGrid,"p":[Direction]},{"a":2,"n":"PrepareNeighbour","t":8,"pi":[{"n":"data","pt":$n[3].List$1(CellData),"ps":0}],"sn":"PrepareNeighbour","rt":$n[0].Void,"p":[$n[3].List$1(CellData)]},{"a":2,"n":"coordinate","t":4,"rt":$n[1].Vector2Int,"sn":"coordinate"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"neighbours","t":4,"rt":$n[3].List$1(CellData),"sn":"neighbours"}]}; }, $n);
    /*CellGrid end.*/

    /*GridType start.*/
    $m("GridType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Hexagon","is":true,"t":4,"rt":GridType,"sn":"Hexagon","box":function ($v) { return Bridge.box($v, GridType, System.Enum.toStringFn(GridType));}},{"a":2,"n":"Rectangle","is":true,"t":4,"rt":GridType,"sn":"Rectangle","box":function ($v) { return Bridge.box($v, GridType, System.Enum.toStringFn(GridType));}}]}; }, $n);
    /*GridType end.*/

    /*AxisType start.*/
    $m("AxisType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XY","is":true,"t":4,"rt":AxisType,"sn":"XY","box":function ($v) { return Bridge.box($v, AxisType, System.Enum.toStringFn(AxisType));}},{"a":2,"n":"XZ","is":true,"t":4,"rt":AxisType,"sn":"XZ","box":function ($v) { return Bridge.box($v, AxisType, System.Enum.toStringFn(AxisType));}}]}; }, $n);
    /*AxisType end.*/

    /*Direction start.*/
    $m("Direction", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Down","is":true,"t":4,"rt":Direction,"sn":"Down","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"DownLeft","is":true,"t":4,"rt":Direction,"sn":"DownLeft","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"DownRight","is":true,"t":4,"rt":Direction,"sn":"DownRight","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"Left","is":true,"t":4,"rt":Direction,"sn":"Left","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"Right","is":true,"t":4,"rt":Direction,"sn":"Right","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"Up","is":true,"t":4,"rt":Direction,"sn":"Up","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"UpLeft","is":true,"t":4,"rt":Direction,"sn":"UpLeft","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}},{"a":2,"n":"UpRight","is":true,"t":4,"rt":Direction,"sn":"UpRight","box":function ($v) { return Bridge.box($v, Direction, System.Enum.toStringFn(Direction));}}]}; }, $n);
    /*Direction end.*/

    /*GridCreator start.*/
    $m("GridCreator", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CanSpawn","t":8,"pi":[{"n":"type","pt":GridType,"ps":0},{"n":"coordinate","pt":$n[1].Vector2Int,"ps":1}],"sn":"CanSpawn","rt":$n[0].Boolean,"p":[GridType,$n[1].Vector2Int],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Create","t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"gridType","pt":GridType,"ps":1},{"n":"axisType","pt":AxisType,"ps":2},{"n":"setting","pt":GridSetting,"ps":3},{"n":"size","pt":$n[1].Vector2,"ps":4},{"n":"createAsPrefab","pt":$n[0].Boolean,"ps":5},{"n":"sizeActive","pt":$n[1].Vector2,"ps":6}],"sn":"Create","rt":GridSystem,"p":[$n[1].Transform,GridType,AxisType,GridSetting,$n[1].Vector2,$n[0].Boolean,$n[1].Vector2]},{"a":1,"n":"GetDistance","t":8,"pi":[{"n":"gridType","pt":GridType,"ps":0},{"n":"cellSetting","pt":GridSetting,"ps":1}],"sn":"GetDistance","rt":$n[1].Vector2,"p":[GridType,GridSetting]},{"a":1,"n":"GetPrefab","t":8,"pi":[{"n":"gridType","pt":GridType,"ps":0},{"n":"cellSetting","pt":GridSetting,"ps":1}],"sn":"GetPrefab","rt":CellGrid,"p":[GridType,GridSetting]},{"a":1,"n":"GetcellPosition","t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0},{"n":"count","pt":$n[0].Int32,"ps":1},{"n":"type","pt":AxisType,"ps":2},{"n":"gridType","pt":GridType,"ps":3},{"n":"setting","pt":GridSetting,"ps":4}],"sn":"GetcellPosition","rt":$n[1].Vector3,"p":[$n[1].Vector3,$n[0].Int32,AxisType,GridType,GridSetting]},{"a":1,"n":"SetCenter","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].GameObject,"ps":0}],"sn":"SetCenter","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"SetNeighbor","t":8,"pi":[{"n":"manager","pt":GridSystem,"ps":0},{"n":"gridType","pt":GridType,"ps":1}],"sn":"SetNeighbor","rt":$n[0].Void,"p":[GridSystem,GridType]}]}; }, $n);
    /*GridCreator end.*/

    /*GridSystem start.*/
    $m("GridSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCell","t":8,"pi":[{"n":"coordinate","pt":$n[1].Vector2Int,"ps":0}],"sn":"GetCell","rt":CellGrid,"p":[$n[1].Vector2Int]},{"a":2,"n":"SetCells","t":8,"pi":[{"n":"cells","pt":$n[3].List$1(CellGrid),"ps":0}],"sn":"SetCells","rt":$n[0].Void,"p":[$n[3].List$1(CellGrid)]},{"a":2,"n":"CoordinateOrigin","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_CoordinateOrigin","t":8,"rt":$n[1].Vector3,"fg":"CoordinateOrigin"},"fn":"CoordinateOrigin"},{"a":2,"n":"cells","t":16,"rt":$n[3].List$1(CellGrid),"g":{"a":2,"n":"get_cells","t":8,"rt":$n[3].List$1(CellGrid),"fg":"cells"},"fn":"cells"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listCell","t":4,"rt":$n[3].List$1(CellGrid),"sn":"listCell"}]}; }, $n);
    /*GridSystem end.*/

    /*SetCenterPosition start.*/
    $m("SetCenterPosition", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.ContextMenu.ctor("SetCenter")],"a":2,"n":"SetCenter","t":8,"sn":"SetCenter","rt":$n[0].Void}]}; }, $n);
    /*SetCenterPosition end.*/

    /*GridSetting start.*/
    $m("GridSetting", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Game/Level/Create/GridSetting", fileName: "GridSetting", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"hexagon","t":4,"rt":GridSettingData,"sn":"hexagon"},{"a":2,"n":"rectangle","t":4,"rt":GridSettingData,"sn":"rectangle"}]}; }, $n);
    /*GridSetting end.*/

    /*GridSettingData start.*/
    $m("GridSettingData", function () { return {"att":1057033,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Size","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_Size","t":8,"rt":$n[1].Vector2,"fg":"Size"},"fn":"Size"},{"a":2,"n":"prefab","t":4,"rt":CellGrid,"sn":"prefab"},{"a":2,"n":"size","t":4,"rt":$n[6].Vector3Variable,"sn":"size"}]}; }, $n);
    /*GridSettingData end.*/

    /*MapSystem start.*/
    $m("MapSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCell","t":8,"pi":[{"n":"coordinate","pt":$n[1].Vector2Int,"ps":0}],"sn":"GetCell","rt":CellGrid,"p":[$n[1].Vector2Int]},{"a":2,"n":"GetCell","t":8,"pi":[{"n":"position","pt":$n[1].Vector3,"ps":0}],"sn":"GetCell$1","rt":CellGrid,"p":[$n[1].Vector3]},{"a":1,"n":"GetDistance","t":8,"pi":[{"n":"gridType","pt":GridType,"ps":0},{"n":"cellSetting","pt":GridSetting,"ps":1}],"sn":"GetDistance","rt":$n[1].Vector2,"p":[GridType,GridSetting]},{"a":2,"n":"GridSystem","t":16,"rt":GridSystem,"g":{"a":2,"n":"get_GridSystem","t":8,"rt":GridSystem,"fg":"GridSystem"},"fn":"GridSystem"},{"a":2,"n":"SizeActive","t":16,"rt":$n[1].Vector2Int,"g":{"a":2,"n":"get_SizeActive","t":8,"rt":$n[1].Vector2Int,"fg":"SizeActive"},"fn":"SizeActive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"axisType","t":4,"rt":AxisType,"sn":"axisType","box":function ($v) { return Bridge.box($v, AxisType, System.Enum.toStringFn(AxisType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gridOffset","t":4,"rt":$n[1].Vector2,"sn":"gridOffset"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gridSystem","t":4,"rt":GridSystem,"sn":"gridSystem"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gridType","t":4,"rt":GridType,"sn":"gridType","box":function ($v) { return Bridge.box($v, GridType, System.Enum.toStringFn(GridType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"path","t":4,"rt":$n[0].String,"sn":"path"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"plane","t":4,"rt":Plane,"sn":"plane"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"setting","t":4,"rt":GridSetting,"sn":"setting"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sizeActive","t":4,"rt":$n[1].Vector2Int,"sn":"sizeActive"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sizeGrid","t":4,"rt":$n[1].Vector2Int,"sn":"sizeGrid"}]}; }, $n);
    /*MapSystem end.*/

    /*Outline start.*/
    $m("Outline", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Active","t":8,"sn":"Active","rt":$n[0].Void},{"a":1,"n":"AddMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"AddMaterial","rt":$n[0].Void,"p":[$n[1].Material]},{"a":2,"n":"ChangeShader","t":8,"pi":[{"n":"shader","pt":$n[1].Shader,"ps":0}],"sn":"ChangeShader","rt":$n[0].Void,"p":[$n[1].Shader]},{"a":2,"n":"Deactive","t":8,"sn":"Deactive","rt":$n[0].Void},{"a":1,"n":"RemoveMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"RemoveMaterial","rt":$n[0].Void,"p":[$n[1].Material]},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"SetActive","t":8,"pi":[{"n":"isActive","pt":$n[0].Boolean,"ps":0}],"sn":"SetActive","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"SetColor","t":8,"pi":[{"n":"color","pt":$n[1].Color,"ps":0}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[1].Color]},{"a":2,"n":"SetRenderQueue","t":8,"pi":[{"n":"renderQueue","pt":$n[0].Int32,"ps":0}],"sn":"SetRenderQueue","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetUp","t":8,"pi":[{"n":"renderer","pt":$n[1].Renderer,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1},{"n":"width","dv":1.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"SetUp","rt":$n[0].Void,"p":[$n[1].Renderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"SetWidth","t":8,"pi":[{"n":"size","pt":$n[0].Single,"ps":0}],"sn":"SetWidth","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"_color","t":4,"rt":$n[1].Color,"sn":"_color"},{"a":1,"n":"_materialAdd","t":4,"rt":$n[1].Material,"sn":"_materialAdd"},{"a":1,"n":"_outlineMaterial","t":4,"rt":$n[1].Material,"sn":"_outlineMaterial"},{"a":1,"n":"_renderQueueOrigin","t":4,"rt":$n[0].Int32,"sn":"_renderQueueOrigin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_renderer","t":4,"rt":$n[1].Renderer,"sn":"_renderer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"colorProperty","t":4,"rt":$n[0].String,"sn":"colorProperty"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"widthProperty","t":4,"rt":$n[0].String,"sn":"widthProperty"}]}; }, $n);
    /*Outline end.*/

    /*ImmortalData start.*/
    $m("ImmortalData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Data/ImmortalData", fileName: "immortal_data"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Init","t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"OnCheckImmortalStatus","t":8,"sn":"OnCheckImmortalStatus","rt":$n[0].Void},{"a":2,"n":"OnUpdateImmortalStatus","t":8,"sn":"OnUpdateImmortalStatus","rt":$n[0].Void},{"a":2,"n":"SetTimeImmortal","t":8,"pi":[{"n":"timeSet","pt":$n[0].Int32,"ps":0}],"sn":"SetTimeImmortal","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"IsImmortalStatusVariable","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsImmortalStatusVariable","t":8,"rt":$n[0].Boolean,"fg":"IsImmortalStatusVariable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsImmortalStatusVariable"},{"a":2,"n":"OnEndStatusImmortalAction","t":4,"rt":Function,"sn":"OnEndStatusImmortalAction"},{"a":2,"n":"OnInStatusImmortalAction","t":4,"rt":Function,"sn":"OnInStatusImmortalAction"},{"a":2,"n":"OnUpdateTimeImmortalAction","t":4,"rt":Function,"sn":"OnUpdateTimeImmortalAction"},{"a":1,"n":"_isStartCountDownTimeImmortal","t":4,"rt":$n[0].Boolean,"sn":"_isStartCountDownTimeImmortal","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isFirstTimePlayGame","t":4,"rt":$n[6].BooleanVariable,"sn":"isFirstTimePlayGame"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isImmortalStatusVariable","t":4,"rt":$n[0].Boolean,"sn":"isImmortalStatusVariable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"totalTimeCountDownImmortalVariable","t":4,"rt":$n[6].IntegerVariable,"sn":"totalTimeCountDownImmortalVariable"}]}; }, $n);
    /*ImmortalData end.*/

    /*GraphicsQualitySetting start.*/
    $m("GraphicsQualitySetting", function () { return {"nested":[GraphicsQualitySetting.GraphicsQualityLevel],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "graphics_quality_setting", menuName: "Game/Settings/Graphics Quality"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Refresh","t":8,"sn":"Refresh","rt":$n[0].Void},{"a":2,"n":"SetGraphicsQuality","t":8,"pi":[{"n":"setting","pt":GraphicsQualitySetting.GraphicsQualityLevel,"ps":0}],"sn":"SetGraphicsQuality","rt":$n[0].Void,"p":[GraphicsQualitySetting.GraphicsQualityLevel]},{"a":1,"n":"UpdateGraphicsQuality","t":8,"pi":[{"n":"qualityIndex","pt":$n[0].Int32,"ps":0}],"sn":"UpdateGraphicsQuality","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"GraphicSettings","t":16,"rt":$n[3].List$1(GraphicsQualitySetting.GraphicsQualityLevel),"g":{"a":2,"n":"get_GraphicSettings","t":8,"rt":$n[3].List$1(GraphicsQualitySetting.GraphicsQualityLevel),"fg":"GraphicSettings"},"fn":"GraphicSettings"},{"a":2,"n":"QualityValue","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_QualityValue","t":8,"rt":$n[0].Int32,"fg":"QualityValue","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_QualityValue","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"QualityValue"},"fn":"QualityValue"},{"a":2,"n":"SettingsCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SettingsCount","t":8,"rt":$n[0].Int32,"fg":"SettingsCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SettingsCount"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"graphicSettings","t":4,"rt":$n[3].List$1(GraphicsQualitySetting.GraphicsQualityLevel),"sn":"graphicSettings"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"guid","t":4,"rt":$n[0].String,"sn":"guid"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelDefault","t":4,"rt":$n[0].Int32,"sn":"levelDefault","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*GraphicsQualitySetting end.*/

    /*GraphicsQualitySetting+GraphicsQualityLevel start.*/
    $m("GraphicsQualitySetting.GraphicsQualityLevel", function () { return {"td":GraphicsQualitySetting,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"antiAliasing","t":4,"rt":$n[0].Int32,"sn":"antiAliasing","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"qualityLevel","t":4,"rt":$n[0].Int32,"sn":"qualityLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"qualityName","t":4,"rt":$n[0].String,"sn":"qualityName"},{"a":2,"n":"shadowDistance","t":4,"rt":$n[0].Int32,"sn":"shadowDistance","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"shadowNearPlaneOffset","t":4,"rt":$n[0].Int32,"sn":"shadowNearPlaneOffset","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"shadowProjection","t":4,"rt":$n[1].ShadowProjection,"sn":"shadowProjection","box":function ($v) { return Bridge.box($v, UnityEngine.ShadowProjection, System.Enum.toStringFn(UnityEngine.ShadowProjection));}},{"a":2,"n":"shadowQuality","t":4,"rt":$n[1].ShadowQuality,"sn":"shadowQuality","box":function ($v) { return Bridge.box($v, UnityEngine.ShadowQuality, System.Enum.toStringFn(UnityEngine.ShadowQuality));}},{"a":2,"n":"shadowResolution","t":4,"rt":$n[1].ShadowResolution,"sn":"shadowResolution","box":function ($v) { return Bridge.box($v, UnityEngine.ShadowResolution, System.Enum.toStringFn(UnityEngine.ShadowResolution));}}]}; }, $n);
    /*GraphicsQualitySetting+GraphicsQualityLevel end.*/

    /*GraphicsQualitySettingUI start.*/
    $m("GraphicsQualitySettingUI", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"OnSliderValueChanged","t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0}],"sn":"OnSliderValueChanged","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"graphicsQualitySetting","t":4,"rt":GraphicsQualitySetting,"sn":"graphicsQualitySetting"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isRefreshOnStart","t":4,"rt":$n[0].Boolean,"sn":"isRefreshOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"qualitySlider","t":4,"rt":$n[8].Slider,"sn":"qualitySlider"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"txtQuality","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"txtQuality"}]}; }, $n);
    /*GraphicsQualitySettingUI end.*/

    /*TouchSystem start.*/
    $m("TouchSystem", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"CleanUp","t":8,"sn":"CleanUp","rt":$n[0].Void},{"a":2,"n":"GetPointPosition","t":8,"sn":"GetPointPosition","rt":$n[1].Vector3},{"a":2,"n":"GetToucher","t":8,"sn":"GetToucher","rt":$n[1].GameObject},{"ov":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"IsPointerOverUI","t":8,"sn":"IsPointerOverUI","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnTouchBegin","t":8,"pi":[{"n":"touchPosition","pt":$n[1].Vector3,"ps":0}],"sn":"OnTouchBegin","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":1,"n":"OnTouchEnd","t":8,"pi":[{"n":"touchPosition","pt":$n[1].Vector3,"ps":0}],"sn":"OnTouchEnd","rt":$n[0].Void,"p":[$n[1].Vector3]},{"a":2,"n":"LastPosition","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_LastPosition","t":8,"rt":$n[1].Vector3,"fg":"LastPosition"},"fn":"LastPosition"},{"a":2,"n":"ActionBegin","t":4,"rt":Function,"sn":"ActionBegin"},{"a":2,"n":"ActionEnd","t":4,"rt":Function,"sn":"ActionEnd"},{"a":1,"n":"_lastPosition","t":4,"rt":$n[1].Vector3,"sn":"_lastPosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"distance","t":4,"rt":$n[0].Single,"sn":"distance","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"includeLayer","t":4,"rt":$n[1].LayerMask,"sn":"includeLayer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"inputEventTouchBegin","t":4,"rt":$n[11].InputEventTouchBegin,"sn":"inputEventTouchBegin"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"inputEventTouchEnd","t":4,"rt":$n[11].InputEventTouchEnd,"sn":"inputEventTouchEnd"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sceneCamera","t":4,"rt":$n[1].Camera,"sn":"sceneCamera"}]}; }, $n);
    /*TouchSystem end.*/

    /*TrackingEnum start.*/
    $m("TrackingEnum", function () { return {"nested":[TrackingEnum.EResourceType,TrackingEnum.EResourceName,TrackingEnum.EResourceReason,TrackingEnum.EConnection,TrackingEnum.EPlayType,TrackingEnum.ELevelResult,TrackingEnum.ELevelLoseBy,TrackingEnum.EPlacement,TrackingEnum.EIapShowType,TrackingEnum.EAdEndType,TrackingEnum.ELoadType],"att":1048961,"a":2,"s":true}; }, $n);
    /*TrackingEnum end.*/

    /*TrackingEnum+EResourceType start.*/
    $m("TrackingEnum.EResourceType", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"booster","is":true,"t":4,"rt":TrackingEnum.EResourceType,"sn":"booster","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceType, System.Enum.toStringFn(TrackingEnum.EResourceType));}},{"a":2,"n":"currency","is":true,"t":4,"rt":TrackingEnum.EResourceType,"sn":"currency","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceType, System.Enum.toStringFn(TrackingEnum.EResourceType));}},{"a":2,"n":"item","is":true,"t":4,"rt":TrackingEnum.EResourceType,"sn":"item","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceType, System.Enum.toStringFn(TrackingEnum.EResourceType));}}]}; }, $n);
    /*TrackingEnum+EResourceType end.*/

    /*TrackingEnum+EResourceName start.*/
    $m("TrackingEnum.EResourceName", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"freeze_time","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"freeze_time","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"gold","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"gold","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"hammer","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"hammer","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"heart","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"heart","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"heart_immortal","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"heart_immortal","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"level_time","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"level_time","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"magnet","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"magnet","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}},{"a":2,"n":"star","is":true,"t":4,"rt":TrackingEnum.EResourceName,"sn":"star","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceName, System.Enum.toStringFn(TrackingEnum.EResourceName));}}]}; }, $n);
    /*TrackingEnum+EResourceName end.*/

    /*TrackingEnum+EResourceReason start.*/
    $m("TrackingEnum.EResourceReason", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"exchange","is":true,"t":4,"rt":TrackingEnum.EResourceReason,"sn":"exchange","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceReason, System.Enum.toStringFn(TrackingEnum.EResourceReason));}},{"a":2,"n":"purchase","is":true,"t":4,"rt":TrackingEnum.EResourceReason,"sn":"purchase","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceReason, System.Enum.toStringFn(TrackingEnum.EResourceReason));}},{"a":2,"n":"reward","is":true,"t":4,"rt":TrackingEnum.EResourceReason,"sn":"reward","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceReason, System.Enum.toStringFn(TrackingEnum.EResourceReason));}},{"a":2,"n":"use","is":true,"t":4,"rt":TrackingEnum.EResourceReason,"sn":"use","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceReason, System.Enum.toStringFn(TrackingEnum.EResourceReason));}},{"a":2,"n":"watch_ads","is":true,"t":4,"rt":TrackingEnum.EResourceReason,"sn":"watch_ads","box":function ($v) { return Bridge.box($v, TrackingEnum.EResourceReason, System.Enum.toStringFn(TrackingEnum.EResourceReason));}}]}; }, $n);
    /*TrackingEnum+EResourceReason end.*/

    /*TrackingEnum+EConnection start.*/
    $m("TrackingEnum.EConnection", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"offline","is":true,"t":4,"rt":TrackingEnum.EConnection,"sn":"offline","box":function ($v) { return Bridge.box($v, TrackingEnum.EConnection, System.Enum.toStringFn(TrackingEnum.EConnection));}},{"a":2,"n":"online","is":true,"t":4,"rt":TrackingEnum.EConnection,"sn":"online","box":function ($v) { return Bridge.box($v, TrackingEnum.EConnection, System.Enum.toStringFn(TrackingEnum.EConnection));}}]}; }, $n);
    /*TrackingEnum+EConnection end.*/

    /*TrackingEnum+EPlayType start.*/
    $m("TrackingEnum.EPlayType", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"home","is":true,"t":4,"rt":TrackingEnum.EPlayType,"sn":"home","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlayType, System.Enum.toStringFn(TrackingEnum.EPlayType));}},{"a":2,"n":"restart","is":true,"t":4,"rt":TrackingEnum.EPlayType,"sn":"restart","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlayType, System.Enum.toStringFn(TrackingEnum.EPlayType));}},{"a":2,"n":"win_continue","is":true,"t":4,"rt":TrackingEnum.EPlayType,"sn":"win_continue","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlayType, System.Enum.toStringFn(TrackingEnum.EPlayType));}}]}; }, $n);
    /*TrackingEnum+EPlayType end.*/

    /*TrackingEnum+ELevelResult start.*/
    $m("TrackingEnum.ELevelResult", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"exit","is":true,"t":4,"rt":TrackingEnum.ELevelResult,"sn":"exit","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelResult, System.Enum.toStringFn(TrackingEnum.ELevelResult));}},{"a":2,"n":"lose","is":true,"t":4,"rt":TrackingEnum.ELevelResult,"sn":"lose","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelResult, System.Enum.toStringFn(TrackingEnum.ELevelResult));}},{"a":2,"n":"quit","is":true,"t":4,"rt":TrackingEnum.ELevelResult,"sn":"quit","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelResult, System.Enum.toStringFn(TrackingEnum.ELevelResult));}},{"a":2,"n":"replay","is":true,"t":4,"rt":TrackingEnum.ELevelResult,"sn":"replay","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelResult, System.Enum.toStringFn(TrackingEnum.ELevelResult));}},{"a":2,"n":"tutorial","is":true,"t":4,"rt":TrackingEnum.ELevelResult,"sn":"tutorial","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelResult, System.Enum.toStringFn(TrackingEnum.ELevelResult));}},{"a":2,"n":"win","is":true,"t":4,"rt":TrackingEnum.ELevelResult,"sn":"win","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelResult, System.Enum.toStringFn(TrackingEnum.ELevelResult));}}]}; }, $n);
    /*TrackingEnum+ELevelResult end.*/

    /*TrackingEnum+ELevelLoseBy start.*/
    $m("TrackingEnum.ELevelLoseBy", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"bomb_explode","is":true,"t":4,"rt":TrackingEnum.ELevelLoseBy,"sn":"bomb_explode","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelLoseBy, System.Enum.toStringFn(TrackingEnum.ELevelLoseBy));}},{"a":2,"n":"out_of_time","is":true,"t":4,"rt":TrackingEnum.ELevelLoseBy,"sn":"out_of_time","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelLoseBy, System.Enum.toStringFn(TrackingEnum.ELevelLoseBy));}},{"a":2,"n":"shutter_gate_closed","is":true,"t":4,"rt":TrackingEnum.ELevelLoseBy,"sn":"shutter_gate_closed","box":function ($v) { return Bridge.box($v, TrackingEnum.ELevelLoseBy, System.Enum.toStringFn(TrackingEnum.ELevelLoseBy));}}]}; }, $n);
    /*TrackingEnum+ELevelLoseBy end.*/

    /*TrackingEnum+EPlacement start.*/
    $m("TrackingEnum.EPlacement", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"add_time","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"add_time","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"app_open","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"app_open","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"battle_pass","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"battle_pass","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"building","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"building","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"buy_booster_in_game","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"buy_booster_in_game","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"buy_freeze_time","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"buy_freeze_time","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"buy_hammer","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"buy_hammer","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"buy_magnet","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"buy_magnet","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"coin_icon_in_home","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"coin_icon_in_home","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"daily_gift","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"daily_gift","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"daily_mission_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"daily_mission_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"debug","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"debug","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"endless_treasure_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"endless_treasure_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"glam_rush_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"glam_rush_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"golden_ticket_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"golden_ticket_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"home_icon","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"home_icon","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"home_shop","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"home_shop","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"in_game","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"in_game","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"keep_streak_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"keep_streak_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"level_end","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"level_end","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"none","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"none","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"one_time_recharge_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"one_time_recharge_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"out_of_time_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"out_of_time_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"refill_life","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"refill_life","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"starter_pack_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"starter_pack_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"unlocked_building","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"unlocked_building","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"vip_pack_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"vip_pack_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"welcome_back_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"welcome_back_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"win_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"win_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"win_popup_extra_reward","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"win_popup_extra_reward","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}},{"a":2,"n":"win_streak_popup","is":true,"t":4,"rt":TrackingEnum.EPlacement,"sn":"win_streak_popup","box":function ($v) { return Bridge.box($v, TrackingEnum.EPlacement, System.Enum.toStringFn(TrackingEnum.EPlacement));}}]}; }, $n);
    /*TrackingEnum+EPlacement end.*/

    /*TrackingEnum+EIapShowType start.*/
    $m("TrackingEnum.EIapShowType", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"pack","is":true,"t":4,"rt":TrackingEnum.EIapShowType,"sn":"pack","box":function ($v) { return Bridge.box($v, TrackingEnum.EIapShowType, System.Enum.toStringFn(TrackingEnum.EIapShowType));}},{"a":2,"n":"shop","is":true,"t":4,"rt":TrackingEnum.EIapShowType,"sn":"shop","box":function ($v) { return Bridge.box($v, TrackingEnum.EIapShowType, System.Enum.toStringFn(TrackingEnum.EIapShowType));}}]}; }, $n);
    /*TrackingEnum+EIapShowType end.*/

    /*TrackingEnum+EAdEndType start.*/
    $m("TrackingEnum.EAdEndType", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"done","is":true,"t":4,"rt":TrackingEnum.EAdEndType,"sn":"done","box":function ($v) { return Bridge.box($v, TrackingEnum.EAdEndType, System.Enum.toStringFn(TrackingEnum.EAdEndType));}},{"a":2,"n":"quit","is":true,"t":4,"rt":TrackingEnum.EAdEndType,"sn":"quit","box":function ($v) { return Bridge.box($v, TrackingEnum.EAdEndType, System.Enum.toStringFn(TrackingEnum.EAdEndType));}}]}; }, $n);
    /*TrackingEnum+EAdEndType end.*/

    /*TrackingEnum+ELoadType start.*/
    $m("TrackingEnum.ELoadType", function () { return {"td":TrackingEnum,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"fail","is":true,"t":4,"rt":TrackingEnum.ELoadType,"sn":"fail","box":function ($v) { return Bridge.box($v, TrackingEnum.ELoadType, System.Enum.toStringFn(TrackingEnum.ELoadType));}},{"a":2,"n":"success","is":true,"t":4,"rt":TrackingEnum.ELoadType,"sn":"success","box":function ($v) { return Bridge.box($v, TrackingEnum.ELoadType, System.Enum.toStringFn(TrackingEnum.ELoadType));}}]}; }, $n);
    /*TrackingEnum+ELoadType end.*/

    /*TrackingEvent start.*/
    $m("TrackingEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Game/Tracking/Event", fileName: "tracking_event", order: 0
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*TrackingEvent end.*/

    /*TrackingParameter start.*/
    $m("TrackingParameter", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Boolean],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"boolValue","pt":$n[0].Boolean,"ps":1}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Double],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"doubleValue","pt":$n[0].Double,"ps":1}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].Int64],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"longValue","pt":$n[0].Int64,"ps":1}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String],"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"stringValue","pt":$n[0].String,"ps":1}],"sn":"$ctor3"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"a":2,"n":"Value","t":16,"rt":$n[0].Object,"g":{"a":2,"n":"get_Value","t":8,"rt":$n[0].Object,"fg":"Value"},"fn":"Value"},{"a":1,"backing":true,"n":"<Name>k__BackingField","t":4,"rt":$n[0].String,"sn":"Name"},{"a":1,"backing":true,"n":"<Value>k__BackingField","t":4,"rt":$n[0].Object,"sn":"Value"}]}; }, $n);
    /*TrackingParameter end.*/

    /*GamePlayableManager start.*/
    $m("GamePlayableManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"GetGameState","t":8,"sn":"GetGameState","rt":GameState,"box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"a":1,"n":"NextLevel","t":8,"sn":"NextLevel","rt":$n[0].Void},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnLoseGame","t":8,"pi":[{"n":"delayPopupShowTime","dv":2.5,"o":true,"pt":$n[0].Single,"ps":0}],"sn":"OnLoseGame","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"OnWinGame","t":8,"pi":[{"n":"delayPopupShowTime","dv":2.5,"o":true,"pt":$n[0].Single,"ps":0}],"sn":"OnWinGame","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"PlayCurrentLevel","t":8,"sn":"PlayCurrentLevel","rt":$n[0].Void},{"a":1,"n":"ReplayGame","t":8,"sn":"ReplayGame","rt":$n[0].Void},{"a":2,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"StartGame","t":8,"sn":"StartGame","rt":$n[0].Void},{"a":2,"n":"IsGamePlaying","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsGamePlaying","t":8,"rt":$n[0].Boolean,"fg":"IsGamePlaying","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsGamePlaying"},{"a":1,"n":"_currentLevelMode","t":4,"rt":ELevelMode,"sn":"_currentLevelMode","box":function ($v) { return Bridge.box($v, ELevelMode, System.Enum.toStringFn(ELevelMode));}},{"a":1,"n":"_delayTimeTween","t":4,"rt":$n[4].Tween,"sn":"_delayTimeTween"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callLoseLevelEvent","t":4,"rt":$n[2].FloatEvent,"sn":"callLoseLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callNextLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"callNextLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callPlayCurrentLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"callPlayCurrentLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callReplayLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"callReplayLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callWinLevelEvent","t":4,"rt":$n[2].FloatEvent,"sn":"callWinLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventGetCurrentLevel","t":4,"rt":$n[10].EventGetCurrentLevel,"sn":"eventGetCurrentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventGetPreviousLevel","t":4,"rt":$n[10].EventGetPreviousLevel,"sn":"eventGetPreviousLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventLoadLevel","t":4,"rt":$n[10].EventLoadLevel,"sn":"eventLoadLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gameState","t":4,"rt":GameState,"sn":"gameState","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"indexLevelVariable","t":4,"rt":$n[6].IntegerVariable,"sn":"indexLevelVariable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelHolder","t":4,"rt":$n[1].Transform,"sn":"levelHolder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelModeData","t":4,"rt":LevelModeData,"sn":"levelModeData"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"onLoadLevelComplete","t":4,"rt":$n[2].EventNoParam,"sn":"onLoadLevelComplete"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"}]}; }, $n);
    /*GamePlayableManager end.*/

    /*GameState start.*/
    $m("GameState", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Lobby","is":true,"t":4,"rt":GameState,"sn":"Lobby","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"a":2,"n":"LoseGame","is":true,"t":4,"rt":GameState,"sn":"LoseGame","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"a":2,"n":"PlayingGame","is":true,"t":4,"rt":GameState,"sn":"PlayingGame","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"a":2,"n":"PrepareGame","is":true,"t":4,"rt":GameState,"sn":"PrepareGame","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"a":2,"n":"WaitingResult","is":true,"t":4,"rt":GameState,"sn":"WaitingResult","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}},{"a":2,"n":"WinGame","is":true,"t":4,"rt":GameState,"sn":"WinGame","box":function ($v) { return Bridge.box($v, GameState, System.Enum.toStringFn(GameState));}}]}; }, $n);
    /*GameState end.*/

    /*ButtonCTA start.*/
    $m("ButtonCTA", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"TriggerCTA","t":8,"sn":"TriggerCTA","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"urlAndroid","t":4,"rt":$n[0].String,"sn":"urlAndroid"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"urlIos","t":4,"rt":$n[0].String,"sn":"urlIos"}]}; }, $n);
    /*ButtonCTA end.*/

    /*AnimatorUIControl start.*/
    $m("AnimatorUIControl", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Play","t":8,"sn":"Play","rt":$n[0].Void},{"a":2,"n":"PlayAnimation","t":8,"pi":[{"n":"animation","pt":AnimationData,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"actionComplete","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"PlayAnimation","rt":$n[0].Void,"p":[AnimationData,$n[0].Int32,Function]},{"a":2,"n":"PlayAnimation","t":8,"pi":[{"n":"animationBases","pt":$n[3].List$1(AnimationData),"ps":0},{"n":"actionStepComplete","dv":null,"o":true,"pt":Function,"ps":1},{"n":"actionComplete","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"PlayAnimation$1","rt":$n[0].Void,"p":[$n[3].List$1(AnimationData),Function,Function]},{"a":1,"n":"_playAnimationCount","t":4,"rt":$n[0].Int32,"sn":"_playAnimationCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"animations","t":4,"rt":$n[3].List$1(AnimationData),"sn":"animations"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"graphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"graphic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isHideWhenPlay","t":4,"rt":$n[0].Boolean,"sn":"isHideWhenPlay","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sound","t":4,"rt":$n[5].SoundData,"sn":"sound"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayPlay","t":4,"rt":$n[0].Single,"sn":"timeDelayPlay","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Audio"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayPlaySfx","t":4,"rt":$n[0].Single,"sn":"timeDelayPlaySfx","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeHide","t":4,"rt":$n[0].Single,"sn":"timeHide","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*AnimatorUIControl end.*/

    /*AnimationData start.*/
    $m("AnimationData", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"IsLoop","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoop","t":8,"rt":$n[0].Boolean,"fg":"IsLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoop"},{"a":2,"n":"Name","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Name","t":8,"rt":$n[0].String,"fg":"Name"},"fn":"Name"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isLoop","t":4,"rt":$n[0].Boolean,"sn":"isLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*AnimationData end.*/

    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty start.*/
    $m("IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*IAmAnEmptyScriptJustToMakeCodelessProjectsCompileProperty end.*/

    /*DG.Tweening.DOTweenModuleAudio start.*/
    $m("DG.Tweening.DOTweenModuleAudio", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOComplete","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"withCallbacks","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOComplete","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlip","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOFlip","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOGoto","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"to","pt":$n[0].Single,"ps":1},{"n":"andPlay","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DOGoto","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOKill","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"complete","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DOKill","rt":$n[0].Int32,"p":[$n[13].AudioMixer,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPitch","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].AudioSource,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPitch","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].AudioSource,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPlay","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlay","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayBackwards","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayBackwards","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOPlayForward","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOPlayForward","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORestart","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORestart","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DORewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DORewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOSetFloat","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0},{"n":"floatName","pt":$n[0].String,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOSetFloat","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[13].AudioMixer,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOSmoothRewind","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOSmoothRewind","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"DOTogglePause","is":true,"t":8,"pi":[{"n":"target","pt":$n[13].AudioMixer,"ps":0}],"sn":"DOTogglePause","rt":$n[0].Int32,"p":[$n[13].AudioMixer],"box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleAudio end.*/

    /*DG.Tweening.DOTweenModulePhysics start.*/
    $m("DG.Tweening.DOTweenModulePhysics", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[4].Sequence,"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[15].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":3}],"sn":"DOLocalPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[15].Path,$n[0].Single,$n[4].PathMode]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[4].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[4].PathType,$n[4].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOLookAt","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"towards","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"axisConstraint","dv":0,"o":true,"pt":$n[4].AxisConstraint,"ps":3},{"n":"up","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Vector3),"ps":4}],"sn":"DOLookAt","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[4].AxisConstraint,$n[0].Nullable$1(UnityEngine.Vector3)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":4,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":$n[15].Path,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":3}],"sn":"DOPath$1","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,$n[15].Path,$n[0].Single,$n[4].PathMode]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector3),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[4].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody,System.Array.type(UnityEngine.Vector3),$n[0].Single,$n[4].PathType,$n[4].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"mode","dv":0,"o":true,"pt":$n[4].RotateMode,"ps":3}],"sn":"DORotate","rt":$n[14].TweenerCore$3(UnityEngine.Quaternion,UnityEngine.Vector3,DG.Tweening.Plugins.Options.QuaternionOptions),"p":[$n[1].Rigidbody,$n[1].Vector3,$n[0].Single,$n[4].RotateMode]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics end.*/

    /*DG.Tweening.DOTweenModulePhysics2D start.*/
    $m("DG.Tweening.DOTweenModulePhysics2D", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOJump","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJump","rt":$n[4].Sequence,"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOLocalPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[4].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOLocalPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[4].PathType,$n[4].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DOMove","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMove","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMoveY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMoveY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPath","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"path","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"pathType","dv":0,"o":true,"pt":$n[4].PathType,"ps":3},{"n":"pathMode","dv":1,"o":true,"pt":$n[4].PathMode,"ps":4},{"n":"resolution","dv":10,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"gizmoColor","dv":null,"o":true,"pt":$n[0].Nullable$1(UnityEngine.Color),"ps":6}],"sn":"DOPath","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].Rigidbody2D,System.Array.type(UnityEngine.Vector2),$n[0].Single,$n[4].PathType,$n[4].PathMode,$n[0].Int32,$n[0].Nullable$1(UnityEngine.Color)]},{"a":2,"n":"DORotate","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Rigidbody2D,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DORotate","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].Rigidbody2D,$n[0].Single,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModulePhysics2D end.*/

    /*DG.Tweening.DOTweenModuleSprite start.*/
    $m("DG.Tweening.DOTweenModuleSprite", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[4].Tweener,"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[1].SpriteRenderer,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].SpriteRenderer,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[1].SpriteRenderer,pc.ColorGradient,$n[0].Single]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleSprite end.*/

    /*DG.Tweening.DOTweenModuleUI start.*/
    $m("DG.Tweening.DOTweenModuleUI", function () { return {"nested":[$n[4].DOTweenModuleUI.Utils],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOAnchorMax","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMax","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorMin","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorMin","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector3,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3D","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector3,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DX","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DY","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPos3DZ","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPos3DZ","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,UnityEngine.Vector3,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOAnchorPosY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOAnchorPosY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor","rt":$n[4].Tweener,"p":[$n[8].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$1","rt":$n[4].Tweener,"p":[$n[8].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOBlendableColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOBlendableColor$2","rt":$n[4].Tweener,"p":[$n[8].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Graphic,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[8].Graphic,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Image,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[8].Image,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Text,"ps":0},{"n":"endValue","pt":$n[1].Color,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOColor$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[8].Text,$n[1].Color,$n[0].Single]},{"a":2,"n":"DOCounter","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Text,"ps":0},{"n":"fromValue","pt":$n[0].Int32,"ps":1},{"n":"endValue","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3},{"n":"addThousandsSeparator","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"culture","dv":null,"o":true,"pt":$n[16].CultureInfo,"ps":5}],"sn":"DOCounter","rt":$n[14].TweenerCore$3(System.Int32,System.Int32,DG.Tweening.Plugins.Options.NoOptions),"p":[$n[8].Text,$n[0].Int32,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[16].CultureInfo]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].CanvasGroup,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[1].CanvasGroup,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Graphic,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$1","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[8].Graphic,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$2","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[8].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFade","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Text,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFade$3","rt":$n[14].TweenerCore$3(UnityEngine.Color,UnityEngine.Color,DG.Tweening.Plugins.Options.ColorOptions),"p":[$n[8].Text,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFillAmount","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Image,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOFillAmount","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[8].Image,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOFlexibleSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOFlexibleSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[8].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Image,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[8].Image,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOHorizontalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOHorizontalNormalizedPos","rt":$n[4].Tweener,"p":[$n[8].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOJumpAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"jumpPower","pt":$n[0].Single,"ps":2},{"n":"numJumps","pt":$n[0].Int32,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOJumpAnchorPos","rt":$n[4].Sequence,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOMinSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOMinSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[8].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DONormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].ScrollRect,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DONormalizedPos","rt":$n[4].Tweener,"p":[$n[8].ScrollRect,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPivot","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivot","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single]},{"a":2,"n":"DOPivotX","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotX","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPivotY","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOPivotY","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single]},{"a":2,"n":"DOPreferredSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].LayoutElement,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOPreferredSize","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[8].LayoutElement,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOPunchAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"punch","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"elasticity","dv":1.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"DOPunchAnchorPos","rt":$n[4].Tweener,"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","dv":100.0,"o":true,"pt":$n[0].Single,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos","rt":$n[4].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[0].Single,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOShakeAnchorPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"strength","pt":$n[1].Vector2,"ps":2},{"n":"vibrato","dv":10,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"randomness","dv":90.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"fadeOut","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"DOShakeAnchorPos$1","rt":$n[4].Tweener,"p":[$n[1].RectTransform,$n[0].Single,$n[1].Vector2,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DOSizeDelta","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].RectTransform,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOSizeDelta","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].RectTransform,$n[1].Vector2,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOText","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Text,"ps":0},{"n":"endValue","pt":$n[0].String,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"richTextEnabled","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scrambleMode","dv":0,"o":true,"pt":$n[4].ScrambleMode,"ps":4},{"n":"scrambleChars","dv":null,"o":true,"pt":$n[0].String,"ps":5}],"sn":"DOText","rt":$n[14].TweenerCore$3(System.String,System.String,DG.Tweening.Plugins.Options.StringOptions),"p":[$n[8].Text,$n[0].String,$n[0].Single,$n[0].Boolean,$n[4].ScrambleMode,$n[0].String]},{"a":2,"n":"DOValue","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Slider,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOValue","rt":$n[14].TweenerCore$3(System.Single,System.Single,DG.Tweening.Plugins.Options.FloatOptions),"p":[$n[8].Slider,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"DOVerticalNormalizedPos","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].ScrollRect,"ps":0},{"n":"endValue","pt":$n[0].Single,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2},{"n":"snapping","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"DOVerticalNormalizedPos","rt":$n[4].Tweener,"p":[$n[8].ScrollRect,$n[0].Single,$n[0].Single,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI end.*/

    /*DG.Tweening.DOTweenModuleUI+Utils start.*/
    $m("DG.Tweening.DOTweenModuleUI.Utils", function () { return {"td":$n[4].DOTweenModuleUI,"att":1048962,"a":2,"s":true,"m":[{"a":2,"n":"SwitchToRectTransform","is":true,"t":8,"pi":[{"n":"from","pt":$n[1].RectTransform,"ps":0},{"n":"to","pt":$n[1].RectTransform,"ps":1}],"sn":"SwitchToRectTransform","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].RectTransform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUI+Utils end.*/

    /*DG.Tweening.DOTweenModuleUnityVersion start.*/
    $m("DG.Tweening.DOTweenModuleUnityVersion", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"duration","pt":$n[0].Single,"ps":2}],"sn":"DOGradientColor","rt":$n[4].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].Single]},{"a":2,"n":"DOGradientColor","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"gradient","pt":pc.ColorGradient,"ps":1},{"n":"property","pt":$n[0].String,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOGradientColor$1","rt":$n[4].Sequence,"p":[$n[1].Material,pc.ColorGradient,$n[0].String,$n[0].Single]},{"a":2,"n":"DOOffset","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOOffset","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"DOTiling","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Material,"ps":0},{"n":"endValue","pt":$n[1].Vector2,"ps":1},{"n":"propertyID","pt":$n[0].Int32,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"DOTiling","rt":$n[14].TweenerCore$3(UnityEngine.Vector2,UnityEngine.Vector2,DG.Tweening.Plugins.Options.VectorOptions),"p":[$n[1].Material,$n[1].Vector2,$n[0].Int32,$n[0].Single]},{"a":2,"n":"WaitForCompletion","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForCompletion","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForElapsedLoops","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForElapsedLoops","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Int32,$n[0].Boolean]},{"a":2,"n":"WaitForKill","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForKill","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForPosition","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":2}],"sn":"WaitForPosition","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Single,$n[0].Boolean]},{"a":2,"n":"WaitForRewind","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForRewind","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]},{"a":2,"n":"WaitForStart","is":true,"t":8,"pi":[{"n":"t","pt":$n[4].Tween,"ps":0},{"n":"returnCustomYieldInstruction","pt":$n[0].Boolean,"ps":1}],"sn":"WaitForStart","rt":$n[1].CustomYieldInstruction,"p":[$n[4].Tween,$n[0].Boolean]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUnityVersion end.*/

    /*DG.Tweening.DOTweenCYInstruction start.*/
    $m("DG.Tweening.DOTweenCYInstruction", function () { return {"nested":[$n[4].DOTweenCYInstruction.WaitForCompletion,$n[4].DOTweenCYInstruction.WaitForRewind,$n[4].DOTweenCYInstruction.WaitForKill,$n[4].DOTweenCYInstruction.WaitForElapsedLoops,$n[4].DOTweenCYInstruction.WaitForPosition,$n[4].DOTweenCYInstruction.WaitForStart],"att":1048961,"a":2,"s":true}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForCompletion", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForCompletion end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForRewind", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForRewind end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForKill start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForKill", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForKill end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForElapsedLoops", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween,$n[0].Int32],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0},{"n":"elapsedLoops","pt":$n[0].Int32,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"elapsedLoops","t":4,"rt":$n[0].Int32,"sn":"elapsedLoops","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForElapsedLoops end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForPosition", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween,$n[0].Single],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0},{"n":"position","pt":$n[0].Single,"ps":1}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"position","t":4,"rt":$n[0].Single,"sn":"position","ro":true,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForPosition end.*/

    /*DG.Tweening.DOTweenCYInstruction+WaitForStart start.*/
    $m("DG.Tweening.DOTweenCYInstruction.WaitForStart", function () { return {"td":$n[4].DOTweenCYInstruction,"att":1048578,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[4].Tween],"pi":[{"n":"tween","pt":$n[4].Tween,"ps":0}],"sn":"ctor"},{"ov":true,"a":2,"n":"keepWaiting","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_keepWaiting","t":8,"rt":$n[0].Boolean,"fg":"keepWaiting","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"keepWaiting"},{"a":1,"n":"t","t":4,"rt":$n[4].Tween,"sn":"t","ro":true}]}; }, $n);
    /*DG.Tweening.DOTweenCYInstruction+WaitForStart end.*/

    /*DG.Tweening.DOTweenModuleUtils start.*/
    $m("DG.Tweening.DOTweenModuleUtils", function () { return {"nested":[$n[4].DOTweenModuleUtils.Physics],"att":1048961,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":1,"n":"Preserver","is":true,"t":8,"sn":"Preserver","rt":$n[0].Void},{"a":1,"n":"_initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"_initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils end.*/

    /*DG.Tweening.DOTweenModuleUtils+Physics start.*/
    $m("DG.Tweening.DOTweenModuleUtils.Physics", function () { return {"td":$n[4].DOTweenModuleUtils,"att":1048962,"a":2,"s":true,"m":[{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"CreateDOTweenPathTween","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"tweenRigidbody","pt":$n[0].Boolean,"ps":1},{"n":"isLocal","pt":$n[0].Boolean,"ps":2},{"n":"path","pt":$n[15].Path,"ps":3},{"n":"duration","pt":$n[0].Single,"ps":4},{"n":"pathMode","pt":$n[4].PathMode,"ps":5}],"sn":"CreateDOTweenPathTween","rt":$n[14].TweenerCore$3(UnityEngine.Vector3,DG.Tweening.Plugins.Core.PathCore.Path,DG.Tweening.Plugins.Options.PathOptions),"p":[$n[1].MonoBehaviour,$n[0].Boolean,$n[0].Boolean,$n[15].Path,$n[0].Single,$n[4].PathMode]},{"at":[new UnityEngine.Scripting.PreserveAttribute()],"a":2,"n":"HasRigidbody","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"HasRigidbody2D","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].Component,"ps":0}],"sn":"HasRigidbody2D","rt":$n[0].Boolean,"p":[$n[1].Component],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetOrientationOnPath","is":true,"t":8,"pi":[{"n":"options","pt":$n[17].PathOptions,"ps":0},{"n":"t","pt":$n[4].Tween,"ps":1},{"n":"newRot","pt":$n[1].Quaternion,"ps":2},{"n":"trans","pt":$n[1].Transform,"ps":3}],"sn":"SetOrientationOnPath","rt":$n[0].Void,"p":[$n[17].PathOptions,$n[4].Tween,$n[1].Quaternion,$n[1].Transform]}]}; }, $n);
    /*DG.Tweening.DOTweenModuleUtils+Physics end.*/

    /*DG.Tweening.EEasingType start.*/
    $m("DG.Tweening.EEasingType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnimationCurve","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"AnimationCurve","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InBack","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InBack","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InBounce","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InBounce","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InCirc","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InCirc","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InCubic","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InCubic","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InElastic","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InElastic","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InExpo","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InExpo","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutBack","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutBack","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutBounce","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutBounce","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutCirc","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutCirc","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutCubic","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutCubic","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutElastic","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutElastic","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutExpo","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutExpo","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutQuad","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutQuad","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutQuart","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutQuart","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutQuint","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutQuint","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InOutSine","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InOutSine","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InQuad","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InQuad","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InQuart","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InQuart","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InQuint","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InQuint","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"InSine","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"InSine","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"Linear","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"Linear","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutBack","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutBack","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutBounce","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutBounce","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutCirc","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutCirc","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutCubic","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutCubic","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutElastic","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutElastic","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutExpo","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutExpo","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutQuad","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutQuad","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutQuart","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutQuart","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutQuint","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutQuint","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}},{"a":2,"n":"OutSine","is":true,"t":4,"rt":$n[4].EEasingType,"sn":"OutSine","box":function ($v) { return Bridge.box($v, DG.Tweening.EEasingType, System.Enum.toStringFn(DG.Tweening.EEasingType));}}]}; }, $n);
    /*DG.Tweening.EEasingType end.*/

    /*DG.Tweening.EasingType start.*/
    $m("DG.Tweening.EasingType", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Interpolate","is":true,"t":8,"pi":[{"n":"type","pt":$n[4].EEasingType,"ps":0}],"sn":"Interpolate","rt":$n[4].Ease,"p":[$n[4].EEasingType],"box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}}]}; }, $n);
    /*DG.Tweening.EasingType end.*/

    /*Spine.BoneMatrix start.*/
    $m("Spine.BoneMatrix", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[18].Bone],"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[spine.BoneData],"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"$ctor2"},{"a":2,"n":"CalculateSetupWorld","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0}],"sn":"CalculateSetupWorld","rt":$n[18].BoneMatrix,"p":[spine.BoneData]},{"a":1,"n":"GetInheritedInternal","is":true,"t":8,"pi":[{"n":"boneData","pt":spine.BoneData,"ps":0},{"n":"parentMatrix","pt":$n[18].BoneMatrix,"ps":1}],"sn":"GetInheritedInternal","rt":$n[18].BoneMatrix,"p":[spine.BoneData,$n[18].BoneMatrix]},{"a":2,"n":"TransformMatrix","t":8,"pi":[{"n":"local","pt":$n[18].BoneMatrix,"ps":0}],"sn":"TransformMatrix","rt":$n[18].BoneMatrix,"p":[$n[18].BoneMatrix]},{"a":2,"n":"a","t":4,"rt":$n[0].Single,"sn":"a","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"b","t":4,"rt":$n[0].Single,"sn":"b","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"c","t":4,"rt":$n[0].Single,"sn":"c","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"d","t":4,"rt":$n[0].Single,"sn":"d","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.BoneMatrix end.*/

    /*Spine.SpineSkeletonExtensions start.*/
    $m("Spine.SpineSkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"InheritsRotation","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsRotation","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"InheritsScale","is":true,"t":8,"pi":[{"n":"mode","pt":spine.TransformMode,"ps":0}],"sn":"InheritsScale","rt":$n[0].Boolean,"p":[spine.TransformMode],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsWeighted","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0}],"sn":"IsWeighted","rt":$n[0].Boolean,"p":[spine.VertexAttachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.SpineSkeletonExtensions end.*/

    /*Spine.Unity.AnimationReferenceAsset start.*/
    $m("Spine.Unity.AnimationReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/Animation Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[12].AnimationReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":$n[18].Animation,"p":[$n[12].AnimationReferenceAsset]},{"a":2,"n":"Animation","t":16,"rt":$n[18].Animation,"g":{"a":2,"n":"get_Animation","t":8,"rt":$n[18].Animation,"fg":"Animation"},"fn":"Animation"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"animation","t":4,"rt":$n[18].Animation,"sn":"animation"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":3,"n":"animationName","t":4,"rt":$n[0].String,"sn":"animationName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.AnimationReferenceAsset end.*/

    /*Spine.Unity.AtlasAssetBase start.*/
    $m("Spine.Unity.AtlasAssetBase", function () { return {"nested":[$n[12].AtlasAssetBase.LoadingMode],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"v":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[18].Atlas,"p":[$n[0].Boolean]},{"v":true,"a":2,"n":"RequireTextureLoaded","t":8,"pi":[{"n":"placeholderTexture","pt":$n[1].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[1].Texture,"ps":1},{"n":"onTextureLoaded","pt":Function,"ps":2}],"sn":"RequireTextureLoaded","rt":$n[0].Void,"p":[$n[1].Texture,$n[1].Texture,Function]},{"v":true,"a":2,"n":"RequireTexturesLoaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[1].Material,"ps":1}],"sn":"RequireTexturesLoaded","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Material]},{"ab":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ab":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ab":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ab":true,"a":2,"n":"Materials","t":16,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"g":{"ab":true,"a":2,"n":"get_Materials","t":8,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"a":2,"n":"OnDemandTextureLoader","t":16,"rt":$n[12].OnDemandTextureLoader,"g":{"a":2,"n":"get_OnDemandTextureLoader","t":8,"rt":$n[12].OnDemandTextureLoader,"fg":"OnDemandTextureLoader"},"s":{"a":2,"n":"set_OnDemandTextureLoader","t":8,"p":[$n[12].OnDemandTextureLoader],"rt":$n[0].Void,"fs":"OnDemandTextureLoader"},"fn":"OnDemandTextureLoader"},{"ab":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ab":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"v":true,"a":2,"n":"TextureLoadingMode","t":16,"rt":$n[12].AtlasAssetBase.LoadingMode,"g":{"v":true,"a":2,"n":"get_TextureLoadingMode","t":8,"rt":$n[12].AtlasAssetBase.LoadingMode,"fg":"TextureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},"s":{"v":true,"a":2,"n":"set_TextureLoadingMode","t":8,"p":[$n[12].AtlasAssetBase.LoadingMode],"rt":$n[0].Void,"fs":"TextureLoadingMode"},"fn":"TextureLoadingMode"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"onDemandTextureLoader","t":4,"rt":$n[12].OnDemandTextureLoader,"sn":"onDemandTextureLoader"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"textureLoadingMode","t":4,"rt":$n[12].AtlasAssetBase.LoadingMode,"sn":"textureLoadingMode","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":1,"backing":true,"n":"<IsLoaded>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<MaterialCount>k__BackingField","t":4,"rt":$n[0].Int32,"sn":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"backing":true,"n":"<Materials>k__BackingField","t":4,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"sn":"Materials"},{"a":1,"backing":true,"n":"<PrimaryMaterial>k__BackingField","t":4,"rt":$n[1].Material,"sn":"PrimaryMaterial"}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase end.*/

    /*Spine.Unity.AtlasAssetBase+LoadingMode start.*/
    $m("Spine.Unity.AtlasAssetBase.LoadingMode", function () { return {"td":$n[12].AtlasAssetBase,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Normal","is":true,"t":4,"rt":$n[12].AtlasAssetBase.LoadingMode,"sn":"Normal","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}},{"a":2,"n":"OnDemand","is":true,"t":4,"rt":$n[12].AtlasAssetBase.LoadingMode,"sn":"OnDemand","box":function ($v) { return Bridge.box($v, Spine.Unity.AtlasAssetBase.LoadingMode, System.Enum.toStringFn(Spine.Unity.AtlasAssetBase.LoadingMode));}}]}; }, $n);
    /*Spine.Unity.AtlasAssetBase+LoadingMode end.*/

    /*Spine.Unity.BlendModeMaterials start.*/
    $m("Spine.Unity.BlendModeMaterials", function () { return {"nested":[$n[12].BlendModeMaterials.ReplacementMaterial],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ApplyMaterials","t":8,"pi":[{"n":"skeletonData","pt":$n[18].SkeletonData,"ps":0}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[18].SkeletonData]},{"a":2,"n":"BlendModeForMaterial","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"BlendModeForMaterial","rt":spine.BlendMode,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, spine.BlendMode, System.Enum.toStringFn(spine.BlendMode));}},{"a":3,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[18].AtlasRegion,"ps":0},{"n":"replacementMaterials","pt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[18].AtlasRegion,"p":[$n[18].AtlasRegion,$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial)]},{"a":2,"n":"RequiresBlendModeMaterials","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_RequiresBlendModeMaterials","t":8,"rt":$n[0].Boolean,"fg":"RequiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_RequiresBlendModeMaterials","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"RequiresBlendModeMaterials"},"fn":"RequiresBlendModeMaterials"},{"a":2,"n":"additiveMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"additiveMaterials"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"multiplyMaterials"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.HideInInspector()],"a":3,"n":"requiresBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"requiresBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"screenMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.BlendModeMaterials.ReplacementMaterial),"sn":"screenMaterials"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials end.*/

    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial start.*/
    $m("Spine.Unity.BlendModeMaterials.ReplacementMaterial", function () { return {"td":$n[12].BlendModeMaterials,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"pageName","t":4,"rt":$n[0].String,"sn":"pageName"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterials+ReplacementMaterial end.*/

    /*Spine.Unity.EventDataReferenceAsset start.*/
    $m("Spine.Unity.EventDataReferenceAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/EventData Reference Asset", order: 100
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"asset","pt":$n[12].EventDataReferenceAsset,"ps":0}],"sn":"op_Implicit","rt":spine.EventData,"p":[$n[12].EventDataReferenceAsset]},{"a":2,"n":"EventData","t":16,"rt":spine.EventData,"g":{"a":2,"n":"get_EventData","t":8,"rt":spine.EventData,"fg":"EventData"},"fn":"EventData"},{"a":1,"n":"QuietSkeletonData","is":true,"t":4,"rt":$n[0].Boolean,"sn":"QuietSkeletonData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"eventData","t":4,"rt":spine.EventData,"sn":"eventData"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineEvent("", "skeletonDataAsset", true, false, false)],"a":3,"n":"eventName","t":4,"rt":$n[0].String,"sn":"eventName"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.EventDataReferenceAsset end.*/

    /*Spine.Unity.OnDemandTextureLoader start.*/
    $m("Spine.Unity.OnDemandTextureLoader", function () { return {"nested":[Function],"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"AssignPlaceholderTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[3].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignPlaceholderTextures","rt":$n[0].Boolean,"p":[$n[3].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"AssignTargetTextures","t":8,"pi":[{"n":"modifiedMaterials","out":true,"pt":$n[3].IEnumerable$1(UnityEngine.Material),"ps":0}],"sn":"AssignTargetTextures","rt":$n[0].Boolean,"p":[$n[3].IEnumerable$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"BeginCustomTextureLoading","t":8,"sn":"BeginCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"Clear","t":8,"pi":[{"n":"clearAtlasAsset","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ab":true,"a":2,"n":"EndCustomTextureLoading","t":8,"sn":"EndCustomTextureLoading","rt":$n[0].Void},{"ab":true,"a":2,"n":"GetPlaceholderTextureName","t":8,"pi":[{"n":"originalTextureName","pt":$n[0].String,"ps":0}],"sn":"GetPlaceholderTextureName","rt":$n[0].String,"p":[$n[0].String]},{"v":true,"a":2,"n":"HasNullMainTexturesAssigned","t":8,"pi":[{"n":"nullTextureMaterials","out":true,"pt":$n[3].List$1(UnityEngine.Material),"ps":0}],"sn":"HasNullMainTexturesAssigned","rt":$n[0].Boolean,"p":[$n[3].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderAssigned","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0}],"sn":"HasPlaceholderAssigned","rt":$n[0].Boolean,"p":[$n[1].Material],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"ab":true,"a":2,"n":"HasPlaceholderTexturesAssigned","t":8,"pi":[{"n":"placeholderMaterials","out":true,"pt":$n[3].List$1(UnityEngine.Material),"ps":0}],"sn":"HasPlaceholderTexturesAssigned","rt":$n[0].Boolean,"p":[$n[3].List$1(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"OnTextureLoaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureLoaded","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureRequested","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureRequested","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"a":3,"n":"OnTextureUnloaded","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"textureIndex","pt":$n[0].Int32,"ps":1}],"sn":"OnTextureUnloaded","rt":$n[0].Void,"p":[$n[1].Material,$n[0].Int32]},{"ab":true,"a":2,"n":"RequestLoadMaterialTextures","t":8,"pi":[{"n":"material","pt":$n[1].Material,"ps":0},{"n":"overrideMaterial","ref":true,"pt":$n[1].Material,"ps":1}],"sn":"RequestLoadMaterialTextures","rt":$n[0].Void,"p":[$n[1].Material,$n[1].Material]},{"ab":true,"a":2,"n":"RequestLoadTexture","t":8,"pi":[{"n":"placeholderTexture","pt":$n[1].Texture,"ps":0},{"n":"replacementTexture","ref":true,"pt":$n[1].Texture,"ps":1},{"n":"onTextureLoaded","dv":null,"o":true,"pt":Function,"ps":2}],"sn":"RequestLoadTexture","rt":$n[0].Void,"p":[$n[1].Texture,$n[1].Texture,Function]},{"a":2,"n":"atlasAsset","t":4,"rt":$n[12].AtlasAssetBase,"sn":"atlasAsset"},{"a":2,"n":"TextureLoaded","t":2,"ad":{"a":2,"n":"add_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureRequested","t":2,"ad":{"a":2,"n":"add_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"TextureUnloaded","t":2,"ad":{"a":2,"n":"add_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_TextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeTextureUnloaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureLoaded","t":2,"ad":{"a":3,"n":"add_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureLoaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureLoaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureLoaded","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureRequested","t":2,"ad":{"a":3,"n":"add_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureRequested","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureRequested","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureRequested","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"onTextureUnloaded","t":2,"ad":{"a":3,"n":"add_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addonTextureUnloaded","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove_onTextureUnloaded","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeonTextureUnloaded","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.OnDemandTextureLoader end.*/

    /*Spine.Unity.RegionlessAttachmentLoader start.*/
    $m("Spine.Unity.RegionlessAttachmentLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"NewBoundingBoxAttachment","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewBoundingBoxAttachment","rt":spine.BoundingBoxAttachment,"p":[$n[18].Skin,$n[0].String]},{"a":2,"n":"NewClippingAttachment","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewClippingAttachment","rt":spine.ClippingAttachment,"p":[$n[18].Skin,$n[0].String]},{"a":2,"n":"NewMeshAttachment","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewMeshAttachment","rt":$n[18].MeshAttachment,"p":[$n[18].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":2,"n":"NewPathAttachment","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPathAttachment","rt":spine.PathAttachment,"p":[$n[18].Skin,$n[0].String]},{"a":2,"n":"NewPointAttachment","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1}],"sn":"NewPointAttachment","rt":$n[18].PointAttachment,"p":[$n[18].Skin,$n[0].String]},{"a":2,"n":"NewRegionAttachment","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"path","pt":$n[0].String,"ps":2},{"n":"sequence","pt":spine.Sequence,"ps":3}],"sn":"NewRegionAttachment","rt":$n[18].RegionAttachment,"p":[$n[18].Skin,$n[0].String,$n[0].String,spine.Sequence]},{"a":1,"n":"EmptyRegion","is":true,"t":16,"rt":$n[18].AtlasRegion,"g":{"a":1,"n":"get_EmptyRegion","t":8,"rt":$n[18].AtlasRegion,"fg":"EmptyRegion","is":true},"fn":"EmptyRegion"},{"a":1,"n":"emptyRegion","is":true,"t":4,"rt":$n[18].AtlasRegion,"sn":"emptyRegion"}]}; }, $n);
    /*Spine.Unity.RegionlessAttachmentLoader end.*/

    /*Spine.Unity.SkeletonDataAsset start.*/
    $m("Spine.Unity.SkeletonDataAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New SkeletonDataAsset", menuName: "Spine/SkeletonData Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAsset","pt":$n[12].AtlasAssetBase,"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[12].SkeletonDataAsset,"p":[$n[1].TextAsset,$n[12].AtlasAssetBase,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"skeletonDataFile","pt":$n[1].TextAsset,"ps":0},{"n":"atlasAssets","pt":System.Array.type(Spine.Unity.AtlasAssetBase),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"CreateRuntimeInstance$1","rt":$n[12].SkeletonDataAsset,"p":[$n[1].TextAsset,System.Array.type(Spine.Unity.AtlasAssetBase),$n[0].Boolean,$n[0].Single]},{"a":2,"n":"FillStateData","t":8,"pi":[{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"FillStateData","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"GetAnimationStateData","t":8,"sn":"GetAnimationStateData","rt":spine.AnimationStateData},{"a":4,"n":"GetAtlasArray","t":8,"sn":"GetAtlasArray","rt":System.Array.type(Spine.Atlas)},{"a":2,"n":"GetSkeletonData","t":8,"pi":[{"n":"quiet","pt":$n[0].Boolean,"ps":0}],"sn":"GetSkeletonData","rt":$n[18].SkeletonData,"p":[$n[0].Boolean]},{"a":4,"n":"InitializeWithData","t":8,"pi":[{"n":"sd","pt":$n[18].SkeletonData,"ps":0}],"sn":"InitializeWithData","rt":$n[0].Void,"p":[$n[18].SkeletonData]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0},{"n":"attachmentLoader","pt":$n[18].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData","rt":$n[18].SkeletonData,"p":[$n[0].Array.type(System.Byte),$n[18].AttachmentLoader,$n[0].Single]},{"a":4,"n":"ReadSkeletonData","is":true,"t":8,"pi":[{"n":"text","pt":$n[0].String,"ps":0},{"n":"attachmentLoader","pt":$n[18].AttachmentLoader,"ps":1},{"n":"scale","pt":$n[0].Single,"ps":2}],"sn":"ReadSkeletonData$1","rt":$n[18].SkeletonData,"p":[$n[0].String,$n[18].AttachmentLoader,$n[0].Single]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"a":2,"n":"atlasAssets","t":4,"rt":System.Array.type(Spine.Unity.AtlasAssetBase),"sn":"atlasAssets"},{"a":2,"n":"blendModeMaterials","t":4,"rt":$n[12].BlendModeMaterials,"sn":"blendModeMaterials"},{"a":2,"n":"controller","t":4,"rt":$n[1].RuntimeAnimatorController,"sn":"controller"},{"a":2,"n":"defaultMix","t":4,"rt":$n[0].Single,"sn":"defaultMix","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"duration","t":4,"rt":$n[0].Array.type(System.Single),"sn":"duration"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"fromAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"fromAnimation"},{"a":2,"n":"isUpgradingBlendModeMaterials","t":4,"rt":$n[0].Boolean,"sn":"isUpgradingBlendModeMaterials","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonData","t":4,"rt":$n[18].SkeletonData,"sn":"skeletonData"},{"at":[new UnityEngine.TooltipAttribute("Use SkeletonDataModifierAssets to apply changes to the SkeletonData after being loaded, such as apply blend mode Materials to Attachments under slots with special blend modes.")],"a":2,"n":"skeletonDataModifiers","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonDataModifierAsset),"sn":"skeletonDataModifiers"},{"a":2,"n":"skeletonJSON","t":4,"rt":$n[1].TextAsset,"sn":"skeletonJSON"},{"a":1,"n":"stateData","t":4,"rt":spine.AnimationStateData,"sn":"stateData"},{"at":[new Spine.Unity.SpineAnimation("", "", false, false)],"a":2,"n":"toAnimation","t":4,"rt":$n[0].Array.type(System.String),"sn":"toAnimation"}]}; }, $n);
    /*Spine.Unity.SkeletonDataAsset end.*/

    /*Spine.Unity.SkeletonDataCompatibility start.*/
    $m("Spine.Unity.SkeletonDataCompatibility", function () { return {"nested":[$n[12].SkeletonDataCompatibility.SourceType,$n[12].SkeletonDataCompatibility.VersionInfo,$n[12].SkeletonDataCompatibility.CompatibilityProblemInfo],"att":1048961,"a":2,"s":true}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility end.*/

    /*Spine.Unity.SkeletonDataCompatibility+SourceType start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.SourceType", function () { return {"td":$n[12].SkeletonDataCompatibility,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Binary","is":true,"t":4,"rt":$n[12].SkeletonDataCompatibility.SourceType,"sn":"Binary","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"Json","is":true,"t":4,"rt":$n[12].SkeletonDataCompatibility.SourceType,"sn":"Json","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+SourceType end.*/

    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.VersionInfo", function () { return {"td":$n[12].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"rawVersion","t":4,"rt":$n[0].String,"sn":"rawVersion"},{"a":2,"n":"sourceType","t":4,"rt":$n[12].SkeletonDataCompatibility.SourceType,"sn":"sourceType","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonDataCompatibility.SourceType, System.Enum.toStringFn(Spine.Unity.SkeletonDataCompatibility.SourceType));}},{"a":2,"n":"version","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"version"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+VersionInfo end.*/

    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo start.*/
    $m("Spine.Unity.SkeletonDataCompatibility.CompatibilityProblemInfo", function () { return {"td":$n[12].SkeletonDataCompatibility,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"DescriptionString","t":8,"sn":"DescriptionString","rt":$n[0].String},{"a":2,"n":"actualVersion","t":4,"rt":$n[12].SkeletonDataCompatibility.VersionInfo,"sn":"actualVersion"},{"a":2,"n":"compatibleVersions","t":4,"rt":$n[0].Array.type(System.Array.type(System.Int32)),"sn":"compatibleVersions"},{"a":2,"n":"explicitProblemDescription","t":4,"rt":$n[0].String,"sn":"explicitProblemDescription"}]}; }, $n);
    /*Spine.Unity.SkeletonDataCompatibility+CompatibilityProblemInfo end.*/

    /*Spine.Unity.SkeletonDataModifierAsset start.*/
    $m("Spine.Unity.SkeletonDataModifierAsset", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[18].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[18].SkeletonData]}]}; }, $n);
    /*Spine.Unity.SkeletonDataModifierAsset end.*/

    /*Spine.Unity.SpineAtlasAsset start.*/
    $m("Spine.Unity.SpineAtlasAsset", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine Atlas Asset", menuName: "Spine/Spine Atlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":3}],"sn":"CreateRuntimeInstance","rt":$n[12].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Material),$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$1","rt":$n[12].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Material,$n[0].Boolean,Function]},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"atlasText","pt":$n[1].TextAsset,"ps":0},{"n":"textures","pt":System.Array.type(UnityEngine.Texture2D),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"initialize","pt":$n[0].Boolean,"ps":3},{"n":"newCustomTextureLoader","dv":null,"o":true,"pt":Function,"ps":4}],"sn":"CreateRuntimeInstance$2","rt":$n[12].SpineAtlasAsset,"p":[$n[1].TextAsset,System.Array.type(UnityEngine.Texture2D),$n[1].Shader,$n[0].Boolean,Function]},{"a":2,"n":"GenerateMesh","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"mesh","pt":$n[1].Mesh,"ps":1},{"n":"material","out":true,"pt":$n[1].Material,"ps":2},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"GenerateMesh","rt":$n[1].Mesh,"p":[$n[0].String,$n[1].Mesh,$n[1].Material,$n[0].Single]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[18].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[18].Atlas,"sn":"atlas"},{"a":2,"n":"atlasFile","t":4,"rt":$n[1].TextAsset,"sn":"atlasFile"},{"a":2,"n":"customTextureLoader","t":4,"rt":$n[18].TextureLoader,"sn":"customTextureLoader"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"}]}; }, $n);
    /*Spine.Unity.SpineAtlasAsset end.*/

    /*Spine.Unity.NoOpTextureLoader start.*/
    $m("Spine.Unity.NoOpTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[18].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[18].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]}]}; }, $n);
    /*Spine.Unity.NoOpTextureLoader end.*/

    /*Spine.Unity.MaterialsTextureLoader start.*/
    $m("Spine.Unity.MaterialsTextureLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[12].SpineAtlasAsset],"pi":[{"n":"atlasAsset","pt":$n[12].SpineAtlasAsset,"ps":0}],"sn":"ctor"},{"a":2,"n":"Load","t":8,"pi":[{"n":"page","pt":$n[18].AtlasPage,"ps":0},{"n":"path","pt":$n[0].String,"ps":1}],"sn":"Load","rt":$n[0].Void,"p":[$n[18].AtlasPage,$n[0].String]},{"a":2,"n":"Unload","t":8,"pi":[{"n":"texture","pt":$n[0].Object,"ps":0}],"sn":"Unload","rt":$n[0].Void,"p":[$n[0].Object]},{"a":1,"n":"atlasAsset","t":4,"rt":$n[12].SpineAtlasAsset,"sn":"atlasAsset"}]}; }, $n);
    /*Spine.Unity.MaterialsTextureLoader end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset", function () { return {"nested":[$n[12].SpineSpriteAtlasAsset.SavedRegionInfo],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        fileName: "New Spine SpriteAtlas Asset", menuName: "Spine/Spine SpriteAtlas Asset"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AccessPackedSprites","is":true,"t":8,"pi":[{"n":"spriteAtlas","pt":$n[19].SpriteAtlas,"ps":0}],"sn":"AccessPackedSprites","rt":System.Array.type(UnityEngine.Sprite),"p":[$n[19].SpriteAtlas]},{"a":2,"n":"AccessPackedTexture","is":true,"t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0}],"sn":"AccessPackedTexture","rt":$n[1].Texture2D,"p":[System.Array.type(UnityEngine.Sprite)]},{"a":3,"n":"AssignRegionsFromSavedRegions","t":8,"pi":[{"n":"sprites","pt":System.Array.type(UnityEngine.Sprite),"ps":0},{"n":"usedAtlas","pt":$n[18].Atlas,"ps":1}],"sn":"AssignRegionsFromSavedRegions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Sprite),$n[18].Atlas]},{"ov":true,"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"CreateRuntimeInstance","is":true,"t":8,"pi":[{"n":"spriteAtlasFile","pt":$n[19].SpriteAtlas,"ps":0},{"n":"materials","pt":System.Array.type(UnityEngine.Material),"ps":1},{"n":"initialize","pt":$n[0].Boolean,"ps":2}],"sn":"CreateRuntimeInstance","rt":$n[12].SpineSpriteAtlasAsset,"p":[$n[19].SpriteAtlas,System.Array.type(UnityEngine.Material),$n[0].Boolean]},{"ov":true,"a":2,"n":"GetAtlas","t":8,"pi":[{"n":"onlyMetaData","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"GetAtlas","rt":$n[18].Atlas,"p":[$n[0].Boolean]},{"a":1,"n":"LoadAtlas","t":8,"pi":[{"n":"spriteAtlas","pt":$n[19].SpriteAtlas,"ps":0}],"sn":"LoadAtlas","rt":$n[18].Atlas,"p":[$n[19].SpriteAtlas]},{"a":1,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":2,"n":"IsLoaded","t":16,"rt":$n[0].Boolean,"g":{"ov":true,"a":2,"n":"get_IsLoaded","t":8,"rt":$n[0].Boolean,"fg":"IsLoaded","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLoaded"},{"ov":true,"a":2,"n":"MaterialCount","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_MaterialCount","t":8,"rt":$n[0].Int32,"fg":"MaterialCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaterialCount"},{"ov":true,"a":2,"n":"Materials","t":16,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"g":{"ov":true,"a":2,"n":"get_Materials","t":8,"rt":$n[3].IEnumerable$1(UnityEngine.Material),"fg":"Materials"},"fn":"Materials"},{"ov":true,"a":2,"n":"PrimaryMaterial","t":16,"rt":$n[1].Material,"g":{"ov":true,"a":2,"n":"get_PrimaryMaterial","t":8,"rt":$n[1].Material,"fg":"PrimaryMaterial"},"fn":"PrimaryMaterial"},{"a":3,"n":"atlas","t":4,"rt":$n[18].Atlas,"sn":"atlas"},{"a":2,"n":"materials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materials"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"savedRegions","t":4,"rt":System.Array.type(Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo),"sn":"savedRegions"},{"a":2,"n":"spriteAtlasFile","t":4,"rt":$n[19].SpriteAtlas,"sn":"spriteAtlasFile"},{"a":2,"n":"updateRegionsInPlayMode","t":4,"rt":$n[0].Boolean,"sn":"updateRegionsInPlayMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset end.*/

    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo start.*/
    $m("Spine.Unity.SpineSpriteAtlasAsset.SavedRegionInfo", function () { return {"td":$n[12].SpineSpriteAtlasAsset,"att":1056772,"a":3,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"height","t":4,"rt":$n[0].Single,"sn":"height","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"packingRotation","t":4,"rt":$n[1].SpritePackingRotation,"sn":"packingRotation","box":function ($v) { return Bridge.box($v, UnityEngine.SpritePackingRotation, System.Enum.toStringFn(UnityEngine.SpritePackingRotation));}},{"a":2,"n":"width","t":4,"rt":$n[0].Single,"sn":"width","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"x","t":4,"rt":$n[0].Single,"sn":"x","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"y","t":4,"rt":$n[0].Single,"sn":"y","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SpineSpriteAtlasAsset+SavedRegionInfo end.*/

    /*Spine.Unity.BoneFollower start.*/
    $m("Spine.Unity.BoneFollower", function () { return {"nested":[$n[12].BoneFollower.AxisOrientation],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/BoneFollower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[12].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"bone","t":4,"rt":$n[18].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonRenderer", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale."),new UnityEngine.Serialization.FormerlySerializedAsAttribute("followScale")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("resetOnAwake")],"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollower end.*/

    /*Spine.Unity.BoneFollower+AxisOrientation start.*/
    $m("Spine.Unity.BoneFollower.AxisOrientation", function () { return {"td":$n[12].BoneFollower,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"XAxis","is":true,"t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"XAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"YAxis","is":true,"t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"YAxis","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}}]}; }, $n);
    /*Spine.Unity.BoneFollower+AxisOrientation end.*/

    /*Spine.Unity.BoneFollowerGraphic start.*/
    $m("Spine.Unity.BoneFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/UI/BoneFollowerGraphic"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoneFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"SetBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetBone","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SkeletonGraphic","t":16,"rt":$n[12].SkeletonGraphic,"g":{"a":2,"n":"get_SkeletonGraphic","t":8,"rt":$n[12].SkeletonGraphic,"fg":"SkeletonGraphic"},"s":{"a":2,"n":"set_SkeletonGraphic","t":8,"p":[$n[12].SkeletonGraphic],"rt":$n[0].Void,"fs":"SkeletonGraphic"},"fn":"SkeletonGraphic"},{"a":2,"n":"bone","t":4,"rt":$n[18].Bone,"sn":"bone"},{"at":[new Spine.Unity.SpineBone("", "skeletonGraphic", true, false)],"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":2,"n":"followBoneRotation","t":4,"rt":$n[0].Boolean,"sn":"followBoneRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the target bone's local scale.")],"a":2,"n":"followLocalScale","t":4,"rt":$n[0].Boolean,"sn":"followLocalScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Includes the parent bone's lossy world scale. BoneFollower cannot inherit rotated/skewed scale because of UnityEngine.Transform property limitations.")],"a":2,"n":"followParentWorldScale","t":4,"rt":$n[0].Boolean,"sn":"followParentWorldScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Follows the skeleton's flip state by controlling this Transform's local scale.")],"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followXYPosition","t":4,"rt":$n[0].Boolean,"sn":"followXYPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followZPosition","t":4,"rt":$n[0].Boolean,"sn":"followZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initializeOnAwake","t":4,"rt":$n[0].Boolean,"sn":"initializeOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Applies when 'Follow Skeleton Flip' is disabled but 'Follow Bone Rotation' is enabled. When flipping the skeleton by scaling its Transform, this follower's rotation is adjusted instead of its scale to follow the bone orientation. When one of the axes is flipped,  only one axis can be followed, either the X or the Y axis, which is selected here.")],"a":2,"n":"maintainedAxisOrientation","t":4,"rt":$n[12].BoneFollower.AxisOrientation,"sn":"maintainedAxisOrientation","box":function ($v) { return Bridge.box($v, Spine.Unity.BoneFollower.AxisOrientation, System.Enum.toStringFn(Spine.Unity.BoneFollower.AxisOrientation));}},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoneFollowerGraphic end.*/

    /*Spine.Unity.BoundingBoxFollower start.*/
    $m("Spine.Unity.BoundingBoxFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":3}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[18].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[18].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[18].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"slot","t":4,"rt":$n[18].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollower end.*/

    /*Spine.Unity.BoundingBoxFollowerGraphic start.*/
    $m("Spine.Unity.BoundingBoxFollowerGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#BoundingBoxFollowerGraphic")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddCollidersForSkin","t":8,"pi":[{"n":"skin","pt":$n[18].Skin,"ps":0},{"n":"slotIndex","pt":$n[0].Int32,"ps":1},{"n":"previousColliders","pt":System.Array.type(UnityEngine.PolygonCollider2D),"ps":2},{"n":"scale","pt":$n[0].Single,"ps":3},{"n":"collidersCount","ref":true,"pt":$n[0].Int32,"ps":4}],"sn":"AddCollidersForSkin","rt":$n[0].Void,"p":[$n[18].Skin,$n[0].Int32,System.Array.type(UnityEngine.PolygonCollider2D),$n[0].Single,$n[0].Int32]},{"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":1,"n":"DisposeExcessCollidersAfter","t":8,"pi":[{"n":"requiredCount","pt":$n[0].Int32,"ps":0}],"sn":"DisposeExcessCollidersAfter","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"HandleRebuild","t":8,"pi":[{"n":"sr","pt":$n[12].SkeletonGraphic,"ps":0}],"sn":"HandleRebuild","rt":$n[0].Void,"p":[$n[12].SkeletonGraphic]},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"MatchAttachment","t":8,"pi":[{"n":"attachment","pt":spine.Attachment,"ps":0}],"sn":"MatchAttachment","rt":$n[0].Void,"p":[spine.Attachment]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"CurrentAttachment","t":16,"rt":spine.BoundingBoxAttachment,"g":{"a":2,"n":"get_CurrentAttachment","t":8,"rt":spine.BoundingBoxAttachment,"fg":"CurrentAttachment"},"fn":"CurrentAttachment"},{"a":2,"n":"CurrentAttachmentName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentAttachmentName","t":8,"rt":$n[0].String,"fg":"CurrentAttachmentName"},"fn":"CurrentAttachmentName"},{"a":2,"n":"CurrentCollider","t":16,"rt":$n[1].PolygonCollider2D,"g":{"a":2,"n":"get_CurrentCollider","t":8,"rt":$n[1].PolygonCollider2D,"fg":"CurrentCollider"},"fn":"CurrentCollider"},{"a":2,"n":"IsTrigger","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsTrigger","t":8,"rt":$n[0].Boolean,"fg":"IsTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsTrigger"},{"a":2,"n":"Slot","t":16,"rt":$n[18].Slot,"g":{"a":2,"n":"get_Slot","t":8,"rt":$n[18].Slot,"fg":"Slot"},"fn":"Slot"},{"a":4,"n":"DebugMessages","is":true,"t":4,"rt":$n[0].Boolean,"sn":"DebugMessages","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"colliderTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,UnityEngine.PolygonCollider2D),"sn":"colliderTable","ro":true},{"a":1,"n":"currentAttachment","t":4,"rt":spine.BoundingBoxAttachment,"sn":"currentAttachment"},{"a":1,"n":"currentAttachmentName","t":4,"rt":$n[0].String,"sn":"currentAttachmentName"},{"a":1,"n":"currentCollider","t":4,"rt":$n[1].PolygonCollider2D,"sn":"currentCollider"},{"a":2,"n":"isTrigger","t":4,"rt":$n[0].Boolean,"sn":"isTrigger","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nameTable","t":4,"rt":$n[3].Dictionary$2(spine.BoundingBoxAttachment,System.String),"sn":"nameTable","ro":true},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":1,"n":"slot","t":4,"rt":$n[18].Slot,"sn":"slot"},{"at":[new Spine.Unity.SpineSlot("", "skeletonGraphic", true, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":2,"n":"usedByComposite","t":4,"rt":$n[0].Boolean,"sn":"usedByComposite","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"usedByEffector","t":4,"rt":$n[0].Boolean,"sn":"usedByEffector","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.BoundingBoxFollowerGraphic end.*/

    /*Spine.Unity.PointFollower start.*/
    $m("Spine.Unity.PointFollower", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/Point Follower"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#PointFollower")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleRebuildRenderer","t":8,"pi":[{"n":"skeletonRenderer","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRebuildRenderer","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"UpdateReferences","t":8,"sn":"UpdateReferences","rt":$n[0].Void},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":1,"n":"bone","t":4,"rt":$n[18].Bone,"sn":"bone"},{"a":2,"n":"followRotation","t":4,"rt":$n[0].Boolean,"sn":"followRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonFlip","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"followSkeletonZPosition","t":4,"rt":$n[0].Boolean,"sn":"followSkeletonZPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"point","t":4,"rt":$n[18].PointAttachment,"sn":"point"},{"at":[new Spine.Unity.SpineAttachment(true, false, false, "slotName", "skeletonRenderer", "", true, true)],"a":2,"n":"pointAttachmentName","t":4,"rt":$n[0].String,"sn":"pointAttachmentName"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":1,"n":"skeletonTransformIsParent","t":4,"rt":$n[0].Boolean,"sn":"skeletonTransformIsParent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "skeletonRenderer", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"},{"a":1,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.PointFollower end.*/

    /*Spine.Unity.SkeletonSubmeshGraphic start.*/
    $m("Spine.Unity.SkeletonSubmeshGraphic", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.CanvasRenderer)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnPopulateMesh","t":8,"pi":[{"n":"vh","pt":$n[8].VertexHelper,"ps":0}],"sn":"OnPopulateMesh","rt":$n[0].Void,"p":[$n[8].VertexHelper]},{"ov":true,"a":2,"n":"SetMaterialDirty","t":8,"sn":"SetMaterialDirty","rt":$n[0].Void},{"ov":true,"a":2,"n":"SetVerticesDirty","t":8,"sn":"SetVerticesDirty","rt":$n[0].Void}]}; }, $n);
    /*Spine.Unity.SkeletonSubmeshGraphic end.*/

    /*Spine.Unity.SkeletonMecanimRootMotion start.*/
    $m("Spine.Unity.SkeletonMecanimRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanimRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"layerIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"OnClipApplied","t":8,"pi":[{"n":"animation","pt":$n[18].Animation,"ps":0},{"n":"layerIndex","pt":$n[0].Int32,"ps":1},{"n":"weight","pt":$n[0].Single,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"lastTime","pt":$n[0].Single,"ps":4},{"n":"playsBackward","pt":$n[0].Boolean,"ps":5}],"sn":"OnClipApplied","rt":$n[0].Void,"p":[$n[18].Animation,$n[0].Int32,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"SkeletonMecanim","t":16,"rt":$n[12].SkeletonMecanim,"g":{"a":2,"n":"get_SkeletonMecanim","t":8,"rt":$n[12].SkeletonMecanim,"fg":"SkeletonMecanim"},"fn":"SkeletonMecanim"},{"a":1,"n":"DefaultMecanimLayerFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultMecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"mecanimLayerFlags","t":4,"rt":$n[0].Int32,"sn":"mecanimLayerFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"movementDelta","t":4,"rt":$n[1].Vector2,"sn":"movementDelta"},{"a":3,"n":"rotationDelta","t":4,"rt":$n[0].Single,"sn":"rotationDelta","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"skeletonMecanim","t":4,"rt":$n[12].SkeletonMecanim,"sn":"skeletonMecanim"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanimRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotion start.*/
    $m("Spine.Unity.SkeletonRootMotion", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRootMotion")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[18].TrackEntry,"ps":1},{"n":"track","pt":$n[18].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta","rt":$n[0].Void,"p":[$n[0].Single,$n[18].TrackEntry,$n[18].TrackEntry]},{"a":1,"n":"ApplyMixAlphaToDelta","t":8,"pi":[{"n":"currentDelta","ref":true,"pt":$n[1].Vector2,"ps":0},{"n":"next","pt":$n[18].TrackEntry,"ps":1},{"n":"track","pt":$n[18].TrackEntry,"ps":2}],"sn":"ApplyMixAlphaToDelta$1","rt":$n[0].Void,"p":[$n[1].Vector2,$n[18].TrackEntry,$n[18].TrackEntry]},{"ov":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"ov":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetMixAlpha","t":8,"pi":[{"n":"cumulatedMixAlpha","ref":true,"pt":$n[0].Single,"ps":0},{"n":"next","pt":$n[18].TrackEntry,"ps":1},{"n":"track","pt":$n[18].TrackEntry,"ps":2}],"sn":"GetMixAlpha","rt":$n[0].Void,"p":[$n[0].Single,$n[18].TrackEntry,$n[18].TrackEntry]},{"ov":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"ov":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"ov":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"ov":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":1,"n":"DefaultAnimationTrackFlags","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultAnimationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"animationState","t":4,"rt":$n[18].AnimationState,"sn":"animationState"},{"a":2,"n":"animationTrackFlags","t":4,"rt":$n[0].Int32,"sn":"animationTrackFlags","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotion end.*/

    /*Spine.Unity.SkeletonRootMotionBase start.*/
    $m("Spine.Unity.SkeletonRootMotionBase", function () { return {"nested":[Function,$n[12].SkeletonRootMotionBase.RootMotionInfo],"att":1048705,"a":2,"at":[new UnityEngine.DefaultExecutionOrder(1)],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AdjustRootMotionToDistance","t":8,"pi":[{"n":"distanceToTarget","pt":$n[1].Vector2,"ps":0},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"adjustX","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"adjustY","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"minX","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"maxX","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":5},{"n":"minY","dv":0.0,"o":true,"pt":$n[0].Single,"ps":6},{"n":"maxY","dv":3.40282347E+38,"o":true,"pt":$n[0].Single,"ps":7},{"n":"allowXTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"allowYTranslation","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"AdjustRootMotionToDistance","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"ApplyConstraintToPos","t":8,"pi":[{"n":"animation","pt":$n[18].Animation,"ps":0},{"n":"constraint","pt":$n[18].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintPos","pt":$n[0].Boolean,"ps":4},{"n":"pos","ref":true,"pt":$n[1].Vector2,"ps":5}],"sn":"ApplyConstraintToPos","rt":$n[0].Void,"p":[$n[18].Animation,$n[18].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[1].Vector2]},{"a":1,"n":"ApplyConstraintToRotation","t":8,"pi":[{"n":"animation","pt":$n[18].Animation,"ps":0},{"n":"constraint","pt":$n[18].TransformConstraint,"ps":1},{"n":"constraintIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"useLastConstraintRotation","pt":$n[0].Boolean,"ps":4},{"n":"rotation","ref":true,"pt":$n[0].Single,"ps":5}],"sn":"ApplyConstraintToRotation","rt":$n[0].Void,"p":[$n[18].Animation,$n[18].TransformConstraint,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ApplyRootMotion","t":8,"pi":[{"n":"skeletonTranslationDelta","pt":$n[1].Vector2,"ps":0},{"n":"skeletonRotationDelta","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2},{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":3}],"sn":"ApplyRootMotion","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2,$n[0].Boolean]},{"a":1,"n":"ApplyTransformConstraints","t":8,"sn":"ApplyTransformConstraints","rt":$n[0].Void},{"ab":true,"a":3,"n":"CalculateAnimationsMovementDelta","t":8,"sn":"CalculateAnimationsMovementDelta","rt":$n[1].Vector2},{"v":true,"a":3,"n":"CalculateAnimationsRotationDelta","t":8,"sn":"CalculateAnimationsRotationDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"ClearEffectiveBoneOffsets","t":8,"pi":[{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":0}],"sn":"ClearEffectiveBoneOffsets","rt":$n[0].Void,"p":[$n[1].Vector2]},{"a":1,"n":"ClearRigidbodyTempMovement","t":8,"sn":"ClearRigidbodyTempMovement","rt":$n[0].Void},{"a":3,"n":"FindRigidbodyComponent","t":8,"sn":"FindRigidbodyComponent","rt":$n[0].Void},{"a":1,"n":"FindTransformConstraintsAffectingBone","t":8,"sn":"FindTransformConstraintsAffectingBone","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GatherTopLevelBones","t":8,"sn":"GatherTopLevelBones","rt":$n[0].Void},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"animation","pt":$n[18].Animation,"ps":0}],"sn":"GetAnimationRootMotion","rt":$n[1].Vector2,"p":[$n[18].Animation]},{"a":2,"n":"GetAnimationRootMotion","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[18].Animation,"ps":2}],"sn":"GetAnimationRootMotion$1","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,$n[18].Animation]},{"a":2,"n":"GetAnimationRootMotionInfo","t":8,"pi":[{"n":"animation","pt":$n[18].Animation,"ps":0},{"n":"currentTime","pt":$n[0].Single,"ps":1}],"sn":"GetAnimationRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[18].Animation,$n[0].Single]},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"animation","pt":$n[18].Animation,"ps":0}],"sn":"GetAnimationRootMotionRotation","rt":$n[0].Single,"p":[$n[18].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetAnimationRootMotionRotation","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"animation","pt":$n[18].Animation,"ps":2}],"sn":"GetAnimationRootMotionRotation$1","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[18].Animation],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetConstraintLastPosIndex","t":8,"pi":[{"n":"constraintIndex","pt":$n[0].Int32,"ps":0}],"sn":"GetConstraintLastPosIndex","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ab":true,"a":2,"n":"GetRemainingRootMotion","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRemainingRootMotion","rt":$n[1].Vector2,"p":[$n[0].Int32]},{"ab":true,"a":2,"n":"GetRootMotionInfo","t":8,"pi":[{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":0}],"sn":"GetRootMotionInfo","rt":$n[12].SkeletonRootMotionBase.RootMotionInfo,"p":[$n[0].Int32]},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"sn":"GetScaleAffectingRootMotion","rt":$n[1].Vector2},{"a":1,"n":"GetScaleAffectingRootMotion","t":8,"pi":[{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":0}],"sn":"GetScaleAffectingRootMotion$1","rt":$n[1].Vector2,"p":[$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceMovementDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[1].Vector2,"ps":0},{"n":"parentBoneScale","out":true,"pt":$n[1].Vector2,"ps":1},{"n":"totalScale","out":true,"pt":$n[1].Vector2,"ps":2}],"sn":"GetSkeletonSpaceMovementDelta","rt":$n[1].Vector2,"p":[$n[1].Vector2,$n[1].Vector2,$n[1].Vector2]},{"a":1,"n":"GetSkeletonSpaceRotationDelta","t":8,"pi":[{"n":"boneLocalDelta","pt":$n[0].Single,"ps":0},{"n":"totalScaleAffectingRootMotion","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpaceRotationDelta","rt":$n[0].Single,"p":[$n[0].Single,$n[1].Vector2],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimelineMovementDelta","t":8,"pi":[{"n":"startTime","pt":$n[0].Single,"ps":0},{"n":"endTime","pt":$n[0].Single,"ps":1},{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":2},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":3},{"n":"animation","pt":$n[18].Animation,"ps":4}],"sn":"GetTimelineMovementDelta","rt":$n[1].Vector2,"p":[$n[0].Single,$n[0].Single,spine.TranslateXTimeline,spine.TranslateYTimeline,$n[18].Animation]},{"a":1,"n":"HandleUpdateLocal","t":8,"pi":[{"n":"animatedSkeletonComponent","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"HandleUpdateLocal","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"PhysicsUpdate","t":8,"pi":[{"n":"skeletonAnimationUsesFixedUpdate","pt":$n[0].Boolean,"ps":0}],"sn":"PhysicsUpdate","rt":$n[0].Void,"p":[$n[0].Boolean]},{"v":true,"a":3,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":1,"n":"SetEffectiveBoneOffsetsTo","t":8,"pi":[{"n":"displacementSkeletonSpace","pt":$n[1].Vector2,"ps":0},{"n":"rotationSkeletonSpace","pt":$n[0].Single,"ps":1},{"n":"parentBoneScale","pt":$n[1].Vector2,"ps":2}],"sn":"SetEffectiveBoneOffsetsTo","rt":$n[0].Void,"p":[$n[1].Vector2,$n[0].Single,$n[1].Vector2]},{"a":2,"n":"SetRootMotionBone","t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"SetRootMotionBone","rt":$n[0].Void,"p":[$n[0].String]},{"v":true,"a":3,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":1,"n":"UpdateLastConstraintPos","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintPos","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":1,"n":"UpdateLastConstraintRotation","t":8,"pi":[{"n":"transformConstraintsItems","pt":System.Array.type(Spine.TransformConstraint),"ps":0}],"sn":"UpdateLastConstraintRotation","rt":$n[0].Void,"p":[System.Array.type(Spine.TransformConstraint)]},{"a":2,"n":"AdditionalRigidbody2DMovement","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_AdditionalRigidbody2DMovement","t":8,"rt":$n[1].Vector2,"fg":"AdditionalRigidbody2DMovement"},"s":{"a":2,"n":"set_AdditionalRigidbody2DMovement","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"AdditionalRigidbody2DMovement"},"fn":"AdditionalRigidbody2DMovement"},{"v":true,"a":3,"n":"AdditionalScale","t":16,"rt":$n[0].Single,"g":{"v":true,"a":3,"n":"get_AdditionalScale","t":8,"rt":$n[0].Single,"fg":"AdditionalScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"AdditionalScale"},{"a":2,"n":"PreviousRigidbodyRootMotion2D","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion2D","t":8,"rt":$n[1].Vector2,"fg":"PreviousRigidbodyRootMotion2D"},"fn":"PreviousRigidbodyRootMotion2D"},{"a":2,"n":"PreviousRigidbodyRootMotion3D","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_PreviousRigidbodyRootMotion3D","t":8,"rt":$n[1].Vector3,"fg":"PreviousRigidbodyRootMotion3D"},"fn":"PreviousRigidbodyRootMotion3D"},{"a":2,"n":"RootMotionBone","t":16,"rt":$n[18].Bone,"g":{"a":2,"n":"get_RootMotionBone","t":8,"rt":$n[18].Bone,"fg":"RootMotionBone"},"fn":"RootMotionBone"},{"a":3,"n":"SkeletonAnimationUsesFixedUpdate","t":16,"rt":$n[0].Boolean,"g":{"a":3,"n":"get_SkeletonAnimationUsesFixedUpdate","t":8,"rt":$n[0].Boolean,"fg":"SkeletonAnimationUsesFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"SkeletonAnimationUsesFixedUpdate"},{"a":2,"n":"TargetSkeletonAnimationComponent","t":16,"rt":$n[12].ISkeletonAnimation,"g":{"a":2,"n":"get_TargetSkeletonAnimationComponent","t":8,"rt":$n[12].ISkeletonAnimation,"fg":"TargetSkeletonAnimationComponent"},"fn":"TargetSkeletonAnimationComponent"},{"a":2,"n":"TargetSkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"a":2,"n":"get_TargetSkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"TargetSkeletonComponent"},"fn":"TargetSkeletonComponent"},{"a":2,"n":"UsesRigidbody","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRigidbody","t":8,"rt":$n[0].Boolean,"fg":"UsesRigidbody","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"UsesRigidbody"},{"a":3,"n":"accumulatedUntilFixedUpdate","t":4,"rt":$n[0].Boolean,"sn":"accumulatedUntilFixedUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"additionalRigidbody2DMovement","t":4,"rt":$n[1].Vector2,"sn":"additionalRigidbody2DMovement"},{"a":2,"n":"applyRigidbody2DGravity","t":4,"rt":$n[0].Boolean,"sn":"applyRigidbody2DGravity","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"disableOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"initialOffset","t":4,"rt":$n[1].Vector2,"sn":"initialOffset"},{"a":3,"n":"initialOffsetRotation","t":4,"rt":$n[0].Single,"sn":"initialOffsetRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"previousRigidbodyRootMotion","t":4,"rt":$n[1].Vector3,"sn":"previousRigidbodyRootMotion"},{"a":2,"n":"rigidBody","t":4,"rt":$n[1].Rigidbody,"sn":"rigidBody"},{"at":[new UnityEngine.HeaderAttribute("Optional")],"a":2,"n":"rigidBody2D","t":4,"rt":$n[1].Rigidbody2D,"sn":"rigidBody2D"},{"a":3,"n":"rigidbody2DRotation","t":4,"rt":$n[0].Single,"sn":"rigidbody2DRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"rigidbodyDisplacement","t":4,"rt":$n[1].Vector3,"sn":"rigidbodyDisplacement"},{"a":3,"n":"rigidbodyLocalRotation","t":4,"rt":$n[1].Quaternion,"sn":"rigidbodyLocalRotation"},{"a":3,"n":"rootMotionBone","t":4,"rt":$n[18].Bone,"sn":"rootMotionBone"},{"a":3,"n":"rootMotionBoneIndex","t":4,"rt":$n[0].Int32,"sn":"rootMotionBoneIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new Spine.Unity.SpineBone("", "", true, false),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"rootMotionBoneName","t":4,"rt":$n[0].String,"sn":"rootMotionBoneName"},{"a":2,"n":"rootMotionScaleRotation","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleX","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionScaleY","t":4,"rt":$n[0].Single,"sn":"rootMotionScaleY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateXPerY","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateXPerY","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"rootMotionTranslateYPerX","t":4,"rt":$n[0].Single,"sn":"rootMotionTranslateYPerX","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"skeletonComponent","t":4,"rt":$n[12].ISkeletonComponent,"sn":"skeletonComponent"},{"a":3,"n":"tempSkeletonDisplacement","t":4,"rt":$n[1].Vector2,"sn":"tempSkeletonDisplacement"},{"a":3,"n":"tempSkeletonRotation","t":4,"rt":$n[0].Single,"sn":"tempSkeletonRotation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":3,"n":"topLevelBones","t":4,"rt":$n[3].List$1(Spine.Bone),"sn":"topLevelBones"},{"a":3,"n":"transformConstraintIndices","t":4,"rt":$n[3].List$1(System.Int32),"sn":"transformConstraintIndices"},{"a":3,"n":"transformConstraintLastPos","t":4,"rt":$n[3].List$1(UnityEngine.Vector2),"sn":"transformConstraintLastPos"},{"a":3,"n":"transformConstraintLastRotation","t":4,"rt":$n[3].List$1(System.Single),"sn":"transformConstraintLastRotation"},{"a":2,"n":"transformPositionX","t":4,"rt":$n[0].Boolean,"sn":"transformPositionX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformPositionY","t":4,"rt":$n[0].Boolean,"sn":"transformPositionY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"transformRotation","t":4,"rt":$n[0].Boolean,"sn":"transformRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"PhysicsUpdateRootMotionOverride","t":2,"ad":{"a":2,"n":"add_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addPhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_PhysicsUpdateRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removePhysicsUpdateRootMotionOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"ProcessRootMotionOverride","t":2,"ad":{"a":2,"n":"add_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_ProcessRootMotionOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeProcessRootMotionOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase end.*/

    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo start.*/
    $m("Spine.Unity.SkeletonRootMotionBase.RootMotionInfo", function () { return {"td":$n[12].SkeletonRootMotionBase,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"current","t":4,"rt":$n[1].Vector2,"sn":"current"},{"a":2,"n":"end","t":4,"rt":$n[1].Vector2,"sn":"end"},{"a":2,"n":"mid","t":4,"rt":$n[1].Vector2,"sn":"mid"},{"a":2,"n":"start","t":4,"rt":$n[1].Vector2,"sn":"start"},{"a":2,"n":"timeIsPastMid","t":4,"rt":$n[0].Boolean,"sn":"timeIsPastMid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonRootMotionBase+RootMotionInfo end.*/

    /*Spine.Unity.SkeletonAnimation start.*/
    $m("Spine.Unity.SkeletonAnimation", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonAnimation"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonAnimation-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddToGameObject","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"AddToGameObject","rt":$n[12].SkeletonAnimation,"p":[$n[1].GameObject,$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":2,"n":"NewSkeletonAnimationGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"NewSkeletonAnimationGameObject","rt":$n[12].SkeletonAnimation,"p":[$n[12].SkeletonDataAsset,$n[0].Boolean]},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":3,"n":"Update","t":8,"sn":"Update$1","rt":$n[0].Void},{"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"AnimationName","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_AnimationName","t":8,"rt":$n[0].String,"fg":"AnimationName"},"s":{"a":2,"n":"set_AnimationName","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"AnimationName"},"fn":"AnimationName"},{"a":2,"n":"AnimationState","t":16,"rt":$n[18].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[18].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[12].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[12].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[12].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineAnimation("", "", true, false)],"a":1,"n":"_animationName","t":4,"rt":$n[0].String,"sn":"_animationName"},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"state","t":4,"rt":$n[18].AnimationState,"sn":"state"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[12].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonAnimation end.*/

    /*Spine.Unity.SkeletonGraphic start.*/
    $m("Spine.Unity.SkeletonGraphic", function () { return {"nested":[$n[12].SkeletonGraphic.LayoutMode,Function,Function,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.$ctor1(UnityEngine.CanvasRenderer, UnityEngine.RectTransform),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonGraphic (Unity UI Canvas)"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphic-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSkeletonGraphicComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"AddSkeletonGraphicComponent","rt":$n[12].SkeletonGraphic,"p":[$n[1].GameObject,$n[12].SkeletonDataAsset,$n[1].Material]},{"a":2,"n":"AfterAnimationApplied","t":8,"sn":"AfterAnimationApplied","rt":$n[0].Void},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":3,"n":"DestroyMeshes","t":8,"sn":"DestroyMeshes","rt":$n[0].Void},{"a":3,"n":"DisableUnusedCanvasRenderers","t":8,"pi":[{"n":"usedCount","pt":$n[0].Int32,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"DisableUnusedCanvasRenderers","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"DisposeMeshBuffers","t":8,"sn":"DisposeMeshBuffers","rt":$n[0].Void},{"a":3,"n":"EnsureCanvasRendererCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureCanvasRendererCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureMeshesCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshesCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":3,"n":"EnsureSeparatorPartCount","t":8,"sn":"EnsureSeparatorPartCount","rt":$n[0].Void},{"a":3,"n":"EnsureUsedTexturesAndMaterialsCount","t":8,"pi":[{"n":"targetCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureUsedTexturesAndMaterialsCount","rt":$n[0].Void,"p":[$n[0].Int32]},{"v":true,"a":3,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"GetCurrentRectSize","t":8,"sn":"GetCurrentRectSize","rt":$n[1].Vector2},{"a":2,"n":"GetLastMesh","t":8,"sn":"GetLastMesh","rt":$n[1].Mesh},{"a":3,"n":"GetLayoutScale","t":8,"pi":[{"n":"mode","pt":$n[12].SkeletonGraphic.LayoutMode,"ps":0}],"sn":"GetLayoutScale","rt":$n[0].Single,"p":[$n[12].SkeletonGraphic.LayoutMode],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":2,"n":"HasMultipleSubmeshInstructions","t":8,"sn":"HasMultipleSubmeshInstructions","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"InitMeshBuffers","t":8,"sn":"InitMeshBuffers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":3,"n":"MatchRectTransformMultipleRenderers","t":8,"sn":"MatchRectTransformMultipleRenderers","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"MatchRectTransformSingleRenderer","t":8,"sn":"MatchRectTransformSingleRenderer","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"MatchRectTransformWithBounds","t":8,"sn":"MatchRectTransformWithBounds","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"NewSkeletonGraphicGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"NewSkeletonGraphicGameObject","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonDataAsset,$n[1].Transform,$n[1].Material]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":3,"n":"OnCullStateChanged","t":8,"pi":[{"n":"culled","pt":$n[0].Boolean,"ps":0}],"sn":"OnCullStateChanged","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"PrepareInstructionsAndRenderers","t":8,"pi":[{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":0}],"sn":"PrepareInstructionsAndRenderers","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"PrepareRendererGameObjects","t":8,"pi":[{"n":"currentInstructions","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"isInRebuild","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"PrepareRendererGameObjects","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"ov":true,"a":2,"n":"Rebuild","t":8,"pi":[{"n":"update","pt":$n[8].CanvasUpdate,"ps":0}],"sn":"Rebuild","rt":$n[0].Void,"p":[$n[8].CanvasUpdate]},{"a":1,"n":"SetRectTransformBounds","t":8,"pi":[{"n":"combinedBounds","pt":$n[1].Bounds,"ps":0}],"sn":"SetRectTransformBounds","rt":$n[0].Void,"p":[$n[1].Bounds]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"targetRectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[1].Vector2]},{"a":2,"n":"SetRectTransformSize","is":true,"t":8,"pi":[{"n":"target","pt":$n[8].Graphic,"ps":0},{"n":"size","pt":$n[1].Vector2,"ps":1}],"sn":"SetRectTransformSize$1","rt":$n[0].Void,"p":[$n[8].Graphic,$n[1].Vector2]},{"a":3,"n":"SyncSubmeshGraphicsWithCanvasRenderers","t":8,"sn":"SyncSubmeshGraphicsWithCanvasRenderers","rt":$n[0].Void},{"a":2,"n":"TrimRenderers","t":8,"sn":"TrimRenderers","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimationStatus","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"UpdateAnimationStatus","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateMaterialsMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMaterialsMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMesh","t":8,"sn":"UpdateMesh","rt":$n[0].Void},{"a":3,"n":"UpdateMeshMultipleCanvasRenderers","t":8,"pi":[{"n":"currentInstructions","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshMultipleCanvasRenderers","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":3,"n":"UpdateMeshSingleCanvasRenderer","t":8,"pi":[{"n":"currentInstructions","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"UpdateMeshSingleCanvasRenderer","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":2,"n":"UpdateMeshToInstructions","t":8,"sn":"UpdateMeshToInstructions","rt":$n[0].Void},{"a":3,"n":"UpdateSeparatorPartParents","t":8,"sn":"UpdateSeparatorPartParents","rt":$n[0].Void},{"a":2,"n":"AnimationState","t":16,"rt":$n[18].AnimationState,"g":{"a":2,"n":"get_AnimationState","t":8,"rt":$n[18].AnimationState,"fg":"AnimationState"},"fn":"AnimationState"},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomTextureOverride","t":16,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"g":{"a":2,"n":"get_CustomTextureOverride","t":8,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"fg":"CustomTextureOverride"},"fn":"CustomTextureOverride"},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"MaterialsMultipleCanvasRenderers","t":16,"rt":$n[18].ExposedList$1(UnityEngine.Material),"g":{"a":2,"n":"get_MaterialsMultipleCanvasRenderers","t":8,"rt":$n[18].ExposedList$1(UnityEngine.Material),"fg":"MaterialsMultipleCanvasRenderers"},"fn":"MaterialsMultipleCanvasRenderers"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[12].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[12].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MeshScale","t":8,"rt":$n[0].Single,"fg":"MeshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"MeshScale"},{"a":2,"n":"MeshesMultipleCanvasRenderers","t":16,"rt":$n[18].ExposedList$1(UnityEngine.Mesh),"g":{"a":2,"n":"get_MeshesMultipleCanvasRenderers","t":8,"rt":$n[18].ExposedList$1(UnityEngine.Mesh),"fg":"MeshesMultipleCanvasRenderers"},"fn":"MeshesMultipleCanvasRenderers"},{"a":2,"n":"OverrideTexture","t":16,"rt":$n[1].Texture,"g":{"a":2,"n":"get_OverrideTexture","t":8,"rt":$n[1].Texture,"fg":"OverrideTexture"},"s":{"a":2,"n":"set_OverrideTexture","t":8,"p":[$n[1].Texture],"rt":$n[0].Void,"fs":"OverrideTexture"},"fn":"OverrideTexture"},{"a":2,"n":"SeparatorParts","t":16,"rt":$n[3].List$1(UnityEngine.Transform),"g":{"a":2,"n":"get_SeparatorParts","t":8,"rt":$n[3].List$1(UnityEngine.Transform),"fg":"SeparatorParts"},"fn":"SeparatorParts"},{"a":2,"n":"Skeleton","t":16,"rt":$n[18].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[18].Skeleton,"fg":"Skeleton"},"s":{"a":2,"n":"set_Skeleton","t":8,"p":[$n[18].Skeleton],"rt":$n[0].Void,"fs":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonData","t":16,"rt":$n[18].SkeletonData,"g":{"a":2,"n":"get_SkeletonData","t":8,"rt":$n[18].SkeletonData,"fg":"SkeletonData"},"fn":"SkeletonData"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"TexturesMultipleCanvasRenderers","t":16,"rt":$n[18].ExposedList$1(UnityEngine.Texture),"g":{"a":2,"n":"get_TexturesMultipleCanvasRenderers","t":8,"rt":$n[18].ExposedList$1(UnityEngine.Texture),"fg":"TexturesMultipleCanvasRenderers"},"fn":"TexturesMultipleCanvasRenderers"},{"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UnscaledTime"},"fn":"UnscaledTime"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[12].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[12].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[12].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[12].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[12].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[12].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"ov":true,"a":2,"n":"mainTexture","t":16,"rt":$n[1].Texture,"g":{"ov":true,"a":2,"n":"get_mainTexture","t":8,"rt":$n[1].Texture,"fg":"mainTexture"},"fn":"mainTexture"},{"a":3,"n":"EditReferenceRect","is":true,"t":4,"rt":$n[0].Boolean,"sn":"EditReferenceRect","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SeparatorPartGameObjectName","is":true,"t":4,"rt":$n[0].String,"sn":"SeparatorPartGameObjectName"},{"a":2,"n":"additiveMaterial","t":4,"rt":$n[1].Material,"sn":"additiveMaterial"},{"a":2,"n":"allowMultipleCanvasRenderers","t":4,"rt":$n[0].Boolean,"sn":"allowMultipleCanvasRenderers","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"baseTexture","t":4,"rt":$n[1].Texture,"sn":"baseTexture"},{"a":2,"n":"canvasRenderers","t":4,"rt":$n[3].List$1(UnityEngine.CanvasRenderer),"sn":"canvasRenderers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customTextureOverride","t":4,"rt":$n[3].Dictionary$2(UnityEngine.Texture,UnityEngine.Texture),"sn":"customTextureOverride","ro":true},{"a":2,"n":"disableMeshAssignmentOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableMeshAssignmentOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"enableSeparatorSlots","t":4,"rt":$n[0].Boolean,"sn":"enableSeparatorSlots","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"freeze","t":4,"rt":$n[0].Boolean,"sn":"freeze","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "skeletonDataAsset", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"layoutScaleMode","t":4,"rt":$n[12].SkeletonGraphic.LayoutMode,"sn":"layoutScaleMode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":1,"n":"meshBuffers","t":4,"rt":$n[12].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"meshBuffers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator"},{"a":3,"n":"meshScale","t":4,"rt":$n[0].Single,"sn":"meshScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"meshes","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Mesh),"sn":"meshes","ro":true},{"a":2,"n":"multiplyMaterial","t":4,"rt":$n[1].Material,"sn":"multiplyMaterial"},{"a":1,"n":"overrideTexture","t":4,"rt":$n[1].Texture,"sn":"overrideTexture"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceScale","t":4,"rt":$n[0].Single,"sn":"referenceScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"referenceSize","t":4,"rt":$n[1].Vector2,"sn":"referenceSize"},{"a":2,"n":"screenMaterial","t":4,"rt":$n[1].Material,"sn":"screenMaterial"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"separatorParts","t":4,"rt":$n[3].List$1(UnityEngine.Transform),"sn":"separatorParts"},{"at":[new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[3].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":3,"n":"skeleton","t":4,"rt":$n[18].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"at":[new Spine.Unity.SpineAnimation("", "skeletonDataAsset", true, false)],"a":2,"n":"startingAnimation","t":4,"rt":$n[0].String,"sn":"startingAnimation"},{"a":2,"n":"startingLoop","t":4,"rt":$n[0].Boolean,"sn":"startingLoop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"state","t":4,"rt":$n[18].AnimationState,"sn":"state"},{"a":3,"n":"submeshGraphics","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonSubmeshGraphic),"sn":"submeshGraphics"},{"a":2,"n":"timeScale","t":4,"rt":$n[0].Single,"sn":"timeScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"unscaledTime","t":4,"rt":$n[0].Boolean,"sn":"unscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[12].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateSeparatorPartLocation","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartLocation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"updateSeparatorPartScale","t":4,"rt":$n[0].Boolean,"sn":"updateSeparatorPartScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[12].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[12].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":1,"n":"usedMaterials","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Material),"sn":"usedMaterials","ro":true},{"a":3,"n":"usedRenderersCount","t":4,"rt":$n[0].Int32,"sn":"usedRenderersCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"usedTextures","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Texture),"sn":"usedTextures","ro":true},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AssignMeshOverrideMultipleRenderers","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideMultipleRenderers","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideMultipleRenderers","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"AssignMeshOverrideSingleRenderer","t":2,"ad":{"a":2,"n":"add_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_AssignMeshOverrideSingleRenderer","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeAssignMeshOverrideSingleRenderer","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnInstructionsPrepared","t":2,"ad":{"a":2,"n":"add_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnInstructionsPrepared","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnInstructionsPrepared","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideMultiple","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideMultiple","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideMultiple","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"assignMeshOverrideSingle","t":2,"ad":{"a":1,"n":"add_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_assignMeshOverrideSingle","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeassignMeshOverrideSingle","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic end.*/

    /*Spine.Unity.SkeletonGraphic+LayoutMode start.*/
    $m("Spine.Unity.SkeletonGraphic.LayoutMode", function () { return {"td":$n[12].SkeletonGraphic,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EnvelopeParent","is":true,"t":4,"rt":$n[12].SkeletonGraphic.LayoutMode,"sn":"EnvelopeParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"FitInParent","is":true,"t":4,"rt":$n[12].SkeletonGraphic.LayoutMode,"sn":"FitInParent","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"HeightControlsWidth","is":true,"t":4,"rt":$n[12].SkeletonGraphic.LayoutMode,"sn":"HeightControlsWidth","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"None","is":true,"t":4,"rt":$n[12].SkeletonGraphic.LayoutMode,"sn":"None","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}},{"a":2,"n":"WidthControlsHeight","is":true,"t":4,"rt":$n[12].SkeletonGraphic.LayoutMode,"sn":"WidthControlsHeight","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonGraphic.LayoutMode, System.Enum.toStringFn(Spine.Unity.SkeletonGraphic.LayoutMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonGraphic+LayoutMode end.*/

    /*Spine.Unity.SkeletonMecanim start.*/
    $m("Spine.Unity.SkeletonMecanim", function () { return {"nested":[$n[12].SkeletonMecanim.MecanimTranslator],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.Animator),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonMecanim-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":3,"n":"ApplyAnimation","t":8,"sn":"ApplyAnimation","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"ov":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"v":true,"a":2,"n":"Update","t":8,"pi":[{"n":"deltaTime","pt":$n[0].Single,"ps":0}],"sn":"Update$1","rt":$n[0].Void,"p":[$n[0].Single]},{"a":3,"n":"UpdateAnimation","t":8,"sn":"UpdateAnimation","rt":$n[0].Void},{"a":2,"n":"Translator","t":16,"rt":$n[12].SkeletonMecanim.MecanimTranslator,"g":{"a":2,"n":"get_Translator","t":8,"rt":$n[12].SkeletonMecanim.MecanimTranslator,"fg":"Translator"},"fn":"Translator"},{"a":2,"n":"UpdateTiming","t":16,"rt":$n[12].UpdateTiming,"g":{"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[12].UpdateTiming,"fg":"UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[12].UpdateTiming],"rt":$n[0].Void,"fs":"UpdateTiming"},"fn":"UpdateTiming"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"translator","t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator,"sn":"translator"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"updateTiming","t":4,"rt":$n[12].UpdateTiming,"sn":"updateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":1,"n":"wasUpdatedAfterInit","t":4,"rt":$n[0].Boolean,"sn":"wasUpdatedAfterInit","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"BeforeApply","t":2,"ad":{"a":2,"n":"add_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addBeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeBeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateComplete","t":2,"ad":{"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateLocal","t":2,"ad":{"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"UpdateWorld","t":2,"ad":{"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_BeforeApply","t":2,"ad":{"a":3,"n":"add__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_BeforeApply","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__BeforeApply","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_BeforeApply","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnAnimationRebuild","t":2,"ad":{"a":3,"n":"add__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateComplete","t":2,"ad":{"a":3,"n":"add__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateComplete","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateLocal","t":2,"ad":{"a":3,"n":"add__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateLocal","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_UpdateWorld","t":2,"ad":{"a":3,"n":"add__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_UpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_UpdateWorld","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator", function () { return {"td":$n[12].SkeletonMecanim,"nested":[Function,$n[12].SkeletonMecanim.MecanimTranslator.MixMode,$n[12].SkeletonMecanim.MecanimTranslator.ClipInfos,$n[12].SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer,$n[12].SkeletonMecanim.MecanimTranslator.IntEqualityComparer],"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"AnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Apply","t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[18].Skeleton]},{"a":1,"n":"ApplyAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":1},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"layerIndex","pt":$n[0].Int32,"ps":3},{"n":"layerWeight","pt":$n[0].Single,"ps":4},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":5},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":6}],"sn":"ApplyAnimation","rt":$n[0].Boolean,"p":[$n[18].Skeleton,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ApplyInterruptionAnimation","t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0},{"n":"interpolateWeightTo1","pt":$n[0].Boolean,"ps":1},{"n":"info","pt":$n[1].AnimatorClipInfo,"ps":2},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"layerIndex","pt":$n[0].Int32,"ps":4},{"n":"layerWeight","pt":$n[0].Single,"ps":5},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":6},{"n":"interruptingClipTimeAddition","pt":$n[0].Single,"ps":7},{"n":"useClipWeight1","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8}],"sn":"ApplyInterruptionAnimation","rt":$n[0].Boolean,"p":[$n[18].Skeleton,$n[0].Boolean,$n[1].AnimatorClipInfo,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,spine.MixBlend,$n[0].Single,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"ClearClipInfosForLayers","t":8,"sn":"ClearClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"GetActiveAnimationAndTime","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetActiveAnimationAndTime","rt":$n[3].KeyValuePair$2(Spine.Animation,System.Single),"p":[$n[0].Int32]},{"a":1,"n":"GetAnimation","t":8,"pi":[{"n":"clip","pt":$n[1].AnimationClip,"ps":0}],"sn":"GetAnimation","rt":$n[18].Animation,"p":[$n[1].AnimationClip]},{"a":1,"n":"GetAnimatorClipInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"clipInfoCount","out":true,"pt":$n[0].Int32,"ps":2},{"n":"nextClipInfoCount","out":true,"pt":$n[0].Int32,"ps":3},{"n":"interruptingClipInfoCount","out":true,"pt":$n[0].Int32,"ps":4},{"n":"clipInfo","out":true,"pt":$n[3].IList$1(UnityEngine.AnimatorClipInfo),"ps":5},{"n":"nextClipInfo","out":true,"pt":$n[3].IList$1(UnityEngine.AnimatorClipInfo),"ps":6},{"n":"interruptingClipInfo","out":true,"pt":$n[3].IList$1(UnityEngine.AnimatorClipInfo),"ps":7},{"n":"shallInterpolateWeightTo1","out":true,"pt":$n[0].Boolean,"ps":8}],"sn":"GetAnimatorClipInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[3].IList$1(UnityEngine.AnimatorClipInfo),$n[3].IList$1(UnityEngine.AnimatorClipInfo),$n[3].IList$1(UnityEngine.AnimatorClipInfo),$n[0].Boolean]},{"a":1,"n":"GetAnimatorStateInfos","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"isInterruptionActive","out":true,"pt":$n[0].Boolean,"ps":1},{"n":"stateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":2},{"n":"nextStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":3},{"n":"interruptingStateInfo","out":true,"pt":$n[1].AnimatorStateInfo,"ps":4},{"n":"interruptingClipTimeAddition","out":true,"pt":$n[0].Single,"ps":5}],"sn":"GetAnimatorStateInfos","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[1].AnimatorStateInfo,$n[0].Single]},{"a":1,"n":"GetMixMode","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0},{"n":"layerBlendMode","pt":spine.MixBlend,"ps":1}],"sn":"GetMixMode","rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"p":[$n[0].Int32,spine.MixBlend],"box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":1,"n":"GetStateUpdatesFromAnimator","t":8,"pi":[{"n":"layer","pt":$n[0].Int32,"ps":0}],"sn":"GetStateUpdatesFromAnimator","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"InitClipInfosForLayers","t":8,"sn":"InitClipInfosForLayers","rt":$n[0].Void},{"a":2,"n":"Initialize","t":8,"pi":[{"n":"animator","pt":$n[1].Animator,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[1].Animator,$n[12].SkeletonDataAsset]},{"a":1,"n":"OnClipAppliedCallback","t":8,"pi":[{"n":"clip","pt":$n[18].Animation,"ps":0},{"n":"stateInfo","pt":$n[1].AnimatorStateInfo,"ps":1},{"n":"layerIndex","pt":$n[0].Int32,"ps":2},{"n":"time","pt":$n[0].Single,"ps":3},{"n":"isLooping","pt":$n[0].Boolean,"ps":4},{"n":"weight","pt":$n[0].Single,"ps":5}],"sn":"OnClipAppliedCallback","rt":$n[0].Void,"p":[$n[18].Animation,$n[1].AnimatorStateInfo,$n[0].Int32,$n[0].Single,$n[0].Boolean,$n[0].Single]},{"a":1,"n":"ToSpineAnimationTime","is":true,"t":8,"pi":[{"n":"normalizedTime","pt":$n[0].Single,"ps":0},{"n":"clipLength","pt":$n[0].Single,"ps":1},{"n":"loop","pt":$n[0].Boolean,"ps":2},{"n":"reversed","pt":$n[0].Boolean,"ps":3}],"sn":"ToSpineAnimationTime","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Boolean,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Animator","t":16,"rt":$n[1].Animator,"g":{"a":2,"n":"get_Animator","t":8,"rt":$n[1].Animator,"fg":"Animator"},"fn":"Animator"},{"a":2,"n":"MecanimLayerCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MecanimLayerCount","t":8,"rt":$n[0].Int32,"fg":"MecanimLayerCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MecanimLayerCount"},{"a":2,"n":"MecanimLayerNames","t":16,"rt":$n[0].Array.type(System.String),"g":{"a":2,"n":"get_MecanimLayerNames","t":8,"rt":$n[0].Array.type(System.String),"fg":"MecanimLayerNames"},"fn":"MecanimLayerNames"},{"a":1,"n":"WeightEpsilon","is":true,"t":4,"rt":$n[0].Single,"sn":"WeightEpsilon","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"animationTable","t":4,"rt":$n[3].Dictionary$2(System.Int32,Spine.Animation),"sn":"animationTable","ro":true},{"a":1,"n":"animator","t":4,"rt":$n[1].Animator,"sn":"animator"},{"a":2,"n":"autoReset","t":4,"rt":$n[0].Boolean,"sn":"autoReset","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"clipNameHashCodeTable","t":4,"rt":$n[3].Dictionary$2(UnityEngine.AnimationClip,System.Int32),"sn":"clipNameHashCodeTable","ro":true},{"a":2,"n":"layerBlendModes","t":4,"rt":System.Array.type(spine.MixBlend),"sn":"layerBlendModes"},{"a":3,"n":"layerClipInfos","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos),"sn":"layerClipInfos"},{"a":2,"n":"layerMixModes","t":4,"rt":System.Array.type(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode),"sn":"layerMixModes"},{"a":1,"n":"previousAnimations","t":4,"rt":$n[3].List$1(Spine.Animation),"sn":"previousAnimations","ro":true},{"a":2,"n":"useCustomMixMode","t":4,"rt":$n[0].Boolean,"sn":"useCustomMixMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"OnClipApplied","t":2,"ad":{"a":2,"n":"add_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnClipApplied","rt":$n[0].Void,"p":[Function]}},{"a":3,"n":"_OnClipApplied","t":2,"ad":{"a":3,"n":"add__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"add_OnClipApplied","rt":$n[0].Void,"p":[Function]},"r":{"a":3,"n":"remove__OnClipApplied","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"remove_OnClipApplied","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AlwaysMix","is":true,"t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"AlwaysMix","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"Hard","is":true,"t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"Hard","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}},{"a":2,"n":"MixNext","is":true,"t":4,"rt":$n[12].SkeletonMecanim.MecanimTranslator.MixMode,"sn":"MixNext","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode, System.Enum.toStringFn(Spine.Unity.SkeletonMecanim.MecanimTranslator.MixMode));}}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+MixMode end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.ClipInfos", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":1048580,"a":3,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"clipInfoCount","t":4,"rt":$n[0].Int32,"sn":"clipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"clipInfos","t":4,"rt":$n[3].List$1(UnityEngine.AnimatorClipInfo),"sn":"clipInfos","ro":true},{"a":2,"n":"interruptingClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"interruptingClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"interruptingClipInfos","t":4,"rt":$n[3].List$1(UnityEngine.AnimatorClipInfo),"sn":"interruptingClipInfos","ro":true},{"a":2,"n":"interruptingClipTimeAddition","t":4,"rt":$n[0].Single,"sn":"interruptingClipTimeAddition","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"interruptingStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"interruptingStateInfo"},{"a":2,"n":"isInterruptionActive","t":4,"rt":$n[0].Boolean,"sn":"isInterruptionActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isLastFrameOfInterruption","t":4,"rt":$n[0].Boolean,"sn":"isLastFrameOfInterruption","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"nextClipInfoCount","t":4,"rt":$n[0].Int32,"sn":"nextClipInfoCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"nextClipInfos","t":4,"rt":$n[3].List$1(UnityEngine.AnimatorClipInfo),"sn":"nextClipInfos","ro":true},{"a":2,"n":"nextStateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"nextStateInfo"},{"a":2,"n":"stateInfo","t":4,"rt":$n[1].AnimatorStateInfo,"sn":"stateInfo"}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+ClipInfos end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.AnimationClipEqualityComparer", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[1].AnimationClip,"ps":0},{"n":"y","pt":$n[1].AnimationClip,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[1].AnimationClip,$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[1].AnimationClip,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[1].AnimationClip],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[3].IEqualityComparer$1(UnityEngine.AnimationClip),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+AnimationClipEqualityComparer end.*/

    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer start.*/
    $m("Spine.Unity.SkeletonMecanim.MecanimTranslator.IntEqualityComparer", function () { return {"td":$n[12].SkeletonMecanim.MecanimTranslator,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"x","pt":$n[0].Int32,"ps":0},{"n":"y","pt":$n[0].Int32,"ps":1}],"sn":"equals2","rt":$n[0].Boolean,"p":[$n[0].Int32,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetHashCode","t":8,"pi":[{"n":"o","pt":$n[0].Int32,"ps":0}],"sn":"getHashCode2","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"Instance","is":true,"t":4,"rt":$n[3].IEqualityComparer$1(System.Int32),"sn":"Instance","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonMecanim+MecanimTranslator+IntEqualityComparer end.*/

    /*Spine.Unity.SkeletonRenderer start.*/
    $m("Spine.Unity.SkeletonRenderer", function () { return {"nested":[$n[12].SkeletonRenderer.SpriteMaskInteractionMaterials,Function,Function],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(UnityEngine.MeshRenderer),new UnityEngine.DisallowMultipleComponent(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderer-Component")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddSpineComponent","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"AddSpineComponent","rt":System.Object,"p":[$n[1].GameObject,$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":1,"n":"AssignSpriteMaskMaterials","t":8,"sn":"AssignSpriteMaskMaterials","rt":$n[0].Void},{"v":true,"a":2,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"v":true,"a":2,"n":"ClearState","t":8,"sn":"ClearState","rt":$n[0].Void},{"a":2,"n":"EnsureMeshGeneratorCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0}],"sn":"EnsureMeshGeneratorCapacity","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"slotNamePredicate","pt":Function,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots","rt":$n[0].Void,"p":[Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FindAndApplySeparatorSlots","t":8,"pi":[{"n":"startsWith","pt":$n[0].String,"ps":0},{"n":"clearExistingSeparators","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"updateStringArray","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"FindAndApplySeparatorSlots$1","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"HandleOnDemandLoading","t":8,"sn":"HandleOnDemandLoading","rt":$n[0].Void},{"a":1,"n":"InitSpriteMaskMaterialsForMaskType","t":8,"pi":[{"n":"maskFunction","pt":$n[20].CompareFunction,"ps":0},{"n":"materialsToFill","ref":true,"pt":System.Array.type(UnityEngine.Material),"ps":1}],"sn":"InitSpriteMaskMaterialsForMaskType","rt":$n[0].Boolean,"p":[$n[20].CompareFunction,System.Array.type(UnityEngine.Material)],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsInsideMask","t":8,"sn":"InitSpriteMaskMaterialsInsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InitSpriteMaskMaterialsOutsideMask","t":8,"sn":"InitSpriteMaskMaterialsOutsideMask","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"v":true,"a":2,"n":"Initialize","t":8,"pi":[{"n":"overwrite","pt":$n[0].Boolean,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"Initialize","rt":$n[0].Void,"p":[$n[0].Boolean,$n[0].Boolean]},{"v":true,"a":2,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"v":true,"a":2,"n":"LateUpdateMesh","t":8,"sn":"LateUpdateMesh","rt":$n[0].Void},{"a":2,"n":"NewSpineGameObject","is":true,"t":8,"pi":[{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":0},{"n":"quiet","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"tpc":1,"tprm":["T"],"sn":"NewSpineGameObject","rt":System.Object,"p":[$n[12].SkeletonDataAsset,$n[0].Boolean]},{"a":2,"n":"OnBecameInvisible","t":8,"sn":"OnBecameInvisible","rt":$n[0].Void},{"v":true,"a":2,"n":"OnBecameVisible","t":8,"sn":"OnBecameVisible","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"ReapplySeparatorSlotNames","t":8,"sn":"ReapplySeparatorSlotNames","rt":$n[0].Void},{"a":1,"n":"SetMaterialSettingsToFixDrawOrder","t":8,"sn":"SetMaterialSettingsToFixDrawOrder","rt":$n[0].Void},{"a":2,"n":"SetMeshSettings","t":8,"pi":[{"n":"settings","pt":$n[12].MeshGenerator.Settings,"ps":0}],"sn":"SetMeshSettings","rt":$n[0].Void,"p":[$n[12].MeshGenerator.Settings]},{"a":2,"n":"CustomMaterialOverride","t":16,"rt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"g":{"a":2,"n":"get_CustomMaterialOverride","t":8,"rt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"fg":"CustomMaterialOverride"},"fn":"CustomMaterialOverride"},{"a":2,"n":"CustomSlotMaterials","t":16,"rt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"g":{"a":2,"n":"get_CustomSlotMaterials","t":8,"rt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"fg":"CustomSlotMaterials"},"fn":"CustomSlotMaterials"},{"a":2,"n":"Skeleton","t":16,"rt":$n[18].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[18].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"SkeletonDataAsset"},"fn":"SkeletonDataAsset"},{"a":2,"n":"UpdateMode","t":16,"rt":$n[12].UpdateMode,"g":{"a":2,"n":"get_UpdateMode","t":8,"rt":$n[12].UpdateMode,"fg":"UpdateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},"s":{"a":2,"n":"set_UpdateMode","t":8,"p":[$n[12].UpdateMode],"rt":$n[0].Void,"fs":"UpdateMode"},"fn":"UpdateMode"},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_NONE","is":true,"t":4,"rt":$n[20].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_NONE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","is":true,"t":4,"rt":$n[20].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_INSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","is":true,"t":4,"rt":$n[20].CompareFunction,"sn":"STENCIL_COMP_MASKINTERACTION_VISIBLE_OUTSIDE","box":function ($v) { return Bridge.box($v, UnityEngine.Rendering.CompareFunction, System.Enum.toStringFn(UnityEngine.Rendering.CompareFunction));}},{"a":2,"n":"STENCIL_COMP_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"STENCIL_COMP_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"SUBMESH_DUMMY_PARAM_ID","is":true,"t":4,"rt":$n[0].Int32,"sn":"SUBMESH_DUMMY_PARAM_ID","ro":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("calculateNormals")],"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clearStateOnDisable","t":4,"rt":$n[0].Boolean,"sn":"clearStateOnDisable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"currentInstructions","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"currentInstructions","ro":true},{"a":1,"n":"customMaterialOverride","t":4,"rt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"sn":"customMaterialOverride","ro":true},{"a":1,"n":"customSlotMaterials","t":4,"rt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"sn":"customSlotMaterials","ro":true},{"a":2,"n":"disableRenderingOnOverride","t":4,"rt":$n[0].Boolean,"sn":"disableRenderingOnOverride","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"fixDrawOrder","t":4,"rt":$n[0].Boolean,"sn":"fixDrawOrder","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipX","t":4,"rt":$n[0].Boolean,"sn":"initialFlipX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"initialFlipY","t":4,"rt":$n[0].Boolean,"sn":"initialFlipY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSkin("", "", true, false, true)],"a":2,"n":"initialSkinName","t":4,"rt":$n[0].String,"sn":"initialSkinName"},{"a":2,"n":"maskInteraction","t":4,"rt":$n[1].SpriteMaskInteraction,"sn":"maskInteraction","box":function ($v) { return Bridge.box($v, UnityEngine.SpriteMaskInteraction, System.Enum.toStringFn(UnityEngine.SpriteMaskInteraction));}},{"a":2,"n":"maskMaterials","t":4,"rt":$n[12].SkeletonRenderer.SpriteMaskInteractionMaterials,"sn":"maskMaterials"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator","ro":true},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"rendererBuffers","t":4,"rt":$n[12].MeshRendererBuffers,"sn":"rendererBuffers","ro":true},{"a":1,"n":"reusedPropertyBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"reusedPropertyBlock"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("submeshSeparators"),new UnityEngine.SerializeFieldAttribute(),new Spine.Unity.SpineSlot("", "", false, true, false)],"a":3,"n":"separatorSlotNames","t":4,"rt":$n[0].Array.type(System.String),"sn":"separatorSlotNames"},{"a":2,"n":"separatorSlots","t":4,"rt":$n[3].List$1(Spine.Slot),"sn":"separatorSlots","ro":true},{"a":2,"n":"singleSubmesh","t":4,"rt":$n[0].Boolean,"sn":"singleSubmesh","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skeleton","t":4,"rt":$n[18].Skeleton,"sn":"skeleton"},{"a":2,"n":"skeletonDataAsset","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"skeletonDataAsset"},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"updateMode","t":4,"rt":$n[12].UpdateMode,"sn":"updateMode","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"updateWhenInvisible","t":4,"rt":$n[12].UpdateMode,"sn":"updateWhenInvisible","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GenerateMeshOverride","t":2,"ad":{"a":2,"n":"add_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addGenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_GenerateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeGenerateMeshOverride","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPostProcessVertices","t":2,"ad":{"a":2,"n":"add_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPostProcessVertices","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPostProcessVertices","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPostProcessVertices","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnRebuild","t":2,"ad":{"a":2,"n":"add_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRebuild","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRebuild","rt":$n[0].Void,"p":[Function]}},{"a":1,"n":"generateMeshOverride","t":2,"ad":{"a":1,"n":"add_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addgenerateMeshOverride","rt":$n[0].Void,"p":[Function]},"r":{"a":1,"n":"remove_generateMeshOverride","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removegenerateMeshOverride","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer end.*/

    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials start.*/
    $m("Spine.Unity.SkeletonRenderer.SpriteMaskInteractionMaterials", function () { return {"td":$n[12].SkeletonRenderer,"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AnyMaterialCreated","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_AnyMaterialCreated","t":8,"rt":$n[0].Boolean,"fg":"AnyMaterialCreated","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"AnyMaterialCreated"},{"a":2,"n":"materialsInsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsInsideMask"},{"a":2,"n":"materialsMaskDisabled","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsMaskDisabled"},{"a":2,"n":"materialsOutsideMask","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"materialsOutsideMask"}]}; }, $n);
    /*Spine.Unity.SkeletonRenderer+SpriteMaskInteractionMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials", function () { return {"nested":[$n[12].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,$n[12].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonGraphicCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomTextureOverrides","t":8,"sn":"RemoveCustomTextureOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomTextureOverrides","t":8,"sn":"SetCustomTextureOverrides","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customTextureOverrides","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride),"sn":"customTextureOverrides"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[12].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonGraphicCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonGraphicCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride start.*/
    $m("Spine.Unity.SkeletonGraphicCustomMaterials.AtlasTextureOverride", function () { return {"td":$n[12].SkeletonGraphicCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonGraphicCustomMaterials.AtlasTextureOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonGraphicCustomMaterials.AtlasTextureOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalTexture","t":4,"rt":$n[1].Texture,"sn":"originalTexture"},{"a":2,"n":"overrideEnabled","t":4,"rt":$n[0].Boolean,"sn":"overrideEnabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementTexture","t":4,"rt":$n[1].Texture,"sn":"replacementTexture"}]}; }, $n);
    /*Spine.Unity.SkeletonGraphicCustomMaterials+AtlasTextureOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials", function () { return {"nested":[$n[12].SkeletonRendererCustomMaterials.SlotMaterialOverride,$n[12].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRendererCustomMaterials")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"RemoveCustomMaterialOverrides","t":8,"sn":"RemoveCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"RemoveCustomSlotMaterials","t":8,"sn":"RemoveCustomSlotMaterials","rt":$n[0].Void},{"a":1,"n":"SetCustomMaterialOverrides","t":8,"sn":"SetCustomMaterialOverrides","rt":$n[0].Void},{"a":1,"n":"SetCustomSlotMaterials","t":8,"sn":"SetCustomSlotMaterials","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customMaterialOverrides","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride),"sn":"customMaterialOverrides"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"customSlotMaterials","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride),"sn":"customSlotMaterials"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.SlotMaterialOverride", function () { return {"td":$n[12].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonRendererCustomMaterials.SlotMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonRendererCustomMaterials.SlotMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new Spine.Unity.SpineSlot("", "", false, true, false)],"a":2,"n":"slotName","t":4,"rt":$n[0].String,"sn":"slotName"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+SlotMaterialOverride end.*/

    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride start.*/
    $m("Spine.Unity.SkeletonRendererCustomMaterials.AtlasMaterialOverride", function () { return {"td":$n[12].SkeletonRendererCustomMaterials,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonRendererCustomMaterials.AtlasMaterialOverride,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[12].SkeletonRendererCustomMaterials.AtlasMaterialOverride],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"originalMaterial","t":4,"rt":$n[1].Material,"sn":"originalMaterial"},{"a":2,"n":"overrideDisabled","t":4,"rt":$n[0].Boolean,"sn":"overrideDisabled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"replacementMaterial","t":4,"rt":$n[1].Material,"sn":"replacementMaterial"}]}; }, $n);
    /*Spine.Unity.SkeletonRendererCustomMaterials+AtlasMaterialOverride end.*/

    /*Spine.Unity.SkeletonPartsRenderer start.*/
    $m("Spine.Unity.SkeletonPartsRenderer", function () { return {"nested":[Function],"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor1(UnityEngine.MeshRenderer, UnityEngine.MeshFilter),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClearMesh","t":8,"sn":"ClearMesh","rt":$n[0].Void},{"a":1,"n":"LazyIntialize","t":8,"sn":"LazyIntialize","rt":$n[0].Void},{"a":2,"n":"NewPartsRendererGameObject","is":true,"t":8,"pi":[{"n":"parent","pt":$n[1].Transform,"ps":0},{"n":"name","pt":$n[0].String,"ps":1},{"n":"sortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"NewPartsRendererGameObject","rt":$n[12].SkeletonPartsRenderer,"p":[$n[1].Transform,$n[0].String,$n[0].Int32]},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":2,"n":"RenderParts","t":8,"pi":[{"n":"instructions","pt":$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"RenderParts","rt":$n[0].Void,"p":[$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"SetPropertyBlock","t":8,"pi":[{"n":"block","pt":$n[1].MaterialPropertyBlock,"ps":0}],"sn":"SetPropertyBlock","rt":$n[0].Void,"p":[$n[1].MaterialPropertyBlock]},{"a":2,"n":"MeshFilter","t":16,"rt":$n[1].MeshFilter,"g":{"a":2,"n":"get_MeshFilter","t":8,"rt":$n[1].MeshFilter,"fg":"MeshFilter"},"fn":"MeshFilter"},{"a":2,"n":"MeshGenerator","t":16,"rt":$n[12].MeshGenerator,"g":{"a":2,"n":"get_MeshGenerator","t":8,"rt":$n[12].MeshGenerator,"fg":"MeshGenerator"},"fn":"MeshGenerator"},{"a":2,"n":"MeshRenderer","t":16,"rt":$n[1].MeshRenderer,"g":{"a":2,"n":"get_MeshRenderer","t":8,"rt":$n[1].MeshRenderer,"fg":"MeshRenderer"},"fn":"MeshRenderer"},{"a":1,"n":"buffers","t":4,"rt":$n[12].MeshRendererBuffers,"sn":"buffers"},{"a":1,"n":"currentInstructions","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"currentInstructions"},{"a":1,"n":"meshFilter","t":4,"rt":$n[1].MeshFilter,"sn":"meshFilter"},{"a":1,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator"},{"a":1,"n":"meshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"meshRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonPartsRenderer end.*/

    /*Spine.Unity.SkeletonRenderSeparator start.*/
    $m("Spine.Unity.SkeletonRenderSeparator", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonRenderSeparator")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddPartsRenderer","t":8,"pi":[{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":0},{"n":"name","dv":null,"o":true,"pt":$n[0].String,"ps":1}],"sn":"AddPartsRenderer","rt":$n[12].SkeletonPartsRenderer,"p":[$n[0].Int32,$n[0].String]},{"a":2,"n":"AddToSkeletonRenderer","is":true,"t":8,"pi":[{"n":"skeletonRenderer","pt":$n[12].SkeletonRenderer,"ps":0},{"n":"sortingLayerID","dv":0,"o":true,"pt":$n[0].Int32,"ps":1},{"n":"extraPartsRenderers","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"sortingOrderIncrement","dv":5,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"baseSortingOrder","dv":0,"o":true,"pt":$n[0].Int32,"ps":4},{"n":"addMinimumPartsRenderers","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddToSkeletonRenderer","rt":$n[12].SkeletonRenderSeparator,"p":[$n[12].SkeletonRenderer,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Boolean]},{"a":3,"n":"ClearPartsRendererMeshes","t":8,"sn":"ClearPartsRendererMeshes","rt":$n[0].Void},{"a":1,"n":"HandleRender","t":8,"pi":[{"n":"instruction","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"HandleRender","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"SkeletonRenderer"},"s":{"a":2,"n":"set_SkeletonRenderer","t":8,"p":[$n[12].SkeletonRenderer],"rt":$n[0].Void,"fs":"SkeletonRenderer"},"fn":"SkeletonRenderer"},{"a":2,"n":"DefaultSortingOrderIncrement","is":true,"t":4,"rt":$n[0].Int32,"sn":"DefaultSortingOrderIncrement","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"copiedBlock","t":4,"rt":$n[1].MaterialPropertyBlock,"sn":"copiedBlock"},{"at":[new UnityEngine.TooltipAttribute("Copies MeshRenderer flags into each parts renderer")],"a":2,"n":"copyMeshRendererFlags","t":4,"rt":$n[0].Boolean,"sn":"copyMeshRendererFlags","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"copyPropertyBlock","t":4,"rt":$n[0].Boolean,"sn":"copyPropertyBlock","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"mainMeshRenderer","t":4,"rt":$n[1].MeshRenderer,"sn":"mainMeshRenderer"},{"a":2,"n":"partsRenderers","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonPartsRenderer),"sn":"partsRenderers"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnMeshAndMaterialsUpdated","t":2,"ad":{"a":2,"n":"add_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnMeshAndMaterialsUpdated","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnMeshAndMaterialsUpdated","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonRenderSeparator end.*/

    /*Spine.Unity.ActivateBasedOnFlipDirection start.*/
    $m("Spine.Unity.ActivateBasedOnFlipDirection", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CompensateMovementAfterFlipX","t":8,"pi":[{"n":"toActivate","pt":$n[1].Transform,"ps":0},{"n":"toDeactivate","pt":$n[1].Transform,"ps":1}],"sn":"CompensateMovementAfterFlipX","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"HandleFlip","t":8,"pi":[{"n":"isFlippedX","pt":$n[0].Boolean,"ps":0}],"sn":"HandleFlip","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"ResetJointPositions","t":8,"pi":[{"n":"joints","pt":System.Array.type(UnityEngine.HingeJoint2D),"ps":0}],"sn":"ResetJointPositions","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.HingeJoint2D)]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"activeOnFlippedX","t":4,"rt":$n[1].GameObject,"sn":"activeOnFlippedX"},{"a":2,"n":"activeOnNormalX","t":4,"rt":$n[1].GameObject,"sn":"activeOnNormalX"},{"a":1,"n":"jointsFlippedX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsFlippedX"},{"a":1,"n":"jointsNormalX","t":4,"rt":System.Array.type(UnityEngine.HingeJoint2D),"sn":"jointsNormalX"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[12].ISkeletonComponent,"sn":"skeletonComponent"},{"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":1,"n":"wasFlippedXBefore","t":4,"rt":$n[0].Boolean,"sn":"wasFlippedXBefore","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ActivateBasedOnFlipDirection end.*/

    /*Spine.Unity.SkeletonUtility start.*/
    $m("Spine.Unity.SkeletonUtility", function () { return {"nested":[Function],"att":1048833,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.ISkeletonAnimation),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtility")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoneRigidbody2D","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"isKinematic","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"gravityScale","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"AddBoneRigidbody2D","rt":$n[1].Rigidbody2D,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"AddBoundingBoxAsComponent","is":true,"t":8,"pi":[{"n":"box","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"slot","pt":$n[18].Slot,"ps":1},{"n":"gameObject","pt":$n[1].GameObject,"ps":2},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"AddBoundingBoxAsComponent","rt":$n[1].PolygonCollider2D,"p":[spine.BoundingBoxAttachment,$n[18].Slot,$n[1].GameObject,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":1},{"n":"slot","pt":$n[18].Slot,"ps":2},{"n":"parent","pt":$n[1].Transform,"ps":3},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"AddBoundingBoxGameObject$1","rt":$n[1].PolygonCollider2D,"p":[$n[0].String,spine.BoundingBoxAttachment,$n[18].Slot,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"AddBoundingBoxGameObject","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1},{"n":"slotName","pt":$n[0].String,"ps":2},{"n":"attachmentName","pt":$n[0].String,"ps":3},{"n":"parent","pt":$n[1].Transform,"ps":4},{"n":"isTrigger","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"AddBoundingBoxGameObject","rt":$n[1].PolygonCollider2D,"p":[$n[18].Skeleton,$n[0].String,$n[0].String,$n[0].String,$n[1].Transform,$n[0].Boolean]},{"a":2,"n":"CollectBones","t":8,"sn":"CollectBones","rt":$n[0].Void},{"a":2,"n":"GetBoneRoot","t":8,"sn":"GetBoneRoot","rt":$n[1].Transform},{"a":2,"n":"GetBoundingBoxBounds","is":true,"t":8,"pi":[{"n":"boundingBox","pt":spine.BoundingBoxAttachment,"ps":0},{"n":"depth","dv":0.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"GetBoundingBoxBounds","rt":$n[1].Bounds,"p":[spine.BoundingBoxAttachment,$n[0].Single]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"g","pt":$n[12].SkeletonGraphic,"ps":0}],"sn":"HandleRendererReset","rt":$n[0].Void,"p":[$n[12].SkeletonGraphic]},{"a":1,"n":"HandleRendererReset","t":8,"pi":[{"n":"r","pt":$n[12].SkeletonRenderer,"ps":0}],"sn":"HandleRendererReset$1","rt":$n[0].Void,"p":[$n[12].SkeletonRenderer]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"RegisterBone","t":8,"pi":[{"n":"bone","pt":$n[12].SkeletonUtilityBone,"ps":0}],"sn":"RegisterBone","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone]},{"a":2,"n":"RegisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[12].SkeletonUtilityConstraint,"ps":0}],"sn":"RegisterConstraint","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityConstraint]},{"a":2,"n":"ResubscribeEvents","t":8,"sn":"ResubscribeEvents","rt":$n[0].Void},{"a":2,"n":"SetColliderPointsLocal","is":true,"t":8,"pi":[{"n":"collider","pt":$n[1].PolygonCollider2D,"ps":0},{"n":"slot","pt":$n[18].Slot,"ps":1},{"n":"box","pt":spine.BoundingBoxAttachment,"ps":2},{"n":"scale","dv":1.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"SetColliderPointsLocal","rt":$n[0].Void,"p":[$n[1].PolygonCollider2D,$n[18].Slot,spine.BoundingBoxAttachment,$n[0].Single]},{"a":2,"n":"SpawnBone","t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBone","rt":$n[1].GameObject,"p":[$n[18].Bone,$n[1].Transform,$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnBoneRecursively","t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":2},{"n":"pos","pt":$n[0].Boolean,"ps":3},{"n":"rot","pt":$n[0].Boolean,"ps":4},{"n":"sca","pt":$n[0].Boolean,"ps":5}],"sn":"SpawnBoneRecursively","rt":$n[1].GameObject,"p":[$n[18].Bone,$n[1].Transform,$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnHierarchy","t":8,"pi":[{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnHierarchy","rt":$n[1].GameObject,"p":[$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"SpawnRoot","t":8,"pi":[{"n":"mode","pt":$n[12].SkeletonUtilityBone.Mode,"ps":0},{"n":"pos","pt":$n[0].Boolean,"ps":1},{"n":"rot","pt":$n[0].Boolean,"ps":2},{"n":"sca","pt":$n[0].Boolean,"ps":3}],"sn":"SpawnRoot","rt":$n[1].GameObject,"p":[$n[12].SkeletonUtilityBone.Mode,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"UnregisterBone","t":8,"pi":[{"n":"bone","pt":$n[12].SkeletonUtilityBone,"ps":0}],"sn":"UnregisterBone","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone]},{"a":2,"n":"UnregisterConstraint","t":8,"pi":[{"n":"constraint","pt":$n[12].SkeletonUtilityConstraint,"ps":0}],"sn":"UnregisterConstraint","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityConstraint]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllBones","t":8,"pi":[{"n":"phase","pt":$n[12].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"UpdateAllBones","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"UpdateComplete","t":8,"pi":[{"n":"anim","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"UpdateComplete","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"a":1,"n":"UpdateLocal","t":8,"pi":[{"n":"anim","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"UpdateLocal","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"a":1,"n":"UpdateWorld","t":8,"pi":[{"n":"anim","pt":$n[12].ISkeletonAnimation,"ps":0}],"sn":"UpdateWorld","rt":$n[0].Void,"p":[$n[12].ISkeletonAnimation]},{"a":2,"n":"IsValid","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsValid","t":8,"rt":$n[0].Boolean,"fg":"IsValid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsValid"},{"a":2,"n":"PositionScale","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_PositionScale","t":8,"rt":$n[0].Single,"fg":"PositionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"PositionScale"},{"a":2,"n":"Skeleton","t":16,"rt":$n[18].Skeleton,"g":{"a":2,"n":"get_Skeleton","t":8,"rt":$n[18].Skeleton,"fg":"Skeleton"},"fn":"Skeleton"},{"a":2,"n":"SkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"SkeletonComponent"},"fn":"SkeletonComponent"},{"a":2,"n":"boneComponents","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonUtilityBone),"sn":"boneComponents"},{"a":2,"n":"boneRoot","t":4,"rt":$n[1].Transform,"sn":"boneRoot"},{"a":2,"n":"constraintComponents","t":4,"rt":$n[3].List$1(Spine.Unity.SkeletonUtilityConstraint),"sn":"constraintComponents"},{"a":2,"n":"flipBy180DegreeRotation","t":4,"rt":$n[0].Boolean,"sn":"flipBy180DegreeRotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasConstraints","t":4,"rt":$n[0].Boolean,"sn":"hasConstraints","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"hasOverrideBones","t":4,"rt":$n[0].Boolean,"sn":"hasOverrideBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"needToReprocessBones","t":4,"rt":$n[0].Boolean,"sn":"needToReprocessBones","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"positionScale","t":4,"rt":$n[0].Single,"sn":"positionScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"skeletonAnimation","t":4,"rt":$n[12].ISkeletonAnimation,"sn":"skeletonAnimation"},{"a":1,"n":"skeletonComponent","t":4,"rt":$n[12].ISkeletonComponent,"sn":"skeletonComponent"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonGraphic","t":4,"rt":$n[12].SkeletonGraphic,"sn":"skeletonGraphic"},{"at":[new UnityEngine.HideInInspector()],"a":2,"n":"skeletonRenderer","t":4,"rt":$n[12].SkeletonRenderer,"sn":"skeletonRenderer"},{"a":2,"n":"OnReset","t":2,"ad":{"a":2,"n":"add_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnReset","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnReset","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnReset","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*Spine.Unity.SkeletonUtility end.*/

    /*Spine.Unity.SkeletonUtilityBone start.*/
    $m("Spine.Unity.SkeletonUtilityBone", function () { return {"nested":[$n[12].SkeletonUtilityBone.Mode,$n[12].SkeletonUtilityBone.UpdatePhase],"att":1048577,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.AddComponentMenu.ctor("Spine/SkeletonUtilityBone"),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityBone")],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddBoundingBox","t":8,"pi":[{"n":"skinName","pt":$n[0].String,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"AddBoundingBox","rt":$n[0].Void,"p":[$n[0].String,$n[0].String,$n[0].String]},{"a":2,"n":"BoneTransformModeIncompatible","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"BoneTransformModeIncompatible","rt":$n[0].Boolean,"p":[$n[18].Bone],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"DoUpdate","t":8,"pi":[{"n":"phase","pt":$n[12].SkeletonUtilityBone.UpdatePhase,"ps":0}],"sn":"DoUpdate","rt":$n[0].Void,"p":[$n[12].SkeletonUtilityBone.UpdatePhase]},{"a":1,"n":"HandleOnReset","t":8,"sn":"HandleOnReset","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Reset","t":8,"sn":"Reset","rt":$n[0].Void},{"a":2,"n":"IncompatibleTransformMode","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IncompatibleTransformMode","t":8,"rt":$n[0].Boolean,"fg":"IncompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IncompatibleTransformMode"},{"a":2,"n":"bone","t":4,"rt":$n[18].Bone,"sn":"bone"},{"a":2,"n":"boneName","t":4,"rt":$n[0].String,"sn":"boneName"},{"a":1,"n":"cachedTransform","t":4,"rt":$n[1].Transform,"sn":"cachedTransform"},{"a":2,"n":"hierarchy","t":4,"rt":$n[12].SkeletonUtility,"sn":"hierarchy"},{"a":1,"n":"incompatibleTransformMode","t":4,"rt":$n[0].Boolean,"sn":"incompatibleTransformMode","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"mode","t":4,"rt":$n[12].SkeletonUtilityBone.Mode,"sn":"mode","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"overrideAlpha","t":4,"rt":$n[0].Single,"sn":"overrideAlpha","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"parentReference","t":4,"rt":$n[1].Transform,"sn":"parentReference"},{"a":2,"n":"position","t":4,"rt":$n[0].Boolean,"sn":"position","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotation","t":4,"rt":$n[0].Boolean,"sn":"rotation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"scale","t":4,"rt":$n[0].Boolean,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"skeletonTransform","t":4,"rt":$n[1].Transform,"sn":"skeletonTransform"},{"a":2,"n":"transformLerpComplete","t":4,"rt":$n[0].Boolean,"sn":"transformLerpComplete","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"valid","t":4,"rt":$n[0].Boolean,"sn":"valid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"zPosition","t":4,"rt":$n[0].Boolean,"sn":"zPosition","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone end.*/

    /*Spine.Unity.SkeletonUtilityBone+Mode start.*/
    $m("Spine.Unity.SkeletonUtilityBone.Mode", function () { return {"td":$n[12].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Follow","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.Mode,"sn":"Follow","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}},{"a":2,"n":"Override","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.Mode,"sn":"Override","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.Mode, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.Mode));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+Mode end.*/

    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase start.*/
    $m("Spine.Unity.SkeletonUtilityBone.UpdatePhase", function () { return {"td":$n[12].SkeletonUtilityBone,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Complete","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.UpdatePhase,"sn":"Complete","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"Local","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.UpdatePhase,"sn":"Local","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}},{"a":2,"n":"World","is":true,"t":4,"rt":$n[12].SkeletonUtilityBone.UpdatePhase,"sn":"World","box":function ($v) { return Bridge.box($v, Spine.Unity.SkeletonUtilityBone.UpdatePhase, System.Enum.toStringFn(Spine.Unity.SkeletonUtilityBone.UpdatePhase));}}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityBone+UpdatePhase end.*/

    /*Spine.Unity.SkeletonUtilityConstraint start.*/
    $m("Spine.Unity.SkeletonUtilityConstraint", function () { return {"att":1048705,"a":2,"at":[new UnityEngine.ExecuteAlwaysAttribute(),new UnityEngine.RequireComponent.ctor(Spine.Unity.SkeletonUtilityBone),new UnityEngine.HelpURLAttribute("http://esotericsoftware.com/spine-unity#SkeletonUtilityConstraint")],"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"DoUpdate","t":8,"sn":"DoUpdate","rt":$n[0].Void},{"v":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":3,"n":"bone","t":4,"rt":$n[12].SkeletonUtilityBone,"sn":"bone"},{"a":3,"n":"hierarchy","t":4,"rt":$n[12].SkeletonUtility,"sn":"hierarchy"}]}; }, $n);
    /*Spine.Unity.SkeletonUtilityConstraint end.*/

    /*Spine.Unity.UpdateMode start.*/
    $m("Spine.Unity.UpdateMode", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"EverythingExceptMesh","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"EverythingExceptMesh","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"FullUpdate","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"FullUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"Nothing","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"Nothing","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyAnimationStatus","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"OnlyAnimationStatus","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}},{"a":2,"n":"OnlyEventTimelines","is":true,"t":4,"rt":$n[12].UpdateMode,"sn":"OnlyEventTimelines","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateMode, System.Enum.toStringFn(Spine.Unity.UpdateMode));}}]}; }, $n);
    /*Spine.Unity.UpdateMode end.*/

    /*Spine.Unity.UpdateTiming start.*/
    $m("Spine.Unity.UpdateTiming", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"InFixedUpdate","is":true,"t":4,"rt":$n[12].UpdateTiming,"sn":"InFixedUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InLateUpdate","is":true,"t":4,"rt":$n[12].UpdateTiming,"sn":"InLateUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"InUpdate","is":true,"t":4,"rt":$n[12].UpdateTiming,"sn":"InUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},{"a":2,"n":"ManualUpdate","is":true,"t":4,"rt":$n[12].UpdateTiming,"sn":"ManualUpdate","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.UpdateTiming end.*/

    /*Spine.Unity.ISpineComponent start.*/
    $m("Spine.Unity.ISpineComponent", function () { return {"att":1048737,"a":2}; }, $n);
    /*Spine.Unity.ISpineComponent end.*/

    /*Spine.Unity.ISpineComponentExtensions start.*/
    $m("Spine.Unity.ISpineComponentExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"IsNullOrDestroyed","is":true,"t":8,"pi":[{"n":"component","pt":$n[12].ISpineComponent,"ps":0}],"sn":"IsNullOrDestroyed","rt":$n[0].Boolean,"p":[$n[12].ISpineComponent],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.ISpineComponentExtensions end.*/

    /*Spine.Unity.ISkeletonAnimation start.*/
    $m("Spine.Unity.ISkeletonAnimation", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[18].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[18].Skeleton,"fg":"Spine$Unity$ISkeletonAnimation$Skeleton"},"fn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"ab":true,"a":2,"n":"UpdateTiming","t":16,"rt":$n[12].UpdateTiming,"g":{"ab":true,"a":2,"n":"get_UpdateTiming","t":8,"rt":$n[12].UpdateTiming,"fg":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}},"s":{"ab":true,"a":2,"n":"set_UpdateTiming","t":8,"p":[$n[12].UpdateTiming],"rt":$n[0].Void,"fs":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},"fn":"Spine$Unity$ISkeletonAnimation$UpdateTiming"},{"ab":true,"a":2,"n":"OnAnimationRebuild","t":2,"ad":{"ab":true,"a":2,"n":"add_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addOnAnimationRebuild","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnAnimationRebuild","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeOnAnimationRebuild","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateComplete","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateComplete","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateComplete","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateComplete","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateLocal","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateLocal","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateLocal","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateLocal","rt":$n[0].Void,"p":[Function]}},{"ab":true,"a":2,"n":"UpdateWorld","t":2,"ad":{"ab":true,"a":2,"n":"add_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$addUpdateWorld","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_UpdateWorld","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"Spine$Unity$ISkeletonAnimation$removeUpdateWorld","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[18].Skeleton,"sn":"Spine$Unity$ISkeletonAnimation$Skeleton"},{"a":1,"backing":true,"n":"<UpdateTiming>k__BackingField","t":4,"rt":$n[12].UpdateTiming,"sn":"Spine$Unity$ISkeletonAnimation$UpdateTiming","box":function ($v) { return Bridge.box($v, Spine.Unity.UpdateTiming, System.Enum.toStringFn(Spine.Unity.UpdateTiming));}}]}; }, $n);
    /*Spine.Unity.ISkeletonAnimation end.*/

    /*Spine.Unity.IHasSkeletonDataAsset start.*/
    $m("Spine.Unity.IHasSkeletonDataAsset", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},"fn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"Spine$Unity$IHasSkeletonDataAsset$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonDataAsset end.*/

    /*Spine.Unity.ISkeletonComponent start.*/
    $m("Spine.Unity.ISkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Skeleton","t":16,"rt":$n[18].Skeleton,"g":{"ab":true,"a":2,"n":"get_Skeleton","t":8,"rt":$n[18].Skeleton,"fg":"Spine$Unity$ISkeletonComponent$Skeleton"},"fn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"ab":true,"a":2,"n":"SkeletonDataAsset","t":16,"rt":$n[12].SkeletonDataAsset,"g":{"ab":true,"a":2,"n":"get_SkeletonDataAsset","t":8,"rt":$n[12].SkeletonDataAsset,"fg":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},"fn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"},{"a":1,"backing":true,"n":"<Skeleton>k__BackingField","t":4,"rt":$n[18].Skeleton,"sn":"Spine$Unity$ISkeletonComponent$Skeleton"},{"a":1,"backing":true,"n":"<SkeletonDataAsset>k__BackingField","t":4,"rt":$n[12].SkeletonDataAsset,"sn":"Spine$Unity$ISkeletonComponent$SkeletonDataAsset"}]}; }, $n);
    /*Spine.Unity.ISkeletonComponent end.*/

    /*Spine.Unity.IAnimationStateComponent start.*/
    $m("Spine.Unity.IAnimationStateComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AnimationState","t":16,"rt":$n[18].AnimationState,"g":{"ab":true,"a":2,"n":"get_AnimationState","t":8,"rt":$n[18].AnimationState,"fg":"Spine$Unity$IAnimationStateComponent$AnimationState"},"fn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"ab":true,"a":2,"n":"UnscaledTime","t":16,"rt":$n[0].Boolean,"g":{"ab":true,"a":2,"n":"get_UnscaledTime","t":8,"rt":$n[0].Boolean,"fg":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"ab":true,"a":2,"n":"set_UnscaledTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},"fn":"Spine$Unity$IAnimationStateComponent$UnscaledTime"},{"a":1,"backing":true,"n":"<AnimationState>k__BackingField","t":4,"rt":$n[18].AnimationState,"sn":"Spine$Unity$IAnimationStateComponent$AnimationState"},{"a":1,"backing":true,"n":"<UnscaledTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"Spine$Unity$IAnimationStateComponent$UnscaledTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.IAnimationStateComponent end.*/

    /*Spine.Unity.IHasSkeletonRenderer start.*/
    $m("Spine.Unity.IHasSkeletonRenderer", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonRenderer","t":16,"rt":$n[12].SkeletonRenderer,"g":{"ab":true,"a":2,"n":"get_SkeletonRenderer","t":8,"rt":$n[12].SkeletonRenderer,"fg":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},"fn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"},{"a":1,"backing":true,"n":"<SkeletonRenderer>k__BackingField","t":4,"rt":$n[12].SkeletonRenderer,"sn":"Spine$Unity$IHasSkeletonRenderer$SkeletonRenderer"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonRenderer end.*/

    /*Spine.Unity.IHasSkeletonComponent start.*/
    $m("Spine.Unity.IHasSkeletonComponent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"SkeletonComponent","t":16,"rt":$n[12].ISkeletonComponent,"g":{"ab":true,"a":2,"n":"get_SkeletonComponent","t":8,"rt":$n[12].ISkeletonComponent,"fg":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},"fn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"},{"a":1,"backing":true,"n":"<SkeletonComponent>k__BackingField","t":4,"rt":$n[12].ISkeletonComponent,"sn":"Spine$Unity$IHasSkeletonComponent$SkeletonComponent"}]}; }, $n);
    /*Spine.Unity.IHasSkeletonComponent end.*/

    /*Spine.Unity.DoubleBuffered$1 start.*/
    $m("Spine.Unity.DoubleBuffered$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetCurrent","t":8,"sn":"GetCurrent","rt":T},{"a":2,"n":"GetNext","t":8,"sn":"GetNext","rt":T},{"a":1,"n":"a","t":4,"rt":T,"sn":"a","ro":true},{"a":1,"n":"b","t":4,"rt":T,"sn":"b","ro":true},{"a":1,"n":"usingA","t":4,"rt":$n[0].Boolean,"sn":"usingA","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.DoubleBuffered$1 end.*/

    /*Spine.Unity.MeshGeneratorBuffers start.*/
    $m("Spine.Unity.MeshGeneratorBuffers", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"colorBuffer","t":4,"rt":System.Array.type(UnityEngine.Color32),"sn":"colorBuffer"},{"a":2,"n":"meshGenerator","t":4,"rt":$n[12].MeshGenerator,"sn":"meshGenerator"},{"a":2,"n":"uvBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"uvBuffer"},{"a":2,"n":"vertexBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"vertexBuffer"},{"a":2,"n":"vertexCount","t":4,"rt":$n[0].Int32,"sn":"vertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.MeshGeneratorBuffers end.*/

    /*Spine.Unity.MeshGenerator start.*/
    $m("Spine.Unity.MeshGenerator", function () { return {"nested":[$n[12].MeshGenerator.Settings],"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"AddAttachmentTintBlack","t":8,"pi":[{"n":"r2","pt":$n[0].Single,"ps":0},{"n":"g2","pt":$n[0].Single,"ps":1},{"n":"b2","pt":$n[0].Single,"ps":2},{"n":"a","pt":$n[0].Single,"ps":3},{"n":"vertexCount","pt":$n[0].Int32,"ps":4}],"sn":"AddAttachmentTintBlack","rt":$n[0].Void,"p":[$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Int32]},{"a":2,"n":"AddSubmesh","t":8,"pi":[{"n":"instruction","pt":$n[12].SubmeshInstruction,"ps":0},{"n":"updateTriangles","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"AddSubmesh","rt":$n[0].Void,"p":[$n[12].SubmeshInstruction,$n[0].Boolean]},{"a":2,"n":"Begin","t":8,"sn":"Begin","rt":$n[0].Void},{"a":2,"n":"BuildMesh","t":8,"pi":[{"n":"instruction","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMesh","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"BuildMeshWithArrays","t":8,"pi":[{"n":"instruction","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"updateTriangles","pt":$n[0].Boolean,"ps":1}],"sn":"BuildMeshWithArrays","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[0].Boolean]},{"a":2,"n":"EnsureVertexCapacity","t":8,"pi":[{"n":"minimumVertexCount","pt":$n[0].Int32,"ps":0},{"n":"inlcudeTintBlack","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"includeTangents","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNormals","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"EnsureVertexCapacity","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"FillLateVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillLateVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"regionAttachment","pt":$n[18].RegionAttachment,"ps":1}],"sn":"FillMeshLocal$1","rt":$n[0].Void,"p":[$n[1].Mesh,$n[18].RegionAttachment]},{"a":2,"n":"FillMeshLocal","is":true,"t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0},{"n":"meshAttachment","pt":$n[18].MeshAttachment,"ps":1},{"n":"skeletonData","pt":$n[18].SkeletonData,"ps":2}],"sn":"FillMeshLocal","rt":$n[0].Void,"p":[$n[1].Mesh,$n[18].MeshAttachment,$n[18].SkeletonData]},{"a":2,"n":"FillTriangles","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillTriangles","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"FillVertexData","t":8,"pi":[{"n":"mesh","pt":$n[1].Mesh,"ps":0}],"sn":"FillVertexData","rt":$n[0].Void,"p":[$n[1].Mesh]},{"a":2,"n":"GenerateSingleSubmeshInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[18].Skeleton,"ps":1},{"n":"material","pt":$n[1].Material,"ps":2}],"sn":"GenerateSingleSubmeshInstruction","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[18].Skeleton,$n[1].Material]},{"a":2,"n":"GenerateSkeletonRendererInstruction","is":true,"t":8,"pi":[{"n":"instructionOutput","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"skeleton","pt":$n[18].Skeleton,"ps":1},{"n":"customSlotMaterials","pt":$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),"ps":2},{"n":"separatorSlots","pt":$n[3].List$1(Spine.Slot),"ps":3},{"n":"generateMeshOverride","pt":$n[0].Boolean,"ps":4},{"n":"immutableTriangles","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"GenerateSkeletonRendererInstruction","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction,$n[18].Skeleton,$n[3].Dictionary$2(Spine.Slot,UnityEngine.Material),$n[3].List$1(Spine.Slot),$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"GetMeshBounds","t":8,"sn":"GetMeshBounds","rt":$n[1].Bounds},{"a":2,"n":"RequiresMultipleSubmeshesByDrawOrder","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0}],"sn":"RequiresMultipleSubmeshesByDrawOrder","rt":$n[0].Boolean,"p":[$n[18].Skeleton],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"ScaleVertexData","t":8,"pi":[{"n":"scale","pt":$n[0].Single,"ps":0}],"sn":"ScaleVertexData","rt":$n[0].Void,"p":[$n[0].Single]},{"a":4,"n":"SolveTangents2DBuffer","is":true,"t":8,"pi":[{"n":"tangents","pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2}],"sn":"SolveTangents2DBuffer","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":4,"n":"SolveTangents2DEnsureSize","is":true,"t":8,"pi":[{"n":"tangentBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector4),"ps":0},{"n":"tempTanBuffer","ref":true,"pt":System.Array.type(UnityEngine.Vector2),"ps":1},{"n":"vertexCount","pt":$n[0].Int32,"ps":2},{"n":"vertexBufferLength","pt":$n[0].Int32,"ps":3}],"sn":"SolveTangents2DEnsureSize","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector4),System.Array.type(UnityEngine.Vector2),$n[0].Int32,$n[0].Int32]},{"a":4,"n":"SolveTangents2DTriangles","is":true,"t":8,"pi":[{"n":"tempTanBuffer","pt":System.Array.type(UnityEngine.Vector2),"ps":0},{"n":"triangles","pt":$n[0].Array.type(System.Int32),"ps":1},{"n":"triangleCount","pt":$n[0].Int32,"ps":2},{"n":"vertices","pt":System.Array.type(UnityEngine.Vector3),"ps":3},{"n":"uvs","pt":System.Array.type(UnityEngine.Vector2),"ps":4},{"n":"vertexCount","pt":$n[0].Int32,"ps":5}],"sn":"SolveTangents2DTriangles","rt":$n[0].Void,"p":[System.Array.type(UnityEngine.Vector2),$n[0].Array.type(System.Int32),$n[0].Int32,System.Array.type(UnityEngine.Vector3),System.Array.type(UnityEngine.Vector2),$n[0].Int32]},{"a":2,"n":"SubmeshIndexCount","t":8,"pi":[{"n":"submeshIndex","pt":$n[0].Int32,"ps":0}],"sn":"SubmeshIndexCount","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"TrimExcess","t":8,"sn":"TrimExcess","rt":$n[0].Void},{"a":2,"n":"TryReplaceMaterials","is":true,"t":8,"pi":[{"n":"workingSubmeshInstructions","pt":$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"customMaterialOverride","pt":$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material),"ps":1}],"sn":"TryReplaceMaterials","rt":$n[0].Void,"p":[$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[3].Dictionary$2(UnityEngine.Material,UnityEngine.Material)]},{"a":2,"n":"Buffers","t":16,"rt":$n[12].MeshGeneratorBuffers,"g":{"a":2,"n":"get_Buffers","t":8,"rt":$n[12].MeshGeneratorBuffers,"fg":"Buffers"},"fn":"Buffers"},{"a":2,"n":"VertexCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_VertexCount","t":8,"rt":$n[0].Int32,"fg":"VertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"VertexCount"},{"a":1,"n":"AttachmentColors32","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Color32),"sn":"AttachmentColors32"},{"a":1,"n":"AttachmentIndices","is":true,"t":4,"rt":$n[3].List$1(System.Int32),"sn":"AttachmentIndices"},{"a":1,"n":"AttachmentUVs","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Vector2),"sn":"AttachmentUVs"},{"a":1,"n":"AttachmentVerts","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Vector3),"sn":"AttachmentVerts"},{"a":1,"n":"BoundsMaxDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMaxDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"BoundsMinDefault","is":true,"t":4,"rt":$n[0].Single,"sn":"BoundsMinDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"clipper","t":4,"rt":$n[18].SkeletonClipping,"sn":"clipper"},{"a":3,"n":"colorBuffer","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Color32),"sn":"colorBuffer","ro":true},{"a":1,"n":"meshBoundsMax","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMax"},{"a":1,"n":"meshBoundsMin","t":4,"rt":$n[1].Vector2,"sn":"meshBoundsMin"},{"a":1,"n":"meshBoundsThickness","t":4,"rt":$n[0].Single,"sn":"meshBoundsThickness","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"normals","t":4,"rt":System.Array.type(UnityEngine.Vector3),"sn":"normals"},{"a":1,"n":"regionTriangles","t":4,"rt":$n[0].Array.type(System.Int32),"sn":"regionTriangles"},{"a":2,"n":"settings","t":4,"rt":$n[12].MeshGenerator.Settings,"sn":"settings"},{"a":1,"n":"submeshIndex","t":4,"rt":$n[0].Int32,"sn":"submeshIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":3,"n":"submeshes","t":4,"rt":$n[18].ExposedList$1(Spine.ExposedList$1(System.Int32)),"sn":"submeshes","ro":true},{"a":1,"n":"tangents","t":4,"rt":System.Array.type(UnityEngine.Vector4),"sn":"tangents"},{"a":1,"n":"tempTanBuffer","t":4,"rt":System.Array.type(UnityEngine.Vector2),"sn":"tempTanBuffer"},{"a":1,"n":"tempVerts","t":4,"rt":$n[0].Array.type(System.Single),"sn":"tempVerts"},{"a":1,"n":"uv2","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Vector2),"sn":"uv2"},{"a":1,"n":"uv3","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Vector2),"sn":"uv3"},{"a":3,"n":"uvBuffer","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Vector2),"sn":"uvBuffer","ro":true},{"a":3,"n":"vertexBuffer","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Vector3),"sn":"vertexBuffer","ro":true}]}; }, $n);
    /*Spine.Unity.MeshGenerator end.*/

    /*Spine.Unity.MeshGenerator+Settings start.*/
    $m("Spine.Unity.MeshGenerator.Settings", function () { return {"td":$n[12].MeshGenerator,"att":1057034,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Default","is":true,"t":16,"rt":$n[12].MeshGenerator.Settings,"g":{"a":2,"n":"get_Default","t":8,"rt":$n[12].MeshGenerator.Settings,"fg":"Default","is":true},"fn":"Default"},{"a":2,"n":"addNormals","t":4,"rt":$n[0].Boolean,"sn":"addNormals","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"calculateTangents","t":4,"rt":$n[0].Boolean,"sn":"calculateTangents","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("Enable when using Additive blend mode at SkeletonGraphic under a CanvasGroup. When enabled, Additive alpha value is stored at uv2.g instead of color.a to capture CanvasGroup modifying color.a.")],"a":2,"n":"canvasGroupTintBlack","t":4,"rt":$n[0].Boolean,"sn":"canvasGroupTintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.HeaderAttribute("Vertex Data")],"a":2,"n":"pmaVertexColors","t":4,"rt":$n[0].Boolean,"sn":"pmaVertexColors","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"tintBlack","t":4,"rt":$n[0].Boolean,"sn":"tintBlack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useClipping","t":4,"rt":$n[0].Boolean,"sn":"useClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.RangeAttribute(-0.1, 0.0)],"a":2,"n":"zSpacing","t":4,"rt":$n[0].Single,"sn":"zSpacing","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.MeshGenerator+Settings end.*/

    /*Spine.Unity.MeshRendererBuffers start.*/
    $m("Spine.Unity.MeshRendererBuffers", function () { return {"nested":[$n[12].MeshRendererBuffers.SmartMesh],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GetNextMesh","t":8,"sn":"GetNextMesh","rt":$n[12].MeshRendererBuffers.SmartMesh},{"a":2,"n":"GetUpdatedSharedMaterialsArray","t":8,"sn":"GetUpdatedSharedMaterialsArray","rt":System.Array.type(UnityEngine.Material)},{"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":2,"n":"MaterialsChangedInLastUpdate","t":8,"sn":"MaterialsChangedInLastUpdate","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"UpdateSharedMaterials","t":8,"pi":[{"n":"instructions","pt":$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0}],"sn":"UpdateSharedMaterials","rt":$n[0].Void,"p":[$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction)]},{"a":1,"n":"doubleBufferedMesh","t":4,"rt":$n[12].DoubleBuffered$1(Spine.Unity.MeshRendererBuffers.SmartMesh),"sn":"doubleBufferedMesh"},{"a":4,"n":"sharedMaterials","t":4,"rt":System.Array.type(UnityEngine.Material),"sn":"sharedMaterials"},{"a":4,"n":"submeshMaterials","t":4,"rt":$n[18].ExposedList$1(UnityEngine.Material),"sn":"submeshMaterials","ro":true}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers end.*/

    /*Spine.Unity.MeshRendererBuffers+SmartMesh start.*/
    $m("Spine.Unity.MeshRendererBuffers.SmartMesh", function () { return {"td":$n[12].MeshRendererBuffers,"att":1048578,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"instructionUsed","t":4,"rt":$n[12].SkeletonRendererInstruction,"sn":"instructionUsed"},{"a":2,"n":"mesh","t":4,"rt":$n[1].Mesh,"sn":"mesh"}]}; }, $n);
    /*Spine.Unity.MeshRendererBuffers+SmartMesh end.*/

    /*Spine.Unity.SkeletonRendererInstruction start.*/
    $m("Spine.Unity.SkeletonRendererInstruction", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Clear","t":8,"sn":"Clear","rt":$n[0].Void},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":2,"n":"GeometryNotEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[12].SkeletonRendererInstruction,"ps":0},{"n":"b","pt":$n[12].SkeletonRendererInstruction,"ps":1}],"sn":"GeometryNotEqual","rt":$n[0].Boolean,"p":[$n[12].SkeletonRendererInstruction,$n[12].SkeletonRendererInstruction],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","t":8,"pi":[{"n":"other","pt":$n[12].SkeletonRendererInstruction,"ps":0}],"sn":"Set","rt":$n[0].Void,"p":[$n[12].SkeletonRendererInstruction]},{"a":2,"n":"SetWithSubset","t":8,"pi":[{"n":"instructions","pt":$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),"ps":0},{"n":"startSubmesh","pt":$n[0].Int32,"ps":1},{"n":"endSubmesh","pt":$n[0].Int32,"ps":2}],"sn":"SetWithSubset","rt":$n[0].Void,"p":[$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),$n[0].Int32,$n[0].Int32]},{"a":2,"n":"attachments","t":4,"rt":$n[18].ExposedList$1(spine.Attachment),"sn":"attachments","ro":true},{"a":2,"n":"hasActiveClipping","t":4,"rt":$n[0].Boolean,"sn":"hasActiveClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"immutableTriangles","t":4,"rt":$n[0].Boolean,"sn":"immutableTriangles","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"submeshInstructions","t":4,"rt":$n[18].ExposedList$1(Spine.Unity.SubmeshInstruction),"sn":"submeshInstructions","ro":true}]}; }, $n);
    /*Spine.Unity.SkeletonRendererInstruction end.*/

    /*Spine.Unity.SpineMesh start.*/
    $m("Spine.Unity.SpineMesh", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"NewSkeletonMesh","is":true,"t":8,"sn":"NewSkeletonMesh","rt":$n[1].Mesh},{"a":4,"n":"MeshHideflags","is":true,"t":4,"rt":$n[1].HideFlags,"sn":"MeshHideflags","box":function ($v) { return Bridge.box($v, UnityEngine.HideFlags, System.Enum.toStringFn(UnityEngine.HideFlags));}}]}; }, $n);
    /*Spine.Unity.SpineMesh end.*/

    /*Spine.Unity.SubmeshInstruction start.*/
    $m("Spine.Unity.SubmeshInstruction", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"SlotCount","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_SlotCount","t":8,"rt":$n[0].Int32,"fg":"SlotCount","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"SlotCount"},{"a":2,"n":"endSlot","t":4,"rt":$n[0].Int32,"sn":"endSlot","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"forceSeparate","t":4,"rt":$n[0].Boolean,"sn":"forceSeparate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasClipping","t":4,"rt":$n[0].Boolean,"sn":"hasClipping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"hasPMAAdditiveSlot","t":4,"rt":$n[0].Boolean,"sn":"hasPMAAdditiveSlot","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"material","t":4,"rt":$n[1].Material,"sn":"material"},{"a":2,"n":"preActiveClippingSlotSource","t":4,"rt":$n[0].Int32,"sn":"preActiveClippingSlotSource","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawFirstVertexIndex","t":4,"rt":$n[0].Int32,"sn":"rawFirstVertexIndex","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawTriangleCount","t":4,"rt":$n[0].Int32,"sn":"rawTriangleCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"rawVertexCount","t":4,"rt":$n[0].Int32,"sn":"rawVertexCount","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"skeleton","t":4,"rt":$n[18].Skeleton,"sn":"skeleton"},{"a":2,"n":"startSlot","t":4,"rt":$n[0].Int32,"sn":"startSlot","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*Spine.Unity.SubmeshInstruction end.*/

    /*Spine.Unity.BlendModeMaterialsAsset start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset", function () { return {"nested":[$n[12].BlendModeMaterialsAsset.AtlasMaterialCache],"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Spine/SkeletonData Modifiers/Blend Mode Materials", order: 200
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Apply","t":8,"pi":[{"n":"skeletonData","pt":$n[18].SkeletonData,"ps":0}],"sn":"Apply","rt":$n[0].Void,"p":[$n[18].SkeletonData]},{"a":2,"n":"ApplyMaterials","is":true,"t":8,"pi":[{"n":"skeletonData","pt":$n[18].SkeletonData,"ps":0},{"n":"multiplyTemplate","pt":$n[1].Material,"ps":1},{"n":"screenTemplate","pt":$n[1].Material,"ps":2},{"n":"additiveTemplate","pt":$n[1].Material,"ps":3},{"n":"includeAdditiveSlots","pt":$n[0].Boolean,"ps":4}],"sn":"ApplyMaterials","rt":$n[0].Void,"p":[$n[18].SkeletonData,$n[1].Material,$n[1].Material,$n[1].Material,$n[0].Boolean]},{"a":2,"n":"additiveMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"additiveMaterialTemplate"},{"a":2,"n":"applyAdditiveMaterial","t":4,"rt":$n[0].Boolean,"sn":"applyAdditiveMaterial","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"multiplyMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"multiplyMaterialTemplate"},{"a":2,"n":"screenMaterialTemplate","t":4,"rt":$n[1].Material,"sn":"screenMaterialTemplate"}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset end.*/

    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache start.*/
    $m("Spine.Unity.BlendModeMaterialsAsset.AtlasMaterialCache", function () { return {"td":$n[12].BlendModeMaterialsAsset,"att":1048579,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CloneAtlasRegionWithMaterial","t":8,"pi":[{"n":"originalRegion","pt":$n[18].AtlasRegion,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"CloneAtlasRegionWithMaterial","rt":$n[18].AtlasRegion,"p":[$n[18].AtlasRegion,$n[1].Material]},{"a":2,"n":"Dispose","t":8,"sn":"Dispose","rt":$n[0].Void},{"a":1,"n":"GetAtlasPageWithMaterial","t":8,"pi":[{"n":"originalPage","pt":$n[18].AtlasPage,"ps":0},{"n":"materialTemplate","pt":$n[1].Material,"ps":1}],"sn":"GetAtlasPageWithMaterial","rt":$n[18].AtlasPage,"p":[$n[18].AtlasPage,$n[1].Material]},{"a":1,"n":"cache","t":4,"rt":$n[3].Dictionary$2(System.Collections.Generic.KeyValuePair$2(Spine.AtlasPage,UnityEngine.Material),Spine.AtlasPage),"sn":"cache","ro":true}]}; }, $n);
    /*Spine.Unity.BlendModeMaterialsAsset+AtlasMaterialCache end.*/

    /*Spine.Unity.SpineAttributeBase start.*/
    $m("Spine.Unity.SpineAttributeBase", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"dataField","t":4,"rt":$n[0].String,"sn":"dataField"},{"a":2,"n":"fallbackToTextField","t":4,"rt":$n[0].Boolean,"sn":"fallbackToTextField","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"includeNone","t":4,"rt":$n[0].Boolean,"sn":"includeNone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"startsWith","t":4,"rt":$n[0].String,"sn":"startsWith"}]}; }, $n);
    /*Spine.Unity.SpineAttributeBase end.*/

    /*Spine.Unity.SpineBone start.*/
    $m("Spine.Unity.SpineBone", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"},{"a":2,"n":"GetBone","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"renderer","pt":$n[12].SkeletonRenderer,"ps":1}],"sn":"getBone","rt":$n[18].Bone,"p":[$n[0].String,$n[12].SkeletonRenderer]},{"a":2,"n":"GetBoneData","is":true,"t":8,"pi":[{"n":"boneName","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1}],"sn":"getBoneData","rt":spine.BoneData,"p":[$n[0].String,$n[12].SkeletonDataAsset]}]}; }, $n);
    /*Spine.Unity.SpineBone end.*/

    /*Spine.Unity.SpineSlot start.*/
    $m("Spine.Unity.SpineSlot", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"containsBoundingBoxes","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"containsBoundingBoxes","t":4,"rt":$n[0].Boolean,"sn":"containsBoundingBoxes","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSlot end.*/

    /*Spine.Unity.SpineAnimation start.*/
    $m("Spine.Unity.SpineAnimation", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineAnimation end.*/

    /*Spine.Unity.SpineEvent start.*/
    $m("Spine.Unity.SpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"audioOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"audioOnly","t":4,"rt":$n[0].Boolean,"sn":"audioOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineEvent end.*/

    /*Spine.Unity.SpineIkConstraint start.*/
    $m("Spine.Unity.SpineIkConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineIkConstraint end.*/

    /*Spine.Unity.SpineTransformConstraint start.*/
    $m("Spine.Unity.SpineTransformConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpineTransformConstraint end.*/

    /*Spine.Unity.SpinePathConstraint start.*/
    $m("Spine.Unity.SpinePathConstraint", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ctor"}]}; }, $n);
    /*Spine.Unity.SpinePathConstraint end.*/

    /*Spine.Unity.SpineSkin start.*/
    $m("Spine.Unity.SpineSkin", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"startsWith","dv":"","o":true,"pt":$n[0].String,"ps":0},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":1},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"defaultAsEmptyString","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ctor"},{"a":2,"n":"defaultAsEmptyString","t":4,"rt":$n[0].Boolean,"sn":"defaultAsEmptyString","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.SpineSkin end.*/

    /*Spine.Unity.SpineAttachment start.*/
    $m("Spine.Unity.SpineAttachment", function () { return {"nested":[$n[12].SpineAttachment.Hierarchy],"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].String,$n[0].String,$n[0].String,$n[0].Boolean,$n[0].Boolean],"pi":[{"n":"currentSkinOnly","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"returnAttachmentPath","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"placeholdersOnly","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"slotField","dv":"","o":true,"pt":$n[0].String,"ps":3},{"n":"dataField","dv":"","o":true,"pt":$n[0].String,"ps":4},{"n":"skinField","dv":"","o":true,"pt":$n[0].String,"ps":5},{"n":"includeNone","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"fallbackToTextField","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7}],"sn":"ctor"},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonData","pt":$n[18].SkeletonData,"ps":1}],"sn":"getAttachment","rt":spine.Attachment,"p":[$n[0].String,$n[18].SkeletonData]},{"a":2,"n":"GetAttachment","is":true,"t":8,"pi":[{"n":"attachmentPath","pt":$n[0].String,"ps":0},{"n":"skeletonDataAsset","pt":$n[12].SkeletonDataAsset,"ps":1}],"sn":"getAttachment$1","rt":spine.Attachment,"p":[$n[0].String,$n[12].SkeletonDataAsset]},{"a":2,"n":"GetHierarchy","is":true,"t":8,"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"getHierarchy","rt":$n[12].SpineAttachment.Hierarchy,"p":[$n[0].String]},{"a":2,"n":"currentSkinOnly","t":4,"rt":$n[0].Boolean,"sn":"currentSkinOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"placeholdersOnly","t":4,"rt":$n[0].Boolean,"sn":"placeholdersOnly","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"returnAttachmentPath","t":4,"rt":$n[0].Boolean,"sn":"returnAttachmentPath","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"skinField","t":4,"rt":$n[0].String,"sn":"skinField"},{"a":2,"n":"slotField","t":4,"rt":$n[0].String,"sn":"slotField"}]}; }, $n);
    /*Spine.Unity.SpineAttachment end.*/

    /*Spine.Unity.SpineAttachment+Hierarchy start.*/
    $m("Spine.Unity.SpineAttachment.Hierarchy", function () { return {"td":$n[12].SpineAttachment,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"fullPath","pt":$n[0].String,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"},{"a":2,"n":"skin","t":4,"rt":$n[0].String,"sn":"skin"},{"a":2,"n":"slot","t":4,"rt":$n[0].String,"sn":"slot"}]}; }, $n);
    /*Spine.Unity.SpineAttachment+Hierarchy end.*/

    /*Spine.Unity.SpineAtlasRegion start.*/
    $m("Spine.Unity.SpineAtlasRegion", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].String],"pi":[{"n":"atlasAssetField","dv":"","o":true,"pt":$n[0].String,"ps":0}],"sn":"ctor"},{"a":2,"n":"atlasAssetField","t":4,"rt":$n[0].String,"sn":"atlasAssetField"}]}; }, $n);
    /*Spine.Unity.SpineAtlasRegion end.*/

    /*Spine.Unity.SkeletonExtensions start.*/
    $m("Spine.Unity.SkeletonExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[18].MeshAttachment,"ps":0}],"sn":"GetColor","rt":$n[1].Color,"p":[$n[18].MeshAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"a","pt":$n[18].RegionAttachment,"ps":0}],"sn":"GetColor$1","rt":$n[1].Color,"p":[$n[18].RegionAttachment]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[18].Skeleton,"ps":0}],"sn":"GetColor$2","rt":$n[1].Color,"p":[$n[18].Skeleton]},{"a":2,"n":"GetColor","is":true,"t":8,"pi":[{"n":"s","pt":$n[18].Slot,"ps":0}],"sn":"GetColor$3","rt":$n[1].Color,"p":[$n[18].Slot]},{"a":2,"n":"GetColorTintBlack","is":true,"t":8,"pi":[{"n":"s","pt":$n[18].Slot,"ps":0}],"sn":"GetColorTintBlack","rt":$n[1].Color,"p":[$n[18].Slot]},{"a":2,"n":"GetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"GetLocalPosition","rt":$n[1].Vector2,"p":[$n[18].Bone]},{"a":2,"n":"GetLocalQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"GetLocalQuaternion","rt":$n[1].Quaternion,"p":[$n[18].Bone]},{"a":2,"n":"GetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0}],"sn":"GetLocalScale","rt":$n[1].Vector2,"p":[$n[18].Skeleton]},{"a":2,"n":"GetLocalVertices","is":true,"t":8,"pi":[{"n":"va","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[18].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetLocalVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[18].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"GetMaterial","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"GetMaterial","rt":$n[1].Material,"p":[spine.Attachment]},{"a":2,"n":"GetMatrix4x4","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"GetMatrix4x4","rt":$n[1].Matrix4x4,"p":[$n[18].Bone]},{"a":2,"n":"GetQuaternion","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"GetQuaternion","rt":$n[1].Quaternion,"p":[$n[18].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0}],"sn":"GetSkeletonSpacePosition","rt":$n[1].Vector2,"p":[$n[18].Bone]},{"a":2,"n":"GetSkeletonSpacePosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"boneLocal","pt":$n[1].Vector2,"ps":1}],"sn":"GetSkeletonSpacePosition$1","rt":$n[1].Vector2,"p":[$n[18].Bone,$n[1].Vector2]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1}],"sn":"GetWorldPosition","rt":$n[1].Vector3,"p":[$n[18].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":1},{"n":"positionScale","pt":$n[0].Single,"ps":2}],"sn":"GetWorldPosition$1","rt":$n[1].Vector3,"p":[$n[18].Bone,$n[1].Transform,$n[0].Single]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[18].PointAttachment,"ps":0},{"n":"bone","pt":$n[18].Bone,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$2","rt":$n[1].Vector3,"p":[$n[18].PointAttachment,$n[18].Bone,$n[1].Transform]},{"a":2,"n":"GetWorldPosition","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[18].PointAttachment,"ps":0},{"n":"slot","pt":$n[18].Slot,"ps":1},{"n":"spineGameObjectTransform","pt":$n[1].Transform,"ps":2}],"sn":"GetWorldPosition$3","rt":$n[1].Vector3,"p":[$n[18].PointAttachment,$n[18].Slot,$n[1].Transform]},{"a":2,"n":"GetWorldToLocalMatrix","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"ia","out":true,"pt":$n[0].Single,"ps":1},{"n":"ib","out":true,"pt":$n[0].Single,"ps":2},{"n":"ic","out":true,"pt":$n[0].Single,"ps":3},{"n":"id","out":true,"pt":$n[0].Single,"ps":4}],"sn":"GetWorldToLocalMatrix","rt":$n[0].Void,"p":[$n[18].Bone,$n[0].Single,$n[0].Single,$n[0].Single,$n[0].Single]},{"a":2,"n":"GetWorldVertices","is":true,"t":8,"pi":[{"n":"a","pt":spine.VertexAttachment,"ps":0},{"n":"slot","pt":$n[18].Slot,"ps":1},{"n":"buffer","pt":System.Array.type(UnityEngine.Vector2),"ps":2}],"sn":"GetWorldVertices","rt":System.Array.type(UnityEngine.Vector2),"p":[spine.VertexAttachment,$n[18].Slot,System.Array.type(UnityEngine.Vector2)]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[18].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor","rt":$n[0].Void,"p":[$n[18].MeshAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[18].MeshAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$1","rt":$n[0].Void,"p":[$n[18].MeshAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$2","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"attachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$3","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$4","rt":$n[0].Void,"p":[$n[18].Skeleton,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$5","rt":$n[0].Void,"p":[$n[18].Skeleton,$n[1].Color32]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[18].Slot,"ps":0},{"n":"color","pt":$n[1].Color,"ps":1}],"sn":"SetColor$6","rt":$n[0].Void,"p":[$n[18].Slot,$n[1].Color]},{"a":2,"n":"SetColor","is":true,"t":8,"pi":[{"n":"slot","pt":$n[18].Slot,"ps":0},{"n":"color","pt":$n[1].Color32,"ps":1}],"sn":"SetColor$7","rt":$n[0].Void,"p":[$n[18].Slot,$n[1].Color32]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"position","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPosition","rt":$n[0].Void,"p":[$n[18].Bone,$n[1].Vector2]},{"a":2,"n":"SetLocalPosition","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1}],"sn":"SetLocalPosition$1","rt":$n[0].Void,"p":[$n[18].Bone,$n[1].Vector3]},{"a":2,"n":"SetLocalScale","is":true,"t":8,"pi":[{"n":"skeleton","pt":$n[18].Skeleton,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalScale","rt":$n[0].Void,"p":[$n[18].Skeleton,$n[1].Vector2]},{"a":2,"n":"SetPositionSkeletonSpace","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"skeletonSpacePosition","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionSkeletonSpace","rt":$n[1].Vector2,"p":[$n[18].Bone,$n[1].Vector2]},{"a":2,"n":"WorldToLocal","is":true,"t":8,"pi":[{"n":"bone","pt":$n[18].Bone,"ps":0},{"n":"worldPosition","pt":$n[1].Vector2,"ps":1}],"sn":"WorldToLocal","rt":$n[1].Vector2,"p":[$n[18].Bone,$n[1].Vector2]},{"a":1,"n":"ByteToFloat","is":true,"t":4,"rt":$n[0].Single,"sn":"ByteToFloat","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*Spine.Unity.SkeletonExtensions end.*/

    /*Spine.Unity.WaitForSpineEvent start.*/
    $m("Spine.Unity.WaitForSpineEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"n":".ctor","t":1,"p":[$n[18].AnimationState,spine.EventData,$n[0].Boolean],"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[18].AnimationState,$n[0].String,$n[0].Boolean],"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor1"},{"a":2,"n":".ctor","t":1,"p":[$n[12].SkeletonAnimation,spine.EventData,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[12].SkeletonAnimation,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor2"},{"a":2,"n":".ctor","t":1,"p":[$n[12].SkeletonAnimation,$n[0].String,$n[0].Boolean],"pi":[{"n":"skeletonAnimation","pt":$n[12].SkeletonAnimation,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"$ctor3"},{"a":1,"n":"Clear","t":8,"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0}],"sn":"Clear","rt":$n[0].Void,"p":[$n[18].AnimationState]},{"a":1,"n":"HandleAnimationStateEvent","t":8,"pi":[{"n":"trackEntry","pt":$n[18].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEvent","rt":$n[0].Void,"p":[$n[18].TrackEntry,spine.Event]},{"a":1,"n":"HandleAnimationStateEventByName","t":8,"pi":[{"n":"trackEntry","pt":$n[18].TrackEntry,"ps":0},{"n":"e","pt":spine.Event,"ps":1}],"sn":"HandleAnimationStateEventByName","rt":$n[0].Void,"p":[$n[18].TrackEntry,spine.Event]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor","rt":$n[12].WaitForSpineEvent,"p":[$n[18].AnimationState,spine.EventData,$n[0].Boolean]},{"a":2,"n":"NowWaitFor","t":8,"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribeAfterFiring","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"NowWaitFor$1","rt":$n[12].WaitForSpineEvent,"p":[$n[18].AnimationState,$n[0].String,$n[0].Boolean]},{"a":1,"n":"Subscribe","t":8,"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0},{"n":"eventDataReference","pt":spine.EventData,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"Subscribe","rt":$n[0].Void,"p":[$n[18].AnimationState,spine.EventData,$n[0].Boolean]},{"a":1,"n":"SubscribeByName","t":8,"pi":[{"n":"state","pt":$n[18].AnimationState,"ps":0},{"n":"eventName","pt":$n[0].String,"ps":1},{"n":"unsubscribe","pt":$n[0].Boolean,"ps":2}],"sn":"SubscribeByName","rt":$n[0].Void,"p":[$n[18].AnimationState,$n[0].String,$n[0].Boolean]},{"a":2,"n":"WillUnsubscribeAfterFiring","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_WillUnsubscribeAfterFiring","t":8,"rt":$n[0].Boolean,"fg":"WillUnsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_WillUnsubscribeAfterFiring","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"WillUnsubscribeAfterFiring"},"fn":"WillUnsubscribeAfterFiring"},{"a":1,"n":"m_AnimationState","t":4,"rt":$n[18].AnimationState,"sn":"m_AnimationState"},{"a":1,"n":"m_EventName","t":4,"rt":$n[0].String,"sn":"m_EventName"},{"a":1,"n":"m_TargetEvent","t":4,"rt":spine.EventData,"sn":"m_TargetEvent"},{"a":1,"n":"m_WasFired","t":4,"rt":$n[0].Boolean,"sn":"m_WasFired","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"m_unsubscribeAfterFiring","t":4,"rt":$n[0].Boolean,"sn":"m_unsubscribeAfterFiring","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*Spine.Unity.WaitForSpineEvent end.*/

    /*Spine.Unity.AnimationTools.TimelineExtensions start.*/
    $m("Spine.Unity.AnimationTools.TimelineExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.RotateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[18].SkeletonData,"ps":2}],"sn":"Evaluate","rt":$n[0].Single,"p":[spine.RotateTimeline,$n[0].Single,$n[18].SkeletonData],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TranslateTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1},{"n":"skeletonData","dv":null,"o":true,"pt":$n[18].SkeletonData,"ps":2}],"sn":"Evaluate$1","rt":$n[1].Vector2,"p":[spine.TranslateTimeline,$n[0].Single,$n[18].SkeletonData]},{"a":2,"n":"Evaluate","is":true,"t":8,"pi":[{"n":"xTimeline","pt":spine.TranslateXTimeline,"ps":0},{"n":"yTimeline","pt":spine.TranslateYTimeline,"ps":1},{"n":"time","pt":$n[0].Single,"ps":2},{"n":"skeletonData","dv":null,"o":true,"pt":$n[18].SkeletonData,"ps":3}],"sn":"Evaluate$2","rt":$n[1].Vector2,"p":[spine.TranslateXTimeline,spine.TranslateYTimeline,$n[0].Single,$n[18].SkeletonData]},{"a":2,"n":"EvaluateRotateMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateRotateMix","rt":$n[0].Single,"p":[spine.TransformConstraintTimeline,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"EvaluateTranslateXYMix","is":true,"t":8,"pi":[{"n":"timeline","pt":spine.TransformConstraintTimeline,"ps":0},{"n":"time","pt":$n[0].Single,"ps":1}],"sn":"EvaluateTranslateXYMix","rt":$n[1].Vector2,"p":[spine.TransformConstraintTimeline,$n[0].Single]},{"a":2,"n":"FindTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[18].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"tpc":1,"tprm":["T"],"sn":"FindTimelineForBone","rt":System.Object,"p":[$n[18].Animation,$n[0].Int32]},{"a":2,"n":"FindTransformConstraintTimeline","is":true,"t":8,"pi":[{"n":"a","pt":$n[18].Animation,"ps":0},{"n":"transformConstraintIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTransformConstraintTimeline","rt":spine.TransformConstraintTimeline,"p":[$n[18].Animation,$n[0].Int32]},{"a":2,"n":"FindTranslateTimelineForBone","is":true,"t":8,"pi":[{"n":"a","pt":$n[18].Animation,"ps":0},{"n":"boneIndex","pt":$n[0].Int32,"ps":1}],"sn":"FindTranslateTimelineForBone","rt":spine.TranslateTimeline,"p":[$n[18].Animation,$n[0].Int32]}]}; }, $n);
    /*Spine.Unity.AnimationTools.TimelineExtensions end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities", function () { return {"nested":[$n[21].AtlasUtilities.IntAndAtlasRegionKey],"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"ClearCache","is":true,"t":8,"sn":"ClearCache","rt":$n[0].Void},{"a":1,"n":"CopyTexture","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTexture","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureApplyPMA","is":true,"t":8,"pi":[{"n":"source","pt":$n[1].Texture2D,"ps":0},{"n":"sourceRect","pt":$n[1].Rect,"ps":1},{"n":"destination","pt":$n[1].Texture2D,"ps":2}],"sn":"CopyTextureApplyPMA","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Rect,$n[1].Texture2D]},{"a":1,"n":"CopyTextureAttributesFrom","is":true,"t":8,"pi":[{"n":"destination","pt":$n[1].Texture2D,"ps":0},{"n":"source","pt":$n[1].Texture2D,"ps":1}],"sn":"CopyTextureAttributesFrom","rt":$n[0].Void,"p":[$n[1].Texture2D,$n[1].Texture2D]},{"a":1,"n":"GetClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"GetClone","rt":$n[1].Texture2D,"p":[$n[1].Texture2D,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"GetMainTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0}],"sn":"GetMainTexture","rt":$n[1].Texture2D,"p":[$n[18].AtlasRegion]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[3].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[3].List$1(spine.Attachment),"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedAttachments","rt":$n[0].Void,"p":[$n[3].List$1(spine.Attachment),$n[3].List$1(spine.Attachment),$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedAttachments","is":true,"t":8,"pi":[{"n":"sourceAttachments","pt":$n[3].List$1(spine.Attachment),"ps":0},{"n":"outputAttachments","pt":$n[3].List$1(spine.Attachment),"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"newAssetName","dv":"Repacked Attachments","o":true,"pt":$n[0].String,"ps":9},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":10},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":12},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":13},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":14},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":15},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":16}],"sn":"GetRepackedAttachments$1","rt":$n[0].Void,"p":[$n[3].List$1(spine.Attachment),$n[3].List$1(spine.Attachment),$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].String,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[18].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"materialPropertySource","pt":$n[1].Material,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":11},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":12},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":13},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":14}],"sn":"GetRepackedSkin","rt":$n[18].Skin,"p":[$n[18].Skin,$n[0].String,$n[1].Material,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":2,"n":"GetRepackedSkin","is":true,"t":8,"pi":[{"n":"o","pt":$n[18].Skin,"ps":0},{"n":"newName","pt":$n[0].String,"ps":1},{"n":"shader","pt":$n[1].Shader,"ps":2},{"n":"outputMaterial","out":true,"pt":$n[1].Material,"ps":3},{"n":"outputTexture","out":true,"pt":$n[1].Texture2D,"ps":4},{"n":"maxAtlasSize","dv":1024,"o":true,"pt":$n[0].Int32,"ps":5},{"n":"padding","dv":2,"o":true,"pt":$n[0].Int32,"ps":6},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":7},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":8},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":9},{"n":"clearCache","dv":false,"o":true,"pt":$n[0].Boolean,"ps":10},{"n":"useOriginalNonrenderables","dv":true,"o":true,"pt":$n[0].Boolean,"ps":11},{"n":"additionalTexturePropertyIDsToCopy","dv":null,"o":true,"pt":$n[0].Array.type(System.Int32),"ps":12},{"n":"additionalOutputTextures","dv":null,"o":true,"pt":System.Array.type(UnityEngine.Texture2D),"ps":13},{"n":"additionalTextureFormats","dv":null,"o":true,"pt":System.Array.type(UnityEngine.TextureFormat),"ps":14},{"n":"additionalTextureIsLinear","dv":null,"o":true,"pt":$n[0].Array.type(System.Boolean),"ps":15}],"sn":"GetRepackedSkin$1","rt":$n[18].Skin,"p":[$n[18].Skin,$n[0].String,$n[1].Shader,$n[1].Material,$n[1].Texture2D,$n[0].Int32,$n[0].Int32,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Array.type(System.Int32),System.Array.type(UnityEngine.Texture2D),System.Array.type(UnityEngine.TextureFormat),$n[0].Array.type(System.Boolean)]},{"a":1,"n":"GetSpineAtlasRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0},{"n":"includeRotate","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"GetSpineAtlasRect","rt":$n[1].Rect,"p":[$n[18].AtlasRegion,$n[0].Boolean]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0},{"n":"texturePropertyId","pt":$n[0].Int32,"ps":1}],"sn":"GetTexture","rt":$n[1].Texture2D,"p":[$n[18].AtlasRegion,$n[0].Int32]},{"a":1,"n":"GetTexture","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0},{"n":"texturePropertyName","pt":$n[0].String,"ps":1}],"sn":"GetTexture$1","rt":$n[1].Texture2D,"p":[$n[18].AtlasRegion,$n[0].String]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0}],"sn":"GetUnityRect","rt":$n[1].Rect,"p":[$n[18].AtlasRegion]},{"a":1,"n":"GetUnityRect","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"GetUnityRect$1","rt":$n[1].Rect,"p":[$n[18].AtlasRegion,$n[0].Int32]},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(4)],"a":1,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InverseLerp","is":true,"t":8,"pi":[{"n":"a","pt":$n[0].Single,"ps":0},{"n":"b","pt":$n[0].Single,"ps":1},{"n":"value","pt":$n[0].Single,"ps":2}],"sn":"InverseLerp","rt":$n[0].Single,"p":[$n[0].Single,$n[0].Single,$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"IsRenderable","is":true,"t":8,"pi":[{"n":"a","pt":spine.Attachment,"ps":0}],"sn":"IsRenderable","rt":$n[0].Boolean,"p":[spine.Attachment],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"SpineUnityFlipRect","is":true,"t":8,"pi":[{"n":"rect","pt":$n[1].Rect,"ps":0},{"n":"textureHeight","pt":$n[0].Int32,"ps":1}],"sn":"SpineUnityFlipRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32]},{"a":1,"n":"TextureRectToUVRect","is":true,"t":8,"pi":[{"n":"textureRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"TextureRectToUVRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[18].AtlasPage,"ps":1}],"sn":"ToAtlasRegion","rt":$n[18].AtlasRegion,"p":[$n[1].Sprite,$n[18].AtlasPage]},{"a":4,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"isolatedTexture","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"ToAtlasRegion$4","rt":$n[18].AtlasRegion,"p":[$n[1].Sprite,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1}],"sn":"ToAtlasRegion$1","rt":$n[18].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToAtlasRegion$2","rt":$n[18].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToAtlasRegion","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":3}],"sn":"ToAtlasRegion$3","rt":$n[18].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[0].Single,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone","rt":$n[18].AtlasRegion,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"ToAtlasRegionPMAClone$2","rt":$n[18].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$1","rt":$n[18].AtlasRegion,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToAtlasRegionPMAClone","is":true,"t":8,"pi":[{"n":"t","pt":$n[1].Texture2D,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4}],"sn":"ToAtlasRegionPMAClone$3","rt":$n[18].AtlasRegion,"p":[$n[1].Texture2D,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material]},{"a":2,"n":"ToSpineAtlasPage","is":true,"t":8,"pi":[{"n":"m","pt":$n[1].Material,"ps":0}],"sn":"ToSpineAtlasPage","rt":$n[18].AtlasPage,"p":[$n[1].Material]},{"a":2,"n":"ToSprite","is":true,"t":8,"pi":[{"n":"ar","pt":$n[18].AtlasRegion,"ps":0},{"n":"pixelsPerUnit","dv":100.0,"o":true,"pt":$n[0].Single,"ps":1}],"sn":"ToSprite","rt":$n[1].Sprite,"p":[$n[18].AtlasRegion,$n[0].Single]},{"a":1,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"s","pt":$n[1].Sprite,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"ToTexture$1","rt":$n[1].Texture2D,"p":[$n[1].Sprite,$n[1].TextureFormat,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"ToTexture","is":true,"t":8,"pi":[{"n":"ar","pt":$n[18].AtlasRegion,"ps":0},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":1},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"texturePropertyId","dv":0,"o":true,"pt":$n[0].Int32,"ps":3},{"n":"linear","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"applyPMA","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"ToTexture","rt":$n[1].Texture2D,"p":[$n[18].AtlasRegion,$n[1].TextureFormat,$n[0].Boolean,$n[0].Int32,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"UVRectToAtlasRegion","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"referenceRegion","pt":$n[18].AtlasRegion,"ps":1},{"n":"page","pt":$n[18].AtlasPage,"ps":2}],"sn":"UVRectToAtlasRegion","rt":$n[18].AtlasRegion,"p":[$n[1].Rect,$n[18].AtlasRegion,$n[18].AtlasPage]},{"a":1,"n":"UVRectToTextureRect","is":true,"t":8,"pi":[{"n":"uvRect","pt":$n[1].Rect,"ps":0},{"n":"texWidth","pt":$n[0].Int32,"ps":1},{"n":"texHeight","pt":$n[0].Int32,"ps":2}],"sn":"UVRectToTextureRect","rt":$n[1].Rect,"p":[$n[1].Rect,$n[0].Int32,$n[0].Int32]},{"a":1,"n":"CachedRegionTextures","is":true,"t":4,"rt":$n[3].Dictionary$2(Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey,UnityEngine.Texture2D),"sn":"CachedRegionTextures"},{"a":1,"n":"CachedRegionTexturesList","is":true,"t":4,"rt":$n[3].List$1(UnityEngine.Texture2D),"sn":"CachedRegionTexturesList"},{"a":4,"n":"DefaultMipmapBias","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultMipmapBias","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":4,"n":"DefaultScale","is":true,"t":4,"rt":$n[0].Single,"sn":"DefaultScale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"NonrenderingRegion","is":true,"t":4,"rt":$n[0].Int32,"sn":"NonrenderingRegion","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"SpineTextureFormat","is":true,"t":4,"rt":$n[1].TextureFormat,"sn":"SpineTextureFormat","box":function ($v) { return Bridge.box($v, UnityEngine.TextureFormat, System.Enum.toStringFn(UnityEngine.TextureFormat));}},{"a":4,"n":"UseMipMaps","is":true,"t":4,"rt":$n[0].Boolean,"sn":"UseMipMaps","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"existingRegions","is":true,"t":4,"rt":$n[3].Dictionary$2(Spine.AtlasRegion,System.Int32),"sn":"existingRegions","ro":true},{"a":1,"n":"inoutAttachments","is":true,"t":4,"rt":$n[3].List$1(spine.Attachment),"sn":"inoutAttachments"},{"a":1,"n":"originalRegions","is":true,"t":4,"rt":$n[3].List$1(Spine.AtlasRegion),"sn":"originalRegions","ro":true},{"a":1,"n":"regionIndices","is":true,"t":4,"rt":$n[3].List$1(System.Int32),"sn":"regionIndices","ro":true},{"a":1,"n":"repackedRegions","is":true,"t":4,"rt":$n[3].List$1(Spine.AtlasRegion),"sn":"repackedRegions","ro":true},{"a":1,"n":"texturesToPackAtParam","is":true,"t":4,"rt":System.Array.type(System.Collections.Generic.List$1(UnityEngine.Texture2D)),"sn":"texturesToPackAtParam"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities end.*/

    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey start.*/
    $m("Spine.Unity.AttachmentTools.AtlasUtilities.IntAndAtlasRegionKey", function () { return {"td":$n[21].AtlasUtilities,"att":1048843,"a":1,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[18].AtlasRegion],"pi":[{"n":"i","pt":$n[0].Int32,"ps":0},{"n":"region","pt":$n[18].AtlasRegion,"ps":1}],"sn":"$ctor1"},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"i","t":4,"rt":$n[0].Int32,"sn":"i","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"region","t":4,"rt":$n[18].AtlasRegion,"sn":"region"}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AtlasUtilities+IntAndAtlasRegionKey end.*/

    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentCloneExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"atlasRegion","pt":$n[18].AtlasRegion,"ps":1},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"GetRemappedClone","rt":spine.Attachment,"p":[spine.Attachment,$n[18].AtlasRegion,$n[0].Boolean,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"GetRemappedClone","is":true,"t":8,"pi":[{"n":"o","pt":spine.Attachment,"ps":0},{"n":"sprite","pt":$n[1].Sprite,"ps":1},{"n":"sourceMaterial","pt":$n[1].Material,"ps":2},{"n":"premultiplyAlpha","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"cloneMeshAsLinked","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useOriginalRegionSize","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5},{"n":"pivotShiftsMeshUVCoords","dv":true,"o":true,"pt":$n[0].Boolean,"ps":6},{"n":"useOriginalRegionScale","dv":false,"o":true,"pt":$n[0].Boolean,"ps":7},{"n":"pmaCloneTextureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":8},{"n":"pmaCloneMipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":9}],"sn":"GetRemappedClone$1","rt":spine.Attachment,"p":[spine.Attachment,$n[1].Sprite,$n[1].Material,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[0].Boolean,$n[1].TextureFormat,$n[0].Boolean]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentCloneExtensions end.*/

    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions start.*/
    $m("Spine.Unity.AttachmentTools.AttachmentRegionExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"offset","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionOffset$1","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetPositionOffset","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionOffset","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotation","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"rotation","pt":$n[0].Single,"ps":1}],"sn":"SetRotation","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"scale","pt":$n[1].Vector2,"ps":1}],"sn":"SetScale$1","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[1].Vector2]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"regionAttachment","pt":$n[18].RegionAttachment,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[18].RegionAttachment,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"page","pt":$n[18].AtlasPage,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$1","rt":$n[18].RegionAttachment,"p":[$n[1].Sprite,$n[18].AtlasPage,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"material","pt":$n[1].Material,"ps":1},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":2}],"sn":"ToRegionAttachment$2","rt":$n[18].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[0].Single]},{"a":2,"n":"ToRegionAttachment","is":true,"t":8,"pi":[{"n":"region","pt":$n[18].AtlasRegion,"ps":0},{"n":"attachmentName","pt":$n[0].String,"ps":1},{"n":"scale","dv":0.01,"o":true,"pt":$n[0].Single,"ps":2},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":3}],"sn":"ToRegionAttachment","rt":$n[18].RegionAttachment,"p":[$n[18].AtlasRegion,$n[0].String,$n[0].Single,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"materialPropertySource","pt":$n[1].Material,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4}],"sn":"ToRegionAttachmentPMAClone","rt":$n[18].RegionAttachment,"p":[$n[1].Sprite,$n[1].Material,$n[1].TextureFormat,$n[0].Boolean,$n[0].Single]},{"a":2,"n":"ToRegionAttachmentPMAClone","is":true,"t":8,"pi":[{"n":"sprite","pt":$n[1].Sprite,"ps":0},{"n":"shader","pt":$n[1].Shader,"ps":1},{"n":"textureFormat","dv":4,"o":true,"pt":$n[1].TextureFormat,"ps":2},{"n":"mipmaps","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"materialPropertySource","dv":null,"o":true,"pt":$n[1].Material,"ps":4},{"n":"rotation","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"ToRegionAttachmentPMAClone$1","rt":$n[18].RegionAttachment,"p":[$n[1].Sprite,$n[1].Shader,$n[1].TextureFormat,$n[0].Boolean,$n[1].Material,$n[0].Single]}]}; }, $n);
    /*Spine.Unity.AttachmentTools.AttachmentRegionExtensions end.*/

    /*VirtueSky.Vibration.Vibration start.*/
    $m("VirtueSky.Vibration.Vibration", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"CancelAndroid","is":true,"t":8,"sn":"CancelAndroid","rt":$n[0].Void},{"a":2,"n":"HasVibrator","is":true,"t":8,"sn":"HasVibrator","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"a":2,"n":"Vibrate","is":true,"t":8,"sn":"Vibrate","rt":$n[0].Void},{"a":2,"n":"VibrateIOS","is":true,"t":8,"pi":[{"n":"style","pt":$n[22].ImpactFeedbackStyle,"ps":0}],"sn":"VibrateIOS","rt":$n[0].Void,"p":[$n[22].ImpactFeedbackStyle]},{"a":2,"n":"VibrateIOS","is":true,"t":8,"pi":[{"n":"style","pt":$n[22].NotificationFeedbackStyle,"ps":0}],"sn":"VibrateIOS$1","rt":$n[0].Void,"p":[$n[22].NotificationFeedbackStyle]},{"a":2,"n":"VibrateIOS_SelectionChanged","is":true,"t":8,"sn":"VibrateIOS_SelectionChanged","rt":$n[0].Void},{"a":2,"n":"VibrateNope","is":true,"t":8,"sn":"VibrateNope","rt":$n[0].Void},{"a":2,"n":"VibratePeek","is":true,"t":8,"sn":"VibratePeek","rt":$n[0].Void},{"a":2,"n":"VibratePop","is":true,"t":8,"sn":"VibratePop","rt":$n[0].Void},{"a":2,"n":"AndroidVersion","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_AndroidVersion","t":8,"rt":$n[0].Int32,"fg":"AndroidVersion","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"AndroidVersion"},{"a":2,"n":"EnableVibration","is":true,"t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_EnableVibration","t":8,"rt":$n[0].Boolean,"fg":"EnableVibration","is":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_EnableVibration","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"EnableVibration","is":true},"fn":"EnableVibration"},{"a":1,"n":"initialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*VirtueSky.Vibration.Vibration end.*/

    /*VirtueSky.Vibration.ImpactFeedbackStyle start.*/
    $m("VirtueSky.Vibration.ImpactFeedbackStyle", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Heavy","is":true,"t":4,"rt":$n[22].ImpactFeedbackStyle,"sn":"Heavy","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.ImpactFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.ImpactFeedbackStyle));}},{"a":2,"n":"Light","is":true,"t":4,"rt":$n[22].ImpactFeedbackStyle,"sn":"Light","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.ImpactFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.ImpactFeedbackStyle));}},{"a":2,"n":"Medium","is":true,"t":4,"rt":$n[22].ImpactFeedbackStyle,"sn":"Medium","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.ImpactFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.ImpactFeedbackStyle));}},{"a":2,"n":"Rigid","is":true,"t":4,"rt":$n[22].ImpactFeedbackStyle,"sn":"Rigid","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.ImpactFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.ImpactFeedbackStyle));}},{"a":2,"n":"Soft","is":true,"t":4,"rt":$n[22].ImpactFeedbackStyle,"sn":"Soft","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.ImpactFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.ImpactFeedbackStyle));}}]}; }, $n);
    /*VirtueSky.Vibration.ImpactFeedbackStyle end.*/

    /*VirtueSky.Vibration.NotificationFeedbackStyle start.*/
    $m("VirtueSky.Vibration.NotificationFeedbackStyle", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Error","is":true,"t":4,"rt":$n[22].NotificationFeedbackStyle,"sn":"Error","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.NotificationFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.NotificationFeedbackStyle));}},{"a":2,"n":"Success","is":true,"t":4,"rt":$n[22].NotificationFeedbackStyle,"sn":"Success","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.NotificationFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.NotificationFeedbackStyle));}},{"a":2,"n":"Warning","is":true,"t":4,"rt":$n[22].NotificationFeedbackStyle,"sn":"Warning","box":function ($v) { return Bridge.box($v, VirtueSky.Vibration.NotificationFeedbackStyle, System.Enum.toStringFn(VirtueSky.Vibration.NotificationFeedbackStyle));}}]}; }, $n);
    /*VirtueSky.Vibration.NotificationFeedbackStyle end.*/

    /*VirtueSky.Variables.BaseReference start.*/
    $m("VirtueSky.Variables.BaseReference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.BaseReference end.*/

    /*VirtueSky.Variables.BaseReference$2 start.*/
    $m("VirtueSky.Variables.BaseReference$2", function (TType, TVariable) { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"Value","t":16,"rt":TType,"g":{"a":2,"n":"get_Value","t":8,"rt":TType,"fg":"Value"},"s":{"a":2,"n":"set_Value","t":8,"p":[TType],"rt":$n[0].Void,"fs":"Value"},"fn":"Value"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"constantValue","t":4,"rt":TType,"sn":"constantValue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"useVariable","t":4,"rt":$n[0].Boolean,"sn":"useVariable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"variable","t":4,"rt":TVariable,"sn":"variable"}]}; }, $n);
    /*VirtueSky.Variables.BaseReference$2 end.*/

    /*VirtueSky.Variables.BaseVariable$1 start.*/
    $m("VirtueSky.Variables.BaseVariable$1", function (TType) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnAfterDeserialize","t":8,"sn":"OnAfterDeserialize","rt":$n[0].Void},{"a":2,"n":"OnBeforeSerialize","t":8,"sn":"OnBeforeSerialize","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"ResetValue","t":8,"sn":"ResetValue","rt":$n[0].Void},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"CustomId","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CustomId","t":8,"rt":$n[0].String,"fg":"CustomId"},"s":{"a":2,"n":"set_CustomId","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"CustomId"},"fn":"CustomId"},{"a":2,"n":"Guid","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Guid","t":8,"rt":$n[0].String,"fg":"Guid"},"s":{"a":2,"n":"set_Guid","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"Guid"},"fn":"Guid"},{"a":2,"n":"Id","t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_Id","t":8,"rt":$n[0].String,"fg":"Id"},"fn":"Id"},{"a":2,"n":"InitializeValue","t":16,"rt":TType,"g":{"a":2,"n":"get_InitializeValue","t":8,"rt":TType,"fg":"InitializeValue"},"fn":"InitializeValue"},{"a":1,"n":"IsShowCustomId","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_IsShowCustomId","t":8,"rt":$n[0].Boolean,"fg":"IsShowCustomId","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsShowCustomId"},{"a":1,"n":"IsShowGuid","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_IsShowGuid","t":8,"rt":$n[0].Boolean,"fg":"IsShowGuid","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsShowGuid"},{"v":true,"a":2,"n":"Value","t":16,"rt":TType,"g":{"v":true,"a":2,"n":"get_Value","t":8,"rt":TType,"fg":"Value"},"s":{"v":true,"a":2,"n":"set_Value","t":8,"p":[TType],"rt":$n[0].Void,"fs":"Value"},"fn":"Value"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"customId","t":4,"rt":$n[0].String,"sn":"customId"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"guid","t":4,"rt":$n[0].String,"sn":"guid"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"initializeValue","t":4,"rt":TType,"sn":"initializeValue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"isRaiseEvent","t":4,"rt":$n[0].Boolean,"sn":"isRaiseEvent","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"isSaveData","t":4,"rt":$n[0].Boolean,"sn":"isSaveData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"isSetData","t":4,"rt":$n[0].Boolean,"sn":"isSetData","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":3,"n":"runtimeValue","t":4,"rt":TType,"sn":"runtimeValue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"typeId","t":4,"rt":$n[6].TypeId,"sn":"typeId","box":function ($v) { return Bridge.box($v, VirtueSky.Variables.TypeId, System.Enum.toStringFn(VirtueSky.Variables.TypeId));}}]}; }, $n);
    /*VirtueSky.Variables.BaseVariable$1 end.*/

    /*VirtueSky.Variables.TypeId start.*/
    $m("VirtueSky.Variables.TypeId", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"CustomId","is":true,"t":4,"rt":$n[6].TypeId,"sn":"CustomId","box":function ($v) { return Bridge.box($v, VirtueSky.Variables.TypeId, System.Enum.toStringFn(VirtueSky.Variables.TypeId));}},{"a":2,"n":"Guid","is":true,"t":4,"rt":$n[6].TypeId,"sn":"Guid","box":function ($v) { return Bridge.box($v, VirtueSky.Variables.TypeId, System.Enum.toStringFn(VirtueSky.Variables.TypeId));}}]}; }, $n);
    /*VirtueSky.Variables.TypeId end.*/

    /*VirtueSky.Variables.BaseVariableListener$3 start.*/
    $m("VirtueSky.Variables.BaseVariableListener$3", function (TType, TEvent, TResponse) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable$1","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isRaisedOnEnable","t":4,"rt":$n[0].Boolean,"sn":"isRaisedOnEnable","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isRaisedOnStart","t":4,"rt":$n[0].Boolean,"sn":"isRaisedOnStart","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*VirtueSky.Variables.BaseVariableListener$3 end.*/

    /*VirtueSky.Variables.IGuidVariable start.*/
    $m("VirtueSky.Variables.IGuidVariable", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Guid","t":16,"rt":$n[0].String,"g":{"ab":true,"a":2,"n":"get_Guid","t":8,"rt":$n[0].String,"fg":"VirtueSky$Variables$IGuidVariable$Guid"},"s":{"ab":true,"a":2,"n":"set_Guid","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"VirtueSky$Variables$IGuidVariable$Guid"},"fn":"VirtueSky$Variables$IGuidVariable$Guid"},{"a":1,"backing":true,"n":"<Guid>k__BackingField","t":4,"rt":$n[0].String,"sn":"VirtueSky$Variables$IGuidVariable$Guid"}]}; }, $n);
    /*VirtueSky.Variables.IGuidVariable end.*/

    /*VirtueSky.Variables.BooleanReference start.*/
    $m("VirtueSky.Variables.BooleanReference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.BooleanReference end.*/

    /*VirtueSky.Variables.BooleanVariable start.*/
    $m("VirtueSky.Variables.BooleanVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/Boolean", fileName: "bool_variables"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Toggle","t":8,"sn":"Toggle","rt":$n[0].Void}]}; }, $n);
    /*VirtueSky.Variables.BooleanVariable end.*/

    /*VirtueSky.Variables.BooleanVariableListener start.*/
    $m("VirtueSky.Variables.BooleanVariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.BooleanVariableListener end.*/

    /*VirtueSky.Variables.FloatReference start.*/
    $m("VirtueSky.Variables.FloatReference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.FloatReference end.*/

    /*VirtueSky.Variables.FloatVariable start.*/
    $m("VirtueSky.Variables.FloatVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/Float", fileName: "float_variables"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[$n[0].Single]},{"a":2,"n":"IsClamped","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsClamped","t":8,"rt":$n[0].Boolean,"fg":"IsClamped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsClamped"},{"a":2,"n":"Max","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Max","t":8,"rt":$n[0].Single,"fg":"Max","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Max","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Max"},"fn":"Max"},{"a":2,"n":"Min","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Min","t":8,"rt":$n[0].Single,"fg":"Min","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Min","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Min"},"fn":"Min"},{"a":2,"n":"MinMax","t":16,"rt":$n[1].Vector2,"g":{"a":2,"n":"get_MinMax","t":8,"rt":$n[1].Vector2,"fg":"MinMax"},"s":{"a":2,"n":"set_MinMax","t":8,"p":[$n[1].Vector2],"rt":$n[0].Void,"fs":"MinMax"},"fn":"MinMax"},{"ov":true,"a":2,"n":"Value","t":16,"rt":$n[0].Single,"g":{"ov":true,"a":2,"n":"get_Value","t":8,"rt":$n[0].Single,"fg":"Value","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"ov":true,"a":2,"n":"set_Value","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Value"},"fn":"Value"},{"at":[new UnityEngine.TooltipAttribute("Clamps the value of this variable to a minimum and maximum."),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isClamped","t":4,"rt":$n[0].Boolean,"sn":"isClamped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If clamped, sets the minimum and maximum"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minMax","t":4,"rt":$n[1].Vector2,"sn":"minMax"}]}; }, $n);
    /*VirtueSky.Variables.FloatVariable end.*/

    /*VirtueSky.Variables.FloatVariableListener start.*/
    $m("VirtueSky.Variables.FloatVariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.FloatVariableListener end.*/

    /*VirtueSky.Variables.IntegerReference start.*/
    $m("VirtueSky.Variables.IntegerReference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.IntegerReference end.*/

    /*VirtueSky.Variables.IntegerVariable start.*/
    $m("VirtueSky.Variables.IntegerVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/Integer", fileName: "int_variable"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Add","t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"Add","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"IsClamped","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsClamped","t":8,"rt":$n[0].Boolean,"fg":"IsClamped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsClamped"},{"a":2,"n":"Max","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Max","t":8,"rt":$n[0].Int32,"fg":"Max","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Max","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Max"},"fn":"Max"},{"a":2,"n":"Min","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Min","t":8,"rt":$n[0].Int32,"fg":"Min","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Min","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Min"},"fn":"Min"},{"a":2,"n":"MinMax","t":16,"rt":$n[1].Vector2Int,"g":{"a":2,"n":"get_MinMax","t":8,"rt":$n[1].Vector2Int,"fg":"MinMax"},"s":{"a":2,"n":"set_MinMax","t":8,"p":[$n[1].Vector2Int],"rt":$n[0].Void,"fs":"MinMax"},"fn":"MinMax"},{"ov":true,"a":2,"n":"Value","t":16,"rt":$n[0].Int32,"g":{"ov":true,"a":2,"n":"get_Value","t":8,"rt":$n[0].Int32,"fg":"Value","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"ov":true,"a":2,"n":"set_Value","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Value"},"fn":"Value"},{"at":[new UnityEngine.TooltipAttribute("Clamps the value of this variable to a minimum and maximum."),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isClamped","t":4,"rt":$n[0].Boolean,"sn":"isClamped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.TooltipAttribute("If clamped, sets the minimum and maximum"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"minMax","t":4,"rt":$n[1].Vector2Int,"sn":"minMax"}]}; }, $n);
    /*VirtueSky.Variables.IntegerVariable end.*/

    /*VirtueSky.Variables.IntegerVariableListener start.*/
    $m("VirtueSky.Variables.IntegerVariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.IntegerVariableListener end.*/

    /*VirtueSky.Variables.IReference start.*/
    $m("VirtueSky.Variables.IReference", function () { return {"att":1048737,"a":2}; }, $n);
    /*VirtueSky.Variables.IReference end.*/

    /*VirtueSky.Variables.IReference$2 start.*/
    $m("VirtueSky.Variables.IReference$2", function (TType, TVariable) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Value","t":16,"rt":TType,"g":{"ab":true,"a":2,"n":"get_Value","t":8,"rt":TType,"fg":"\"VirtueSky$Variables$IReference$2$\" + Bridge.getTypeAlias(TType) + \"$\" + Bridge.getTypeAlias(TVariable) + \"$Value\""},"s":{"ab":true,"a":2,"n":"set_Value","t":8,"p":[TType],"rt":$n[0].Void,"fs":"\"VirtueSky$Variables$IReference$2$\" + Bridge.getTypeAlias(TType) + \"$\" + Bridge.getTypeAlias(TVariable) + \"$Value\""},"fn":"\"VirtueSky$Variables$IReference$2$\" + Bridge.getTypeAlias(TType) + \"$\" + Bridge.getTypeAlias(TVariable) + \"$Value\""},{"a":1,"backing":true,"n":"<Value>k__BackingField","t":4,"rt":TType,"sn":"\"VirtueSky$Variables$IReference$2$\" + Bridge.getTypeAlias(TType) + \"$\" + Bridge.getTypeAlias(TVariable) + \"$Value\""}]}; }, $n);
    /*VirtueSky.Variables.IReference$2 end.*/

    /*VirtueSky.Variables.IVariable$1 start.*/
    $m("VirtueSky.Variables.IVariable$1", function (TType) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"Value","t":16,"rt":TType,"g":{"ab":true,"a":2,"n":"get_Value","t":8,"rt":TType,"fg":"\"VirtueSky$Variables$IVariable$1$\" + Bridge.getTypeAlias(TType) + \"$Value\""},"s":{"ab":true,"a":2,"n":"set_Value","t":8,"p":[TType],"rt":$n[0].Void,"fs":"\"VirtueSky$Variables$IVariable$1$\" + Bridge.getTypeAlias(TType) + \"$Value\""},"fn":"\"VirtueSky$Variables$IVariable$1$\" + Bridge.getTypeAlias(TType) + \"$Value\""},{"a":1,"backing":true,"n":"<Value>k__BackingField","t":4,"rt":TType,"sn":"\"VirtueSky$Variables$IVariable$1$\" + Bridge.getTypeAlias(TType) + \"$Value\""}]}; }, $n);
    /*VirtueSky.Variables.IVariable$1 end.*/

    /*VirtueSky.Variables.ObjectReference start.*/
    $m("VirtueSky.Variables.ObjectReference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.ObjectReference end.*/

    /*VirtueSky.Variables.ObjectVariable start.*/
    $m("VirtueSky.Variables.ObjectVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/Object", fileName: "object_variables"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.ObjectVariable end.*/

    /*VirtueSky.Variables.ObjectVariableListener start.*/
    $m("VirtueSky.Variables.ObjectVariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.ObjectVariableListener end.*/

    /*VirtueSky.Variables.ShortDoubleReference start.*/
    $m("VirtueSky.Variables.ShortDoubleReference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.ShortDoubleReference end.*/

    /*VirtueSky.Variables.ShortDoubleVariable start.*/
    $m("VirtueSky.Variables.ShortDoubleVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/ShortDouble", fileName: "short_double_variable"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.ShortDoubleVariable end.*/

    /*VirtueSky.Variables.ShortDoubleVariableListener start.*/
    $m("VirtueSky.Variables.ShortDoubleVariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.ShortDoubleVariableListener end.*/

    /*VirtueSky.Variables.StringVariable start.*/
    $m("VirtueSky.Variables.StringVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/String", fileName: "string_variable"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.StringVariable end.*/

    /*VirtueSky.Variables.StringVariableListener start.*/
    $m("VirtueSky.Variables.StringVariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.StringVariableListener end.*/

    /*VirtueSky.Variables.Vector3Reference start.*/
    $m("VirtueSky.Variables.Vector3Reference", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.Vector3Reference end.*/

    /*VirtueSky.Variables.Vector3Variable start.*/
    $m("VirtueSky.Variables.Vector3Variable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Variables/Vector3", fileName: "vector3_variable"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.Vector3Variable end.*/

    /*VirtueSky.Variables.Vector3VariableListener start.*/
    $m("VirtueSky.Variables.Vector3VariableListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Variables.Vector3VariableListener end.*/

    /*VirtueSky.TouchInput.InputEventTouchBegin start.*/
    $m("VirtueSky.TouchInput.InputEventTouchBegin", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Touch Input/Event Touch Begin", fileName: "input_event_touch_begin"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.TouchInput.InputEventTouchBegin end.*/

    /*VirtueSky.TouchInput.InputEventTouchCancel start.*/
    $m("VirtueSky.TouchInput.InputEventTouchCancel", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Touch Input/Event Touch Cancel", fileName: "input_event_touch_cancel"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.TouchInput.InputEventTouchCancel end.*/

    /*VirtueSky.TouchInput.InputEventTouchEnd start.*/
    $m("VirtueSky.TouchInput.InputEventTouchEnd", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Touch Input/Event Touch End", fileName: "input_event_touch_end"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.TouchInput.InputEventTouchEnd end.*/

    /*VirtueSky.TouchInput.InputEventTouchMove start.*/
    $m("VirtueSky.TouchInput.InputEventTouchMove", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Touch Input/Event Touch Move", fileName: "input_event_touch_move"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.TouchInput.InputEventTouchMove end.*/

    /*VirtueSky.TouchInput.InputEventTouchStationary start.*/
    $m("VirtueSky.TouchInput.InputEventTouchStationary", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Touch Input/Event Touch Stationary", fileName: "input_event_touch_stationary"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.TouchInput.InputEventTouchStationary end.*/

    /*VirtueSky.TouchInput.InputPreventTouchVariable start.*/
    $m("VirtueSky.TouchInput.InputPreventTouchVariable", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Touch Input/Variable Prevent Touch", fileName: "input_prevent_touch_variable"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.TouchInput.InputPreventTouchVariable end.*/

    /*VirtueSky.TouchInput.TouchInputManager start.*/
    $m("VirtueSky.TouchInput.TouchInputManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"HandleMouse","t":8,"sn":"HandleMouse","rt":$n[0].Void},{"a":1,"n":"HandleTouch","t":8,"sn":"HandleTouch","rt":$n[0].Void},{"a":1,"n":"OnChangePreventTouch","t":8,"pi":[{"n":"prevent","pt":$n[0].Boolean,"ps":0}],"sn":"OnChangePreventTouch","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"_mouseDown","t":4,"rt":$n[0].Boolean,"sn":"_mouseDown","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_mouseUpdate","t":4,"rt":$n[0].Boolean,"sn":"_mouseUpdate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TooltipAttribute("Event A finger touched the screen")],"a":1,"n":"inputEventTouchBegin","t":4,"rt":$n[11].InputEventTouchBegin,"sn":"inputEventTouchBegin"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TooltipAttribute("The system cancelled tracking for the touch")],"a":1,"n":"inputEventTouchCancel","t":4,"rt":$n[11].InputEventTouchCancel,"sn":"inputEventTouchCancel"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TooltipAttribute("Event A finger was lifted from the screen. This is the final phase of a touch")],"a":1,"n":"inputEventTouchEnd","t":4,"rt":$n[11].InputEventTouchEnd,"sn":"inputEventTouchEnd"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TooltipAttribute("Event A finger moved on the screen")],"a":1,"n":"inputEventTouchMove","t":4,"rt":$n[11].InputEventTouchMove,"sn":"inputEventTouchMove"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TooltipAttribute("Event A finger is touching the screen but hasn't moved")],"a":1,"n":"inputEventTouchStationary","t":4,"rt":$n[11].InputEventTouchStationary,"sn":"inputEventTouchStationary"},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TooltipAttribute("Prevent touch variable")],"a":1,"n":"inputPreventTouchVariable","t":4,"rt":$n[11].InputPreventTouchVariable,"sn":"inputPreventTouchVariable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"preventTouch","t":4,"rt":$n[0].Boolean,"sn":"preventTouch","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"touchPosition","t":4,"rt":$n[1].Vector3,"sn":"touchPosition"}]}; }, $n);
    /*VirtueSky.TouchInput.TouchInputManager end.*/

    /*VirtueSky.ObjectPooling.Pool start.*/
    $m("VirtueSky.ObjectPooling.Pool", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"DeSpawn","is":true,"t":8,"pi":[{"n":"type","pt":System.Object,"ps":0},{"n":"destroy","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"DeSpawn$1","rt":$n[0].Void,"p":[System.Object,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DeSpawn","is":true,"t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"destroy","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DeSpawn","rt":$n[0].Void,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"DeSpawnAll","is":true,"t":8,"sn":"DeSpawnAll","rt":$n[0].Void},{"a":2,"n":"DestroyAll","is":true,"t":8,"sn":"DestroyAll","rt":$n[0].Void},{"a":2,"n":"DestroyAllWaitPools","is":true,"t":8,"sn":"DestroyAllWaitPools","rt":$n[0].Void},{"a":2,"n":"InitPool","is":true,"t":8,"sn":"InitPool","rt":$n[0].Void},{"a":2,"n":"PreSpawn","is":true,"t":8,"pi":[{"n":"poolData","pt":$n[23].PoolData,"ps":0}],"sn":"PreSpawn","rt":$n[0].Void,"p":[$n[23].PoolData]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"type","pt":System.Object,"ps":0},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"tpc":1,"tprm":["T"],"sn":"Spawn","rt":System.Object,"p":[System.Object,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"Spawn$2","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"type","pt":System.Object,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":3},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"tpc":1,"tprm":["T"],"sn":"Spawn$1","rt":System.Object,"p":[System.Object,$n[1].Vector3,$n[1].Quaternion,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":3},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"Spawn$3","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3,$n[1].Quaternion,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"_poolHandle","is":true,"t":4,"rt":$n[23].PoolHandle,"sn":"_poolHandle"}]}; }, $n);
    /*VirtueSky.ObjectPooling.Pool end.*/

    /*VirtueSky.ObjectPooling.PoolData start.*/
    $m("VirtueSky.ObjectPooling.PoolData", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"count","t":4,"rt":$n[0].Int32,"sn":"count","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"prefab","t":4,"rt":$n[1].GameObject,"sn":"prefab"}]}; }, $n);
    /*VirtueSky.ObjectPooling.PoolData end.*/

    /*VirtueSky.ObjectPooling.PooledObjectId start.*/
    $m("VirtueSky.ObjectPooling.PooledObjectId", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"prefab","t":4,"rt":$n[1].GameObject,"sn":"prefab"}]}; }, $n);
    /*VirtueSky.ObjectPooling.PooledObjectId end.*/

    /*VirtueSky.ObjectPooling.PoolHandle start.*/
    $m("VirtueSky.ObjectPooling.PoolHandle", function () { return {"att":1048832,"a":4,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"CleanUp","t":8,"pi":[{"n":"go","pt":$n[1].GameObject,"ps":0}],"sn":"CleanUp","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":4,"n":"DeSpawn","t":8,"pi":[{"n":"type","pt":System.Object,"ps":0},{"n":"destroy","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"tpc":1,"tprm":["T"],"sn":"DeSpawn$1","rt":$n[0].Void,"p":[System.Object,$n[0].Boolean,$n[0].Boolean]},{"a":4,"n":"DeSpawn","t":8,"pi":[{"n":"gameObject","pt":$n[1].GameObject,"ps":0},{"n":"destroy","dv":false,"o":true,"pt":$n[0].Boolean,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2}],"sn":"DeSpawn","rt":$n[0].Void,"p":[$n[1].GameObject,$n[0].Boolean,$n[0].Boolean]},{"a":4,"n":"DeSpawnAll","t":8,"sn":"DeSpawnAll","rt":$n[0].Void},{"a":4,"n":"DestroyAll","t":8,"sn":"DestroyAll","rt":$n[0].Void},{"a":4,"n":"DestroyAllWaitPools","t":8,"sn":"DestroyAllWaitPools","rt":$n[0].Void},{"a":4,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"a":1,"n":"InitializeObj","t":8,"pi":[{"n":"go","pt":$n[1].GameObject,"ps":0}],"sn":"InitializeObj","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":4,"n":"PreSpawn","t":8,"pi":[{"n":"poolData","pt":$n[23].PoolData,"ps":0}],"sn":"PreSpawn","rt":$n[0].Void,"p":[$n[23].PoolData]},{"a":4,"n":"Spawn","t":8,"pi":[{"n":"type","pt":System.Object,"ps":0},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"tpc":1,"tprm":["T"],"sn":"Spawn","rt":System.Object,"p":[System.Object,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":4,"n":"Spawn","t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":1},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":3}],"sn":"Spawn$2","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":4,"n":"Spawn","t":8,"pi":[{"n":"type","pt":System.Object,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":3},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"tpc":1,"tprm":["T"],"sn":"Spawn$1","rt":System.Object,"p":[System.Object,$n[1].Vector3,$n[1].Quaternion,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":4,"n":"Spawn","t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0},{"n":"position","pt":$n[1].Vector3,"ps":1},{"n":"rotation","pt":$n[1].Quaternion,"ps":2},{"n":"parent","dv":null,"o":true,"pt":$n[1].Transform,"ps":3},{"n":"worldPositionStays","dv":true,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"initialize","dv":true,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"Spawn$3","rt":$n[1].GameObject,"p":[$n[1].GameObject,$n[1].Vector3,$n[1].Quaternion,$n[1].Transform,$n[0].Boolean,$n[0].Boolean]},{"a":1,"n":"SpawnNew","t":8,"pi":[{"n":"prefab","pt":$n[1].GameObject,"ps":0}],"sn":"SpawnNew","rt":$n[0].Void,"p":[$n[1].GameObject]},{"a":1,"n":"activePool","t":4,"rt":$n[3].LinkedList$1(UnityEngine.GameObject),"sn":"activePool"},{"a":1,"n":"container","t":4,"rt":$n[1].Transform,"sn":"container"},{"a":1,"n":"initialized","t":4,"rt":$n[0].Boolean,"sn":"initialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"waitPool","t":4,"rt":$n[3].Dictionary$2(UnityEngine.GameObject,System.Collections.Generic.Queue$1(UnityEngine.GameObject)),"sn":"waitPool"}]}; }, $n);
    /*VirtueSky.ObjectPooling.PoolHandle end.*/

    /*VirtueSky.Misc.Common start.*/
    $m("VirtueSky.Misc.Common", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"CallActionAndClean","is":true,"t":8,"pi":[{"n":"action","ref":true,"pt":Function,"ps":0}],"sn":"CallActionAndClean","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"CallActionAndClean","is":true,"t":8,"pi":[{"n":"action","ref":true,"pt":Function,"ps":0},{"n":"_value","pt":System.Object,"ps":1}],"tpc":1,"tprm":["T"],"sn":"CallActionAndClean$1","rt":$n[0].Void,"p":[Function,System.Object]},{"a":2,"n":"CheckInternetConnection","is":true,"t":8,"pi":[{"n":"actionConnected","pt":Function,"ps":0},{"n":"actionDisconnected","pt":Function,"ps":1}],"sn":"CheckInternetConnection","rt":$n[0].Void,"p":[Function,Function]},{"a":2,"n":"ClearTransform","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"ClearTransform","rt":$n[1].Transform,"p":[$n[1].Transform]},{"a":2,"n":"Delay","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"onComplete","pt":Function,"ps":2},{"n":"onUpdate","dv":null,"o":true,"pt":Function,"ps":3},{"n":"isLooped","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useRealTime","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"Delay","rt":$n[24].DelayHandle,"p":[$n[1].MonoBehaviour,$n[0].Single,Function,Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Format","is":true,"t":8,"pi":[{"n":"fmt","pt":$n[0].String,"ps":0},{"n":"args","ip":true,"pt":$n[0].Array.type(System.Object),"ps":1}],"sn":"Format","rt":$n[0].String,"p":[$n[0].String,$n[0].Array.type(System.Object)]},{"a":2,"n":"GetLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetLocalPositionXZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetLocalPositionXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetLocalPositionYZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetLocalPositionYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetLocalRotationXZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetLocalRotationXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetLocalRotationYZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetLocalRotationYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetNumberInAString","is":true,"t":8,"pi":[{"n":"str","pt":$n[0].String,"ps":0}],"sn":"GetNumberInAString","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetPositionXZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetPositionXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetPositionYZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetPositionYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetRotationXZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetRotationXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetRotationYZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetRotationYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetScaleXZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetScaleXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0}],"sn":"GetScaleYZ$1","rt":$n[1].Vector2,"p":[$n[1].Transform]},{"a":2,"n":"GetScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","out":true,"pt":$n[1].Vector2,"ps":1}],"sn":"GetScaleYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"GetScreenRatio","is":true,"t":8,"sn":"GetScreenRatio","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"InternetConnection","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"InternetConnection","rt":$n[9].IEnumerator,"p":[Function]},{"a":2,"n":"IsInteger","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Single,"ps":0}],"sn":"IsInteger","rt":$n[0].Boolean,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"SetAlpha","is":true,"t":8,"pi":[{"n":"graphic","pt":$n[8].Graphic,"ps":0},{"n":"a","pt":$n[0].Single,"ps":1}],"sn":"SetAlpha","rt":$n[8].Graphic,"p":[$n[8].Graphic,$n[0].Single]},{"a":2,"n":"SetAnchoredPositionX","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetAnchoredPositionX","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[0].Single]},{"a":2,"n":"SetAnchoredPositionY","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetAnchoredPositionY","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[0].Single]},{"a":2,"n":"SetAnchoredPositionZ","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetAnchoredPositionZ","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[0].Single]},{"a":2,"n":"SetLocalPositionX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetLocalPositionX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetLocalPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetLocalPositionXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetLocalPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPositionXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetLocalPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetLocalPositionXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetLocalPositionXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPositionXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetLocalPositionXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLocalPositionY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetLocalPositionY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetLocalPositionYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalPositionYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetLocalPositionYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLocalPositionZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetLocalPositionZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetLocalRotationX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetLocalRotationX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetLocalRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetLocalRotationXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetLocalRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalRotationXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetLocalRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetLocalRotationXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetLocalRotationXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalRotationXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetLocalRotationXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLocalRotationY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetLocalRotationY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetLocalRotationYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetLocalRotationYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetLocalRotationYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetLocalRotationZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetLocalRotationZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetPosition","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v3","pt":$n[1].Vector3,"ps":1}],"sn":"SetPosition","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector3]},{"a":2,"n":"SetPositionX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetPositionX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetPositionXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetPositionXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetPositionXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetPositionXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetPositionY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetPositionY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetPositionYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetPositionYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetPositionYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetPositionZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetPositionZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeAnchoredPositionX","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeAnchoredPositionX","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[0].Single]},{"a":2,"n":"SetRelativeAnchoredPositionY","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeAnchoredPositionY","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[0].Single]},{"a":2,"n":"SetRelativeAnchoredPositionZ","is":true,"t":8,"pi":[{"n":"rectTransform","pt":$n[1].RectTransform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeAnchoredPositionZ","rt":$n[0].Void,"p":[$n[1].RectTransform,$n[0].Single]},{"a":2,"n":"SetRelativeLocalPositionX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeLocalPositionX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeLocalPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeLocalPositionXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeLocalPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeLocalPositionXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeLocalPositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeLocalPositionXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeLocalPositionXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeLocalPositionXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeLocalPositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeLocalPositionXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeLocalPositionY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeLocalPositionY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeLocalPositionYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeLocalPositionYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeLocalPositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeLocalPositionYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeLocalPositionZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeLocalPositionZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeLocalRotationX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeLocalRotationX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeLocalRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeLocalRotationXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeLocalRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeLocalRotationXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeLocalRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeLocalRotationXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeLocalRotationXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeLocalRotationXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeLocalRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeLocalRotationXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeLocalRotationY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeLocalRotationY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeLocalRotationYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeLocalRotationYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeLocalRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeLocalRotationYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeLocalRotationZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeLocalRotationZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativePosition","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v3","pt":$n[1].Vector3,"ps":1}],"sn":"SetRelativePosition","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector3]},{"a":2,"n":"SetRelativePositionX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRelativePositionX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativePositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativePositionXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativePositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativePositionXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativePositionXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetRelativePositionXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativePositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativePositionXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativePositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativePositionXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativePositionXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativePositionXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativePositionY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRelativePositionY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativePositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativePositionYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativePositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativePositionYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativePositionYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativePositionYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativePositionZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRelativePositionZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeRotationX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeRotationX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeRotationXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeRotationXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeRotationXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeRotationXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeRotationXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeRotationXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeRotationY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeRotationY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeRotationYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeRotationYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeRotationYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeRotationZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeRotationZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScale","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScale","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScaleX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScaleX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScaleXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeScaleXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeScaleXY$3","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeScaleXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScaleXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeScaleXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeScaleXZ$3","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeScaleXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeScaleY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScaleY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScaleYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRelativeScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRelativeScaleYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRelativeScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRelativeScaleYZ$3","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRelativeScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRelativeScaleYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRelativeScaleZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRelativeScaleZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRotationX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetRotationX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRotationXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRotationXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRotationXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetRotationXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRotationXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRotationXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRotationXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRotationXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotationY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetRotationY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetRotationYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetRotationYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetRotationYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetRotationYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetRotationZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetRotationZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScale","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetScale","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScaleX","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1}],"sn":"SetScaleX","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetScaleXY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetScaleXY$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetScaleXY$3","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetScaleXY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"y","pt":$n[0].Single,"ps":2}],"sn":"SetScaleXY$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetScaleXZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetScaleXZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetScaleXZ$3","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetScaleXZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"x","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetScaleXZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetScaleY","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1}],"sn":"SetScaleY","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"value","pt":$n[0].Single,"ps":1}],"sn":"SetScaleYZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"SetScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"target","pt":$n[1].Transform,"ps":1}],"sn":"SetScaleYZ$2","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Transform]},{"a":2,"n":"SetScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"v2","pt":$n[1].Vector2,"ps":1}],"sn":"SetScaleYZ$3","rt":$n[0].Void,"p":[$n[1].Transform,$n[1].Vector2]},{"a":2,"n":"SetScaleYZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"y","pt":$n[0].Single,"ps":1},{"n":"z","pt":$n[0].Single,"ps":2}],"sn":"SetScaleYZ$1","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single,$n[0].Single]},{"a":2,"n":"SetScaleZ","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].Transform,"ps":0},{"n":"z","pt":$n[0].Single,"ps":1}],"sn":"SetScaleZ","rt":$n[0].Void,"p":[$n[1].Transform,$n[0].Single]},{"a":2,"n":"StopCheckInternetConnection","is":true,"t":8,"sn":"StopCheckInternetConnection","rt":$n[0].Void},{"a":2,"n":"ToWorldPosition","is":true,"t":8,"pi":[{"n":"transform","pt":$n[1].RectTransform,"ps":0},{"n":"camera","dv":null,"o":true,"pt":$n[1].Camera,"ps":1}],"sn":"ToWorldPosition","rt":$n[1].Vector2,"p":[$n[1].RectTransform,$n[1].Camera]},{"a":1,"n":"internetConnectionCoroutine","is":true,"t":4,"rt":$n[9].IEnumerator,"sn":"internetConnectionCoroutine"}]}; }, $n);
    /*VirtueSky.Misc.Common end.*/

    /*VirtueSky.Misc.SkeletonGraphicExtensions start.*/
    $m("VirtueSky.Misc.SkeletonGraphicExtensions", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"AddAnimation","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"trackIndex","pt":$n[0].Int32,"ps":1},{"n":"animationName","pt":$n[0].String,"ps":2},{"n":"loop","pt":$n[0].Boolean,"ps":3},{"n":"timeDelay","dv":0.0,"o":true,"pt":$n[0].Single,"ps":4},{"n":"mixDuration","dv":0.0,"o":true,"pt":$n[0].Single,"ps":5}],"sn":"AddAnimation","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].Int32,$n[0].String,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"a":2,"n":"ChangeAttachment","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentNames","pt":$n[3].List$1(System.String),"ps":2}],"sn":"ChangeAttachment","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].String,$n[3].List$1(System.String)]},{"a":2,"n":"ChangeAttachment","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"slotName","pt":$n[0].String,"ps":1},{"n":"attachmentName","pt":$n[0].String,"ps":2}],"sn":"ChangeAttachment$1","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].String,$n[0].String]},{"a":2,"n":"Duration","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"track","dv":0,"o":true,"pt":$n[0].Int32,"ps":1}],"sn":"Duration","rt":$n[0].Single,"p":[$n[12].SkeletonGraphic,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Duration","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1}],"sn":"Duration$1","rt":$n[0].Single,"p":[$n[12].SkeletonGraphic,$n[0].String],"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"MixSkin","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"mixSkinNames","pt":$n[3].List$1(System.String),"ps":1}],"sn":"MixSkin","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[3].List$1(System.String)]},{"a":2,"n":"MixSkin","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"mixSkinName","pt":$n[0].String,"ps":1}],"sn":"MixSkin$1","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].String]},{"a":2,"n":"OnComplete","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"onComplete","pt":Function,"ps":1},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"target","dv":null,"o":true,"pt":$n[1].MonoBehaviour,"ps":3}],"sn":"OnComplete","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,Function,$n[0].Int32,$n[1].MonoBehaviour]},{"a":2,"n":"OnUpdate","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"onUpdate","pt":Function,"ps":1},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":2},{"n":"target","dv":null,"o":true,"pt":$n[1].MonoBehaviour,"ps":3}],"sn":"OnUpdate","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,Function,$n[0].Int32,$n[1].MonoBehaviour]},{"a":2,"n":"Play","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":3}],"sn":"Play","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].String,$n[0].Boolean,$n[0].Int32]},{"a":2,"n":"PlayOnly","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"animationName","pt":$n[0].String,"ps":1},{"n":"loop","dv":false,"o":true,"pt":$n[0].Boolean,"ps":2},{"n":"trackIndex","dv":0,"o":true,"pt":$n[0].Int32,"ps":3}],"sn":"PlayOnly","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].String,$n[0].Boolean,$n[0].Int32]},{"a":2,"n":"SetSkin","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"skinNames","pt":$n[3].List$1(System.String),"ps":1}],"sn":"SetSkin","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[3].List$1(System.String)]},{"a":2,"n":"SetSkin","is":true,"t":8,"pi":[{"n":"skeletonGraphic","pt":$n[12].SkeletonGraphic,"ps":0},{"n":"skinName","pt":$n[0].String,"ps":1}],"sn":"SetSkin$1","rt":$n[12].SkeletonGraphic,"p":[$n[12].SkeletonGraphic,$n[0].String]}]}; }, $n);
    /*VirtueSky.Misc.SkeletonGraphicExtensions end.*/

    /*VirtueSky.Events.BaseEvent start.*/
    $m("VirtueSky.Events.BaseEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"AddListener","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener,"ps":0}],"sn":"AddListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener]},{"a":2,"n":"Raise","t":8,"sn":"Raise","rt":$n[0].Void},{"a":2,"n":"RemoveAll","t":8,"sn":"RemoveAll","rt":$n[0].Void},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RemoveListener","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener,"ps":0}],"sn":"RemoveListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener]},{"a":1,"n":"listeners","t":4,"rt":$n[3].List$1(VirtueSky.Events.IEventListener),"sn":"listeners","ro":true},{"a":1,"n":"onRaised","t":4,"rt":Function,"sn":"onRaised"},{"a":2,"n":"OnRaised","t":2,"ad":{"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.BaseEvent end.*/

    /*VirtueSky.Events.BaseEvent$1 start.*/
    $m("VirtueSky.Events.BaseEvent$1", function (TType) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"AddListener$1","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$1(TType),"ps":0}],"sn":"AddListener","rt":$n[0].Void,"p":[$n[2].IEventListener$1(TType)]},{"v":true,"a":2,"n":"Raise","t":8,"pi":[{"n":"value","pt":TType,"ps":0}],"sn":"Raise","rt":$n[0].Void,"p":[TType]},{"a":2,"n":"RemoveAll","t":8,"sn":"RemoveAll","rt":$n[0].Void},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RemoveListener$1","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$1(TType),"ps":0}],"sn":"RemoveListener","rt":$n[0].Void,"p":[$n[2].IEventListener$1(TType)]},{"a":1,"n":"listeners","t":4,"rt":$n[3].List$1(VirtueSky.Events.IEventListener$1(TType)),"sn":"listeners","ro":true},{"a":1,"n":"onRaised","t":4,"rt":Function,"sn":"onRaised"},{"a":2,"n":"OnRaised","t":2,"ad":{"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.BaseEvent$1 end.*/

    /*VirtueSky.Events.BaseEvent$2 start.*/
    $m("VirtueSky.Events.BaseEvent$2", function (TType, TResult) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"AddListener$1","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$2(TType,TResult),"ps":0}],"sn":"AddListener","rt":$n[0].Void,"p":[$n[2].IEventListener$2(TType,TResult)]},{"a":2,"n":"Raise","t":8,"pi":[{"n":"value","pt":TType,"ps":0}],"sn":"Raise","rt":TResult,"p":[TType]},{"a":2,"n":"RemoveAll","t":8,"sn":"RemoveAll","rt":$n[0].Void},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"RemoveListener$1","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$2(TType,TResult),"ps":0}],"sn":"RemoveListener","rt":$n[0].Void,"p":[$n[2].IEventListener$2(TType,TResult)]},{"a":1,"n":"listeners","t":4,"rt":$n[3].List$1(VirtueSky.Events.IEventListener$2(TType,TResult)),"sn":"listeners","ro":true},{"a":1,"n":"onRaised","t":4,"rt":Function,"sn":"onRaised"},{"a":2,"n":"OnRaised","t":2,"ad":{"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.BaseEvent$2 end.*/

    /*VirtueSky.Events.BaseEventListener$2 start.*/
    $m("VirtueSky.Events.BaseEventListener$2", function (TEvent, TResponse) { return {"nested":[$n[2].BaseEventListener$2.EventResponseData],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"OnEventRaised","t":8,"pi":[{"n":"eventRaise","pt":$n[2].BaseEvent,"ps":0}],"sn":"OnEventRaised","rt":$n[0].Void,"p":[$n[2].BaseEvent]},{"ov":true,"a":3,"n":"ToggleListenerEvent","t":8,"pi":[{"n":"isListenerEvent","pt":$n[0].Boolean,"ps":0}],"sn":"ToggleListenerEvent","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"_dictionary","t":4,"rt":$n[3].Dictionary$2(VirtueSky.Events.BaseEvent,UnityEngine.Events.UnityEvent),"sn":"_dictionary","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listEventResponseDatas","t":4,"rt":System.Array.type(VirtueSky.Events.BaseEventListener$2.EventResponseData(TEvent,TResponse)),"sn":"listEventResponseDatas"}]}; }, $n);
    /*VirtueSky.Events.BaseEventListener$2 end.*/

    /*VirtueSky.Events.BaseEventListener$2+EventResponseData start.*/
    $m("VirtueSky.Events.BaseEventListener$2.EventResponseData", function (TEvent, TResponse) { return {"td":$n[2].BaseEventListener$2(TEvent,TResponse),"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"event","t":4,"rt":TEvent,"sn":"event"},{"a":2,"n":"response","t":4,"rt":TResponse,"sn":"response"}]}; }, $n);
    /*VirtueSky.Events.BaseEventListener$2+EventResponseData end.*/

    /*VirtueSky.Events.BaseEventListener$3 start.*/
    $m("VirtueSky.Events.BaseEventListener$3", function (TType, TEvent, TResponse) { return {"nested":[$n[2].BaseEventListener$3.EventResponseData],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"OnEventRaised","t":8,"pi":[{"n":"eventRaise","pt":$n[2].BaseEvent$1(TType),"ps":0},{"n":"value","pt":TType,"ps":1}],"sn":"OnEventRaised","rt":$n[0].Void,"p":[$n[2].BaseEvent$1(TType),TType]},{"ov":true,"a":3,"n":"ToggleListenerEvent","t":8,"pi":[{"n":"isListenerEvent","pt":$n[0].Boolean,"ps":0}],"sn":"ToggleListenerEvent","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"_dictionary","t":4,"rt":$n[3].Dictionary$2(VirtueSky.Events.BaseEvent$1(TType),UnityEngine.Events.UnityEvent$1(TType)),"sn":"_dictionary","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"listEventResponseDatas","t":4,"rt":System.Array.type(VirtueSky.Events.BaseEventListener$3.EventResponseData(TType,TEvent,TResponse)),"sn":"listEventResponseDatas"}]}; }, $n);
    /*VirtueSky.Events.BaseEventListener$3 end.*/

    /*VirtueSky.Events.BaseEventListener$3+EventResponseData start.*/
    $m("VirtueSky.Events.BaseEventListener$3.EventResponseData", function (TType, TEvent, TResponse) { return {"td":$n[2].BaseEventListener$3(TType,TEvent,TResponse),"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"event","t":4,"rt":TEvent,"sn":"event"},{"a":2,"n":"response","t":4,"rt":TResponse,"sn":"response"}]}; }, $n);
    /*VirtueSky.Events.BaseEventListener$3+EventResponseData end.*/

    /*VirtueSky.Events.BaseEventListener$4 start.*/
    $m("VirtueSky.Events.BaseEventListener$4", function (TType, TResult, TEvent, TResponse) { return {"nested":[$n[2].BaseEventListener$4.EventResponseData],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"OnEventRaised","t":8,"pi":[{"n":"eventRaise","pt":$n[2].BaseEvent$2(TType,TResult),"ps":0},{"n":"value","pt":TType,"ps":1}],"sn":"OnEventRaised","rt":$n[0].Void,"p":[$n[2].BaseEvent$2(TType,TResult),TType]},{"ov":true,"a":3,"n":"ToggleListenerEvent","t":8,"pi":[{"n":"isListenerEvent","pt":$n[0].Boolean,"ps":0}],"sn":"ToggleListenerEvent","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":3,"n":"_dictionary","t":4,"rt":$n[3].Dictionary$2(VirtueSky.Events.BaseEvent$2(TType,TResult),UnityEngine.Events.UnityEvent$1(TType)),"sn":"_dictionary","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"listEventResponseDatas","t":4,"rt":System.Array.type(VirtueSky.Events.BaseEventListener$4.EventResponseData(TType,TResult,TEvent,TResponse)),"sn":"listEventResponseDatas"}]}; }, $n);
    /*VirtueSky.Events.BaseEventListener$4 end.*/

    /*VirtueSky.Events.BaseEventListener$4+EventResponseData start.*/
    $m("VirtueSky.Events.BaseEventListener$4.EventResponseData", function (TType, TResult, TEvent, TResponse) { return {"td":$n[2].BaseEventListener$4(TType,TResult,TEvent,TResponse),"att":1056770,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"event","t":4,"rt":TEvent,"sn":"event"},{"a":2,"n":"response","t":4,"rt":TResponse,"sn":"response"}]}; }, $n);
    /*VirtueSky.Events.BaseEventListener$4+EventResponseData end.*/

    /*VirtueSky.Events.BaseEventResponse start.*/
    $m("VirtueSky.Events.BaseEventResponse", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BaseEventResponse end.*/

    /*VirtueSky.Events.BaseEventResponse$1 start.*/
    $m("VirtueSky.Events.BaseEventResponse$1", function (TType) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BaseEventResponse$1 end.*/

    /*VirtueSky.Events.EventListenerMono start.*/
    $m("VirtueSky.Events.EventListenerMono", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"OnDestroy","t":8,"sn":"OnDestroy","rt":$n[0].Void},{"a":1,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"a":1,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ab":true,"a":3,"n":"ToggleListenerEvent","t":8,"pi":[{"n":"isListenerEvent","pt":$n[0].Boolean,"ps":0}],"sn":"ToggleListenerEvent","rt":$n[0].Void,"p":[$n[0].Boolean]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"bindingListener","t":4,"rt":$n[2].BindingListener,"sn":"bindingListener","box":function ($v) { return Bridge.box($v, VirtueSky.Events.BindingListener, System.Enum.toStringFn(VirtueSky.Events.BindingListener));}}]}; }, $n);
    /*VirtueSky.Events.EventListenerMono end.*/

    /*VirtueSky.Events.BindingListener start.*/
    $m("VirtueSky.Events.BindingListener", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"UNTIL_DESTROY","is":true,"t":4,"rt":$n[2].BindingListener,"sn":"UNTIL_DESTROY","box":function ($v) { return Bridge.box($v, VirtueSky.Events.BindingListener, System.Enum.toStringFn(VirtueSky.Events.BindingListener));}},{"a":2,"n":"UNTIL_DISABLE","is":true,"t":4,"rt":$n[2].BindingListener,"sn":"UNTIL_DISABLE","box":function ($v) { return Bridge.box($v, VirtueSky.Events.BindingListener, System.Enum.toStringFn(VirtueSky.Events.BindingListener));}}]}; }, $n);
    /*VirtueSky.Events.BindingListener end.*/

    /*VirtueSky.Events.BooleanEvent start.*/
    $m("VirtueSky.Events.BooleanEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Boolean Event", fileName: "bool_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BooleanEvent end.*/

    /*VirtueSky.Events.BooleanEventListener start.*/
    $m("VirtueSky.Events.BooleanEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BooleanEventListener end.*/

    /*VirtueSky.Events.BooleanEventResponse start.*/
    $m("VirtueSky.Events.BooleanEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BooleanEventResponse end.*/

    /*VirtueSky.Events.BoolEventBoolResult start.*/
    $m("VirtueSky.Events.BoolEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/Boolean Result", fileName: "bool_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventBoolResult end.*/

    /*VirtueSky.Events.BoolEventFloatResult start.*/
    $m("VirtueSky.Events.BoolEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/Float Result", fileName: "bool_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventFloatResult end.*/

    /*VirtueSky.Events.BoolEventGameObjectResult start.*/
    $m("VirtueSky.Events.BoolEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/GameObject Result", fileName: "bool_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventGameObjectResult end.*/

    /*VirtueSky.Events.BoolEventIntResult start.*/
    $m("VirtueSky.Events.BoolEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/Int Result", fileName: "bool_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventIntResult end.*/

    /*VirtueSky.Events.BoolEventObjectResult start.*/
    $m("VirtueSky.Events.BoolEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/Object Result", fileName: "bool_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventObjectResult end.*/

    /*VirtueSky.Events.BoolEventStringResult start.*/
    $m("VirtueSky.Events.BoolEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/String Result", fileName: "bool_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventStringResult end.*/

    /*VirtueSky.Events.BoolEventTransformResult start.*/
    $m("VirtueSky.Events.BoolEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/Transform Result", fileName: "bool_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventTransformResult end.*/

    /*VirtueSky.Events.BoolEventVector3Result start.*/
    $m("VirtueSky.Events.BoolEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Boolean Event/Vector3 Result", fileName: "bool_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.BoolEventVector3Result end.*/

    /*VirtueSky.Events.ClickButtonEvent start.*/
    $m("VirtueSky.Events.ClickButtonEvent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ClickButtonEvent end.*/

    /*VirtueSky.Events.DictionaryEvent start.*/
    $m("VirtueSky.Events.DictionaryEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/DictionaryEvent", fileName: "dictionary_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.DictionaryEvent end.*/

    /*VirtueSky.Events.DictionaryEventListener start.*/
    $m("VirtueSky.Events.DictionaryEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.DictionaryEventListener end.*/

    /*VirtueSky.Events.DictionaryEventResponse start.*/
    $m("VirtueSky.Events.DictionaryEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.DictionaryEventResponse end.*/

    /*VirtueSky.Events.EventNoParamBoolResult start.*/
    $m("VirtueSky.Events.EventNoParamBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/Boolean Result", fileName: "event_no_param_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamBoolResult end.*/

    /*VirtueSky.Events.EventNoParamFloatResult start.*/
    $m("VirtueSky.Events.EventNoParamFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/Float Result", fileName: "event_no_param_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamFloatResult end.*/

    /*VirtueSky.Events.EventNoParamGameObjectResult start.*/
    $m("VirtueSky.Events.EventNoParamGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/GameObject Result", fileName: "event_no_param_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamGameObjectResult end.*/

    /*VirtueSky.Events.EventNoParamIntResult start.*/
    $m("VirtueSky.Events.EventNoParamIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/Int Result", fileName: "event_no_param_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamIntResult end.*/

    /*VirtueSky.Events.EventNoParamObjectResult start.*/
    $m("VirtueSky.Events.EventNoParamObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/Object Result", fileName: "event_no_param_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamObjectResult end.*/

    /*VirtueSky.Events.EventNoParamResult$1 start.*/
    $m("VirtueSky.Events.EventNoParamResult$1", function (TResult) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"AddListener","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"Raise","t":8,"sn":"Raise","rt":TResult},{"a":2,"n":"RemoveAll","t":8,"sn":"RemoveAll","rt":$n[0].Void},{"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"RemoveListener","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"onRaised","t":4,"rt":Function,"sn":"onRaised"},{"a":2,"n":"OnRaised","t":2,"ad":{"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.EventNoParamResult$1 end.*/

    /*VirtueSky.Events.EventNoParamStringResult start.*/
    $m("VirtueSky.Events.EventNoParamStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/String Result", fileName: "event_no_param_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamStringResult end.*/

    /*VirtueSky.Events.EventNoParamTransformResult start.*/
    $m("VirtueSky.Events.EventNoParamTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/Transform Result", fileName: "event_no_param_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamTransformResult end.*/

    /*VirtueSky.Events.EventNoParamVector3Result start.*/
    $m("VirtueSky.Events.EventNoParamVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Event No Param/Vector3 Result", fileName: "event_no_param_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParamVector3Result end.*/

    /*VirtueSky.Events.EventListenerNoParam start.*/
    $m("VirtueSky.Events.EventListenerNoParam", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventListenerNoParam end.*/

    /*VirtueSky.Events.EventNoParam start.*/
    $m("VirtueSky.Events.EventNoParam", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Event No Param", fileName: "event_no_param"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventNoParam end.*/

    /*VirtueSky.Events.EventResponse start.*/
    $m("VirtueSky.Events.EventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.EventResponse end.*/

    /*VirtueSky.Events.FloatEventBoolResult start.*/
    $m("VirtueSky.Events.FloatEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/Bool Result", fileName: "float_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventBoolResult end.*/

    /*VirtueSky.Events.FloatEventFloatResult start.*/
    $m("VirtueSky.Events.FloatEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/Float Result", fileName: "float_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventFloatResult end.*/

    /*VirtueSky.Events.FloatEventGameObjectResult start.*/
    $m("VirtueSky.Events.FloatEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/GameObject Result", fileName: "float_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventGameObjectResult end.*/

    /*VirtueSky.Events.FloatEventIntResult start.*/
    $m("VirtueSky.Events.FloatEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/Int Result", fileName: "float_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventIntResult end.*/

    /*VirtueSky.Events.FloatEventObjectResult start.*/
    $m("VirtueSky.Events.FloatEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/Object Result", fileName: "float_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventObjectResult end.*/

    /*VirtueSky.Events.FloatEventStringResult start.*/
    $m("VirtueSky.Events.FloatEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/String Result", fileName: "float_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventStringResult end.*/

    /*VirtueSky.Events.FloatEventTransformResult start.*/
    $m("VirtueSky.Events.FloatEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/Transform Result", fileName: "float_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventTransformResult end.*/

    /*VirtueSky.Events.FloatEventVector3Result start.*/
    $m("VirtueSky.Events.FloatEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Float Event/Vector3 Result", fileName: "float_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventVector3Result end.*/

    /*VirtueSky.Events.FloatEvent start.*/
    $m("VirtueSky.Events.FloatEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Float Event", fileName: "float_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEvent end.*/

    /*VirtueSky.Events.FloatEventListener start.*/
    $m("VirtueSky.Events.FloatEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventListener end.*/

    /*VirtueSky.Events.FloatEventResponse start.*/
    $m("VirtueSky.Events.FloatEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.FloatEventResponse end.*/

    /*VirtueSky.Events.GameObjectEventBoolResult start.*/
    $m("VirtueSky.Events.GameObjectEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/Bool Result", fileName: "gameobject_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventBoolResult end.*/

    /*VirtueSky.Events.GameObjectEventFloatResult start.*/
    $m("VirtueSky.Events.GameObjectEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/Float Result", fileName: "gameobject_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventFloatResult end.*/

    /*VirtueSky.Events.GameObjectEventGameObjectResult start.*/
    $m("VirtueSky.Events.GameObjectEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/GameObject Result", fileName: "gameobject_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventGameObjectResult end.*/

    /*VirtueSky.Events.GameObjectEventIntResult start.*/
    $m("VirtueSky.Events.GameObjectEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/Int Result", fileName: "gameobject_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventIntResult end.*/

    /*VirtueSky.Events.GameObjectEventObjectResult start.*/
    $m("VirtueSky.Events.GameObjectEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/Object Result", fileName: "gameobject_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventObjectResult end.*/

    /*VirtueSky.Events.GameObjectEventStringResult start.*/
    $m("VirtueSky.Events.GameObjectEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/String Result", fileName: "gameobject_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventStringResult end.*/

    /*VirtueSky.Events.GameObjectEventTransformResult start.*/
    $m("VirtueSky.Events.GameObjectEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/Transform Result", fileName: "gameobject_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventTransformResult end.*/

    /*VirtueSky.Events.GameObjectEventVector3Result start.*/
    $m("VirtueSky.Events.GameObjectEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/GameObject Event/Vector3 Result", fileName: "gameobject_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventVector3Result end.*/

    /*VirtueSky.Events.GameObjectEvent start.*/
    $m("VirtueSky.Events.GameObjectEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/GameObject Event", fileName: "gameobject_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEvent end.*/

    /*VirtueSky.Events.GameObjectEventListener start.*/
    $m("VirtueSky.Events.GameObjectEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventListener end.*/

    /*VirtueSky.Events.GameObjectEventResponse start.*/
    $m("VirtueSky.Events.GameObjectEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.GameObjectEventResponse end.*/

    /*VirtueSky.Events.IntEventBoolResult start.*/
    $m("VirtueSky.Events.IntEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/Bool Result", fileName: "int_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventBoolResult end.*/

    /*VirtueSky.Events.IntEventFloatResult start.*/
    $m("VirtueSky.Events.IntEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/Float Result", fileName: "int_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventFloatResult end.*/

    /*VirtueSky.Events.IntEventGameObjectResult start.*/
    $m("VirtueSky.Events.IntEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/GameObject Result", fileName: "int_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventGameObjectResult end.*/

    /*VirtueSky.Events.IntEventIntResult start.*/
    $m("VirtueSky.Events.IntEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/Int Result", fileName: "int_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventIntResult end.*/

    /*VirtueSky.Events.IntEventObjectResult start.*/
    $m("VirtueSky.Events.IntEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/Object Result", fileName: "int_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventObjectResult end.*/

    /*VirtueSky.Events.IntEventStringResult start.*/
    $m("VirtueSky.Events.IntEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/String Result", fileName: "int_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventStringResult end.*/

    /*VirtueSky.Events.IntEventTransformResult start.*/
    $m("VirtueSky.Events.IntEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/Transform Result", fileName: "int_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventTransformResult end.*/

    /*VirtueSky.Events.IntEventVector3Result start.*/
    $m("VirtueSky.Events.IntEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Int Event/Vector3 Result", fileName: "int_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntEventVector3Result end.*/

    /*VirtueSky.Events.IntegerEvent start.*/
    $m("VirtueSky.Events.IntegerEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Integer Event", fileName: "int_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntegerEvent end.*/

    /*VirtueSky.Events.IntegerEventListener start.*/
    $m("VirtueSky.Events.IntegerEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntegerEventListener end.*/

    /*VirtueSky.Events.IntegerEventResponse start.*/
    $m("VirtueSky.Events.IntegerEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.IntegerEventResponse end.*/

    /*VirtueSky.Events.IEvent start.*/
    $m("VirtueSky.Events.IEvent", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$AddListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener,"ps":0}],"sn":"VirtueSky$Events$IEvent$AddListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener]},{"ab":true,"a":2,"n":"Raise","t":8,"sn":"VirtueSky$Events$IEvent$Raise","rt":$n[0].Void},{"ab":true,"a":2,"n":"RemoveAll","t":8,"sn":"VirtueSky$Events$IEvent$RemoveAll","rt":$n[0].Void},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$RemoveListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener,"ps":0}],"sn":"VirtueSky$Events$IEvent$RemoveListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener]},{"ab":true,"a":2,"n":"OnRaised","t":2,"ad":{"ab":true,"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.IEvent end.*/

    /*VirtueSky.Events.IEvent$1 start.*/
    $m("VirtueSky.Events.IEvent$1", function (T) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$AddListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$1(T),"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$AddListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener$1(T)]},{"ab":true,"a":2,"n":"Raise","t":8,"pi":[{"n":"value","pt":T,"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$Raise","rt":$n[0].Void,"p":[T]},{"ab":true,"a":2,"n":"RemoveAll","t":8,"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$RemoveAll","rt":$n[0].Void},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$RemoveListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$1(T),"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$RemoveListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener$1(T)]},{"ab":true,"a":2,"n":"OnRaised","t":2,"ad":{"ab":true,"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$1$" + Bridge.getTypeAlias(T) + "$removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.IEvent$1 end.*/

    /*VirtueSky.Events.IEvent$2 start.*/
    $m("VirtueSky.Events.IEvent$2", function (T, TResult) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$AddListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$2(T,TResult),"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$AddListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener$2(T,TResult)]},{"ab":true,"a":2,"n":"Raise","t":8,"pi":[{"n":"value","pt":T,"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$Raise","rt":TResult,"p":[T]},{"ab":true,"a":2,"n":"RemoveAll","t":8,"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$RemoveAll","rt":$n[0].Void},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$RemoveListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"listener","pt":$n[2].IEventListener$2(T,TResult),"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$RemoveListener$1","rt":$n[0].Void,"p":[$n[2].IEventListener$2(T,TResult)]},{"ab":true,"a":2,"n":"OnRaised","t":2,"ad":{"ab":true,"a":2,"n":"add_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$addOnRaised","rt":$n[0].Void,"p":[Function]},"r":{"ab":true,"a":2,"n":"remove_OnRaised","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEvent$2$" + Bridge.getTypeAlias(T) + "$" + Bridge.getTypeAlias(TResult) + "$removeOnRaised","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Events.IEvent$2 end.*/

    /*VirtueSky.Events.IEventNoParamResult$1 start.*/
    $m("VirtueSky.Events.IEventNoParamResult$1", function (TResult) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"AddListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$AddListener","rt":$n[0].Void,"p":[Function]},{"ab":true,"a":2,"n":"Raise","t":8,"sn":"VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$Raise","rt":TResult},{"ab":true,"a":2,"n":"RemoveAll","t":8,"sn":"VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$RemoveAll","rt":$n[0].Void},{"ab":true,"a":2,"n":"RemoveListener","t":8,"pi":[{"n":"func","pt":Function,"ps":0}],"sn":"VirtueSky$Events$IEventNoParamResult$1$" + Bridge.getTypeAlias(TResult) + "$RemoveListener","rt":$n[0].Void,"p":[Function]}]}; }, $n);
    /*VirtueSky.Events.IEventNoParamResult$1 end.*/

    /*VirtueSky.Events.IEventListener start.*/
    $m("VirtueSky.Events.IEventListener", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"OnEventRaised","t":8,"pi":[{"n":"eventRaise","pt":$n[2].BaseEvent,"ps":0}],"sn":"VirtueSky$Events$IEventListener$OnEventRaised","rt":$n[0].Void,"p":[$n[2].BaseEvent]}]}; }, $n);
    /*VirtueSky.Events.IEventListener end.*/

    /*VirtueSky.Events.IEventListener$1 start.*/
    $m("VirtueSky.Events.IEventListener$1", function (TType) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"OnEventRaised","t":8,"pi":[{"n":"eventRaise","pt":$n[2].BaseEvent$1(TType),"ps":0},{"n":"value","pt":TType,"ps":1}],"sn":"VirtueSky$Events$IEventListener$1$" + Bridge.getTypeAlias(TType) + "$OnEventRaised","rt":$n[0].Void,"p":[$n[2].BaseEvent$1(TType),TType]}]}; }, $n);
    /*VirtueSky.Events.IEventListener$1 end.*/

    /*VirtueSky.Events.IEventListener$2 start.*/
    $m("VirtueSky.Events.IEventListener$2", function (TType, TResult) { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"OnEventRaised","t":8,"pi":[{"n":"eventRaise","pt":$n[2].BaseEvent$2(TType,TResult),"ps":0},{"n":"value","pt":TType,"ps":1}],"sn":"VirtueSky$Events$IEventListener$2$" + Bridge.getTypeAlias(TType) + "$" + Bridge.getTypeAlias(TResult) + "$OnEventRaised","rt":$n[0].Void,"p":[$n[2].BaseEvent$2(TType,TResult),TType]}]}; }, $n);
    /*VirtueSky.Events.IEventListener$2 end.*/

    /*VirtueSky.Events.IEventResponse start.*/
    $m("VirtueSky.Events.IEventResponse", function () { return {"att":1048737,"a":2}; }, $n);
    /*VirtueSky.Events.IEventResponse end.*/

    /*VirtueSky.Events.ObjectEventBoolResult start.*/
    $m("VirtueSky.Events.ObjectEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/Bool Result", fileName: "object_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventBoolResult end.*/

    /*VirtueSky.Events.ObjectEventFloatResult start.*/
    $m("VirtueSky.Events.ObjectEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/Float Result", fileName: "object_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventFloatResult end.*/

    /*VirtueSky.Events.ObjectEventGameObjectResult start.*/
    $m("VirtueSky.Events.ObjectEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/GameObject Result", fileName: "object_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventGameObjectResult end.*/

    /*VirtueSky.Events.ObjectEventIntResult start.*/
    $m("VirtueSky.Events.ObjectEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/Int Result", fileName: "object_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventIntResult end.*/

    /*VirtueSky.Events.ObjectEventObjectResult start.*/
    $m("VirtueSky.Events.ObjectEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/Object Result", fileName: "object_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventObjectResult end.*/

    /*VirtueSky.Events.ObjectEventStringResult start.*/
    $m("VirtueSky.Events.ObjectEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/String Result", fileName: "object_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventStringResult end.*/

    /*VirtueSky.Events.ObjectEventTransformResult start.*/
    $m("VirtueSky.Events.ObjectEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/Transform Result", fileName: "object_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventTransformResult end.*/

    /*VirtueSky.Events.ObjectEventVector3Result start.*/
    $m("VirtueSky.Events.ObjectEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Object Event/Vector3 Result", fileName: "object_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventVector3Result end.*/

    /*VirtueSky.Events.ObjectEvent start.*/
    $m("VirtueSky.Events.ObjectEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Object Event", fileName: "object_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEvent end.*/

    /*VirtueSky.Events.ObjectEventListener start.*/
    $m("VirtueSky.Events.ObjectEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventListener end.*/

    /*VirtueSky.Events.ObjectEventResponse start.*/
    $m("VirtueSky.Events.ObjectEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ObjectEventResponse end.*/

    /*VirtueSky.Events.ShortDoubleEvent start.*/
    $m("VirtueSky.Events.ShortDoubleEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/ShortDouble Event", fileName: "short_double_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ShortDoubleEvent end.*/

    /*VirtueSky.Events.ShortDoubleEventListener start.*/
    $m("VirtueSky.Events.ShortDoubleEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ShortDoubleEventListener end.*/

    /*VirtueSky.Events.ShortDoubleEventResponse start.*/
    $m("VirtueSky.Events.ShortDoubleEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.ShortDoubleEventResponse end.*/

    /*VirtueSky.Events.StringEventBoolResult start.*/
    $m("VirtueSky.Events.StringEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/Bool Result", fileName: "string_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventBoolResult end.*/

    /*VirtueSky.Events.StringEventFloatResult start.*/
    $m("VirtueSky.Events.StringEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/Float Result", fileName: "string_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventFloatResult end.*/

    /*VirtueSky.Events.StringEventGameObjectResult start.*/
    $m("VirtueSky.Events.StringEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/GameObject Result", fileName: "string_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventGameObjectResult end.*/

    /*VirtueSky.Events.StringEventIntResult start.*/
    $m("VirtueSky.Events.StringEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/Int Result", fileName: "string_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventIntResult end.*/

    /*VirtueSky.Events.StringEventObjectResult start.*/
    $m("VirtueSky.Events.StringEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/Object Result", fileName: "string_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventObjectResult end.*/

    /*VirtueSky.Events.StringEventStringResult start.*/
    $m("VirtueSky.Events.StringEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/String Result", fileName: "string_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventStringResult end.*/

    /*VirtueSky.Events.StringEventTransformResult start.*/
    $m("VirtueSky.Events.StringEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/Transform Result", fileName: "string_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventTransformResult end.*/

    /*VirtueSky.Events.StringEventVector3Result start.*/
    $m("VirtueSky.Events.StringEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/String Event/Vector3 Result", fileName: "string_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventVector3Result end.*/

    /*VirtueSky.Events.StringEvent start.*/
    $m("VirtueSky.Events.StringEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/String Event", fileName: "string_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEvent end.*/

    /*VirtueSky.Events.StringEventListener start.*/
    $m("VirtueSky.Events.StringEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventListener end.*/

    /*VirtueSky.Events.StringEventResponse start.*/
    $m("VirtueSky.Events.StringEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.StringEventResponse end.*/

    /*VirtueSky.Events.TransformEventBoolResult start.*/
    $m("VirtueSky.Events.TransformEventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/Bool Result", fileName: "transform_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventBoolResult end.*/

    /*VirtueSky.Events.TransformEventFloatResult start.*/
    $m("VirtueSky.Events.TransformEventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/Float Result", fileName: "transform_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventFloatResult end.*/

    /*VirtueSky.Events.TransformEventGameObjectResult start.*/
    $m("VirtueSky.Events.TransformEventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/GameObject Result", fileName: "transform_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventGameObjectResult end.*/

    /*VirtueSky.Events.TransformEventIntResult start.*/
    $m("VirtueSky.Events.TransformEventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/Int Result", fileName: "transform_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventIntResult end.*/

    /*VirtueSky.Events.TransformEventObjectResult start.*/
    $m("VirtueSky.Events.TransformEventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/Object Result", fileName: "transform_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventObjectResult end.*/

    /*VirtueSky.Events.TransformEventStringResult start.*/
    $m("VirtueSky.Events.TransformEventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/String Result", fileName: "transform_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventStringResult end.*/

    /*VirtueSky.Events.TransformEventTransformResult start.*/
    $m("VirtueSky.Events.TransformEventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/Transform Result", fileName: "transform_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventTransformResult end.*/

    /*VirtueSky.Events.TransformEventVector3Result start.*/
    $m("VirtueSky.Events.TransformEventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Transform Event/Vector3 Result", fileName: "transform_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventVector3Result end.*/

    /*VirtueSky.Events.TransformEvent start.*/
    $m("VirtueSky.Events.TransformEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Transform Event", fileName: "transform_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEvent end.*/

    /*VirtueSky.Events.TransformEventListener start.*/
    $m("VirtueSky.Events.TransformEventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventListener end.*/

    /*VirtueSky.Events.TransformEventResponse start.*/
    $m("VirtueSky.Events.TransformEventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.TransformEventResponse end.*/

    /*VirtueSky.Events.Vector3EventBoolResult start.*/
    $m("VirtueSky.Events.Vector3EventBoolResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/Bool Result", fileName: "vector3_event_bool_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventBoolResult end.*/

    /*VirtueSky.Events.Vector3EventFloatResult start.*/
    $m("VirtueSky.Events.Vector3EventFloatResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/Float Result", fileName: "vector3_event_float_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventFloatResult end.*/

    /*VirtueSky.Events.Vector3EventGameObjectResult start.*/
    $m("VirtueSky.Events.Vector3EventGameObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/GameObject Result", fileName: "vector3_event_gameobject_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventGameObjectResult end.*/

    /*VirtueSky.Events.Vector3EventIntResult start.*/
    $m("VirtueSky.Events.Vector3EventIntResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/Int Result", fileName: "vector3_event_int_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventIntResult end.*/

    /*VirtueSky.Events.Vector3EventObjectResult start.*/
    $m("VirtueSky.Events.Vector3EventObjectResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/Object Result", fileName: "vector3_event_object_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventObjectResult end.*/

    /*VirtueSky.Events.Vector3EventStringResult start.*/
    $m("VirtueSky.Events.Vector3EventStringResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/String Result", fileName: "vector3_event_string_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventStringResult end.*/

    /*VirtueSky.Events.Vector3EventTransformResult start.*/
    $m("VirtueSky.Events.Vector3EventTransformResult", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/Transform Result", fileName: "vector3_event_transform_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventTransformResult end.*/

    /*VirtueSky.Events.Vector3EventVector3Result start.*/
    $m("VirtueSky.Events.Vector3EventVector3Result", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event-Result/Vector3 Event/Vector3 Result", fileName: "vector3_event_vector3_result"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventVector3Result end.*/

    /*VirtueSky.Events.Vector3Event start.*/
    $m("VirtueSky.Events.Vector3Event", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Scriptable/Event/Vector3 Event", fileName: "vector3_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3Event end.*/

    /*VirtueSky.Events.Vector3EventListener start.*/
    $m("VirtueSky.Events.Vector3EventListener", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventListener end.*/

    /*VirtueSky.Events.Vector3EventResponse start.*/
    $m("VirtueSky.Events.Vector3EventResponse", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Events.Vector3EventResponse end.*/

    /*VirtueSky.DataType.ShortDouble start.*/
    $m("VirtueSky.DataType.ShortDouble", function () { return {"nested":[$n[25].ShortDouble.Unit0,$n[25].ShortDouble.Unit1,$n[25].ShortDouble.Unit2,$n[25].ShortDouble.Unit],"att":8457,"a":2,"at":[new System.SerializableAttribute()],"m":[{"n":".cctor","t":1,"sn":"ctor","sm":true},{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":".ctor","t":1,"p":[$n[0].Double],"pi":[{"n":"value","dv":0.0,"o":true,"pt":$n[0].Double,"ps":0}],"sn":"$ctor1"},{"a":2,"n":"AsBool","t":8,"pi":[{"n":"eps","dv":0.3,"o":true,"pt":$n[0].Single,"ps":0}],"sn":"AsBool","rt":$n[0].Boolean,"p":[$n[0].Single],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"AsFloat","t":8,"sn":"AsFloat","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"AsInt","t":8,"sn":"AsInt","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"AsLong","t":8,"sn":"AsLong","rt":$n[0].Int64},{"a":2,"n":"Clamp","is":true,"t":8,"pi":[{"n":"value","pt":$n[25].ShortDouble,"ps":0},{"n":"min","pt":$n[25].ShortDouble,"ps":1},{"n":"max","pt":$n[25].ShortDouble,"ps":2}],"sn":"Clamp","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"CompareTo","t":8,"pi":[{"n":"obj","pt":$n[0].Object,"ps":0}],"sn":"compareTo","rt":$n[0].Int32,"p":[$n[0].Object],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"CompareTo","t":8,"pi":[{"n":"other","pt":$n[25].ShortDouble,"ps":0}],"sn":"compareTo$1","rt":$n[0].Int32,"p":[$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"ov":true,"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[0].Object,"ps":0}],"sn":"equals","rt":$n[0].Boolean,"p":[$n[0].Object],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Equals","t":8,"pi":[{"n":"other","pt":$n[25].ShortDouble,"ps":0}],"sn":"equalsT","rt":$n[0].Boolean,"p":[$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"FindUnit","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Double,"ps":0}],"sn":"FindUnit","rt":$n[25].ShortDouble.Unit,"p":[$n[0].Double]},{"ov":true,"a":2,"n":"GetHashCode","t":8,"sn":"getHashCode","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"Max","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"Max","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"Min","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"Min","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"Pow","t":8,"pi":[{"n":"p","pt":$n[0].Double,"ps":0}],"sn":"Pow","rt":$n[25].ShortDouble,"p":[$n[0].Double]},{"a":2,"n":"SetUnit","is":true,"t":8,"pi":[{"n":"u","pt":$n[0].Int32,"ps":0}],"sn":"SetUnit","rt":$n[0].Void,"p":[$n[0].Int32]},{"ov":true,"a":2,"n":"ToString","t":8,"sn":"toString","rt":$n[0].String},{"a":2,"n":"ToString","t":8,"pi":[{"n":"provider","pt":$n[0].IFormatProvider,"ps":0}],"sn":"ToString","rt":$n[0].String,"p":[$n[0].IFormatProvider]},{"a":2,"n":"ToString","t":8,"pi":[{"n":"format","pt":$n[0].String,"ps":0}],"sn":"ToString$1","rt":$n[0].String,"p":[$n[0].String]},{"a":2,"n":"ToString","t":8,"pi":[{"n":"format","pt":$n[0].String,"ps":0},{"n":"provider","pt":$n[0].IFormatProvider,"ps":1}],"sn":"format","rt":$n[0].String,"p":[$n[0].String,$n[0].IFormatProvider]},{"a":1,"n":"ToString","t":8,"pi":[{"n":"unit","pt":$n[25].ShortDouble.Unit,"ps":0},{"n":"format","dv":"0.##","o":true,"pt":$n[0].String,"ps":1}],"sn":"ToString$2","rt":$n[0].String,"p":[$n[25].ShortDouble.Unit,$n[0].String]},{"a":1,"n":"ToString","t":8,"pi":[{"n":"unit","pt":$n[25].ShortDouble.Unit,"ps":0},{"n":"format","pt":$n[0].String,"ps":1},{"n":"provider","pt":$n[0].IFormatProvider,"ps":2}],"sn":"ToString$3","rt":$n[0].String,"p":[$n[25].ShortDouble.Unit,$n[0].String,$n[0].IFormatProvider]},{"a":2,"n":"op_Addition","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_Addition","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"op_Division","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_Division","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"op_GreaterThan","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_GreaterThan","rt":$n[0].Boolean,"p":[$n[25].ShortDouble,$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"op_GreaterThanOrEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_GreaterThanOrEqual","rt":$n[0].Boolean,"p":[$n[25].ShortDouble,$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Double,"ps":0}],"sn":"op_Implicit$1","rt":$n[25].ShortDouble,"p":[$n[0].Double]},{"a":2,"n":"op_Implicit","is":true,"t":8,"pi":[{"n":"value","pt":$n[25].ShortDouble,"ps":0}],"sn":"op_Implicit","rt":$n[0].Double,"p":[$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}},{"a":2,"n":"op_LessThan","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_LessThan","rt":$n[0].Boolean,"p":[$n[25].ShortDouble,$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"op_LessThanOrEqual","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_LessThanOrEqual","rt":$n[0].Boolean,"p":[$n[25].ShortDouble,$n[25].ShortDouble],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"op_Multiply","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_Multiply","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"op_Subtraction","is":true,"t":8,"pi":[{"n":"a","pt":$n[25].ShortDouble,"ps":0},{"n":"b","pt":$n[25].ShortDouble,"ps":1}],"sn":"op_Subtraction","rt":$n[25].ShortDouble,"p":[$n[25].ShortDouble,$n[25].ShortDouble]},{"a":2,"n":"Ceiling","t":16,"rt":$n[25].ShortDouble,"g":{"a":2,"n":"get_Ceiling","t":8,"rt":$n[25].ShortDouble,"fg":"Ceiling"},"fn":"Ceiling"},{"a":2,"n":"Floor","t":16,"rt":$n[25].ShortDouble,"g":{"a":2,"n":"get_Floor","t":8,"rt":$n[25].ShortDouble,"fg":"Floor"},"fn":"Floor"},{"a":2,"n":"Round","t":16,"rt":$n[25].ShortDouble,"g":{"a":2,"n":"get_Round","t":8,"rt":$n[25].ShortDouble,"fg":"Round"},"fn":"Round"},{"a":2,"n":"True","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_True","t":8,"rt":$n[0].Boolean,"fg":"True","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"True"},{"a":2,"n":"Value","t":16,"rt":$n[0].Double,"g":{"a":2,"n":"get_Value","t":8,"rt":$n[0].Double,"fg":"Value","box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}},"fn":"Value"},{"a":1,"n":"_unitFinder","is":true,"t":4,"rt":Function,"sn":"_unitFinder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"value","t":4,"rt":$n[0].Double,"sn":"value","box":function ($v) { return Bridge.box($v, System.Double, System.Double.format, System.Double.getHashCode);}}]}; }, $n);
    /*VirtueSky.DataType.ShortDouble end.*/

    /*VirtueSky.DataType.ShortDouble+Unit0 start.*/
    $m("VirtueSky.DataType.ShortDouble.Unit0", function () { return {"td":$n[25].ShortDouble,"att":386,"a":2,"s":true,"m":[{"n":".cctor","t":1,"sn":"ctor","sm":true},{"a":2,"n":"Find","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Double,"ps":0}],"sn":"Find","rt":$n[25].ShortDouble.Unit,"p":[$n[0].Double]},{"a":1,"n":"Infinity","is":true,"t":4,"rt":$n[25].ShortDouble.Unit,"sn":"Infinity","ro":true},{"a":1,"n":"Units","is":true,"t":4,"rt":System.Array.type(VirtueSky.DataType.ShortDouble.Unit),"sn":"Units","ro":true},{"a":1,"n":"Zero","is":true,"t":4,"rt":$n[25].ShortDouble.Unit,"sn":"Zero","ro":true}]}; }, $n);
    /*VirtueSky.DataType.ShortDouble+Unit0 end.*/

    /*VirtueSky.DataType.ShortDouble+Unit1 start.*/
    $m("VirtueSky.DataType.ShortDouble.Unit1", function () { return {"td":$n[25].ShortDouble,"att":386,"a":2,"s":true,"m":[{"n":".cctor","t":1,"sn":"ctor","sm":true},{"a":2,"n":"Find","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Double,"ps":0}],"sn":"Find","rt":$n[25].ShortDouble.Unit,"p":[$n[0].Double]},{"a":1,"n":"Infinity","is":true,"t":4,"rt":$n[25].ShortDouble.Unit,"sn":"Infinity","ro":true},{"a":1,"n":"Units","is":true,"t":4,"rt":System.Array.type(VirtueSky.DataType.ShortDouble.Unit),"sn":"Units","ro":true},{"a":1,"n":"Zero","is":true,"t":4,"rt":$n[25].ShortDouble.Unit,"sn":"Zero","ro":true}]}; }, $n);
    /*VirtueSky.DataType.ShortDouble+Unit1 end.*/

    /*VirtueSky.DataType.ShortDouble+Unit2 start.*/
    $m("VirtueSky.DataType.ShortDouble.Unit2", function () { return {"td":$n[25].ShortDouble,"att":386,"a":2,"s":true,"m":[{"n":".cctor","t":1,"sn":"ctor","sm":true},{"a":2,"n":"Find","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Double,"ps":0}],"sn":"Find","rt":$n[25].ShortDouble.Unit,"p":[$n[0].Double]},{"a":1,"n":"Infinity","is":true,"t":4,"rt":$n[25].ShortDouble.Unit,"sn":"Infinity","ro":true},{"a":1,"n":"Signs","is":true,"t":4,"rt":$n[0].Array.type(System.String),"sn":"Signs","ro":true},{"a":1,"n":"Units","is":true,"t":4,"rt":System.Array.type(VirtueSky.DataType.ShortDouble.Unit),"sn":"Units","ro":true},{"a":1,"n":"Zero","is":true,"t":4,"rt":$n[25].ShortDouble.Unit,"sn":"Zero","ro":true}]}; }, $n);
    /*VirtueSky.DataType.ShortDouble+Unit2 end.*/

    /*VirtueSky.DataType.ShortDouble+Unit start.*/
    $m("VirtueSky.DataType.ShortDouble.Unit", function () { return {"td":$n[25].ShortDouble,"att":1048842,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"exponent","t":4,"rt":$n[0].Int32,"sn":"exponent","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"name","t":4,"rt":$n[0].String,"sn":"name"}]}; }, $n);
    /*VirtueSky.DataType.ShortDouble+Unit end.*/

    /*VirtueSky.DataStorage.GameData start.*/
    $m("VirtueSky.DataStorage.GameData", function () { return {"att":1048961,"a":2,"s":true,"m":[{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Backup","is":true,"t":8,"sn":"Backup","rt":$n[0].Array.type(System.Byte)},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"ChangeProfile","is":true,"t":8,"pi":[{"n":"profile","pt":$n[0].Int32,"ps":0}],"sn":"ChangeProfile","rt":$n[0].Void,"p":[$n[0].Int32]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"DeleteAll","is":true,"t":8,"sn":"DeleteAll","rt":$n[0].Void},{"a":2,"n":"DeleteFileData","is":true,"t":8,"sn":"DeleteFileData","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"DeleteKey","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0}],"sn":"DeleteKey","rt":$n[0].Void,"p":[$n[0].String]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":1,"n":"Deserialize","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0}],"tpc":1,"tprm":["T"],"sn":"Deserialize","rt":System.Object,"p":[$n[0].Array.type(System.Byte)]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Get","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"default","dv":null,"o":true,"pt":System.Object,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Get","rt":System.Object,"p":[$n[0].String,System.Object]},{"a":1,"n":"GetDataPath","is":true,"t":8,"pi":[{"n":"name","pt":$n[0].String,"ps":0}],"sn":"GetDataPath","rt":$n[0].String,"p":[$n[0].String]},{"a":2,"n":"GetPersistentDataPath","is":true,"t":8,"sn":"GetPersistentDataPath","rt":$n[0].String},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"HasKey","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0}],"sn":"HasKey","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Init","is":true,"t":8,"sn":"Init","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Load","is":true,"t":8,"sn":"Load","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"LoadAsync","is":true,"t":8,"sn":"LoadAsync","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":1,"n":"RequireNullCheck","is":true,"t":8,"sn":"RequireNullCheck","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Restore","is":true,"t":8,"pi":[{"n":"bytes","pt":$n[0].Array.type(System.Byte),"ps":0}],"sn":"Restore","rt":$n[0].Void,"p":[$n[0].Array.type(System.Byte)]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Save","is":true,"t":8,"sn":"Save","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"SaveAsync","is":true,"t":8,"sn":"SaveAsync","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":1,"n":"Serialize","is":true,"t":8,"pi":[{"n":"data","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Serialize","rt":$n[0].Array.type(System.Byte),"p":[System.Object]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"Set","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"data","pt":System.Object,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Set","rt":$n[0].Void,"p":[$n[0].String,System.Object]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"TryGet","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"data","out":true,"pt":System.Object,"ps":1}],"tpc":1,"tprm":["T"],"sn":"TryGet","rt":$n[0].Boolean,"p":[$n[0].String,System.Object],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"VerifyProfile","is":true,"t":8,"pi":[{"n":"profile","pt":$n[0].Int32,"ps":0}],"sn":"VerifyProfile","rt":$n[0].Boolean,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"GetPath","is":true,"t":16,"rt":$n[0].String,"g":{"a":1,"n":"get_GetPath","t":8,"rt":$n[0].String,"fg":"GetPath","is":true},"fn":"GetPath"},{"a":2,"n":"IsAutoSave","is":true,"t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsAutoSave","t":8,"rt":$n[0].Boolean,"fg":"IsAutoSave","is":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsAutoSave","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsAutoSave","is":true},"fn":"IsAutoSave"},{"a":2,"n":"IsInitialized","is":true,"t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsInitialized","t":8,"rt":$n[0].Boolean,"fg":"IsInitialized","is":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsInitialized"},{"a":1,"n":"INIT_SIZE","is":true,"t":4,"rt":$n[0].Int32,"sn":"INIT_SIZE","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"__Property__Initializer__IsAutoSave","is":true,"t":4,"rt":$n[0].Boolean,"sn":"__Property__Initializer__IsAutoSave","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"datas","is":true,"t":4,"rt":$n[3].Dictionary$2(System.String,System.Array.type(System.Byte)),"sn":"datas"},{"a":1,"n":"isInitialized","is":true,"t":4,"rt":$n[0].Boolean,"sn":"isInitialized","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"profile","is":true,"t":4,"rt":$n[0].Int32,"sn":"profile","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"OnSaveEvent","is":true,"t":2,"ad":{"a":2,"n":"add_OnSaveEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnSaveEvent","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnSaveEvent","is":true,"t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnSaveEvent","rt":$n[0].Void,"p":[Function]}},{"a":1,"backing":true,"n":"<IsAutoSave>k__BackingField","is":true,"t":4,"rt":$n[0].Boolean,"sn":"IsAutoSave","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*VirtueSky.DataStorage.GameData end.*/

    /*VirtueSky.DataStorage.SerializeAdapter start.*/
    $m("VirtueSky.DataStorage.SerializeAdapter", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"FromBinary","is":true,"t":8,"pi":[{"n":"serializedBytes","pt":$n[0].Array.type(System.Byte),"ps":0}],"tpc":1,"tprm":["T"],"sn":"FromBinary","rt":System.Object,"p":[$n[0].Array.type(System.Byte)]},{"a":2,"n":"ToBinary","is":true,"t":8,"pi":[{"n":"obj","pt":System.Object,"ps":0}],"tpc":1,"tprm":["T"],"sn":"ToBinary","rt":$n[0].Array.type(System.Byte),"p":[System.Object]}]}; }, $n);
    /*VirtueSky.DataStorage.SerializeAdapter end.*/

    /*VirtueSky.Core.App start.*/
    $m("VirtueSky.Core.App", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"AddFocusCallback","is":true,"t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"AddFocusCallback","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"AddPauseCallback","is":true,"t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"AddPauseCallback","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"AddQuitCallback","is":true,"t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"AddQuitCallback","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"CancelAllDelay","is":true,"t":8,"sn":"CancelAllDelay","rt":$n[0].Void},{"a":2,"n":"CancelDelay","is":true,"t":8,"pi":[{"n":"delayHandle","pt":$n[24].DelayHandle,"ps":0}],"sn":"CancelDelay","rt":$n[0].Void,"p":[$n[24].DelayHandle]},{"a":2,"n":"Delay","is":true,"t":8,"pi":[{"n":"duration","pt":$n[0].Single,"ps":0},{"n":"onComplete","pt":Function,"ps":1},{"n":"onUpdate","dv":null,"o":true,"pt":Function,"ps":2},{"n":"isLooped","dv":false,"o":true,"pt":$n[0].Boolean,"ps":3},{"n":"useRealTime","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4}],"sn":"Delay","rt":$n[24].DelayHandle,"p":[$n[0].Single,Function,Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"Delay","is":true,"t":8,"pi":[{"n":"target","pt":$n[1].MonoBehaviour,"ps":0},{"n":"duration","pt":$n[0].Single,"ps":1},{"n":"onComplete","pt":Function,"ps":2},{"n":"onUpdate","dv":null,"o":true,"pt":Function,"ps":3},{"n":"isLooped","dv":false,"o":true,"pt":$n[0].Boolean,"ps":4},{"n":"useRealTime","dv":false,"o":true,"pt":$n[0].Boolean,"ps":5}],"sn":"Delay$1","rt":$n[24].DelayHandle,"p":[$n[1].MonoBehaviour,$n[0].Single,Function,Function,$n[0].Boolean,$n[0].Boolean]},{"a":2,"n":"InitMonoGlobalComponent","is":true,"t":8,"pi":[{"n":"monoGlobal","pt":$n[24].MonoGlobal,"ps":0}],"sn":"InitMonoGlobalComponent","rt":$n[0].Void,"p":[$n[24].MonoGlobal]},{"a":2,"n":"PauseAllDelay","is":true,"t":8,"sn":"PauseAllDelay","rt":$n[0].Void},{"a":2,"n":"PauseDelay","is":true,"t":8,"pi":[{"n":"delayHandle","pt":$n[24].DelayHandle,"ps":0}],"sn":"PauseDelay","rt":$n[0].Void,"p":[$n[24].DelayHandle]},{"a":2,"n":"RemoveFocusCallback","is":true,"t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"RemoveFocusCallback","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"RemovePauseCallback","is":true,"t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"RemovePauseCallback","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"RemoveQuitCallback","is":true,"t":8,"pi":[{"n":"callback","pt":Function,"ps":0}],"sn":"RemoveQuitCallback","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"ResumeAllDelay","is":true,"t":8,"sn":"ResumeAllDelay","rt":$n[0].Void},{"a":2,"n":"ResumeDelay","is":true,"t":8,"pi":[{"n":"delayHandle","pt":$n[24].DelayHandle,"ps":0}],"sn":"ResumeDelay","rt":$n[0].Void,"p":[$n[24].DelayHandle]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"RunOnMainThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RunOnMainThread","rt":$n[0].Void,"p":[Function]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StartCoroutine","is":true,"t":8,"pi":[{"n":"routine","pt":$n[9].IEnumerator,"ps":0}],"sn":"StartCoroutine","rt":$n[1].Coroutine,"p":[$n[9].IEnumerator]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StartCoroutine","is":true,"t":8,"pi":[{"n":"methodName","pt":$n[0].String,"ps":0}],"sn":"StartCoroutine$1","rt":$n[1].Coroutine,"p":[$n[0].String]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StartCoroutine","is":true,"t":8,"pi":[{"n":"methodName","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Object,"ps":1}],"sn":"StartCoroutine$2","rt":$n[1].Coroutine,"p":[$n[0].String,$n[0].Object]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StopAllCoroutine","is":true,"t":8,"sn":"StopAllCoroutine","rt":$n[0].Void},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StopCoroutine","is":true,"t":8,"pi":[{"n":"routine","pt":$n[9].IEnumerator,"ps":0}],"sn":"StopCoroutine","rt":$n[0].Void,"p":[$n[9].IEnumerator]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StopCoroutine","is":true,"t":8,"pi":[{"n":"methodName","pt":$n[0].String,"ps":0}],"sn":"StopCoroutine$1","rt":$n[0].Void,"p":[$n[0].String]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"StopCoroutine","is":true,"t":8,"pi":[{"n":"routine","pt":$n[1].Coroutine,"ps":0}],"sn":"StopCoroutine$2","rt":$n[0].Void,"p":[$n[1].Coroutine]},{"a":2,"n":"SubFixedTick","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"SubFixedTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"SubFixedTick","is":true,"t":8,"pi":[{"n":"fixedTick","pt":$n[24].IEntity,"ps":0}],"sn":"SubFixedTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":2,"n":"SubLateTick","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"SubLateTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"SubLateTick","is":true,"t":8,"pi":[{"n":"lateTick","pt":$n[24].IEntity,"ps":0}],"sn":"SubLateTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":2,"n":"SubTick","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"SubTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"SubTick","is":true,"t":8,"pi":[{"n":"tick","pt":$n[24].IEntity,"ps":0}],"sn":"SubTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"ToMainThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ToMainThread","rt":Function,"p":[Function]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"ToMainThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"tpc":1,"tprm":["T"],"sn":"ToMainThread$1","rt":Function,"p":[Function]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"ToMainThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"tpc":2,"tprm":["T1","T2"],"sn":"ToMainThread$2","rt":Function,"p":[Function]},{"at":[new System.Runtime.CompilerServices.MethodImplAttribute.$ctor2(256)],"a":2,"n":"ToMainThread","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"tpc":3,"tprm":["T1","T2","T3"],"sn":"ToMainThread$3","rt":Function,"p":[Function]},{"a":2,"n":"UnSubFixedTick","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"UnSubFixedTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"UnSubFixedTick","is":true,"t":8,"pi":[{"n":"fixedTick","pt":$n[24].IEntity,"ps":0}],"sn":"UnSubFixedTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":2,"n":"UnSubLateTick","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"UnSubLateTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"UnSubLateTick","is":true,"t":8,"pi":[{"n":"lateTick","pt":$n[24].IEntity,"ps":0}],"sn":"UnSubLateTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":2,"n":"UnSubTick","is":true,"t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"UnSubTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"UnSubTick","is":true,"t":8,"pi":[{"n":"tick","pt":$n[24].IEntity,"ps":0}],"sn":"UnSubTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":1,"n":"_monoGlobal","is":true,"t":4,"rt":$n[24].MonoGlobal,"sn":"_monoGlobal"}]}; }, $n);
    /*VirtueSky.Core.App end.*/

    /*VirtueSky.Core.BaseMono start.*/
    $m("VirtueSky.Core.BaseMono", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"CleanUp","t":8,"sn":"CleanUp","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedTick","t":8,"sn":"FixedTick","rt":$n[0].Void},{"v":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"v":true,"a":2,"n":"LateTick","t":8,"sn":"LateTick","rt":$n[0].Void},{"v":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"v":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"SubTick","t":8,"sn":"SubTick","rt":$n[0].Void},{"v":true,"a":2,"n":"Tick","t":8,"sn":"Tick","rt":$n[0].Void},{"a":1,"n":"UnSubTick","t":8,"sn":"UnSubTick","rt":$n[0].Void}]}; }, $n);
    /*VirtueSky.Core.BaseMono end.*/

    /*VirtueSky.Core.BaseSO start.*/
    $m("VirtueSky.Core.BaseSO", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"CleanUp","t":8,"sn":"CleanUp","rt":$n[0].Void},{"v":true,"a":2,"n":"Destroy","t":8,"sn":"Destroy","rt":$n[0].Void},{"a":2,"n":"Disable","t":8,"sn":"Disable","rt":$n[0].Void},{"a":2,"n":"Enable","t":8,"sn":"Enable","rt":$n[0].Void},{"v":true,"a":2,"n":"FixedTick","t":8,"sn":"FixedTick","rt":$n[0].Void},{"v":true,"a":2,"n":"Initialize","t":8,"sn":"Initialize","rt":$n[0].Void},{"v":true,"a":2,"n":"LateTick","t":8,"sn":"LateTick","rt":$n[0].Void},{"a":1,"n":"SubTick","t":8,"sn":"SubTick","rt":$n[0].Void},{"v":true,"a":2,"n":"Tick","t":8,"sn":"Tick","rt":$n[0].Void},{"a":1,"n":"UnSubTick","t":8,"sn":"UnSubTick","rt":$n[0].Void},{"at":[new UnityEngine.SpaceAttribute.$ctor1(10.0),new UnityEngine.SerializeFieldAttribute(),new UnityEngine.TextAreaAttribute.$ctor1(2, 5)],"a":1,"n":"description","t":4,"rt":$n[0].String,"sn":"description"}]}; }, $n);
    /*VirtueSky.Core.BaseSO end.*/

    /*VirtueSky.Core.CacheComponent$1 start.*/
    $m("VirtueSky.Core.CacheComponent$1", function (T) { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"GetCacheComponent","t":8,"sn":"GetCacheComponent","rt":$n[0].Void},{"a":2,"n":"CacheTransform","t":16,"rt":$n[1].Transform,"g":{"a":2,"n":"get_CacheTransform","t":8,"rt":$n[1].Transform,"fg":"CacheTransform"},"s":{"a":1,"n":"set_CacheTransform","t":8,"p":[$n[1].Transform],"rt":$n[0].Void,"fs":"CacheTransform"},"fn":"CacheTransform"},{"a":2,"n":"component","t":4,"rt":T,"sn":"component"},{"a":1,"backing":true,"n":"<CacheTransform>k__BackingField","t":4,"rt":$n[1].Transform,"sn":"CacheTransform"}]}; }, $n);
    /*VirtueSky.Core.CacheComponent$1 end.*/

    /*VirtueSky.Core.DelayHandle start.*/
    $m("VirtueSky.Core.DelayHandle", function () { return {"att":1048577,"a":2,"m":[{"a":4,"n":".ctor","t":1,"p":[$n[0].Single,Function,Function,$n[0].Boolean,$n[0].Boolean,$n[1].MonoBehaviour],"pi":[{"n":"duration","pt":$n[0].Single,"ps":0},{"n":"onComplete","pt":Function,"ps":1},{"n":"onUpdate","pt":Function,"ps":2},{"n":"isLooped","pt":$n[0].Boolean,"ps":3},{"n":"usesRealTime","pt":$n[0].Boolean,"ps":4},{"n":"autoDestroyOwner","pt":$n[1].MonoBehaviour,"ps":5}],"sn":"ctor"},{"a":2,"n":"Cancel","t":8,"sn":"Cancel","rt":$n[0].Void},{"a":1,"n":"GetFireTime","t":8,"sn":"GetFireTime","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetRatioComplete","t":8,"sn":"GetRatioComplete","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetRatioRemaining","t":8,"sn":"GetRatioRemaining","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetTimeDelta","t":8,"sn":"GetTimeDelta","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetTimeElapsed","t":8,"sn":"GetTimeElapsed","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"GetTimeRemaining","t":8,"sn":"GetTimeRemaining","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"GetWorldTime","t":8,"sn":"GetWorldTime","rt":$n[0].Single,"box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"Pause","t":8,"sn":"Pause","rt":$n[0].Void},{"a":2,"n":"Resume","t":8,"sn":"Resume","rt":$n[0].Void},{"a":4,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":2,"n":"Duration","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Duration","t":8,"rt":$n[0].Single,"fg":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":1,"n":"set_Duration","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Duration"},"fn":"Duration"},{"a":2,"n":"IsCancelled","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsCancelled","t":8,"rt":$n[0].Boolean,"fg":"IsCancelled","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsCancelled"},{"a":2,"n":"IsCompleted","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsCompleted","t":8,"rt":$n[0].Boolean,"fg":"IsCompleted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_IsCompleted","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsCompleted"},"fn":"IsCompleted"},{"a":2,"n":"IsDone","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsDone","t":8,"rt":$n[0].Boolean,"fg":"IsDone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsDone"},{"a":2,"n":"IsLooped","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLooped","t":8,"rt":$n[0].Boolean,"fg":"IsLooped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsLooped","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsLooped"},"fn":"IsLooped"},{"a":1,"n":"IsOwnerDestroyed","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_IsOwnerDestroyed","t":8,"rt":$n[0].Boolean,"fg":"IsOwnerDestroyed","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsOwnerDestroyed"},{"a":2,"n":"IsPaused","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsPaused","t":8,"rt":$n[0].Boolean,"fg":"IsPaused","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsPaused"},{"a":2,"n":"UsesRealTime","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_UsesRealTime","t":8,"rt":$n[0].Boolean,"fg":"UsesRealTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":1,"n":"set_UsesRealTime","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"UsesRealTime"},"fn":"UsesRealTime"},{"a":1,"n":"_autoDestroyOwner","t":4,"rt":$n[1].MonoBehaviour,"sn":"_autoDestroyOwner","ro":true},{"a":1,"n":"_hasAutoDestroyOwner","t":4,"rt":$n[0].Boolean,"sn":"_hasAutoDestroyOwner","ro":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_lastUpdateTime","t":4,"rt":$n[0].Single,"sn":"_lastUpdateTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_onComplete","t":4,"rt":Function,"sn":"_onComplete","ro":true},{"a":1,"n":"_onUpdate","t":4,"rt":Function,"sn":"_onUpdate","ro":true},{"a":1,"n":"_startTime","t":4,"rt":$n[0].Single,"sn":"_startTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"_timeElapsedBeforeCancel","t":4,"rt":$n[0].Nullable$1(System.Single),"sn":"_timeElapsedBeforeCancel","box":function ($v) { return Bridge.box($v, System.Single, System.Nullable.toStringFn(System.Single.format), System.Nullable.getHashCodeFn(System.Single.getHashCode));}},{"a":1,"n":"_timeElapsedBeforePause","t":4,"rt":$n[0].Nullable$1(System.Single),"sn":"_timeElapsedBeforePause","box":function ($v) { return Bridge.box($v, System.Single, System.Nullable.toStringFn(System.Single.format), System.Nullable.getHashCodeFn(System.Single.getHashCode));}},{"a":1,"backing":true,"n":"<Duration>k__BackingField","t":4,"rt":$n[0].Single,"sn":"Duration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"backing":true,"n":"<IsCompleted>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsCompleted","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<IsLooped>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"IsLooped","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"backing":true,"n":"<UsesRealTime>k__BackingField","t":4,"rt":$n[0].Boolean,"sn":"UsesRealTime","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*VirtueSky.Core.DelayHandle end.*/

    /*VirtueSky.Core.IEntity start.*/
    $m("VirtueSky.Core.IEntity", function () { return {"att":1048737,"a":2,"m":[{"ab":true,"a":2,"n":"CleanUp","t":8,"sn":"VirtueSky$Core$IEntity$CleanUp","rt":$n[0].Void},{"ab":true,"a":2,"n":"FixedTick","t":8,"sn":"VirtueSky$Core$IEntity$FixedTick","rt":$n[0].Void},{"ab":true,"a":2,"n":"Initialize","t":8,"sn":"VirtueSky$Core$IEntity$Initialize","rt":$n[0].Void},{"ab":true,"a":2,"n":"LateTick","t":8,"sn":"VirtueSky$Core$IEntity$LateTick","rt":$n[0].Void},{"ab":true,"a":2,"n":"Tick","t":8,"sn":"VirtueSky$Core$IEntity$Tick","rt":$n[0].Void}]}; }, $n);
    /*VirtueSky.Core.IEntity end.*/

    /*VirtueSky.Core.MonoGlobal start.*/
    $m("VirtueSky.Core.MonoGlobal", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":4,"n":"AddFixedTick","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"AddFixedTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"AddFixedTick","t":8,"pi":[{"n":"fixedTick","pt":$n[24].IEntity,"ps":0}],"sn":"AddFixedTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":4,"n":"AddLateTick","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"AddLateTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"AddLateTick","t":8,"pi":[{"n":"lateTick","pt":$n[24].IEntity,"ps":0}],"sn":"AddLateTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":4,"n":"AddTick","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"AddTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"AddTick","t":8,"pi":[{"n":"tick","pt":$n[24].IEntity,"ps":0}],"sn":"AddTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":4,"n":"CancelAllDelayHandle","t":8,"sn":"CancelAllDelayHandle","rt":$n[0].Void},{"a":1,"n":"FixedUpdate","t":8,"sn":"FixedUpdate","rt":$n[0].Void},{"a":1,"n":"LateUpdate","t":8,"sn":"LateUpdate","rt":$n[0].Void},{"a":1,"n":"OnApplicationFocus","t":8,"pi":[{"n":"hasFocus","pt":$n[0].Boolean,"ps":0}],"sn":"OnApplicationFocus","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnApplicationPause","t":8,"pi":[{"n":"pauseStatus","pt":$n[0].Boolean,"ps":0}],"sn":"OnApplicationPause","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnApplicationQuit","t":8,"sn":"OnApplicationQuit","rt":$n[0].Void},{"a":4,"n":"PauseAllDelayHandle","t":8,"sn":"PauseAllDelayHandle","rt":$n[0].Void},{"a":4,"n":"RegisterDelayHandle","t":8,"pi":[{"n":"delayHandle","pt":$n[24].DelayHandle,"ps":0}],"sn":"RegisterDelayHandle","rt":$n[0].Void,"p":[$n[24].DelayHandle]},{"a":4,"n":"RemoveFixedTick","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RemoveFixedTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"RemoveFixedTick","t":8,"pi":[{"n":"fixedTick","pt":$n[24].IEntity,"ps":0}],"sn":"RemoveFixedTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":4,"n":"RemoveLateTick","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RemoveLateTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"RemoveLateTick","t":8,"pi":[{"n":"lateTick","pt":$n[24].IEntity,"ps":0}],"sn":"RemoveLateTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":4,"n":"RemoveTick","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RemoveTick","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"RemoveTick","t":8,"pi":[{"n":"tick","pt":$n[24].IEntity,"ps":0}],"sn":"RemoveTick$1","rt":$n[0].Void,"p":[$n[24].IEntity]},{"a":4,"n":"ResumeAllDelayHandle","t":8,"sn":"ResumeAllDelayHandle","rt":$n[0].Void},{"a":4,"n":"RunOnMainThreadImpl","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"RunOnMainThreadImpl","rt":$n[0].Void,"p":[Function]},{"a":4,"n":"StartCoroutineImpl","t":8,"pi":[{"n":"routine","pt":$n[9].IEnumerator,"ps":0}],"sn":"StartCoroutineImpl","rt":$n[1].Coroutine,"p":[$n[9].IEnumerator]},{"a":4,"n":"StartCoroutineImpl","t":8,"pi":[{"n":"methodName","pt":$n[0].String,"ps":0}],"sn":"StartCoroutineImpl$1","rt":$n[1].Coroutine,"p":[$n[0].String]},{"a":4,"n":"StartCoroutineImpl","t":8,"pi":[{"n":"methodName","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Object,"ps":1}],"sn":"StartCoroutineImpl$2","rt":$n[1].Coroutine,"p":[$n[0].String,$n[0].Object]},{"a":4,"n":"StopAllCoroutinesImpl","t":8,"sn":"StopAllCoroutinesImpl","rt":$n[0].Void},{"a":4,"n":"StopCoroutineImpl","t":8,"pi":[{"n":"routine","pt":$n[9].IEnumerator,"ps":0}],"sn":"StopCoroutineImpl","rt":$n[0].Void,"p":[$n[9].IEnumerator]},{"a":4,"n":"StopCoroutineImpl","t":8,"pi":[{"n":"methodName","pt":$n[0].String,"ps":0}],"sn":"StopCoroutineImpl$1","rt":$n[0].Void,"p":[$n[0].String]},{"a":4,"n":"StopCoroutineImpl","t":8,"pi":[{"n":"routine","pt":$n[1].Coroutine,"ps":0}],"sn":"StopCoroutineImpl$2","rt":$n[0].Void,"p":[$n[1].Coroutine]},{"a":4,"n":"ToMainThreadImpl","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"sn":"ToMainThreadImpl","rt":Function,"p":[Function]},{"a":4,"n":"ToMainThreadImpl","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"tpc":1,"tprm":["T"],"sn":"ToMainThreadImpl$1","rt":Function,"p":[Function]},{"a":4,"n":"ToMainThreadImpl","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"tpc":2,"tprm":["T1","T2"],"sn":"ToMainThreadImpl$2","rt":Function,"p":[Function]},{"a":4,"n":"ToMainThreadImpl","t":8,"pi":[{"n":"action","pt":Function,"ps":0}],"tpc":3,"tprm":["T1","T2","T3"],"sn":"ToMainThreadImpl$3","rt":Function,"p":[Function]},{"a":1,"n":"Update","t":8,"sn":"Update","rt":$n[0].Void},{"a":1,"n":"UpdateAllDelayHandle","t":8,"sn":"UpdateAllDelayHandle","rt":$n[0].Void},{"a":1,"n":"_isToMainThreadQueueEmpty","t":4,"rt":$n[0].Boolean,"sn":"_isToMainThreadQueueEmpty","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_localToMainThreads","t":4,"rt":$n[3].List$1(Function),"sn":"_localToMainThreads"},{"a":1,"n":"_timers","t":4,"rt":$n[3].List$1(VirtueSky.Core.DelayHandle),"sn":"_timers"},{"a":1,"n":"_timersToAdd","t":4,"rt":$n[3].List$1(VirtueSky.Core.DelayHandle),"sn":"_timersToAdd"},{"a":1,"n":"_toMainThreads","t":4,"rt":$n[3].List$1(Function),"sn":"_toMainThreads","ro":true},{"a":4,"n":"OnFixedTick","t":2,"ad":{"a":4,"n":"add_OnFixedTick","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnFixedTick","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_OnFixedTick","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnFixedTick","rt":$n[0].Void,"p":[Function]}},{"a":4,"n":"OnGameFocus","t":2,"ad":{"a":4,"n":"add_OnGameFocus","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnGameFocus","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_OnGameFocus","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnGameFocus","rt":$n[0].Void,"p":[Function]}},{"a":4,"n":"OnGamePause","t":2,"ad":{"a":4,"n":"add_OnGamePause","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnGamePause","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_OnGamePause","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnGamePause","rt":$n[0].Void,"p":[Function]}},{"a":4,"n":"OnGameQuit","t":2,"ad":{"a":4,"n":"add_OnGameQuit","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnGameQuit","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_OnGameQuit","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnGameQuit","rt":$n[0].Void,"p":[Function]}},{"a":4,"n":"OnLateTick","t":2,"ad":{"a":4,"n":"add_OnLateTick","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnLateTick","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_OnLateTick","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnLateTick","rt":$n[0].Void,"p":[Function]}},{"a":4,"n":"OnTick","t":2,"ad":{"a":4,"n":"add_OnTick","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnTick","rt":$n[0].Void,"p":[Function]},"r":{"a":4,"n":"remove_OnTick","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnTick","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Core.MonoGlobal end.*/

    /*VirtueSky.Core.RuntimeInitialize start.*/
    $m("VirtueSky.Core.RuntimeInitialize", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"at":[new UnityEngine.RuntimeInitializeOnLoadMethodAttribute.$ctor1(1)],"a":1,"n":"AutoInitialize","is":true,"t":8,"sn":"AutoInitialize","rt":$n[0].Void}]}; }, $n);
    /*VirtueSky.Core.RuntimeInitialize end.*/

    /*VirtueSky.Component.BounceComponent start.*/
    $m("VirtueSky.Component.BounceComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"FixedTick","t":8,"sn":"FixedTick","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":2,"n":"Pause","t":8,"sn":"Pause","rt":$n[0].Void},{"a":2,"n":"Resume","t":8,"sn":"Resume","rt":$n[0].Void},{"a":1,"n":"_posOffset","t":4,"rt":$n[1].Vector3,"sn":"_posOffset"},{"a":1,"n":"_tempPos","t":4,"rt":$n[1].Vector3,"sn":"_tempPos"},{"a":2,"n":"amplitude","t":4,"rt":$n[0].Single,"sn":"amplitude","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"degreesPerSecond","t":4,"rt":$n[0].Single,"sn":"degreesPerSecond","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"frequency","t":4,"rt":$n[0].Single,"sn":"frequency","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"isBounce","t":4,"rt":$n[0].Boolean,"sn":"isBounce","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.HeaderAttribute("Attributes")],"a":2,"n":"isRotate","t":4,"rt":$n[0].Boolean,"sn":"isRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*VirtueSky.Component.BounceComponent end.*/

    /*VirtueSky.Component.FollowTargetComponent start.*/
    $m("VirtueSky.Component.FollowTargetComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"HandleLerp","t":8,"sn":"HandleLerp","rt":$n[0].Void},{"a":1,"n":"HandleSetPos","t":8,"sn":"HandleSetPos","rt":$n[0].Void},{"a":1,"n":"HandleSmoothDamp","t":8,"sn":"HandleSmoothDamp","rt":$n[0].Void},{"ov":true,"a":2,"n":"LateTick","t":8,"sn":"LateTick","rt":$n[0].Void},{"a":2,"n":"SetDirectionFollowTarget","t":8,"pi":[{"n":"d","pt":$n[26].DirectionFollowTarget,"ps":0}],"sn":"SetDirectionFollowTarget","rt":$n[0].Void,"p":[$n[26].DirectionFollowTarget]},{"a":2,"n":"SetTarget","t":8,"pi":[{"n":"t","pt":$n[1].Transform,"ps":0}],"sn":"SetTarget","rt":$n[0].Void,"p":[$n[1].Transform]},{"a":2,"n":"SetTypeFollowTarget","t":8,"pi":[{"n":"t","pt":$n[26].TypeFollowTarget,"ps":0}],"sn":"SetTypeFollowTarget","rt":$n[0].Void,"p":[$n[26].TypeFollowTarget]},{"a":2,"n":"CurrentVelocity","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_CurrentVelocity","t":8,"rt":$n[1].Vector3,"fg":"CurrentVelocity"},"s":{"a":2,"n":"set_CurrentVelocity","t":8,"p":[$n[1].Vector3],"rt":$n[0].Void,"fs":"CurrentVelocity"},"fn":"CurrentVelocity"},{"a":2,"n":"DirectionFollowTarget","t":16,"rt":$n[26].DirectionFollowTarget,"g":{"a":2,"n":"get_DirectionFollowTarget","t":8,"rt":$n[26].DirectionFollowTarget,"fg":"DirectionFollowTarget","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},"s":{"a":2,"n":"set_DirectionFollowTarget","t":8,"p":[$n[26].DirectionFollowTarget],"rt":$n[0].Void,"fs":"DirectionFollowTarget"},"fn":"DirectionFollowTarget"},{"a":2,"n":"InterpolateValue","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_InterpolateValue","t":8,"rt":$n[0].Single,"fg":"InterpolateValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_InterpolateValue","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"InterpolateValue"},"fn":"InterpolateValue"},{"a":2,"n":"MaxSpeed","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_MaxSpeed","t":8,"rt":$n[0].Single,"fg":"MaxSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_MaxSpeed","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"MaxSpeed"},"fn":"MaxSpeed"},{"a":2,"n":"OffsetTrans","t":16,"rt":$n[1].Vector3,"g":{"a":2,"n":"get_OffsetTrans","t":8,"rt":$n[1].Vector3,"fg":"OffsetTrans"},"s":{"a":2,"n":"set_OffsetTrans","t":8,"p":[$n[1].Vector3],"rt":$n[0].Void,"fs":"OffsetTrans"},"fn":"OffsetTrans"},{"a":2,"n":"SmoothTime","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_SmoothTime","t":8,"rt":$n[0].Single,"fg":"SmoothTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_SmoothTime","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"SmoothTime"},"fn":"SmoothTime"},{"a":2,"n":"TargetTransform","t":16,"rt":$n[1].Transform,"g":{"a":2,"n":"get_TargetTransform","t":8,"rt":$n[1].Transform,"fg":"TargetTransform"},"s":{"a":2,"n":"set_TargetTransform","t":8,"p":[$n[1].Transform],"rt":$n[0].Void,"fs":"TargetTransform"},"fn":"TargetTransform"},{"a":2,"n":"TypeFollowTarget","t":16,"rt":$n[26].TypeFollowTarget,"g":{"a":2,"n":"get_TypeFollowTarget","t":8,"rt":$n[26].TypeFollowTarget,"fg":"TypeFollowTarget","box":function ($v) { return Bridge.box($v, VirtueSky.Component.TypeFollowTarget, System.Enum.toStringFn(VirtueSky.Component.TypeFollowTarget));}},"s":{"a":2,"n":"set_TypeFollowTarget","t":8,"p":[$n[26].TypeFollowTarget],"rt":$n[0].Void,"fs":"TypeFollowTarget"},"fn":"TypeFollowTarget"},{"at":[new UnityEngine.TooltipAttribute("if currentTrans is null, then currentTrans will be set up with the current game object"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentTrans","t":4,"rt":$n[1].Transform,"sn":"currentTrans"},{"at":[new UnityEngine.TooltipAttribute("The current velocity, this value is modified by the function every time you call it."),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentVelocity","t":4,"rt":$n[1].Vector3,"sn":"currentVelocity"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"directionFollowTarget","t":4,"rt":$n[26].DirectionFollowTarget,"sn":"directionFollowTarget","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"at":[new UnityEngine.TooltipAttribute("Value used to interpolate between target and this object"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"interpolateValue","t":4,"rt":$n[0].Single,"sn":"interpolateValue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.TooltipAttribute("Optionally allows you to clamp the maximum speed."),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxSpeed","t":4,"rt":$n[0].Single,"sn":"maxSpeed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offsetTrans","t":4,"rt":$n[1].Vector3,"sn":"offsetTrans"},{"at":[new UnityEngine.TooltipAttribute("Approximately the time it will take to reach the target. A smaller value will reach the target faster."),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"smoothTime","t":4,"rt":$n[0].Single,"sn":"smoothTime","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetTrans","t":4,"rt":$n[1].Transform,"sn":"targetTrans"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"typeFollowTarget","t":4,"rt":$n[26].TypeFollowTarget,"sn":"typeFollowTarget","box":function ($v) { return Bridge.box($v, VirtueSky.Component.TypeFollowTarget, System.Enum.toStringFn(VirtueSky.Component.TypeFollowTarget));}}]}; }, $n);
    /*VirtueSky.Component.FollowTargetComponent end.*/

    /*VirtueSky.Component.DirectionFollowTarget start.*/
    $m("VirtueSky.Component.DirectionFollowTarget", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"X","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"X","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"a":2,"n":"XY","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"XY","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"a":2,"n":"XYZ","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"XYZ","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"a":2,"n":"XZ","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"XZ","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"a":2,"n":"Y","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"Y","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"a":2,"n":"YZ","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"YZ","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}},{"a":2,"n":"Z","is":true,"t":4,"rt":$n[26].DirectionFollowTarget,"sn":"Z","box":function ($v) { return Bridge.box($v, VirtueSky.Component.DirectionFollowTarget, System.Enum.toStringFn(VirtueSky.Component.DirectionFollowTarget));}}]}; }, $n);
    /*VirtueSky.Component.DirectionFollowTarget end.*/

    /*VirtueSky.Component.TypeFollowTarget start.*/
    $m("VirtueSky.Component.TypeFollowTarget", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Lerp","is":true,"t":4,"rt":$n[26].TypeFollowTarget,"sn":"Lerp","box":function ($v) { return Bridge.box($v, VirtueSky.Component.TypeFollowTarget, System.Enum.toStringFn(VirtueSky.Component.TypeFollowTarget));}},{"a":2,"n":"SetPosition","is":true,"t":4,"rt":$n[26].TypeFollowTarget,"sn":"SetPosition","box":function ($v) { return Bridge.box($v, VirtueSky.Component.TypeFollowTarget, System.Enum.toStringFn(VirtueSky.Component.TypeFollowTarget));}},{"a":2,"n":"SmoothDamp","is":true,"t":4,"rt":$n[26].TypeFollowTarget,"sn":"SmoothDamp","box":function ($v) { return Bridge.box($v, VirtueSky.Component.TypeFollowTarget, System.Enum.toStringFn(VirtueSky.Component.TypeFollowTarget));}}]}; }, $n);
    /*VirtueSky.Component.TypeFollowTarget end.*/

    /*VirtueSky.Component.MoveComponent start.*/
    $m("VirtueSky.Component.MoveComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ResumeMoving","t":8,"sn":"ResumeMoving","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"a":2,"n":"StopMoving","t":8,"sn":"StopMoving","rt":$n[0].Void},{"ov":true,"a":2,"n":"Tick","t":8,"sn":"Tick","rt":$n[0].Void},{"a":1,"n":"_currentPoint","t":4,"rt":$n[0].Int32,"sn":"_currentPoint","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_isMoving","t":4,"rt":$n[0].Boolean,"sn":"_isMoving","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_reverse","t":4,"rt":$n[0].Boolean,"sn":"_reverse","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"moveOnAwake","t":4,"rt":$n[0].Boolean,"sn":"moveOnAwake","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"movingObject","t":4,"rt":$n[1].GameObject,"sn":"movingObject"},{"a":2,"n":"points","t":4,"rt":$n[3].List$1(UnityEngine.Transform),"sn":"points"},{"a":2,"n":"speed","t":4,"rt":$n[0].Single,"sn":"speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*VirtueSky.Component.MoveComponent end.*/

    /*VirtueSky.Component.ResizeCameraOrthographicComponent start.*/
    $m("VirtueSky.Component.ResizeCameraOrthographicComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ratio","t":4,"rt":$n[1].Vector2,"sn":"ratio"}]}; }, $n);
    /*VirtueSky.Component.ResizeCameraOrthographicComponent end.*/

    /*VirtueSky.Component.ResizeMatchCanvasScalerComponent start.*/
    $m("VirtueSky.Component.ResizeMatchCanvasScalerComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"GetCanvas","t":8,"sn":"GetCanvas","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute(),new UnityEngine.RangeAttribute(0.0, 1.0)],"a":1,"n":"aspectRatio","t":4,"rt":$n[0].Single,"sn":"aspectRatio","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"camera","t":4,"rt":$n[1].Camera,"sn":"camera"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"}]}; }, $n);
    /*VirtueSky.Component.ResizeMatchCanvasScalerComponent end.*/

    /*VirtueSky.Component.RotateComponent start.*/
    $m("VirtueSky.Component.RotateComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"FixedTick","t":8,"sn":"FixedTick","rt":$n[0].Void},{"a":2,"n":"Pause","t":8,"sn":"Pause","rt":$n[0].Void},{"a":2,"n":"Resume","t":8,"sn":"Resume","rt":$n[0].Void},{"at":[new UnityEngine.HeaderAttribute("Attributes")],"a":2,"n":"ignoreTimeScale","t":4,"rt":$n[0].Boolean,"sn":"ignoreTimeScale","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isReverse","t":4,"rt":$n[0].Boolean,"sn":"isReverse","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"isRotate","t":4,"rt":$n[0].Boolean,"sn":"isRotate","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotateX","t":4,"rt":$n[0].Boolean,"sn":"rotateX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotateY","t":4,"rt":$n[0].Boolean,"sn":"rotateY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"rotateZ","t":4,"rt":$n[0].Boolean,"sn":"rotateZ","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"speed","t":4,"rt":$n[0].Single,"sn":"speed","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*VirtueSky.Component.RotateComponent end.*/

    /*VirtueSky.Component.SafeAreaComponent start.*/
    $m("VirtueSky.Component.SafeAreaComponent", function () { return {"nested":[$n[26].SafeAreaComponent.SimDevice],"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"ApplySafeArea","t":8,"pi":[{"n":"r","pt":$n[1].Rect,"ps":0}],"sn":"ApplySafeArea","rt":$n[0].Void,"p":[$n[1].Rect]},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"GetSafeArea","t":8,"sn":"GetSafeArea","rt":$n[1].Rect},{"a":1,"n":"Refresh","t":8,"sn":"Refresh","rt":$n[0].Void},{"ov":true,"a":2,"n":"Tick","t":8,"sn":"Tick","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ConformX","t":4,"rt":$n[0].Boolean,"sn":"ConformX","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ConformY","t":4,"rt":$n[0].Boolean,"sn":"ConformY","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"LastOrientation","t":4,"rt":$n[1].ScreenOrientation,"sn":"LastOrientation","box":function ($v) { return Bridge.box($v, UnityEngine.ScreenOrientation, System.Enum.toStringFn(UnityEngine.ScreenOrientation));}},{"a":1,"n":"LastSafeArea","t":4,"rt":$n[1].Rect,"sn":"LastSafeArea"},{"a":1,"n":"LastScreenSize","t":4,"rt":$n[1].Vector2Int,"sn":"LastScreenSize"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"Logging","t":4,"rt":$n[0].Boolean,"sn":"Logging","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"NSA_Pixel3XL_LSL","t":4,"rt":System.Array.type(UnityEngine.Rect),"sn":"NSA_Pixel3XL_LSL"},{"a":1,"n":"NSA_Pixel3XL_LSR","t":4,"rt":System.Array.type(UnityEngine.Rect),"sn":"NSA_Pixel3XL_LSR"},{"a":1,"n":"NSA_iPhoneX","t":4,"rt":System.Array.type(UnityEngine.Rect),"sn":"NSA_iPhoneX"},{"a":1,"n":"NSA_iPhoneXsMax","t":4,"rt":System.Array.type(UnityEngine.Rect),"sn":"NSA_iPhoneXsMax"},{"a":1,"n":"Panel","t":4,"rt":$n[1].RectTransform,"sn":"Panel"},{"a":2,"n":"Sim","is":true,"t":4,"rt":$n[26].SafeAreaComponent.SimDevice,"sn":"Sim","box":function ($v) { return Bridge.box($v, VirtueSky.Component.SafeAreaComponent.SimDevice, System.Enum.toStringFn(VirtueSky.Component.SafeAreaComponent.SimDevice));}}]}; }, $n);
    /*VirtueSky.Component.SafeAreaComponent end.*/

    /*VirtueSky.Component.SafeAreaComponent+SimDevice start.*/
    $m("VirtueSky.Component.SafeAreaComponent.SimDevice", function () { return {"td":$n[26].SafeAreaComponent,"att":258,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"None","is":true,"t":4,"rt":$n[26].SafeAreaComponent.SimDevice,"sn":"None","box":function ($v) { return Bridge.box($v, VirtueSky.Component.SafeAreaComponent.SimDevice, System.Enum.toStringFn(VirtueSky.Component.SafeAreaComponent.SimDevice));}},{"a":2,"n":"Pixel3XL_LSL","is":true,"t":4,"rt":$n[26].SafeAreaComponent.SimDevice,"sn":"Pixel3XL_LSL","box":function ($v) { return Bridge.box($v, VirtueSky.Component.SafeAreaComponent.SimDevice, System.Enum.toStringFn(VirtueSky.Component.SafeAreaComponent.SimDevice));}},{"a":2,"n":"Pixel3XL_LSR","is":true,"t":4,"rt":$n[26].SafeAreaComponent.SimDevice,"sn":"Pixel3XL_LSR","box":function ($v) { return Bridge.box($v, VirtueSky.Component.SafeAreaComponent.SimDevice, System.Enum.toStringFn(VirtueSky.Component.SafeAreaComponent.SimDevice));}},{"a":2,"n":"iPhoneX","is":true,"t":4,"rt":$n[26].SafeAreaComponent.SimDevice,"sn":"iPhoneX","box":function ($v) { return Bridge.box($v, VirtueSky.Component.SafeAreaComponent.SimDevice, System.Enum.toStringFn(VirtueSky.Component.SafeAreaComponent.SimDevice));}},{"a":2,"n":"iPhoneXsMax","is":true,"t":4,"rt":$n[26].SafeAreaComponent.SimDevice,"sn":"iPhoneXsMax","box":function ($v) { return Bridge.box($v, VirtueSky.Component.SafeAreaComponent.SimDevice, System.Enum.toStringFn(VirtueSky.Component.SafeAreaComponent.SimDevice));}}]}; }, $n);
    /*VirtueSky.Component.SafeAreaComponent+SimDevice end.*/

    /*VirtueSky.Component.TimeRemainingComponent start.*/
    $m("VirtueSky.Component.TimeRemainingComponent", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetTimeRemaining","t":8,"sn":"GetTimeRemaining","rt":$n[0].TimeSpan},{"a":2,"n":"InitTargetTime","t":8,"sn":"InitTargetTime","rt":$n[0].Void},{"a":2,"n":"InitTargetTime","t":8,"pi":[{"n":"year","pt":$n[0].Int32,"ps":0},{"n":"month","pt":$n[0].Int32,"ps":1},{"n":"day","pt":$n[0].Int32,"ps":2},{"n":"hour","pt":$n[0].Int32,"ps":3},{"n":"minute","pt":$n[0].Int32,"ps":4},{"n":"second","pt":$n[0].Int32,"ps":5}],"sn":"InitTargetTime$1","rt":$n[0].Void,"p":[$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32,$n[0].Int32]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetDay","t":4,"rt":$n[0].Int32,"sn":"targetDay","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetHour","t":4,"rt":$n[0].Int32,"sn":"targetHour","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetMinute","t":4,"rt":$n[0].Int32,"sn":"targetMinute","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetMonth","t":4,"rt":$n[0].Int32,"sn":"targetMonth","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetSecond","t":4,"rt":$n[0].Int32,"sn":"targetSecond","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"targetTime","t":4,"rt":$n[0].DateTime,"sn":"targetTime","box":function ($v) { return Bridge.box($v, System.DateTime, System.DateTime.format);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"targetYear","t":4,"rt":$n[0].Int32,"sn":"targetYear","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*VirtueSky.Component.TimeRemainingComponent end.*/

    /*VirtueSky.UIButton.ButtonCustom start.*/
    $m("VirtueSky.UIButton.ButtonCustom", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"DoScale","t":8,"sn":"DoScale","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnPointerDown","t":8,"pi":[{"n":"eventData","pt":$n[27].PointerEventData,"ps":0}],"sn":"OnPointerDown","rt":$n[0].Void,"p":[$n[27].PointerEventData]},{"ov":true,"a":2,"n":"OnPointerExit","t":8,"pi":[{"n":"eventData","pt":$n[27].PointerEventData,"ps":0}],"sn":"OnPointerExit","rt":$n[0].Void,"p":[$n[27].PointerEventData]},{"ov":true,"a":2,"n":"OnPointerUp","t":8,"pi":[{"n":"eventData","pt":$n[27].PointerEventData,"ps":0}],"sn":"OnPointerUp","rt":$n[0].Void,"p":[$n[27].PointerEventData]},{"a":1,"n":"ResetScale","t":8,"sn":"ResetScale","rt":$n[0].Void},{"a":1,"n":"Shrug","t":8,"sn":"Shrug","rt":$n[0].Void},{"a":1,"n":"_tween","t":4,"rt":$n[4].Tween,"sn":"_tween"},{"a":1,"n":"canShrug","t":4,"rt":$n[0].Boolean,"sn":"canShrug","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"clickButtonEvent","t":4,"rt":$n[2].ClickButtonEvent,"sn":"clickButtonEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"easingTypes","t":4,"rt":$n[4].Ease,"sn":"easingTypes","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isMotion","t":4,"rt":$n[0].Boolean,"sn":"isMotion","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isShrugOver","t":4,"rt":$n[0].Boolean,"sn":"isShrugOver","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"originScale","t":4,"rt":$n[1].Vector3,"sn":"originScale"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scale","t":4,"rt":$n[0].Single,"sn":"scale","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundDataClickButton","t":4,"rt":$n[5].SoundData,"sn":"soundDataClickButton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"strength","t":4,"rt":$n[0].Single,"sn":"strength","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeShrug","t":4,"rt":$n[0].Single,"sn":"timeShrug","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"useSoundFx","t":4,"rt":$n[0].Boolean,"sn":"useSoundFx","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*VirtueSky.UIButton.ButtonCustom end.*/

    /*VirtueSky.UIButton.ButtonText start.*/
    $m("VirtueSky.UIButton.ButtonText", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.UI.Text)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.UIButton.ButtonText end.*/

    /*VirtueSky.UIButton.ButtonTMP start.*/
    $m("VirtueSky.UIButton.ButtonTMP", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(TMPro.TextMeshProUGUI)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.UIButton.ButtonTMP end.*/

    /*VirtueSky.UIButton.ButtonUI_Text start.*/
    $m("VirtueSky.UIButton.ButtonUI_Text", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.UI.Image)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.UIButton.ButtonUI_Text end.*/

    /*VirtueSky.UIButton.ButtonUI_TMP start.*/
    $m("VirtueSky.UIButton.ButtonUI_TMP", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.UI.Image)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.UIButton.ButtonUI_TMP end.*/

    /*VirtueSky.UIButton.ButtonUI start.*/
    $m("VirtueSky.UIButton.ButtonUI", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.UI.Image)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.UIButton.ButtonUI end.*/

    /*VirtueSky.Audio.AudioHelper start.*/
    $m("VirtueSky.Audio.AudioHelper", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"FinishSfx","is":true,"t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0},{"n":"finishSfxEvent","pt":$n[5].FinishSfxEvent,"ps":1}],"sn":"FinishSfx","rt":$n[0].Void,"p":[$n[5].SoundCache,$n[5].FinishSfxEvent]},{"a":2,"n":"PauseMusic","is":true,"t":8,"pi":[{"n":"pauseMusicEvent","pt":$n[5].PauseMusicEvent,"ps":0}],"sn":"PauseMusic","rt":$n[0].Void,"p":[$n[5].PauseMusicEvent]},{"a":2,"n":"PauseSfx","is":true,"t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0},{"n":"pauseSfxEvent","pt":$n[5].PauseSfxEvent,"ps":1}],"sn":"PauseSfx","rt":$n[0].Void,"p":[$n[5].SoundCache,$n[5].PauseSfxEvent]},{"a":2,"n":"PlayMusic","is":true,"t":8,"pi":[{"n":"soundData","pt":$n[5].SoundData,"ps":0},{"n":"playMusicEvent","pt":$n[5].PlayMusicEvent,"ps":1}],"sn":"PlayMusic","rt":$n[0].Void,"p":[$n[5].SoundData,$n[5].PlayMusicEvent]},{"a":2,"n":"PlaySfx","is":true,"t":8,"pi":[{"n":"soundData","pt":$n[5].SoundData,"ps":0},{"n":"playSfxEvent","pt":$n[5].PlaySfxEvent,"ps":1}],"sn":"PlaySfx","rt":$n[5].SoundCache,"p":[$n[5].SoundData,$n[5].PlaySfxEvent]},{"a":2,"n":"ResumeMusic","is":true,"t":8,"pi":[{"n":"resumeMusicEvent","pt":$n[5].ResumeMusicEvent,"ps":0}],"sn":"ResumeMusic","rt":$n[0].Void,"p":[$n[5].ResumeMusicEvent]},{"a":2,"n":"ResumeSfx","is":true,"t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0},{"n":"resumeSfxEvent","pt":$n[5].ResumeSfxEvent,"ps":1}],"sn":"ResumeSfx","rt":$n[0].Void,"p":[$n[5].SoundCache,$n[5].ResumeSfxEvent]},{"a":2,"n":"StopAllSfx","is":true,"t":8,"pi":[{"n":"stopAllSfxEvent","pt":$n[5].StopAllSfxEvent,"ps":0}],"sn":"StopAllSfx","rt":$n[0].Void,"p":[$n[5].StopAllSfxEvent]},{"a":2,"n":"StopMusic","is":true,"t":8,"pi":[{"n":"stopMusicEvent","pt":$n[5].StopMusicEvent,"ps":0}],"sn":"StopMusic","rt":$n[0].Void,"p":[$n[5].StopMusicEvent]},{"a":2,"n":"StopSfx","is":true,"t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0},{"n":"stopSfxEvent","pt":$n[5].StopSfxEvent,"ps":1}],"sn":"StopSfx","rt":$n[0].Void,"p":[$n[5].SoundCache,$n[5].StopSfxEvent]}]}; }, $n);
    /*VirtueSky.Audio.AudioHelper end.*/

    /*VirtueSky.Audio.AudioManager start.*/
    $m("VirtueSky.Audio.AudioManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":1,"n":"FinishSfx","t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0}],"sn":"FinishSfx","rt":$n[0].Void,"p":[$n[5].SoundCache]},{"a":1,"n":"GetSoundCache","t":8,"pi":[{"n":"soundData","pt":$n[5].SoundData,"ps":0}],"sn":"GetSoundCache","rt":$n[5].SoundCache,"p":[$n[5].SoundData]},{"a":1,"n":"GetSoundComponent","t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0}],"sn":"GetSoundComponent","rt":$n[5].SoundComponent,"p":[$n[5].SoundCache]},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"OnFinishPlayingAudio","t":8,"pi":[{"n":"soundComponent","pt":$n[5].SoundComponent,"ps":0}],"sn":"OnFinishPlayingAudio","rt":$n[0].Void,"p":[$n[5].SoundComponent]},{"a":1,"n":"OnMusicVolumeChanged","t":8,"pi":[{"n":"volume","pt":$n[0].Single,"ps":0}],"sn":"OnMusicVolumeChanged","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"OnSfxVolumeChanged","t":8,"pi":[{"n":"volume","pt":$n[0].Single,"ps":0}],"sn":"OnSfxVolumeChanged","rt":$n[0].Void,"p":[$n[0].Single]},{"a":1,"n":"PauseMusic","t":8,"sn":"PauseMusic","rt":$n[0].Void},{"a":1,"n":"PauseSfx","t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0}],"sn":"PauseSfx","rt":$n[0].Void,"p":[$n[5].SoundCache]},{"a":1,"n":"PlayMusic","t":8,"pi":[{"n":"soundData","pt":$n[5].SoundData,"ps":0}],"sn":"PlayMusic","rt":$n[0].Void,"p":[$n[5].SoundData]},{"a":1,"n":"PlaySfx","t":8,"pi":[{"n":"soundData","pt":$n[5].SoundData,"ps":0}],"sn":"PlaySfx","rt":$n[5].SoundCache,"p":[$n[5].SoundData]},{"a":1,"n":"ResumeMusic","t":8,"sn":"ResumeMusic","rt":$n[0].Void},{"a":1,"n":"ResumeSfx","t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0}],"sn":"ResumeSfx","rt":$n[0].Void,"p":[$n[5].SoundCache]},{"a":1,"n":"StopAllSfx","t":8,"sn":"StopAllSfx","rt":$n[0].Void},{"a":1,"n":"StopAndCleanAudioComponent","t":8,"pi":[{"n":"soundComponent","pt":$n[5].SoundComponent,"ps":0}],"sn":"StopAndCleanAudioComponent","rt":$n[0].Void,"p":[$n[5].SoundComponent]},{"a":1,"n":"StopAudioMusic","t":8,"pi":[{"n":"soundComponent","pt":$n[5].SoundComponent,"ps":0}],"sn":"StopAudioMusic","rt":$n[0].Void,"p":[$n[5].SoundComponent]},{"a":1,"n":"StopMusic","t":8,"sn":"StopMusic","rt":$n[0].Void},{"a":1,"n":"StopSfx","t":8,"pi":[{"n":"soundCache","pt":$n[5].SoundCache,"ps":0}],"sn":"StopSfx","rt":$n[0].Void,"p":[$n[5].SoundCache]},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"audioHolder","t":4,"rt":$n[1].Transform,"sn":"audioHolder"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventFinishSfx","t":4,"rt":$n[5].FinishSfxEvent,"sn":"eventFinishSfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventPauseMusic","t":4,"rt":$n[5].PauseMusicEvent,"sn":"eventPauseMusic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventPauseSfx","t":4,"rt":$n[5].PauseSfxEvent,"sn":"eventPauseSfx"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventPlayMusic","t":4,"rt":$n[5].PlayMusicEvent,"sn":"eventPlayMusic"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventPlaySfx","t":4,"rt":$n[5].PlaySfxEvent,"sn":"eventPlaySfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventResumeMusic","t":4,"rt":$n[5].ResumeMusicEvent,"sn":"eventResumeMusic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventResumeSfx","t":4,"rt":$n[5].ResumeSfxEvent,"sn":"eventResumeSfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventStopAllSfx","t":4,"rt":$n[5].StopAllSfxEvent,"sn":"eventStopAllSfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventStopMusic","t":4,"rt":$n[5].StopMusicEvent,"sn":"eventStopMusic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventStopSfx","t":4,"rt":$n[5].StopSfxEvent,"sn":"eventStopSfx"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isDontDestroyOnLoad","t":4,"rt":$n[0].Boolean,"sn":"isDontDestroyOnLoad","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"key","t":4,"rt":$n[0].Int32,"sn":"key","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listCacheSfx","t":4,"rt":$n[3].List$1(VirtueSky.Audio.SoundComponent),"sn":"listCacheSfx"},{"a":1,"n":"music","t":4,"rt":$n[5].SoundComponent,"sn":"music"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicVolume","t":4,"rt":$n[5].MusicVolumeChange,"sn":"musicVolume"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"sfxVolume","t":4,"rt":$n[5].SfxVolumeChange,"sn":"sfxVolume"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundComponentPrefab","t":4,"rt":$n[5].SoundComponent,"sn":"soundComponentPrefab"}]}; }, $n);
    /*VirtueSky.Audio.AudioManager end.*/

    /*VirtueSky.Audio.PauseMusicEvent start.*/
    $m("VirtueSky.Audio.PauseMusicEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Music Event/Pause Music Event", fileName: "pause_music_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.PauseMusicEvent end.*/

    /*VirtueSky.Audio.PlayMusicEvent start.*/
    $m("VirtueSky.Audio.PlayMusicEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Music Event/Play Music Event", fileName: "play_music_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.PlayMusicEvent end.*/

    /*VirtueSky.Audio.ResumeMusicEvent start.*/
    $m("VirtueSky.Audio.ResumeMusicEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Music Event/Resume Music Event", fileName: "resume_music_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.ResumeMusicEvent end.*/

    /*VirtueSky.Audio.StopMusicEvent start.*/
    $m("VirtueSky.Audio.StopMusicEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Music Event/Stop Music Event", fileName: "stop_music_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.StopMusicEvent end.*/

    /*VirtueSky.Audio.FinishSfxEvent start.*/
    $m("VirtueSky.Audio.FinishSfxEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sfx Event/Finish Sfx Event", fileName: "finish_sfx_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.FinishSfxEvent end.*/

    /*VirtueSky.Audio.PauseSfxEvent start.*/
    $m("VirtueSky.Audio.PauseSfxEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sfx Event/Pause Sfx Event", fileName: "pause_sfx_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.PauseSfxEvent end.*/

    /*VirtueSky.Audio.PlaySfxEvent start.*/
    $m("VirtueSky.Audio.PlaySfxEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sfx Event/Play Sfx Event", fileName: "play_sfx_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.PlaySfxEvent end.*/

    /*VirtueSky.Audio.ResumeSfxEvent start.*/
    $m("VirtueSky.Audio.ResumeSfxEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sfx Event/Resume Sfx Event", fileName: "resume_sfx_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.ResumeSfxEvent end.*/

    /*VirtueSky.Audio.StopAllSfxEvent start.*/
    $m("VirtueSky.Audio.StopAllSfxEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sfx Event/Stop All Sfx Event", fileName: "stop_all_sfx_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.StopAllSfxEvent end.*/

    /*VirtueSky.Audio.StopSfxEvent start.*/
    $m("VirtueSky.Audio.StopSfxEvent", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sfx Event/Stop Sfx Event", fileName: "stop_sfx_event"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.StopSfxEvent end.*/

    /*VirtueSky.Audio.SoundCache start.*/
    $m("VirtueSky.Audio.SoundCache", function () { return {"att":1056769,"a":2,"at":[new System.SerializableAttribute()],"m":[{"a":2,"n":".ctor","t":1,"p":[$n[0].Int32,$n[5].SoundData],"pi":[{"n":"_key","pt":$n[0].Int32,"ps":0},{"n":"_soundData","pt":$n[5].SoundData,"ps":1}],"sn":"ctor"},{"a":4,"n":"key","t":4,"rt":$n[0].Int32,"sn":"key","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":4,"n":"soundData","t":4,"rt":$n[5].SoundData,"sn":"soundData"}]}; }, $n);
    /*VirtueSky.Audio.SoundCache end.*/

    /*VirtueSky.Audio.SoundComponent start.*/
    $m("VirtueSky.Audio.SoundComponent", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.ctor(UnityEngine.AudioSource)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake$1","rt":$n[0].Void},{"a":1,"n":"FadeInVolumeMusic","t":8,"pi":[{"n":"audioClip","pt":$n[1].AudioClip,"ps":0},{"n":"isLooping","pt":$n[0].Boolean,"ps":1},{"n":"endValue","pt":$n[0].Single,"ps":2},{"n":"duration","pt":$n[0].Single,"ps":3}],"sn":"FadeInVolumeMusic","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"a":1,"n":"FadeOutVolumeMusic","t":8,"pi":[{"n":"duration","pt":$n[0].Single,"ps":0},{"n":"fadeCompleted","pt":Function,"ps":1}],"sn":"FadeOutVolumeMusic","rt":$n[0].Void,"p":[$n[0].Single,Function]},{"a":4,"n":"FadePlayMusic","t":8,"pi":[{"n":"audioClip","pt":$n[1].AudioClip,"ps":0},{"n":"isLooping","pt":$n[0].Boolean,"ps":1},{"n":"volume","pt":$n[0].Single,"ps":2},{"n":"isMusicFadeVolume","pt":$n[0].Boolean,"ps":3},{"n":"durationOut","pt":$n[0].Single,"ps":4},{"n":"durationIn","pt":$n[0].Single,"ps":5}],"sn":"FadePlayMusic","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean,$n[0].Single,$n[0].Boolean,$n[0].Single,$n[0].Single]},{"a":4,"n":"Finish","t":8,"sn":"Finish","rt":$n[0].Void},{"a":1,"n":"OnCompletedInvoke","t":8,"sn":"OnCompletedInvoke","rt":$n[0].Void},{"a":4,"n":"Pause","t":8,"sn":"Pause","rt":$n[0].Void},{"a":4,"n":"PlayAudioClip","t":8,"pi":[{"n":"audioClip","pt":$n[1].AudioClip,"ps":0},{"n":"isLooping","pt":$n[0].Boolean,"ps":1},{"n":"volume","pt":$n[0].Single,"ps":2}],"sn":"PlayAudioClip","rt":$n[0].Void,"p":[$n[1].AudioClip,$n[0].Boolean,$n[0].Single]},{"a":4,"n":"Resume","t":8,"sn":"Resume","rt":$n[0].Void},{"a":4,"n":"Stop","t":8,"sn":"Stop","rt":$n[0].Void},{"a":2,"n":"GetClip","t":16,"rt":$n[1].AudioClip,"g":{"a":2,"n":"get_GetClip","t":8,"rt":$n[1].AudioClip,"fg":"GetClip"},"fn":"GetClip"},{"a":2,"n":"IsLooping","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsLooping","t":8,"rt":$n[0].Boolean,"fg":"IsLooping","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsLooping"},{"a":2,"n":"IsPlaying","t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsPlaying","t":8,"rt":$n[0].Boolean,"fg":"IsPlaying","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"IsPlaying"},{"a":2,"n":"Key","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_Key","t":8,"rt":$n[0].Int32,"fg":"Key","box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_Key","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"Key"},"fn":"Key"},{"a":2,"n":"Volume","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_Volume","t":8,"rt":$n[0].Single,"fg":"Volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"s":{"a":2,"n":"set_Volume","t":8,"p":[$n[0].Single],"rt":$n[0].Void,"fs":"Volume"},"fn":"Volume"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"key","t":4,"rt":$n[0].Int32,"sn":"key","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"OnCompleted","t":2,"ad":{"a":2,"n":"add_OnCompleted","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnCompleted","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnCompleted","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnCompleted","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnPaused","t":2,"ad":{"a":2,"n":"add_OnPaused","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnPaused","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnPaused","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnPaused","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnResumed","t":2,"ad":{"a":2,"n":"add_OnResumed","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnResumed","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnResumed","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnResumed","rt":$n[0].Void,"p":[Function]}},{"a":2,"n":"OnStopped","t":2,"ad":{"a":2,"n":"add_OnStopped","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"addOnStopped","rt":$n[0].Void,"p":[Function]},"r":{"a":2,"n":"remove_OnStopped","t":8,"pi":[{"n":"value","pt":Function,"ps":0}],"sn":"removeOnStopped","rt":$n[0].Void,"p":[Function]}}]}; }, $n);
    /*VirtueSky.Audio.SoundComponent end.*/

    /*VirtueSky.Audio.SoundData start.*/
    $m("VirtueSky.Audio.SoundData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Sound Data", fileName: "sound_data"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetAudioClip","t":8,"sn":"GetAudioClip","rt":$n[1].AudioClip},{"a":2,"n":"NumberOfAudioClips","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_NumberOfAudioClips","t":8,"rt":$n[0].Int32,"fg":"NumberOfAudioClips","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"NumberOfAudioClips"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"audioClips","t":4,"rt":$n[3].List$1(UnityEngine.AudioClip),"sn":"audioClips"},{"a":2,"n":"fadeInDuration","t":4,"rt":$n[0].Single,"sn":"fadeInDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"fadeOutDuration","t":4,"rt":$n[0].Single,"sn":"fadeOutDuration","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Fade Volume - Only Music"),new UnityEngine.TooltipAttribute("Only Music Background")],"a":2,"n":"isMusicFadeVolume","t":4,"rt":$n[0].Boolean,"sn":"isMusicFadeVolume","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SpaceAttribute.ctor()],"a":2,"n":"loop","t":4,"rt":$n[0].Boolean,"sn":"loop","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.RangeAttribute(0.0, 1.0)],"a":2,"n":"volume","t":4,"rt":$n[0].Single,"sn":"volume","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*VirtueSky.Audio.SoundData end.*/

    /*VirtueSky.Audio.MusicVolumeChange start.*/
    $m("VirtueSky.Audio.MusicVolumeChange", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Volume Change Variable/Music Volume Change", fileName: "music_volume"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.MusicVolumeChange end.*/

    /*VirtueSky.Audio.SfxVolumeChange start.*/
    $m("VirtueSky.Audio.SfxVolumeChange", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Audio/Volume Change Variable/Sfx Volume Change", fileName: "sfx_volume"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*VirtueSky.Audio.SfxVolumeChange end.*/

    /*VirtueSky.Vfx.VfxData start.*/
    $m("VirtueSky.Vfx.VfxData", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Sunflower/Vfx/Vfx Data", fileName: "vfx_data"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetVfxByIndex","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GetVfxByIndex","rt":$n[1].GameObject,"p":[$n[0].Int32]},{"a":2,"n":"GetVfxRandom","t":8,"sn":"GetVfxRandom","rt":$n[1].GameObject},{"a":1,"n":"PickRandom","t":8,"pi":[{"n":"collection","pt":$n[3].List$1(UnityEngine.GameObject),"ps":0}],"sn":"PickRandom","rt":$n[1].GameObject,"p":[$n[3].List$1(UnityEngine.GameObject)]},{"a":2,"n":"TimeDestroy","t":16,"rt":$n[0].Single,"g":{"a":2,"n":"get_TimeDestroy","t":8,"rt":$n[0].Single,"fg":"TimeDestroy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},"fn":"TimeDestroy"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listVfx","t":4,"rt":$n[3].List$1(UnityEngine.GameObject),"sn":"listVfx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDestroy","t":4,"rt":$n[0].Single,"sn":"timeDestroy","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}}]}; }, $n);
    /*VirtueSky.Vfx.VfxData end.*/

    /*VirtueSky.Vfx.VfxSpawner start.*/
    $m("VirtueSky.Vfx.VfxSpawner", function () { return {"att":1048961,"a":2,"s":true,"m":[{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"vfxData","pt":$n[28].VfxData,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"index","dv":-1,"o":true,"pt":$n[0].Int32,"ps":2}],"sn":"Spawn","rt":$n[0].Void,"p":[$n[28].VfxData,$n[1].Transform,$n[0].Int32]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"vfxData","pt":$n[28].VfxData,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2},{"n":"quaternion","pt":$n[1].Quaternion,"ps":3},{"n":"index","dv":-1,"o":true,"pt":$n[0].Int32,"ps":4}],"sn":"Spawn$1","rt":$n[0].Void,"p":[$n[28].VfxData,$n[1].Transform,$n[1].Vector3,$n[1].Quaternion,$n[0].Int32]},{"a":2,"n":"Spawn","is":true,"t":8,"pi":[{"n":"vfxData","pt":$n[28].VfxData,"ps":0},{"n":"parent","pt":$n[1].Transform,"ps":1},{"n":"position","pt":$n[1].Vector3,"ps":2},{"n":"quaternion","pt":$n[1].Quaternion,"ps":3},{"n":"localScale","pt":$n[1].Vector3,"ps":4},{"n":"index","dv":-1,"o":true,"pt":$n[0].Int32,"ps":5}],"sn":"Spawn$2","rt":$n[0].Void,"p":[$n[28].VfxData,$n[1].Transform,$n[1].Vector3,$n[1].Quaternion,$n[1].Vector3,$n[0].Int32]}]}; }, $n);
    /*VirtueSky.Vfx.VfxSpawner end.*/

    /*TheBeginning.UI.GameplayPopup start.*/
    $m("TheBeginning.UI.GameplayPopup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"OnBackToBuildTutorialPlaying","t":8,"pi":[{"n":"isPlaying","pt":$n[0].Boolean,"ps":0}],"sn":"OnBackToBuildTutorialPlaying","rt":$n[0].Void,"p":[$n[0].Boolean]},{"ov":true,"a":3,"n":"OnBeforeHide","t":8,"sn":"OnBeforeHide","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeShow","t":8,"sn":"OnBeforeShow","rt":$n[0].Void},{"a":2,"n":"OnClickHome","t":8,"sn":"OnClickHome","rt":$n[0].Void},{"a":2,"n":"OnClickLose","t":8,"sn":"OnClickLose","rt":$n[0].Void},{"a":2,"n":"OnClickPrevious","t":8,"sn":"OnClickPrevious","rt":$n[0].Void},{"a":2,"n":"OnClickReplay","t":8,"sn":"OnClickReplay","rt":$n[0].Void},{"a":2,"n":"OnClickSetting","t":8,"sn":"OnClickSetting","rt":$n[0].Void},{"a":2,"n":"OnClickSkip","t":8,"sn":"OnClickSkip","rt":$n[0].Void},{"a":2,"n":"OnClickWin","t":8,"sn":"OnClickWin","rt":$n[0].Void},{"a":1,"n":"OnPreStartLevel","t":8,"sn":"OnPreStartLevel","rt":$n[0].Void},{"a":1,"n":"OnShowBoosterGuildEvent","t":8,"pi":[{"n":"isShowing","pt":$n[0].Boolean,"ps":0}],"sn":"OnShowBoosterGuildEvent","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"OnShowCTAButton","t":8,"pi":[{"n":"isShow","pt":$n[0].Boolean,"ps":0}],"sn":"OnShowCTAButton","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"Refresh","t":8,"sn":"Refresh","rt":$n[0].Void},{"a":2,"n":"Setup","t":8,"pi":[{"n":"currentLevel","pt":$n[0].Int32,"ps":0}],"sn":"Setup","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":1,"n":"UpdateBoardLevelMode","t":8,"sn":"UpdateBoardLevelMode","rt":$n[0].Void},{"a":1,"n":"_tweenAddTime","t":4,"rt":$n[3].List$1(DG.Tweening.Tween),"sn":"_tweenAddTime"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimeIcon","t":4,"rt":$n[1].GameObject,"sn":"addTimeIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimeModel","t":4,"rt":$n[1].RectTransform,"sn":"addTimeModel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimeModelDefaultPos","t":4,"rt":$n[1].RectTransform,"sn":"addTimeModelDefaultPos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimeModelToPos","t":4,"rt":$n[1].RectTransform,"sn":"addTimeModelToPos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimePlayEvent","t":4,"rt":$n[2].IntegerEvent,"sn":"addTimePlayEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"addTimeText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"addTimeText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"backLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"backLevelEvent"},{"at":[new UnityEngine.Serialization.FormerlySerializedAsAttribute("boardLevelText"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boardLevel","t":4,"rt":$n[8].Image,"sn":"boardLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"boardLevelText","t":4,"rt":$n[8].Image,"sn":"boardLevelText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"btnBackHome","t":4,"rt":$n[1].GameObject,"sn":"btnBackHome"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callReplayLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"callReplayLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callReturnHomeEvent","t":4,"rt":$n[2].EventNoParam,"sn":"callReturnHomeEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ctaButton","t":4,"rt":$n[1].GameObject,"sn":"ctaButton"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"easeMove","t":4,"rt":$n[4].Ease,"sn":"easeMove","box":function ($v) { return Bridge.box($v, DG.Tweening.Ease, System.Enum.toStringFn(DG.Tweening.Ease));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"groupUI","t":4,"rt":$n[1].GameObject,"sn":"groupUI"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"indexLevelVariable","t":4,"rt":$n[6].IntegerVariable,"sn":"indexLevelVariable"},{"at":[new UnityEngine.HeaderAttribute("Tutorial"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isBackToBuildTutorialPlaying","t":4,"rt":$n[6].BooleanVariable,"sn":"isBackToBuildTutorialPlaying"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPlayingLevel","t":4,"rt":$n[6].BooleanVariable,"sn":"isPlayingLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isStartingLevel","t":4,"rt":$n[6].BooleanVariable,"sn":"isStartingLevel"},{"at":[new UnityEngine.HeaderAttribute("Additional Time"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelAdditionalTime","t":4,"rt":LevelAdditionalTime,"sn":"levelAdditionalTime"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelModeData","t":4,"rt":LevelModeData,"sn":"levelModeData"},{"a":2,"n":"levelText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"levelText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelTextNumber","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"levelTextNumber"},{"a":2,"n":"levelTypeText","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"levelTypeText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"loseLevelEvent","t":4,"rt":$n[2].FloatEvent,"sn":"loseLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicInGame","t":4,"rt":$n[5].SoundData,"sn":"musicInGame"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"nextLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"nextLevelEvent"},{"at":[new UnityEngine.HeaderAttribute("Booster Guid"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"onShowBoosterGuild","t":4,"rt":$n[2].BooleanEvent,"sn":"onShowBoosterGuild"},{"at":[new UnityEngine.HeaderAttribute("Audio"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playMusicEvent","t":4,"rt":$n[5].PlayMusicEvent,"sn":"playMusicEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"preStartLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"preStartLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"replayEvent","t":4,"rt":$n[2].EventNoParam,"sn":"replayEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"replayIcon","t":4,"rt":$n[8].Image,"sn":"replayIcon"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleDefault","t":4,"rt":$n[0].Single,"sn":"scaleDefault","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleToEnd","t":4,"rt":$n[0].Single,"sn":"scaleToEnd","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"settingIcon","t":4,"rt":$n[8].Image,"sn":"settingIcon"},{"at":[new UnityEngine.HeaderAttribute("CTA Button"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"showCTAButtonEvent","t":4,"rt":$n[2].BooleanEvent,"sn":"showCTAButtonEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundHardLevel","t":4,"rt":$n[5].SoundData,"sn":"soundHardLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"stringFormatAddTimeText","t":4,"rt":$n[0].String,"sn":"stringFormatAddTimeText"},{"a":2,"n":"stringFormatLevel","t":4,"rt":$n[0].String,"sn":"stringFormatLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayMove","t":4,"rt":$n[0].Single,"sn":"timeDelayMove","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeMove","t":4,"rt":$n[0].Single,"sn":"timeMove","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Animation"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"transHardLevel","t":4,"rt":$n[12].SkeletonGraphic,"sn":"transHardLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"transHardLevelAnim","t":4,"rt":$n[0].String,"sn":"transHardLevelAnim"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"unlockWinStreakLevel","t":4,"rt":$n[6].IntegerVariable,"sn":"unlockWinStreakLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"winLevelEvent","t":4,"rt":$n[2].FloatEvent,"sn":"winLevelEvent"}]}; }, $n);
    /*TheBeginning.UI.GameplayPopup end.*/

    /*TheBeginning.UI.LosePopup start.*/
    $m("TheBeginning.UI.LosePopup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ClosePopup","t":8,"sn":"ClosePopup","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnAfterHide","t":8,"sn":"OnAfterHide","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnAfterShow","t":8,"sn":"OnAfterShow","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeHide","t":8,"sn":"OnBeforeHide","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeShow","t":8,"sn":"OnBeforeShow","rt":$n[0].Void},{"a":2,"n":"OnClickReplay","t":8,"sn":"OnClickReplay","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentLevel","t":4,"rt":$n[6].IntegerVariable,"sn":"currentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"headerText","t":4,"rt":$n[8].Image,"sn":"headerText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"heartData","t":4,"rt":HeartData,"sn":"heartData"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"iconTransform","t":4,"rt":$n[1].Transform,"sn":"iconTransform"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelFormatText","t":4,"rt":$n[0].String,"sn":"levelFormatText"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"replayGameEvent","t":4,"rt":$n[2].EventNoParam,"sn":"replayGameEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"returnHomeEvent","t":4,"rt":$n[2].EventNoParam,"sn":"returnHomeEvent"}]}; }, $n);
    /*TheBeginning.UI.LosePopup end.*/

    /*TheBeginning.UI.PopupManager start.*/
    $m("TheBeginning.UI.PopupManager", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"a":2,"n":"Get","is":true,"t":8,"tpc":1,"tprm":["T"],"sn":"Get","rt":$n[29].UIPopup},{"a":1,"n":"GetKeyPopup","t":8,"pi":[{"n":"fullName","pt":$n[0].String,"ps":0}],"sn":"GetKeyPopup","rt":$n[0].String,"p":[$n[0].String]},{"a":2,"n":"Hide","is":true,"t":8,"pi":[{"n":"hidePopupCompleted","dv":null,"o":true,"pt":Function,"ps":0}],"tpc":1,"tprm":["T"],"sn":"Hide","rt":$n[0].Void,"p":[Function]},{"a":2,"n":"HideAll","is":true,"t":8,"sn":"HideAll","rt":$n[0].Void},{"a":1,"n":"InternalGet","t":8,"tpc":1,"tprm":["T"],"sn":"InternalGet","rt":$n[29].UIPopup},{"a":1,"n":"InternalHide","t":8,"pi":[{"n":"hidePopupCompleted","dv":null,"o":true,"pt":Function,"ps":0}],"tpc":1,"tprm":["T"],"sn":"InternalHide","rt":$n[0].Void,"p":[Function]},{"a":1,"n":"InternalHideAll","t":8,"sn":"InternalHideAll","rt":$n[0].Void},{"a":1,"n":"InternalIsPopupReady","t":8,"tpc":1,"tprm":["T"],"sn":"InternalIsPopupReady","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"InternalShow","t":8,"pi":[{"n":"isHideAll","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"showPopupCompleted","dv":null,"o":true,"pt":Function,"ps":1}],"tpc":1,"tprm":["T"],"sn":"InternalShow","rt":$n[0].Void,"p":[$n[0].Boolean,Function]},{"a":2,"n":"IsPopupReady","is":true,"t":8,"tpc":1,"tprm":["T"],"sn":"IsPopupReady","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Show","is":true,"t":8,"pi":[{"n":"isHideAll","dv":true,"o":true,"pt":$n[0].Boolean,"ps":0},{"n":"showPopupCompleted","dv":null,"o":true,"pt":Function,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Show","rt":$n[0].Void,"p":[$n[0].Boolean,Function]},{"a":1,"n":"_ins","is":true,"t":4,"rt":$n[29].PopupManager,"sn":"_ins"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"cameraUI","t":4,"rt":$n[1].Camera,"sn":"cameraUI"},{"a":1,"n":"container","t":4,"rt":$n[3].Dictionary$2(System.Type,TheBeginning.UI.UIPopup),"sn":"container","ro":true},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"index","t":4,"rt":$n[0].Int32,"sn":"index","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"parentContainer","t":4,"rt":$n[1].Transform,"sn":"parentContainer"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"popupSettings","t":4,"rt":$n[29].PopupSettings,"sn":"popupSettings"}]}; }, $n);
    /*TheBeginning.UI.PopupManager end.*/

    /*TheBeginning.UI.SettingPopup start.*/
    $m("TheBeginning.UI.SettingPopup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Init","t":8,"sn":"Init","rt":$n[0].Void},{"a":1,"n":"InitBtnLanguage","t":8,"sn":"InitBtnLanguage","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnAfterShow","t":8,"sn":"OnAfterShow","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeHide","t":8,"sn":"OnBeforeHide","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeShow","t":8,"sn":"OnBeforeShow","rt":$n[0].Void},{"a":2,"n":"OnClickHome","t":8,"sn":"OnClickHome","rt":$n[0].Void},{"a":2,"n":"OnClickRestorePurchase","t":8,"sn":"OnClickRestorePurchase","rt":$n[0].Void},{"a":2,"n":"OnClickSettingMusic","t":8,"sn":"OnClickSettingMusic","rt":$n[0].Void},{"a":2,"n":"OnClickSettingSound","t":8,"sn":"OnClickSettingSound","rt":$n[0].Void},{"a":2,"n":"OnClickSettingVibration","t":8,"sn":"OnClickSettingVibration","rt":$n[0].Void},{"a":2,"n":"OnClickShowPrivacyConsent","t":8,"sn":"OnClickShowPrivacyConsent","rt":$n[0].Void},{"a":1,"n":"UpdateStatus","t":8,"sn":"UpdateStatus","rt":$n[0].Void},{"at":[new UnityEngine.HeaderAttribute("Restore"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"btnRestorePurchase","t":4,"rt":$n[30].ButtonUI,"sn":"btnRestorePurchase"},{"at":[new UnityEngine.HeaderAttribute("Home"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"buttonHome","t":4,"rt":$n[1].GameObject,"sn":"buttonHome"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"buttonMusic","t":4,"rt":$n[8].Image,"sn":"buttonMusic"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"buttonSound","t":4,"rt":$n[8].Image,"sn":"buttonSound"},{"at":[new UnityEngine.HeaderAttribute("Vibrate"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"buttonVibrate","t":4,"rt":$n[8].Image,"sn":"buttonVibrate"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"callReturnHome","t":4,"rt":$n[2].EventNoParam,"sn":"callReturnHome"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"indexLevelVariable","t":4,"rt":$n[6].IntegerVariable,"sn":"indexLevelVariable"},{"at":[new UnityEngine.HeaderAttribute("Tutorial"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isBackToBuildTutorialPlaying","t":4,"rt":$n[6].BooleanVariable,"sn":"isBackToBuildTutorialPlaying"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isGlamRushFinished","t":4,"rt":$n[6].BooleanVariable,"sn":"isGlamRushFinished"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPauseGame","t":4,"rt":$n[6].BooleanVariable,"sn":"isPauseGame"},{"at":[new UnityEngine.HeaderAttribute("Properties"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isPlayingLevel","t":4,"rt":$n[6].BooleanVariable,"sn":"isPlayingLevel"},{"at":[new UnityEngine.HeaderAttribute("Config"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isStartingGlamRush","t":4,"rt":$n[6].BooleanVariable,"sn":"isStartingGlamRush"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"isStartingLevel","t":4,"rt":$n[6].BooleanVariable,"sn":"isStartingLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicOff","t":4,"rt":$n[1].Sprite,"sn":"musicOff"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicOn","t":4,"rt":$n[1].Sprite,"sn":"musicOn"},{"at":[new UnityEngine.HeaderAttribute("Music"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"musicVolume","t":4,"rt":$n[6].FloatVariable,"sn":"musicVolume"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pauseTimeLevelVariable","t":4,"rt":$n[6].BooleanVariable,"sn":"pauseTimeLevelVariable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundOff","t":4,"rt":$n[1].Sprite,"sn":"soundOff"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundOn","t":4,"rt":$n[1].Sprite,"sn":"soundOn"},{"at":[new UnityEngine.HeaderAttribute("Sound"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundVolume","t":4,"rt":$n[6].FloatVariable,"sn":"soundVolume"},{"at":[new UnityEngine.HeaderAttribute("Variable"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"unlockWinStreakLevel","t":4,"rt":$n[6].IntegerVariable,"sn":"unlockWinStreakLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vibrateOff","t":4,"rt":$n[1].Sprite,"sn":"vibrateOff"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"vibrateOn","t":4,"rt":$n[1].Sprite,"sn":"vibrateOn"}]}; }, $n);
    /*TheBeginning.UI.SettingPopup end.*/

    /*TheBeginning.UI.SettingPopupInGame start.*/
    $m("TheBeginning.UI.SettingPopupInGame", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*TheBeginning.UI.SettingPopupInGame end.*/

    /*TheBeginning.UI.PopupSettings start.*/
    $m("TheBeginning.UI.PopupSettings", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetPrefabPopup","t":8,"pi":[{"n":"popupName","pt":$n[0].String,"ps":0}],"sn":"GetPrefabPopup","rt":$n[29].UIPopup,"p":[$n[0].String]},{"a":2,"n":"ItemPopupConfigs","t":16,"rt":$n[3].List$1(TheBeginning.UI.UIPopup),"g":{"a":2,"n":"get_ItemPopupConfigs","t":8,"rt":$n[3].List$1(TheBeginning.UI.UIPopup),"fg":"ItemPopupConfigs"},"fn":"ItemPopupConfigs"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listUiPopups","t":4,"rt":$n[3].List$1(TheBeginning.UI.UIPopup),"sn":"listUiPopups"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pathLoad","t":4,"rt":$n[0].String,"sn":"pathLoad"}]}; }, $n);
    /*TheBeginning.UI.PopupSettings end.*/

    /*TheBeginning.UI.UpdatePopup start.*/
    $m("TheBeginning.UI.UpdatePopup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnBeforeShow","t":8,"sn":"OnBeforeShow","rt":$n[0].Void},{"a":2,"n":"OnChangeValueShowAgain","t":8,"sn":"OnChangeValueShowAgain","rt":$n[0].Void},{"a":1,"n":"Setup","t":8,"sn":"Setup","rt":$n[0].Void},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"contentUpdateVariable","t":4,"rt":$n[6].StringVariable,"sn":"contentUpdateVariable"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"dontShowAgainPopupUpdate","t":4,"rt":$n[6].BooleanVariable,"sn":"dontShowAgainPopupUpdate"},{"at":[new UnityEngine.SpaceAttribute.ctor(),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"textContent","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"textContent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"textVersion","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"textVersion"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"toggleShowAgain","t":4,"rt":$n[8].Toggle,"sn":"toggleShowAgain"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"versionUpdateVariable","t":4,"rt":$n[6].StringVariable,"sn":"versionUpdateVariable"}]}; }, $n);
    /*TheBeginning.UI.UpdatePopup end.*/

    /*TheBeginning.UI.UIPopup start.*/
    $m("TheBeginning.UI.UIPopup", function () { return {"att":1048577,"a":2,"at":[new UnityEngine.RequireComponent.$ctor2(UnityEngine.Canvas, UnityEngine.UI.GraphicRaycaster, UnityEngine.CanvasGroup)],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"v":true,"a":2,"n":"Hide","t":8,"sn":"Hide","rt":$n[0].Void},{"v":true,"a":3,"n":"OnAfterHide","t":8,"sn":"OnAfterHide","rt":$n[0].Void},{"v":true,"a":3,"n":"OnAfterShow","t":8,"sn":"OnAfterShow","rt":$n[0].Void},{"v":true,"a":3,"n":"OnBeforeHide","t":8,"sn":"OnBeforeHide","rt":$n[0].Void},{"v":true,"a":3,"n":"OnBeforeShow","t":8,"sn":"OnBeforeShow","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"v":true,"a":2,"n":"Show","t":8,"sn":"Show","rt":$n[0].Void},{"a":1,"n":"ConditionHideInBack","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_ConditionHideInBack","t":8,"rt":$n[0].Boolean,"fg":"ConditionHideInBack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"ConditionHideInBack"},{"a":1,"n":"ConditionHideMove","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_ConditionHideMove","t":8,"rt":$n[0].Boolean,"fg":"ConditionHideMove","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"ConditionHideMove"},{"a":1,"n":"ConditionShowFlip","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_ConditionShowFlip","t":8,"rt":$n[0].Boolean,"fg":"ConditionShowFlip","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"ConditionShowFlip"},{"a":1,"n":"ConditionShowMove","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_ConditionShowMove","t":8,"rt":$n[0].Boolean,"fg":"ConditionShowMove","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"ConditionShowMove"},{"a":1,"n":"ConditionShowOutBack","t":16,"rt":$n[0].Boolean,"g":{"a":1,"n":"get_ConditionShowOutBack","t":8,"rt":$n[0].Boolean,"fg":"ConditionShowOutBack","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"fn":"ConditionShowOutBack"},{"a":2,"n":"ActionHide","t":4,"rt":Function,"sn":"ActionHide"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"background","t":4,"rt":$n[1].GameObject,"sn":"background"},{"a":2,"n":"canvas","t":4,"rt":$n[1].Canvas,"sn":"canvas"},{"a":2,"n":"canvasGroup","t":4,"rt":$n[1].CanvasGroup,"sn":"canvasGroup"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"container","t":4,"rt":$n[1].GameObject,"sn":"container"},{"a":2,"n":"durationHidePopup","t":4,"rt":$n[0].Single,"sn":"durationHidePopup","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":2,"n":"durationShowPopup","t":4,"rt":$n[0].Single,"sn":"durationShowPopup","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eulerAngleShowFrom","t":4,"rt":$n[1].Vector3,"sn":"eulerAngleShowFrom"},{"a":2,"n":"hideAnimationType","t":4,"rt":$n[29].HideAnimationType,"sn":"hideAnimationType","box":function ($v) { return Bridge.box($v, TheBeginning.UI.HideAnimationType, System.Enum.toStringFn(TheBeginning.UI.HideAnimationType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"hideMovePopup","t":4,"rt":$n[29].MovePopupType,"sn":"hideMovePopup","box":function ($v) { return Bridge.box($v, TheBeginning.UI.MovePopupType, System.Enum.toStringFn(TheBeginning.UI.MovePopupType));}},{"a":3,"n":"isActive","t":4,"rt":$n[0].Boolean,"sn":"isActive","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isAutoShow","t":4,"rt":$n[0].Boolean,"sn":"isAutoShow","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"isNotSortingLayer","t":4,"rt":$n[0].Boolean,"sn":"isNotSortingLayer","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offsetHideMove","t":4,"rt":$n[0].Single,"sn":"offsetHideMove","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"offsetShowMove","t":4,"rt":$n[0].Single,"sn":"offsetShowMove","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Audio"),new UnityEngine.SerializeFieldAttribute()],"a":3,"n":"playSfxEvent","t":4,"rt":$n[5].PlaySfxEvent,"sn":"playSfxEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pointHidePos","t":4,"rt":$n[6].Vector3Variable,"sn":"pointHidePos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"pointShowPos","t":4,"rt":$n[6].Vector3Variable,"sn":"pointShowPos"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleFromHide","t":4,"rt":$n[1].Vector3,"sn":"scaleFromHide"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"scaleFromShow","t":4,"rt":$n[1].Vector3,"sn":"scaleFromShow"},{"a":2,"n":"showAnimationType","t":4,"rt":$n[29].ShowAnimationType,"sn":"showAnimationType","box":function ($v) { return Bridge.box($v, TheBeginning.UI.ShowAnimationType, System.Enum.toStringFn(TheBeginning.UI.ShowAnimationType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"showMovePopup","t":4,"rt":$n[29].MovePopupType,"sn":"showMovePopup","box":function ($v) { return Bridge.box($v, TheBeginning.UI.MovePopupType, System.Enum.toStringFn(TheBeginning.UI.MovePopupType));}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundClose","t":4,"rt":$n[5].SoundData,"sn":"soundClose"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundOpen","t":4,"rt":$n[5].SoundData,"sn":"soundOpen"},{"a":1,"n":"tween","t":4,"rt":$n[4].Tween,"sn":"tween"},{"a":2,"n":"useAnimation","t":4,"rt":$n[0].Boolean,"sn":"useAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useHideAnimation","t":4,"rt":$n[0].Boolean,"sn":"useHideAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"useShowAnimation","t":4,"rt":$n[0].Boolean,"sn":"useShowAnimation","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*TheBeginning.UI.UIPopup end.*/

    /*TheBeginning.UI.ShowAnimationType start.*/
    $m("TheBeginning.UI.ShowAnimationType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fade","is":true,"t":4,"rt":$n[29].ShowAnimationType,"sn":"Fade","box":function ($v) { return Bridge.box($v, TheBeginning.UI.ShowAnimationType, System.Enum.toStringFn(TheBeginning.UI.ShowAnimationType));}},{"a":2,"n":"Flip","is":true,"t":4,"rt":$n[29].ShowAnimationType,"sn":"Flip","box":function ($v) { return Bridge.box($v, TheBeginning.UI.ShowAnimationType, System.Enum.toStringFn(TheBeginning.UI.ShowAnimationType));}},{"a":2,"n":"Move","is":true,"t":4,"rt":$n[29].ShowAnimationType,"sn":"Move","box":function ($v) { return Bridge.box($v, TheBeginning.UI.ShowAnimationType, System.Enum.toStringFn(TheBeginning.UI.ShowAnimationType));}},{"a":2,"n":"OutBack","is":true,"t":4,"rt":$n[29].ShowAnimationType,"sn":"OutBack","box":function ($v) { return Bridge.box($v, TheBeginning.UI.ShowAnimationType, System.Enum.toStringFn(TheBeginning.UI.ShowAnimationType));}},{"a":2,"n":"OutBackFromPoint","is":true,"t":4,"rt":$n[29].ShowAnimationType,"sn":"OutBackFromPoint","box":function ($v) { return Bridge.box($v, TheBeginning.UI.ShowAnimationType, System.Enum.toStringFn(TheBeginning.UI.ShowAnimationType));}}]}; }, $n);
    /*TheBeginning.UI.ShowAnimationType end.*/

    /*TheBeginning.UI.HideAnimationType start.*/
    $m("TheBeginning.UI.HideAnimationType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Fade","is":true,"t":4,"rt":$n[29].HideAnimationType,"sn":"Fade","box":function ($v) { return Bridge.box($v, TheBeginning.UI.HideAnimationType, System.Enum.toStringFn(TheBeginning.UI.HideAnimationType));}},{"a":2,"n":"InBack","is":true,"t":4,"rt":$n[29].HideAnimationType,"sn":"InBack","box":function ($v) { return Bridge.box($v, TheBeginning.UI.HideAnimationType, System.Enum.toStringFn(TheBeginning.UI.HideAnimationType));}},{"a":2,"n":"InBackToPoint","is":true,"t":4,"rt":$n[29].HideAnimationType,"sn":"InBackToPoint","box":function ($v) { return Bridge.box($v, TheBeginning.UI.HideAnimationType, System.Enum.toStringFn(TheBeginning.UI.HideAnimationType));}},{"a":2,"n":"Move","is":true,"t":4,"rt":$n[29].HideAnimationType,"sn":"Move","box":function ($v) { return Bridge.box($v, TheBeginning.UI.HideAnimationType, System.Enum.toStringFn(TheBeginning.UI.HideAnimationType));}}]}; }, $n);
    /*TheBeginning.UI.HideAnimationType end.*/

    /*TheBeginning.UI.MovePopupType start.*/
    $m("TheBeginning.UI.MovePopupType", function () { return {"att":257,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Down","is":true,"t":4,"rt":$n[29].MovePopupType,"sn":"Down","box":function ($v) { return Bridge.box($v, TheBeginning.UI.MovePopupType, System.Enum.toStringFn(TheBeginning.UI.MovePopupType));}},{"a":2,"n":"Left","is":true,"t":4,"rt":$n[29].MovePopupType,"sn":"Left","box":function ($v) { return Bridge.box($v, TheBeginning.UI.MovePopupType, System.Enum.toStringFn(TheBeginning.UI.MovePopupType));}},{"a":2,"n":"Right","is":true,"t":4,"rt":$n[29].MovePopupType,"sn":"Right","box":function ($v) { return Bridge.box($v, TheBeginning.UI.MovePopupType, System.Enum.toStringFn(TheBeginning.UI.MovePopupType));}},{"a":2,"n":"Up","is":true,"t":4,"rt":$n[29].MovePopupType,"sn":"Up","box":function ($v) { return Bridge.box($v, TheBeginning.UI.MovePopupType, System.Enum.toStringFn(TheBeginning.UI.MovePopupType));}}]}; }, $n);
    /*TheBeginning.UI.MovePopupType end.*/

    /*TheBeginning.UI.WinPopup start.*/
    $m("TheBeginning.UI.WinPopup", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":3,"n":"OnAfterHide","t":8,"sn":"OnAfterHide","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeHide","t":8,"sn":"OnBeforeHide","rt":$n[0].Void},{"ov":true,"a":3,"n":"OnBeforeShow","t":8,"sn":"OnBeforeShow","rt":$n[0].Void},{"a":1,"n":"OnClaimCoinWin","t":8,"pi":[{"n":"isWatchAds","pt":$n[0].Boolean,"ps":0}],"sn":"OnClaimCoinWin","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":2,"n":"OnClickContinue","t":8,"sn":"OnClickContinue","rt":$n[0].Void},{"a":1,"n":"OnMoveAllCoinDone","t":8,"sn":"OnMoveAllCoinDone","rt":$n[0].Void},{"a":1,"n":"Setup","t":8,"sn":"Setup","rt":$n[0].Void},{"a":1,"n":"_delayShowBtnContinue","t":4,"rt":$n[24].DelayHandle,"sn":"_delayShowBtnContinue"},{"a":1,"n":"_isCanClickContinue","t":4,"rt":$n[0].Boolean,"sn":"_isCanClickContinue","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":1,"n":"_moneyWin","t":4,"rt":$n[0].Int32,"sn":"_moneyWin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"_tweenScaleBtnContinue","t":4,"rt":$n[4].Tween,"sn":"_tweenScaleBtnContinue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"btnTapToContinue","t":4,"rt":$n[8].Button,"sn":"btnTapToContinue"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentLevel","t":4,"rt":$n[6].IntegerVariable,"sn":"currentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"gameSettings","t":4,"rt":GameSettings,"sn":"gameSettings"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"group","t":4,"rt":$n[1].GameObject,"sn":"group"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listAnimatorUI","t":4,"rt":$n[3].List$1(AnimatorUIControl),"sn":"listAnimatorUI"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moneyWin","t":4,"rt":$n[0].Int32,"sn":"moneyWin","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"moveAllCoinDone","t":4,"rt":$n[2].EventNoParam,"sn":"moveAllCoinDone"},{"a":1,"n":"percent","t":4,"rt":$n[0].Single,"sn":"percent","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"playCurrentLevelEvent","t":4,"rt":$n[2].EventNoParam,"sn":"playCurrentLevelEvent"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"ratioScaleContinueButton","t":4,"rt":$n[0].Single,"sn":"ratioScaleContinueButton","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"soundFx","t":4,"rt":$n[5].SoundData,"sn":"soundFx"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"starPosition","t":4,"rt":$n[1].GameObject,"sn":"starPosition"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"textButtonComplete","t":4,"rt":$n[7].TextMeshProUGUI,"sn":"textButtonComplete"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"textValueFormat","t":4,"rt":$n[0].String,"sn":"textValueFormat"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayPlayFx","t":4,"rt":$n[0].Single,"sn":"timeDelayPlayFx","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeDelayShowContinue","t":4,"rt":$n[0].Single,"sn":"timeDelayShowContinue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeScaleContinue","t":4,"rt":$n[0].Single,"sn":"timeScaleContinue","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"at":[new UnityEngine.HeaderAttribute("Animation"),new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"timeShowAnimation","t":4,"rt":$n[0].Single,"sn":"timeShowAnimation","box":function ($v) { return Bridge.box($v, System.Single, System.Single.format, System.Single.getHashCode);}},{"a":1,"n":"waitMoveAllCoinDone","t":4,"rt":$n[0].Boolean,"sn":"waitMoveAllCoinDone","box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}}]}; }, $n);
    /*TheBeginning.UI.WinPopup end.*/

    /*TheBeginning.LevelSystem.EventGetTransformCurrentLevel start.*/
    $m("TheBeginning.LevelSystem.EventGetTransformCurrentLevel", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Event Custom/Event Get Transform Current Level", fileName: "event_get_transform_current_level"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*TheBeginning.LevelSystem.EventGetTransformCurrentLevel end.*/

    /*TheBeginning.LevelSystem.EventGetCurrentLevel start.*/
    $m("TheBeginning.LevelSystem.EventGetCurrentLevel", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Event Custom/Event Get Current Level", fileName: "event_get_current_level"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*TheBeginning.LevelSystem.EventGetCurrentLevel end.*/

    /*TheBeginning.LevelSystem.EventGetPreviousLevel start.*/
    $m("TheBeginning.LevelSystem.EventGetPreviousLevel", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Event Custom/Event Get Previous Level", fileName: "event_get_previous_level"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*TheBeginning.LevelSystem.EventGetPreviousLevel end.*/

    /*TheBeginning.LevelSystem.EventLoadLevel start.*/
    $m("TheBeginning.LevelSystem.EventLoadLevel", function () { return {"att":1048577,"a":2,"at":[Bridge.apply(new UnityEngine.CreateAssetMenuAttribute(), {
        menuName: "Event Custom/Event Load Level", fileName: "event_load_level"
    } )],"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"}]}; }, $n);
    /*TheBeginning.LevelSystem.EventLoadLevel end.*/

    /*TheBeginning.LevelSystem.Level start.*/
    $m("TheBeginning.LevelSystem.Level", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GetTransform","t":8,"sn":"GetTransform","rt":$n[1].Transform},{"ov":true,"a":2,"n":"OnDisable","t":8,"sn":"OnDisable","rt":$n[0].Void},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventGetTransformCurrentLevel","t":4,"rt":$n[10].EventGetTransformCurrentLevel,"sn":"eventGetTransformCurrentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"indexLevelVariable","t":4,"rt":$n[6].IntegerVariable,"sn":"indexLevelVariable"}]}; }, $n);
    /*TheBeginning.LevelSystem.Level end.*/

    /*TheBeginning.LevelSystem.LevelLoader start.*/
    $m("TheBeginning.LevelSystem.LevelLoader", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"ActiveCurrentLevel","t":8,"pi":[{"n":"active","pt":$n[0].Boolean,"ps":0}],"sn":"ActiveCurrentLevel","rt":$n[0].Void,"p":[$n[0].Boolean]},{"a":1,"n":"CurrentLevel","t":8,"sn":"CurrentLevel","rt":$n[10].Level},{"a":1,"n":"HandleIndexLevel","t":8,"pi":[{"n":"indexLevel","pt":$n[0].Int32,"ps":0}],"sn":"HandleIndexLevel","rt":$n[0].Int32,"p":[$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":1,"n":"LoadLevel","t":8,"sn":"LoadLevel","rt":$n[10].Level},{"ov":true,"a":2,"n":"OnEnable","t":8,"sn":"OnEnable","rt":$n[0].Void},{"a":1,"n":"PreviousLevel","t":8,"sn":"PreviousLevel","rt":$n[10].Level},{"a":1,"n":"Start","t":8,"sn":"Start","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentIndexLevel","t":4,"rt":$n[6].IntegerVariable,"sn":"currentIndexLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentIndexLevelLoopBy","t":4,"rt":$n[6].IntegerVariable,"sn":"currentIndexLevelLoopBy"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"currentLevel","t":4,"rt":$n[10].Level,"sn":"currentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventGetCurrentLevel","t":4,"rt":$n[10].EventGetCurrentLevel,"sn":"eventGetCurrentLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventGetPreviousLevel","t":4,"rt":$n[10].EventGetPreviousLevel,"sn":"eventGetPreviousLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"eventLoadLevel","t":4,"rt":$n[10].EventLoadLevel,"sn":"eventLoadLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelSettings","t":4,"rt":$n[10].LevelSettings,"sn":"levelSettings"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"previousLevel","t":4,"rt":$n[10].Level,"sn":"previousLevel"}]}; }, $n);
    /*TheBeginning.LevelSystem.LevelLoader end.*/

    /*TheBeginning.LevelSystem.LevelSettings start.*/
    $m("TheBeginning.LevelSystem.LevelSettings", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"GePrefabLevel","t":8,"pi":[{"n":"index","pt":$n[0].Int32,"ps":0}],"sn":"GePrefabLevel","rt":$n[10].Level,"p":[$n[0].Int32]},{"a":2,"n":"GePrefabLevel","t":8,"pi":[{"n":"levelName","pt":$n[0].String,"ps":0}],"sn":"GePrefabLevel$1","rt":$n[10].Level,"p":[$n[0].String]},{"a":2,"n":"MaxLevel","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_MaxLevel","t":8,"rt":$n[0].Int32,"fg":"MaxLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"MaxLevel"},{"a":2,"n":"StartLoopLevel","t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_StartLoopLevel","t":8,"rt":$n[0].Int32,"fg":"StartLoopLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"StartLoopLevel"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"levelFormat","t":4,"rt":$n[0].String,"sn":"levelFormat"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"listLevels","t":4,"rt":$n[3].List$1(TheBeginning.LevelSystem.Level),"sn":"listLevels"},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"maxLevel","t":4,"rt":$n[0].Int32,"sn":"maxLevel","box":function ($v) { return Bridge.box($v, System.Int32);}},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"startLoopLevel","t":4,"rt":$n[0].Int32,"sn":"startLoopLevel","box":function ($v) { return Bridge.box($v, System.Int32);}}]}; }, $n);
    /*TheBeginning.LevelSystem.LevelSettings end.*/

    /*TheBeginning.Services.PoolInitialization start.*/
    $m("TheBeginning.Services.PoolInitialization", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Initialization","t":8,"sn":"Initialization","rt":$n[0].Void}]}; }, $n);
    /*TheBeginning.Services.PoolInitialization end.*/

    /*TheBeginning.Services.RuntimeInitialization start.*/
    $m("TheBeginning.Services.RuntimeInitialization", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":1,"n":"Awake","t":8,"sn":"Awake","rt":$n[0].Void},{"at":[new UnityEngine.SerializeFieldAttribute()],"a":1,"n":"serviceInitializations","t":4,"rt":System.Array.type(TheBeginning.Services.ServiceInitialization),"sn":"serviceInitializations"}]}; }, $n);
    /*TheBeginning.Services.RuntimeInitialization end.*/

    /*TheBeginning.Services.ServiceInitialization start.*/
    $m("TheBeginning.Services.ServiceInitialization", function () { return {"att":1048705,"a":2,"m":[{"a":3,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ab":true,"a":2,"n":"Initialization","t":8,"sn":"Initialization","rt":$n[0].Void}]}; }, $n);
    /*TheBeginning.Services.ServiceInitialization end.*/

    /*TheBeginning.Services.VibrationInitialization start.*/
    $m("TheBeginning.Services.VibrationInitialization", function () { return {"att":1048577,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"ov":true,"a":2,"n":"Initialization","t":8,"sn":"Initialization","rt":$n[0].Void}]}; }, $n);
    /*TheBeginning.Services.VibrationInitialization end.*/

    /*TheBeginning.Data.UserData start.*/
    $m("TheBeginning.Data.UserData", function () { return {"att":1048841,"a":2,"m":[{"a":2,"isSynthetic":true,"n":".ctor","t":1,"sn":"ctor"},{"a":2,"n":"Get","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defaultValue","dv":null,"o":true,"pt":System.Object,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Get","rt":System.Object,"p":[$n[0].String,System.Object]},{"a":2,"n":"GetBoosterAmount","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defaultValue","pt":$n[0].Int32,"ps":1}],"sn":"GetBoosterAmount","rt":$n[0].Int32,"p":[$n[0].String,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetBoosterUnlock","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defaultValue","pt":$n[0].Boolean,"ps":1}],"sn":"GetBoosterUnlock","rt":$n[0].Boolean,"p":[$n[0].String,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetCurrentSelectRoom","is":true,"t":8,"sn":"GetCurrentSelectRoom","rt":$n[0].Int32,"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetInitData","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0}],"sn":"GetInitData","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetItemBattlePassClaimed","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0}],"sn":"GetItemBattlePassClaimed","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetNumberShowGameObject","is":true,"t":8,"pi":[{"n":"gameObjectID","pt":$n[0].String,"ps":0}],"sn":"GetNumberShowGameObject","rt":$n[0].Int32,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetPlayerProfileFrameThemeFlag","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defaultValue","pt":$n[0].String,"ps":1}],"sn":"GetPlayerProfileFrameThemeFlag","rt":$n[0].String,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"GetSkinMakeupUnlocked","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defaultValue","pt":$n[0].Boolean,"ps":1}],"sn":"GetSkinMakeupUnlocked","rt":$n[0].Boolean,"p":[$n[0].String,$n[0].Boolean],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"GetSkinMakeupUnlockedSelectName","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defaultValue","pt":$n[0].String,"ps":1}],"sn":"GetSkinMakeupUnlockedSelectName","rt":$n[0].String,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"GetStatValue","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"defauleValue","pt":$n[0].Int32,"ps":1}],"sn":"GetStatValue","rt":$n[0].Int32,"p":[$n[0].String,$n[0].Int32],"box":function ($v) { return Bridge.box($v, System.Int32);}},{"a":2,"n":"GetUnlockWinStreakGift","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0}],"sn":"GetUnlockWinStreakGift","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IncreaseNumberShowGameObject","is":true,"t":8,"pi":[{"n":"gameObjectID","pt":$n[0].String,"ps":0}],"sn":"IncreaseNumberShowGameObject","rt":$n[0].Void,"p":[$n[0].String]},{"a":2,"n":"IsClaimedTodayDailyReward","is":true,"t":8,"sn":"IsClaimedTodayDailyReward","rt":$n[0].Boolean,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"IsItemEquipped","is":true,"t":8,"pi":[{"n":"itemIdentity","pt":$n[0].String,"ps":0}],"sn":"IsItemEquipped","rt":$n[0].Boolean,"p":[$n[0].String],"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},{"a":2,"n":"Set","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"data","pt":System.Object,"ps":1}],"tpc":1,"tprm":["T"],"sn":"Set","rt":$n[0].Void,"p":[$n[0].String,System.Object]},{"a":2,"n":"SetBoosterAmount","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Int32,"ps":1}],"sn":"SetBoosterAmount","rt":$n[0].Void,"p":[$n[0].String,$n[0].Int32]},{"a":2,"n":"SetBoosterUnlock","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Boolean,"ps":1}],"sn":"SetBoosterUnlock","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SetCurrentSelectRoom","is":true,"t":8,"pi":[{"n":"value","pt":$n[0].Int32,"ps":0}],"sn":"SetCurrentSelectRoom","rt":$n[0].Void,"p":[$n[0].Int32]},{"a":2,"n":"SetInitData","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Boolean,"ps":1}],"sn":"SetInitData","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SetItemBattlePassClaimed","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Boolean,"ps":1}],"sn":"SetItemBattlePassClaimed","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SetItemEquipped","is":true,"t":8,"pi":[{"n":"itemIdentity","pt":$n[0].String,"ps":0},{"n":"isEquipped","dv":true,"o":true,"pt":$n[0].Boolean,"ps":1}],"sn":"SetItemEquipped","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SetPlayerProfileFrameThemeLag","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].String,"ps":1}],"sn":"SetPlayerProfileFrameThemeLag","rt":$n[0].Void,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"SetSkinMakeupUnlocked","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Boolean,"ps":1}],"sn":"SetSkinMakeupUnlocked","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"SetSkinMakeupUnlockedSelectName","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].String,"ps":1}],"sn":"SetSkinMakeupUnlockedSelectName","rt":$n[0].Void,"p":[$n[0].String,$n[0].String]},{"a":2,"n":"SetStatValue","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Int32,"ps":1}],"sn":"SetStatValue","rt":$n[0].Void,"p":[$n[0].String,$n[0].Int32]},{"a":2,"n":"SetUnlockWinStreakGift","is":true,"t":8,"pi":[{"n":"key","pt":$n[0].String,"ps":0},{"n":"value","pt":$n[0].Boolean,"ps":1}],"sn":"SetUnlockWinStreakGift","rt":$n[0].Void,"p":[$n[0].String,$n[0].Boolean]},{"a":2,"n":"CurrentMonthBattlePass","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_CurrentMonthBattlePass","t":8,"rt":$n[0].String,"fg":"CurrentMonthBattlePass","is":true},"s":{"a":2,"n":"set_CurrentMonthBattlePass","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"CurrentMonthBattlePass","is":true},"fn":"CurrentMonthBattlePass"},{"a":2,"n":"DailyRewardDayIndex","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_DailyRewardDayIndex","t":8,"rt":$n[0].Int32,"fg":"DailyRewardDayIndex","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_DailyRewardDayIndex","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"DailyRewardDayIndex","is":true},"fn":"DailyRewardDayIndex"},{"a":2,"n":"DateTimeStart","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_DateTimeStart","t":8,"rt":$n[0].String,"fg":"DateTimeStart","is":true},"s":{"a":2,"n":"set_DateTimeStart","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"DateTimeStart","is":true},"fn":"DateTimeStart"},{"a":2,"n":"DayStartWinStreak","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_DayStartWinStreak","t":8,"rt":$n[0].String,"fg":"DayStartWinStreak","is":true},"s":{"a":2,"n":"set_DayStartWinStreak","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"DayStartWinStreak","is":true},"fn":"DayStartWinStreak"},{"a":2,"n":"IsFirstOpenGame","is":true,"t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsFirstOpenGame","t":8,"rt":$n[0].Boolean,"fg":"IsFirstOpenGame","is":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsFirstOpenGame","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsFirstOpenGame","is":true},"fn":"IsFirstOpenGame"},{"a":2,"n":"IsItemUnlocked","is":true,"t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsItemUnlocked","t":8,"rt":$n[0].Boolean,"fg":"IsItemUnlocked","is":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsItemUnlocked","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsItemUnlocked","is":true},"fn":"IsItemUnlocked"},{"a":2,"n":"IsStartLoopingDailyReward","is":true,"t":16,"rt":$n[0].Boolean,"g":{"a":2,"n":"get_IsStartLoopingDailyReward","t":8,"rt":$n[0].Boolean,"fg":"IsStartLoopingDailyReward","is":true,"box":function ($v) { return Bridge.box($v, System.Boolean, System.Boolean.toString);}},"s":{"a":2,"n":"set_IsStartLoopingDailyReward","t":8,"p":[$n[0].Boolean],"rt":$n[0].Void,"fs":"IsStartLoopingDailyReward","is":true},"fn":"IsStartLoopingDailyReward"},{"a":2,"n":"LastDailyGift","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_LastDailyGift","t":8,"rt":$n[0].String,"fg":"LastDailyGift","is":true},"s":{"a":2,"n":"set_LastDailyGift","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"LastDailyGift","is":true},"fn":"LastDailyGift"},{"a":2,"n":"LastDailyInfinity","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_LastDailyInfinity","t":8,"rt":$n[0].String,"fg":"LastDailyInfinity","is":true},"s":{"a":2,"n":"set_LastDailyInfinity","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"LastDailyInfinity","is":true},"fn":"LastDailyInfinity"},{"a":2,"n":"LastDailyMainGiftClaimed","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_LastDailyMainGiftClaimed","t":8,"rt":$n[0].String,"fg":"LastDailyMainGiftClaimed","is":true},"s":{"a":2,"n":"set_LastDailyMainGiftClaimed","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"LastDailyMainGiftClaimed","is":true},"fn":"LastDailyMainGiftClaimed"},{"a":2,"n":"LastDailyRewardClaimed","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_LastDailyRewardClaimed","t":8,"rt":$n[0].String,"fg":"LastDailyRewardClaimed","is":true},"s":{"a":2,"n":"set_LastDailyRewardClaimed","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"LastDailyRewardClaimed","is":true},"fn":"LastDailyRewardClaimed"},{"a":2,"n":"LastSessiontime","is":true,"t":16,"rt":$n[0].String,"g":{"a":2,"n":"get_LastSessiontime","t":8,"rt":$n[0].String,"fg":"LastSessiontime","is":true},"s":{"a":2,"n":"set_LastSessiontime","t":8,"p":[$n[0].String],"rt":$n[0].Void,"fs":"LastSessiontime","is":true},"fn":"LastSessiontime"},{"a":2,"n":"PercentWinGift","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_PercentWinGift","t":8,"rt":$n[0].Int32,"fg":"PercentWinGift","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_PercentWinGift","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"PercentWinGift","is":true},"fn":"PercentWinGift"},{"a":2,"n":"ProgressAmount","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_ProgressAmount","t":8,"rt":$n[0].Int32,"fg":"ProgressAmount","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_ProgressAmount","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"ProgressAmount","is":true},"fn":"ProgressAmount"},{"a":2,"n":"TotalClaimDailyReward","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TotalClaimDailyReward","t":8,"rt":$n[0].Int32,"fg":"TotalClaimDailyReward","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"s":{"a":2,"n":"set_TotalClaimDailyReward","t":8,"p":[$n[0].Int32],"rt":$n[0].Void,"fs":"TotalClaimDailyReward","is":true},"fn":"TotalClaimDailyReward"},{"a":2,"n":"TotalPlayedDays","is":true,"t":16,"rt":$n[0].Int32,"g":{"a":2,"n":"get_TotalPlayedDays","t":8,"rt":$n[0].Int32,"fg":"TotalPlayedDays","is":true,"box":function ($v) { return Bridge.box($v, System.Int32);}},"fn":"TotalPlayedDays"},{"a":2,"n":"IdItemUnlocked","is":true,"t":4,"rt":$n[0].String,"sn":"IdItemUnlocked"}]}; }, $n);
    /*TheBeginning.Data.UserData end.*/

    }});
